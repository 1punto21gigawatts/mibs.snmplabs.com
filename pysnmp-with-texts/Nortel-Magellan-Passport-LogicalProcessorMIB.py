#
# PySNMP MIB module Nortel-Magellan-Passport-LogicalProcessorMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-LogicalProcessorMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
PassportCounter64, Integer32, DisplayString, InterfaceIndex, RowStatus, Gauge32, Counter32, StorageType, RowPointer, Unsigned32 = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "PassportCounter64", "Integer32", "DisplayString", "InterfaceIndex", "RowStatus", "Gauge32", "Counter32", "StorageType", "RowPointer", "Unsigned32")
EnterpriseDateAndTime, Hex, AsciiString, NonReplicated, Link = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "EnterpriseDateAndTime", "Hex", "AsciiString", "NonReplicated", "Link")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, ModuleIdentity, TimeTicks, iso, MibIdentifier, ObjectIdentity, NotificationType, Gauge32, Counter32, Bits, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "ModuleIdentity", "TimeTicks", "iso", "MibIdentifier", "ObjectIdentity", "NotificationType", "Gauge32", "Counter32", "Bits", "Unsigned32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
logicalProcessorMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11))
lp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12))
lpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1), )
if mibBuilder.loadTexts: lpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpRowStatusTable.setDescription('This entry controls the addition and deletion of lp components.')
lpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpRowStatusEntry.setDescription('A single entry in the table represents a single lp component.')
lpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpRowStatus.setDescription('This variable is used as the basis for SNMP naming of lp components. These components can be added and deleted.')
lpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpStorageType.setDescription('This variable represents the storage type value for the lp tables.')
lpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpIndex.setDescription('This variable represents the index for the lp tables.')
lpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 100), )
if mibBuilder.loadTexts: lpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpProvTable.setDescription('This Group contains the provisionable attributes for the LP component.')
lpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpProvEntry.setDescription('An entry in the lpProvTable.')
lpMainCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 100, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpMainCard.setStatus('mandatory')
if mibBuilder.loadTexts: lpMainCard.setDescription('This is the preferred processor card on which this LP should be assigned.')
lpSpareCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 100, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSpareCard.setStatus('mandatory')
if mibBuilder.loadTexts: lpSpareCard.setDescription('This is the spare processor card on which this LP should be assigned.')
lpLogicalProcessorType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 100, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpLogicalProcessorType.setStatus('mandatory')
if mibBuilder.loadTexts: lpLogicalProcessorType.setDescription('This is the Logical Processor Type (LPT) that determines which software this LP will run.')
lpCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 101), )
if mibBuilder.loadTexts: lpCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 101, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpCidDataEntry.setDescription('An entry in the lpCidDataTable.')
lpCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 101, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102), )
if mibBuilder.loadTexts: lpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpStateEntry.setDescription('An entry in the lpStateTable.')
lpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 102, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103), )
if mibBuilder.loadTexts: lpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpOperTable.setDescription('This Group contains the operational attributes for the LP component.')
lpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpOperEntry.setDescription('An entry in the lpOperTable.')
lpActiveCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpActiveCard.setStatus('mandatory')
if mibBuilder.loadTexts: lpActiveCard.setDescription('This attribute indicates on which card this LP is currently running (if any).')
lpMainCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("notProvisioned", 0), ("notAvailable", 1), ("available", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMainCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpMainCardStatus.setDescription("This attribute specifies the status of this LP's main card. The following values have been defined: notProvisioned No main card has been provisioned notAvailable The main card is not available available The main card is available (running as standby) active The main card is running as active")
lpSpareCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notProvisioned", 0), ("notAvailable", 1), ("alreadyInUse", 2), ("available", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSpareCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSpareCardStatus.setDescription("This attribute specifies the status of this LP's spare card. The following values have been defined: notProvisioned No spare card has been provisioned notAvailable The spare card is not available alreadyInUse The spare card is already in use by another LP available The spare card is available (running as standby) active The spare card is running as active")
lpRestartOnCpSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpRestartOnCpSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: lpRestartOnCpSwitch.setDescription("This attribute indicates whether the Lp always restarts upon a CP switchover. The value is true if the featureList of the associated Sw Lpt component contains a feature that does not support hitless CP switchover. The value is also true when the feature noHitlessCpSwitch is provisioned on the CP. A value of false does not guarantee 'no restart'; dynamic conditions may still result in an FP restart when a CP switchover occurs.")
lpScheduledSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 103, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpScheduledSwitchover.setStatus('mandatory')
if mibBuilder.loadTexts: lpScheduledSwitchover.setDescription('This attribute indicates the execution time of the scheduled switchover. When there is no switchover scheduled the time is equals to 0 (0000-00-00 00:00).')
lpUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104), )
if mibBuilder.loadTexts: lpUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpUtilTable.setDescription("This group contains the operational attributes that specify the processor's utilization levels. When this group exists for an LP component, the attributes are representative of the active card.")
lpUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpUtilEntry.setDescription('An entry in the lpUtilTable.')
lpTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpTimeInterval.setDescription('This attribute indicates the time period (in minutes) for which the average, minimum and maximum utilization values are calculated. This attribute is reset to 0 every 15 minutes.')
lpCpuUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: lpCpuUtil.setDescription('This attribute indicates an approximation of the current processor utilization level (expressed as a percentage).')
lpCpuUtilAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpCpuUtilAvg.setStatus('mandatory')
if mibBuilder.loadTexts: lpCpuUtilAvg.setDescription('This attribute indicates an average processor utilization level over the specified time period, timeInterval. This average is calculated based on one minute CPU utilization averages.')
lpCpuUtilAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpCpuUtilAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: lpCpuUtilAvgMin.setDescription('This attribute indicates the minimum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
lpCpuUtilAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpCpuUtilAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: lpCpuUtilAvgMax.setDescription('This attribute indicates the maximum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
lpMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpMsgBlockUsage.setDescription("This attribute indicates the processor's current shared message block memory utilization (in kilobytes). If there is no shared memory on the card, this attribute indicates 0.")
lpMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: lpMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
lpMsgBlockUsageAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMsgBlockUsageAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: lpMsgBlockUsageAvgMin.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
lpMsgBlockUsageAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMsgBlockUsageAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: lpMsgBlockUsageAvgMax.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
lpLocalMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLocalMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: lpLocalMsgBlockUsage.setDescription("This attribute indicates the processor's current memory utilization (in kilobytes) of message blocks which are used for local messaging on the card.")
lpLocalMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLocalMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: lpLocalMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, localMsgBlockUsage.")
lpLocalMsgBlockUsageMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLocalMsgBlockUsageMin.setStatus('mandatory')
if mibBuilder.loadTexts: lpLocalMsgBlockUsageMin.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, localMsgBlockUsage.")
lpLocalMsgBlockUsageMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 104, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLocalMsgBlockUsageMax.setStatus('mandatory')
if mibBuilder.loadTexts: lpLocalMsgBlockUsageMax.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, localMsgBlockUsage.")
lpCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 105), )
if mibBuilder.loadTexts: lpCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpCapTable.setDescription("This group contains the operational attributes that specify the processor's capacity levels. When this group exists for an LP component, the attributes are representative of the active Card.")
lpCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 105, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"))
if mibBuilder.loadTexts: lpCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpCapEntry.setDescription('An entry in the lpCapTable.')
lpMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 105, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpMsgBlockCapacity.setDescription("This attribute indicates the processor card's shared message block memory capacity (in kilobytes).")
lpLocalMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 105, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLocalMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: lpLocalMsgBlockCapacity.setDescription("This attribute indicates the processor card's local message block memory capacity (in kilobytes). These message blocks are used for local messaging on the card.")
lpLinkToApplicationsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 242), )
if mibBuilder.loadTexts: lpLinkToApplicationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpLinkToApplicationsTable.setDescription('This attribute allows applications to link themselves directly to the LP component.')
lpLinkToApplicationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 242, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpLinkToApplicationsValue"))
if mibBuilder.loadTexts: lpLinkToApplicationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpLinkToApplicationsEntry.setDescription('An entry in the lpLinkToApplicationsTable.')
lpLinkToApplicationsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 242, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpLinkToApplicationsValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpLinkToApplicationsValue.setDescription('This variable represents both the value and the index for the lpLinkToApplicationsTable.')
lpMemoryCapacityTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 244), )
if mibBuilder.loadTexts: lpMemoryCapacityTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryCapacityTable.setDescription("This attribute indicates the processor card's memory capacity (in kilobytes) for each type of memory.")
lpMemoryCapacityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 244, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpMemoryCapacityIndex"))
if mibBuilder.loadTexts: lpMemoryCapacityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryCapacityEntry.setDescription('An entry in the lpMemoryCapacityTable.')
lpMemoryCapacityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 244, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: lpMemoryCapacityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryCapacityIndex.setDescription('This variable represents the lpMemoryCapacityTable specific index for the lpMemoryCapacityTable.')
lpMemoryCapacityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 244, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMemoryCapacityValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryCapacityValue.setDescription('This variable represents an individual value for the lpMemoryCapacityTable.')
lpMemoryUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 245), )
if mibBuilder.loadTexts: lpMemoryUsageTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageTable.setDescription("This attribute indicates the processor's current memory utilization (in kilobytes) for each type of memory.")
lpMemoryUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 245, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpMemoryUsageIndex"))
if mibBuilder.loadTexts: lpMemoryUsageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageEntry.setDescription('An entry in the lpMemoryUsageTable.')
lpMemoryUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 245, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: lpMemoryUsageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageIndex.setDescription('This variable represents the lpMemoryUsageTable specific index for the lpMemoryUsageTable.')
lpMemoryUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 245, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMemoryUsageValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageValue.setDescription('This variable represents an individual value for the lpMemoryUsageTable.')
lpMemoryUsageAvgTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 276), )
if mibBuilder.loadTexts: lpMemoryUsageAvgTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgTable.setDescription("This attribute indicates the processor's average memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
lpMemoryUsageAvgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 276, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpMemoryUsageAvgIndex"))
if mibBuilder.loadTexts: lpMemoryUsageAvgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgEntry.setDescription('An entry in the lpMemoryUsageAvgTable.')
lpMemoryUsageAvgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 276, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: lpMemoryUsageAvgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgIndex.setDescription('This variable represents the lpMemoryUsageAvgTable specific index for the lpMemoryUsageAvgTable.')
lpMemoryUsageAvgValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 276, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMemoryUsageAvgValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgValue.setDescription('This variable represents an individual value for the lpMemoryUsageAvgTable.')
lpMemoryUsageAvgMinTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 277), )
if mibBuilder.loadTexts: lpMemoryUsageAvgMinTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMinTable.setDescription("This attribute indicates the processor's minimum memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
lpMemoryUsageAvgMinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 277, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpMemoryUsageAvgMinIndex"))
if mibBuilder.loadTexts: lpMemoryUsageAvgMinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMinEntry.setDescription('An entry in the lpMemoryUsageAvgMinTable.')
lpMemoryUsageAvgMinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 277, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: lpMemoryUsageAvgMinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMinIndex.setDescription('This variable represents the lpMemoryUsageAvgMinTable specific index for the lpMemoryUsageAvgMinTable.')
lpMemoryUsageAvgMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 277, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMemoryUsageAvgMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMinValue.setDescription('This variable represents an individual value for the lpMemoryUsageAvgMinTable.')
lpMemoryUsageAvgMaxTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 278), )
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxTable.setDescription("This attribute indicates the processor's maximum memory utilization (in kilobytes) for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
lpMemoryUsageAvgMaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 278, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpMemoryUsageAvgMaxIndex"))
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxEntry.setDescription('An entry in the lpMemoryUsageAvgMaxTable.')
lpMemoryUsageAvgMaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 278, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxIndex.setDescription('This variable represents the lpMemoryUsageAvgMaxTable specific index for the lpMemoryUsageAvgMaxTable.')
lpMemoryUsageAvgMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 278, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpMemoryUsageAvgMaxValue.setDescription('This variable represents an individual value for the lpMemoryUsageAvgMaxTable.')
lpDS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5))
lpDS3RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1), )
if mibBuilder.loadTexts: lpDS3RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3 components.')
lpDS3RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RowStatusEntry.setDescription('A single entry in the table represents a single lpDS3 component.')
lpDS3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3 components. These components can be added and deleted.')
lpDS3ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StorageType.setDescription('This variable represents the storage type value for the lpDS3 tables.')
lpDS3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpDS3Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3Index.setDescription('This variable represents the index for the lpDS3 tables.')
lpDS3ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10), )
if mibBuilder.loadTexts: lpDS3ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ProvTable.setDescription('This group contains all of the provisioning data for a DS3 component.')
lpDS3ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ProvEntry.setDescription('An entry in the lpDS3ProvTable.')
lpDS3CbitParity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CbitParity.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CbitParity.setDescription('This attribute indicates if C-Bit parity has been turned ON or OFF. The CBIT component will appear under the DS3 component when the cbitParity attribute is set to on.')
lpDS3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 450)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineLength.setDescription('This attribute defines the line length for equalization calculations for the DS3 line. The range is between 0 and 450 feet (1 metre = 3.28 feet). Note: There are currently only two ranges as far as the equalization calculation performed on the FP is concerned: 0 to 224ft and 225 to 450ft.')
lpDS3ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ClockingSource.setDescription("This attribute defines the type of clocking source used for synchronizing the DS3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means use of a signal phase-locked to the incoming DS3 line rate; module means the use of a signal phase-locked to the CP reference clock. Note that the multiport cell-based cards have one common clock source for all ports. For this reason, the following rules apply for the value of clockingSource across the board's three ports: All three clockingSource values must be 'local' OR All three clockingSource values must be 'module' OR One clockingSource value must be 'line' and the other two must be 'otherPort'. The there is no NS component provisioned, the default value for this attribute will be local. If the NS component has been provisioned, the default value is module, except for the 1pDS3C cards. For the 1pDS3C cards, the default and only valid value for this attribute is local. The clockingSource of the DS1 sub-component becomes the effective clocking source for this attribute. All the DS1 sub-components have the same clocking source.")
lpDS3ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the DS3 component.')
lpDS3Mapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("direct", 0), ("plcp", 1))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3Mapping.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3Mapping.setDescription('This attribute indicates if ATM cells will be mapped directly into the DS3 payload, or whether PLCP mapping will be used. The PLCP component will appear under the DS3 component when this attribute is set to plcp. This attribute will be ignored when set on frame-based cards.')
lpDS3CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 11), )
if mibBuilder.loadTexts: lpDS3CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpDS3CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CidDataEntry.setDescription('An entry in the lpDS3CidDataTable.')
lpDS3CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpDS3AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 12), )
if mibBuilder.loadTexts: lpDS3AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpDS3AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3AdminInfoEntry.setDescription('An entry in the lpDS3AdminInfoTable.')
lpDS3Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpDS3CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CommentText.setDescription('Any miscellaneous text about the facility.')
lpDS3IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 13), )
if mibBuilder.loadTexts: lpDS3IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpDS3IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3IfEntryEntry.setDescription('An entry in the lpDS3IfEntryTable.')
lpDS3IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpDS3IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpDS3OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 14), )
if mibBuilder.loadTexts: lpDS3OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpDS3OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3OperStatusEntry.setDescription('An entry in the lpDS3OperStatusTable.')
lpDS3SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpDS3StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15), )
if mibBuilder.loadTexts: lpDS3StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpDS3StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StateEntry.setDescription('An entry in the lpDS3StateTable.')
lpDS3AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpDS3ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpDS3ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpDS3AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpDS3StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpDS3UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpDS3OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16), )
if mibBuilder.loadTexts: lpDS3OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3OperTable.setDescription('This group contains the common operational data for DS3 component.')
lpDS3OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3OperEntry.setDescription('An entry in the lpDS3OperTable.')
lpDS3LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LosAlarm.setDescription('This attribute displays whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is detected at the DS3 line interface upon observing 175 +/- 75 continuous pulse positions with no pulses of either positive or negative polarity. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
lpDS3LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when Severely Errored Frame (SEF) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. A SEF defect is detected when 3 (or more) out of 16 (or fewer) F-bits are in error, or one (or more) M-bits in two (or more) out of four (or fewer) consecutive M-frames are in error. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. As long as SEF defects are detected, the node also transmits the far-end SEF/AIS defect indicator over the outgoing line. When not running in C-Bit Parity mode, the txRai attribute is also set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
lpDS3RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RxAisAlarm.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm state has been entered. An AIS alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is the occurrence of AIS (valid DS3 frame with payload containing the 1010...sequence and with C-Bits set to zero) in contiguous M-frames for a time greater than 100 milliseconds. If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the AIS alarm condition is cleared (after AIS has been no longer detected for a period of 10 seconds +/- 0.5 seconds). As long as AIS is detected, the node also transmits the far-end SEF/AIS defect indicator over the outgoing line. When not running in C-Bit Parity mode, the txRai attribute is also set to on when transmitting the far- end SEF/AIS defect indicator on the outgoing line. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
lpDS3RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RxRaiAlarm.setDescription('This attribute displays whether a Remote Alarm Indication (RAI) alarm state has been entered. When not running the C-Bit Parity mode, the RAI alarm state is entered when the far-end SEF/AIS defect indicator has been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the incoming DS3 line. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the RAI alarm condition is cleared. The condition is cleared when the far-end SEF/AIS defect indicator has not been detected for 10 seconds +/- 0.5 seconds. When running the C-Bit Parity mode, the RAI alarm state is entered upon detection of a far-end alarm over the Far-End Alarm and Control (FEAC) channel. The RAI alarm state is exited as soon as no more far-end alarm is detected on the FEAC channel. The far- end alarms that can be detected on the FEAC channel and that cause the RAI alarm state to be entered are: equipment failure alarm (service affecting), LOS alarm, LOF alarm, idle and AIS alarm. The rxRaiAlarm attribute is always set to off when the component has been locked and left offline.')
lpDS3RxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3RxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RxIdle.setDescription('This attribute displays whether an Idle failure condition has been reported on the DS3 port. An Idle condition is reported when DS3 Idle defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The DS3 Idle defect is the occurrence of a valid DS3 frame with the information bits set to a 11001100.. sequence. If the DS3 Idle defects are intermittently occurring, the DS3 Idle defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the Idle failure condition is cleared. The failure condition is cleared when the DS3 idle pattern has not been detected for at least 10 seconds +/- 0.5 seconds. The rxIdle attribute is always set to off when the component has been locked and left offline. The idle pattern indicates that the far-end is physically connected but not put in service. For instance, DS3 idle is transmitted on the outgoing line when the DS3 component is locked and not used for operational testing.')
lpDS3TxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TxAis.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm is being transmitted on the DS3 line. Currently, AIS is never transmitted by a Passport DS3 node.')
lpDS3TxRai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TxRai.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TxRai.setDescription('When not running C-Bit Parity mode, this attribute displays whether the far-end SEF/AIS defect indicator is transmitted over the outgoing line when the DS3 component has been unlocked or used in operational testing. When running in C-Bit Parity mode, this attribute displays whether a far-end alarm is sent over the Far-End Alarm and Control (FEAC) channel when the DS3 component has been unlocked or used in operational testing. When the DS3 component is locked and not used in operational testing, this attribute is always set to off.')
lpDS3TxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 16, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TxIdle.setDescription('This attribute displays whether the DS3 Idle signal is transmitted over the outgoing line. DS3 Idle is sent when the DS3 component has been locked and not used in operational testing.')
lpDS3StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17), )
if mibBuilder.loadTexts: lpDS3StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StatsTable.setDescription('This group contains the specific DS3 common operational data for a DS3 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"))
if mibBuilder.loadTexts: lpDS3StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3StatsEntry.setDescription('An entry in the lpDS3StatsTable.')
lpDS3RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3RunningTime.setDescription("This attribute indicates the total number of seconds since the DS3 component has been activated and been in unlocked state or used for operational testing. All the other error counts that follow as well as each DS3 subcomponent's error counts can be updated when this count is active.")
lpDS3ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has been in an error free state.')
lpDS3LineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCV) detected. A DS3 Line Code Violation is a B3Zs error. LCV counting is inhibited for second intervals where Line Severely Errored Second (LSES) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3LineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LES) that have been counted. A LES is declared for second intervals containing one or more LCV or one or more Loss Of Signal (LOS) defects.')
lpDS3LineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSES) that have been counted. A LSES is declared for second intervals containing more than 44 LCVs or one or more LOS defects.')
lpDS3LineLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LineLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineLosSec.setDescription('This attribute indicates the total number of Line LOS Seconds (LOSS) that have been counted. A LOSS is declared for second intervals containing one or more LOS defects.')
lpDS3LineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3LineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3LineFailures.setDescription('This attribute indicates the total number of times that a line failure (LOS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3PathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a P-bit parity error, or possibly a frame error or a disagreement between P-bits or X-bits. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3PathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of Path Errored Seconds is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
lpDS3PathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than 44 PCVs or one or more SEF or AIS defects. Counting of PSESs is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
lpDS3PathSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathSefAisSec.setDescription('This attribute indicates the total number of SEF/AIS Seconds (PSASs). A PSAS is declared for second intervals containing one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSAS is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
lpDS3PathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 path is unavailable. The DS3 path becomes unavailable at the onset of 10 consecutive Path Severely Errored Seconds (PSES). The 10 PSESs are included in the unavailable time. Once unavailable, the DS3 path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where PUAS is counted, counting of Path Coding Violations (PCV), Path Errored Seconds (PES), Path Severely Errored Seconds (PSES) and Path Sef/Ais Seconds (PSAS) is inhibited.')
lpDS3PathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOF/AIS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2))
lpDS3TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1), )
if mibBuilder.loadTexts: lpDS3TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3Test components.')
lpDS3TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3TestIndex"))
if mibBuilder.loadTexts: lpDS3TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3Test component.')
lpDS3TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3Test components. These components cannot be added nor deleted.')
lpDS3TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestStorageType.setDescription('This variable represents the storage type value for the lpDS3Test tables.')
lpDS3TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestIndex.setDescription('This variable represents the index for the lpDS3Test tables.')
lpDS3TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 10), )
if mibBuilder.loadTexts: lpDS3TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpDS3TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3TestIndex"))
if mibBuilder.loadTexts: lpDS3TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestStateEntry.setDescription('An entry in the lpDS3TestStateTable.')
lpDS3TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpDS3TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpDS3TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpDS3TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11), )
if mibBuilder.loadTexts: lpDS3TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpDS3TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3TestIndex"))
if mibBuilder.loadTexts: lpDS3TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestSetupEntry.setDescription('An entry in the lpDS3TestSetupTable.')
lpDS3TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpDS3TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpDS3TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpDS3TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpDS3TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpDS3TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpDS3TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpDS3TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpDS3TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12), )
if mibBuilder.loadTexts: lpDS3TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpDS3TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3TestIndex"))
if mibBuilder.loadTexts: lpDS3TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestResultsEntry.setDescription('An entry in the lpDS3TestResultsTable.')
lpDS3TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpDS3TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpDS3TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpDS3TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpDS3TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpDS3TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS3TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS3CBit = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3))
lpDS3CBitRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1), )
if mibBuilder.loadTexts: lpDS3CBitRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3CBit components.')
lpDS3CBitRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CBitIndex"))
if mibBuilder.loadTexts: lpDS3CBitRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3CBit component.')
lpDS3CBitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3CBit components. These components cannot be added nor deleted.')
lpDS3CBitComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3CBitStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitStorageType.setDescription('This variable represents the storage type value for the lpDS3CBit tables.')
lpDS3CBitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3CBitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitIndex.setDescription('This variable represents the index for the lpDS3CBit tables.')
lpDS3CBitOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 10), )
if mibBuilder.loadTexts: lpDS3CBitOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitOperationalTable.setDescription('This group contains the DS3 C-Bit Parity operational data for the CBIT component.')
lpDS3CBitOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CBitIndex"))
if mibBuilder.loadTexts: lpDS3CBitOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitOperationalEntry.setDescription('An entry in the lpDS3CBitOperationalTable.')
lpDS3CBitFarEndAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("equipmentFailure", 0), ("los", 1), ("sef", 2), ("ais", 3), ("idle", 4), ("none", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndAlarm.setDescription('This attribute indicates the Far-End alarm signal that is currently received at the DS3 interface. This signal is carried over the Far- End Alarm and Control (FEAC) bits of DS3 frames. Five far-end alarm signals can be received: far-end equipment failure that is received when the far-end terminal has detected a local equipment failure; far-end Loss Of Signal (LOS) that is received when the far- end DS3 terminal has declared a LOS failure condition; far-end Loss of Frame (LOF) when the far-end DS3 terminal has declared a Loss Of Frame (LOF) failure condition; far-end Alarm Indication Signal (AIS) when the far-end has declared an AIS failure condition; far-end Idle when the far-end has declared an Idle signal condition.')
lpDS3CBitLoopedbackToFarEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitLoopedbackToFarEnd.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitLoopedbackToFarEnd.setDescription('This indicates whether or not the DS3 component is currently looping back the incoming DS3 signal or one of its DS1 tributaries to the far-end DS3 terminal. This is activated when the far-end DS3 equipment has ordered the local terminal to do so. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) notused29(29) notused30(30) ds3Line(31)')
lpDS3CBitLoopbackAtFarEndRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitLoopbackAtFarEndRequested.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitLoopbackAtFarEndRequested.setDescription('This attribute indicates which DS1 tributaries are being looped back, or if the DS3 line is being looped back. Each value listed indicates a loopback request has been made. When a loopback deactivation command has been sent to the far end, the corresponding value will be removed from the list. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) notused29(29) notused30(30) ds3Line(31)')
lpDS3CBitStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11), )
if mibBuilder.loadTexts: lpDS3CBitStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitStatsTable.setDescription('This group contains the DS3 C-Bit Parity statistical data for the CBIT component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3CBitStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CBitIndex"))
if mibBuilder.loadTexts: lpDS3CBitStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitStatsEntry.setDescription('An entry in the lpDS3CBitStatsTable.')
lpDS3CBitCbitErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitCbitErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitCbitErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has not suffered any C-Bit errors.')
lpDS3CBitCbitCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitCbitCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitCbitCodeViolations.setDescription('This attribute indicates the total count of C-Bit Parity Code Violations (CCV). A CCV is obtained when the parity calculated over the previous DS3 frame and the value of the CP-bits appearing in the current DS3 frame differ. The value of this attribute will wrap around to 0 if it does reach its maximum value. CCV counting is inhibited for second intervals where C-Bit Parity Severely Errored Seconds (CSES) are counted. It is also inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3CBitCbitErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitCbitErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitCbitErroredSec.setDescription('This attribute indicates the total number of C-Bit Parity Errored Seconds (CES). A CES second is declared for second intervals containing one or more CCVs or when one or more SEF (Severely Errored Frame) or AIS (Alarm Indication Signal) defects. CES counting is inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted.')
lpDS3CBitCbitSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitCbitSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitCbitSevErroredSec.setDescription('This attribute indicates the total number of C-Bit Parity Severely Errored Seconds (CSES). A CSES is declared for second intervals containing more than 44 CCVs or one or more SEF or AIS defects. The occurrence of CSES in a one second interval causes the inhibition of CCV counting during that second interval. CSES counting is also inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted.')
lpDS3CBitCbitUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitCbitUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitCbitUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 path is unavailable. The DS3 path becomes unavailable at the onset of 10 consecutive C-Bit Severely Errored Seconds (CSES). The 10 CSESs are included in the unavailable time. Once unavailable, the DS3 path becomes available at the onset of 10 contiguous seconds with no CSES. The 10 seconds with no CSES are excluded from the unavailable time. For second intervals where CUAS is counted, counting of C-Bit Coding Violations (CCV), C-Bit Errored Seconds (CES) and C-Bit Severely Errored Seconds (CSES) is inhibited.')
lpDS3CBitFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has not suffered of any far-end errors.')
lpDS3CBitFarEndCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndCodeViolations.setDescription('This attribute indicates the total count of DS3 frames containing a Coding Violation on the Far-End (FECV), also known as a Far-End Block Error (FEBE). Each FEBE is reported over the FEBE bits each time the far-end DS3 terminal detects a C-BIT Parity error over a received DS3 frame. For second intervals where Far-End Unavailable Seconds (FEAUS) or Far-End Severely Errored Seconds (FESES) are counted, counting of FECVs is inhibited. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3CBitFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndErroredSec.setDescription('This attribute indicates the total number of Far-End Errored Seconds (FEES). A FEES is declared for second intervals containing with one or more FECVs or one or more far-end SEF/ AIS defects. A far-end SEF/AIS defect occurs when the X-Bits of the DS3 frame are received as being set to zero. For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FEESs is inhibited.')
lpDS3CBitFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndSevErroredSec.setDescription('This attribute indicates the total number of Far-End Severely Errored Seconds (FESES). A FESES is declared for second intervals containing more than 44 FECVs or one or more far-end SEF/AIS defects. For second intervals where a FESES is counted, counting of FECVs is inhibited. For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FESESs is inhibited.')
lpDS3CBitFarEndSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndSefAisSec.setDescription('This attribute indicates the total number of Far-End SEF/AIS Seconds (FESAS). A FESAS is declared for second intervals containing one or more far-end SEF/AIS defects.For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FESASs is inhibited.')
lpDS3CBitFarEndUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 far-end path is unavailable. The DS3 far-end path becomes unavailable at the onset of 10 consecutive Far-End Severely Errored Seconds (FESES). The 10 FESESs are included in the unavailable time. Once unavailable, the DS3 far-end path becomes available at the onset of 10 contiguous seconds with no FESES. The 10 seconds with no FESES are excluded from the unavailable time. For second intervals where FEUAS is counted, counting of Far-End Coding Violations (FECV), Far-End Errored Seconds (FEES), Far-End Severely Errored Seconds (FESES) and Far-End Sef/Ais Seconds (FESAS) is inhibited.')
lpDS3CBitFarEndFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 3, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CBitFarEndFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CBitFarEndFailures.setDescription('This attribute indicates the total number of times that a far-end path failure (i.e. a Far-End SEF/AIS defect) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3Plcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4))
lpDS3PlcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1), )
if mibBuilder.loadTexts: lpDS3PlcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3Plcp components.')
lpDS3PlcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3PlcpIndex"))
if mibBuilder.loadTexts: lpDS3PlcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3Plcp component.')
lpDS3PlcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3Plcp components. These components cannot be added nor deleted.')
lpDS3PlcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3PlcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpStorageType.setDescription('This variable represents the storage type value for the lpDS3Plcp tables.')
lpDS3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpIndex.setDescription('This variable represents the index for the lpDS3Plcp tables.')
lpDS3PlcpOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 10), )
if mibBuilder.loadTexts: lpDS3PlcpOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpOperationalTable.setDescription('This group contains the operational data for the PLCP component.')
lpDS3PlcpOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3PlcpIndex"))
if mibBuilder.loadTexts: lpDS3PlcpOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpOperationalEntry.setDescription('An entry in the lpDS3PlcpOperationalTable.')
lpDS3PlcpLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpLofAlarm.setDescription('This attribute displays whether a PLCP Loss Of Frame (LOF) failure alarm state has been entered. An LOF failure is declared when a PLCP LOF defect persists for 2.5 s +/- 0.5 s. An LOF defect occurs when an OOF (Out of Frame) state persists for more than 1 ms. If the OOF events are intermittent, the LOF defect counter is decremented at a rate of 1/12 (for DS3 PLCP) or 1/9 (for G.751 E3 PLCP) of the incrementing rate, with all measurements based on a 200 ms polling cycle. An OOF event (also known as a PLCP SEF event) is declared when an error is detected in both the A1 and A2 octets, or when two consecutive POHIDs are found in error. OOF is removed when two valid sets of framing octets and two valid and sequential POHID octets have been found. The LOF defect is removed when the defect counter reaches zero, i.e. when OOF events are absent for more than 12 ms (DS3 PLCP) or 9 ms (G.751 E3 PLCP). LOF failure alarm is cleared when LOF defect is absent for 10.0 s +/- 0.5 s The DS3 or E3 component goes into an operational state of disabled until the LOF failure alarm is cleared. The terminal declaring the LOF failure alarm will transmit a PLCP RAI signal to the far-end for the duration of the alarm. The lofAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
lpDS3PlcpRxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpRxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpRxRaiAlarm.setDescription('This attribute displays whether a PLCP Remote Alarm Indication (RAI) failure alarm state has been entered. An RAI failure alarm occurs when ten consecutive PLCP RAI bits (bit 5 in the G1 byte) are high on the incoming line. An RAI failure alarm is cleared when ten consecutive RAI bits are set to 0. Note: Some standards call this alarm RFI. The rxRaiAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
lpDS3PlcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11), )
if mibBuilder.loadTexts: lpDS3PlcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpStatsTable.setDescription('This group contains the statistical data for the PLCP component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3PlcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3PlcpIndex"))
if mibBuilder.loadTexts: lpDS3PlcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpStatsEntry.setDescription('An entry in the lpDS3PlcpStatsTable.')
lpDS3PlcpErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the near-end PLCP path layer had no errors.')
lpDS3PlcpCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpCodingViolations.setDescription('This attribute indicates the total number of BIP-8 Errors, framing pattern octet errors, and path overhead identification errors detected in received PLCP frames. Counting of PLCP CV is inhibited for second intervals where PLCP Severely Errored Framing Seconds (SEFS) or PLCP Unavailable Seconds (UAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3PlcpErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Coding Violations (CV) or in which a PLCP Severely Errored Framing Second (SEFS) was counted. Counting of PLCP ES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpDS3PlcpSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCPCVs or in which a PLCPSEFS was counted (i.e. a PLCP OOF event occurred). Counting of PLCP SES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpDS3PlcpSevErroredFramingSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpSevErroredFramingSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpSevErroredFramingSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Severely Errored Frame (SEF) events. An SEF event is equivalent to a PLCP OOF (Out of Frame) event. Counting of PLCPP SEFSs is inhibited for second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpDS3PlcpUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpUnavailSec.setDescription('This attribute indicates the number of seconds when the near-end PLCP layer is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP LOF (Loss of Frame) failure alarm state. The PLCP Path Layer becomes available again only after clearing this condition. For second intervals where PLCP UAS are counted, counting of PLCP Severely Errored Framing Seconds (SEFS), PLCP Coding Violations (CV), PLCP Errored Seconds (ES), PLCP Severely Errored Seconds (SES) and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
lpDS3PlcpFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the far- end PLCP path layer had no errors.')
lpDS3PlcpFarEndCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpFarEndCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpFarEndCodingViolations.setDescription('This attribute indicates the total number of PLCP Far-End Block Errors (FEBE) reported by the far-end terminal. Counting of FEBEs is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3PlcpFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpFarEndErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FEES is inhibited during second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
lpDS3PlcpFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpFarEndSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FESES is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
lpDS3PlcpFarEndUnavailableSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3PlcpFarEndUnavailableSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3PlcpFarEndUnavailableSec.setDescription('This attribute indicates the number of seconds during which the PLCP far end is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP RAI (Remote Alarm Indication). Service becomes available again after this condition is cleared. For second intervals where PLCP FEUAS are counted, counting of PLCP Far-End Coding Violations (FECV), PLCP Far- End Errored Seconds (FEES), and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
lpDS3Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5))
lpDS3CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1), )
if mibBuilder.loadTexts: lpDS3CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3Cell components.')
lpDS3CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CellIndex"))
if mibBuilder.loadTexts: lpDS3CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3Cell component.')
lpDS3CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3Cell components. These components can be added and deleted.')
lpDS3CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellStorageType.setDescription('This variable represents the storage type value for the lpDS3Cell tables.')
lpDS3CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellIndex.setDescription('This variable represents the index for the lpDS3Cell tables.')
lpDS3CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 10), )
if mibBuilder.loadTexts: lpDS3CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpDS3CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CellIndex"))
if mibBuilder.loadTexts: lpDS3CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellProvEntry.setDescription('An entry in the lpDS3CellProvTable.')
lpDS3CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpDS3CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpDS3CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpDS3CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 11), )
if mibBuilder.loadTexts: lpDS3CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpDS3CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CellIndex"))
if mibBuilder.loadTexts: lpDS3CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellOperEntry.setDescription('An entry in the lpDS3CellOperTable.')
lpDS3CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12), )
if mibBuilder.loadTexts: lpDS3CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3CellIndex"))
if mibBuilder.loadTexts: lpDS3CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellStatsEntry.setDescription('An entry in the lpDS3CellStatsTable.')
lpDS3CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpDS3CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpDS3CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpDS3DS1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6))
lpDS3DS1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1), )
if mibBuilder.loadTexts: lpDS3DS1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1 components.')
lpDS3DS1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1 component.')
lpDS3DS1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1 components. These components can be added and deleted.')
lpDS3DS1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StorageType.setDescription('This variable represents the storage type value for the lpDS3DS1 tables.')
lpDS3DS1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28)))
if mibBuilder.loadTexts: lpDS3DS1Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1Index.setDescription('This variable represents the index for the lpDS3DS1 tables.')
lpDS3DS1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 10), )
if mibBuilder.loadTexts: lpDS3DS1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ProvTable.setDescription('This group contains all of the provisioning data for a DS1 component.')
lpDS3DS1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ProvEntry.setDescription('An entry in the lpDS3DS1ProvTable.')
lpDS3DS1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("d4", 0), ("esf", 1), ("d4Cas", 4), ("esfCas", 5))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1LineType.setDescription('This attribute defines the framing of the DS1 tributary. d4 defines a framing pattern of 12 frames per multiframe. esf defines a framing pattern of 24 frames per multiframe. d4Cas defines a framing pattern of 12 frames per multiframe with channel associated signalling. esfCas defines a framing pattern of 24 frames per multiframe with channel associated signalling.')
lpDS3DS1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3))).clone(namedValues=NamedValues(("bit7Stuffing", 0), ("none", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ZeroCoding.setDescription("This attribute defines the zero encoding on the DS1 tributary. bit7Stuffing sets bit 7 of every timeslot to a one to guarantee ones's density. This reduces the available bandwidth of the channel by 1/8. none does no zero encoding.")
lpDS3DS1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ClockingSource.setDescription('This attribute defines the source of the transmit clock for the DS1 tributary. When the clocking source is selected from local, the crystal on the port generates the clocking for the DS1 tributary. When the clocking source is selected from line, the port synchronizes to the clock from the DS1 tributary. When the clocking source is selected from module, the ports clock synchronizes to the clock provided by the oscillator on the active CP. On a 1pDS3C card, if the NetworkSynchronization (NS) component is present the default value of this attribute will be module otherwise it will be line. On a 2pDS3cAal card, the only valid values are local and module. If the NS component is present the default value of this attribute will be module otherwise it will be local.')
lpDS3DS1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 11), )
if mibBuilder.loadTexts: lpDS3DS1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpDS3DS1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1CidDataEntry.setDescription('An entry in the lpDS3DS1CidDataTable.')
lpDS3DS1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpDS3DS1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 12), )
if mibBuilder.loadTexts: lpDS3DS1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpDS3DS1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1AdminInfoEntry.setDescription('An entry in the lpDS3DS1AdminInfoTable.')
lpDS3DS1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpDS3DS1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1CommentText.setDescription('Any miscellaneous text about the facility.')
lpDS3DS1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 13), )
if mibBuilder.loadTexts: lpDS3DS1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpDS3DS1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1IfEntryEntry.setDescription('An entry in the lpDS3DS1IfEntryTable.')
lpDS3DS1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpDS3DS1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpDS3DS1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 14), )
if mibBuilder.loadTexts: lpDS3DS1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpDS3DS1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1OperStatusEntry.setDescription('An entry in the lpDS3DS1OperStatusTable.')
lpDS3DS1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpDS3DS1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15), )
if mibBuilder.loadTexts: lpDS3DS1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpDS3DS1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StateEntry.setDescription('An entry in the lpDS3DS1StateTable.')
lpDS3DS1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpDS3DS1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpDS3DS1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpDS3DS1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpDS3DS1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpDS3DS1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpDS3DS1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16), )
if mibBuilder.loadTexts: lpDS3DS1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
lpDS3DS1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1OperEntry.setDescription('An entry in the lpDS3DS1OperTable.')
lpDS3DS1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RxAisAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/- 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period. If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. This tributary goes into an operationalState of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.')
lpDS3DS1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1LofAlarm.setDescription('This attribute indicates whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (2 out of 5 framing bits in error ) have been detected for 3 seconds +/- 0.5 seconds. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. This tributary goes into an operationalState of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
lpDS3DS1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RxRaiAlarm.setDescription('This attribute indicates whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/ 10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds. The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
lpDS3DS1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TxAisAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the tributary is in a locked state.')
lpDS3DS1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TxRaiAlarm.setDescription('This attribute indicates whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the tributary detects a LOF alarm condition.')
lpDS3DS1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17), )
if mibBuilder.loadTexts: lpDS3DS1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
lpDS3DS1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"))
if mibBuilder.loadTexts: lpDS3DS1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1StatsEntry.setDescription('An entry in the lpDS3DS1StatsTable.')
lpDS3DS1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1RunningTime.setDescription('This attribute counts the number of seconds since the tributary was activated.')
lpDS3DS1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ErrorFreeSec.setDescription('This attribute counts the number of seconds that the tributary has been in an error free state.')
lpDS3DS1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ErroredSec.setDescription('This attribute counts the number of errored seconds the tributary has counted since it was activated. An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
lpDS3DS1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1SevErroredSec.setDescription('This attribute counts the number of severely errored seconds the tributary has counted since it was activated. A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
lpDS3DS1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1SevErroredFrmSec.setDescription('This attribute counts the number of severely errored framing seconds the tributary has counted since it was activated A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
lpDS3DS1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1UnavailSec.setDescription('This attribute counts the total number of seconds that the tributary has been in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
lpDS3DS1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1CrcErrors.setDescription('This attribute counts the total number of CRC-6 errors. These will only be counted when the lineType is esf.')
lpDS3DS1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1FrmErrors.setDescription('This attribute counts the total number of frame errors. A frame error is an error in the framing bits.')
lpDS3DS1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip.')
lpDS3DS1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2))
lpDS3DS1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1), )
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1Chan components.')
lpDS3DS1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1Chan component.')
lpDS3DS1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1Chan components. These components can be added and deleted.')
lpDS3DS1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanStorageType.setDescription('This variable represents the storage type value for the lpDS3DS1Chan tables.')
lpDS3DS1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: lpDS3DS1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanIndex.setDescription('This variable represents the index for the lpDS3DS1Chan tables.')
lpDS3DS1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 10), )
if mibBuilder.loadTexts: lpDS3DS1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
lpDS3DS1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanProvEntry.setDescription('An entry in the lpDS3DS1ChanProvTable.')
lpDS3DS1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
lpDS3DS1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependent on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56kbit/s is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
lpDS3DS1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
lpDS3DS1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 11), )
if mibBuilder.loadTexts: lpDS3DS1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpDS3DS1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCidDataEntry.setDescription('An entry in the lpDS3DS1ChanCidDataTable.')
lpDS3DS1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpDS3DS1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 12), )
if mibBuilder.loadTexts: lpDS3DS1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpDS3DS1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanIfEntryEntry.setDescription('An entry in the lpDS3DS1ChanIfEntryTable.')
lpDS3DS1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpDS3DS1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpDS3DS1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 13), )
if mibBuilder.loadTexts: lpDS3DS1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpDS3DS1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanOperStatusEntry.setDescription('An entry in the lpDS3DS1ChanOperStatusTable.')
lpDS3DS1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpDS3DS1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14), )
if mibBuilder.loadTexts: lpDS3DS1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpDS3DS1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanStateEntry.setDescription('An entry in the lpDS3DS1ChanStateTable.')
lpDS3DS1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS3DS1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpDS3DS1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpDS3DS1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpDS3DS1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpDS3DS1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpDS3DS1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpDS3DS1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 15), )
if mibBuilder.loadTexts: lpDS3DS1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
lpDS3DS1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanOperEntry.setDescription('An entry in the lpDS3DS1ChanOperTable.')
lpDS3DS1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
lpDS3DS1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 16), )
if mibBuilder.loadTexts: lpDS3DS1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpDS3DS1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanAdminInfoEntry.setDescription('An entry in the lpDS3DS1ChanAdminInfoTable.')
lpDS3DS1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
lpDS3DS1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
lpDS3DS1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2))
lpDS3DS1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1), )
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1ChanTest components.')
lpDS3DS1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1ChanTest component.')
lpDS3DS1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1ChanTest components. These components cannot be added nor deleted.')
lpDS3DS1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestStorageType.setDescription('This variable represents the storage type value for the lpDS3DS1ChanTest tables.')
lpDS3DS1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3DS1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestIndex.setDescription('This variable represents the index for the lpDS3DS1ChanTest tables.')
lpDS3DS1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 10), )
if mibBuilder.loadTexts: lpDS3DS1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpDS3DS1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestStateEntry.setDescription('An entry in the lpDS3DS1ChanTestStateTable.')
lpDS3DS1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpDS3DS1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpDS3DS1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpDS3DS1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11), )
if mibBuilder.loadTexts: lpDS3DS1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpDS3DS1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestSetupEntry.setDescription('An entry in the lpDS3DS1ChanTestSetupTable.')
lpDS3DS1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpDS3DS1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpDS3DS1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpDS3DS1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpDS3DS1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpDS3DS1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpDS3DS1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpDS3DS1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpDS3DS1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12), )
if mibBuilder.loadTexts: lpDS3DS1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpDS3DS1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestResultsEntry.setDescription('An entry in the lpDS3DS1ChanTestResultsTable.')
lpDS3DS1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpDS3DS1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpDS3DS1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpDS3DS1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpDS3DS1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3DS1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3DS1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpDS3DS1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3DS1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3DS1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS3DS1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS3DS1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3))
lpDS3DS1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1), )
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1ChanCell components.')
lpDS3DS1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1ChanCell component.')
lpDS3DS1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1ChanCell components. These components can be added and deleted.')
lpDS3DS1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellStorageType.setDescription('This variable represents the storage type value for the lpDS3DS1ChanCell tables.')
lpDS3DS1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3DS1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellIndex.setDescription('This variable represents the index for the lpDS3DS1ChanCell tables.')
lpDS3DS1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 10), )
if mibBuilder.loadTexts: lpDS3DS1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpDS3DS1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellProvEntry.setDescription('An entry in the lpDS3DS1ChanCellProvTable.')
lpDS3DS1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpDS3DS1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpDS3DS1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpDS3DS1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 11), )
if mibBuilder.loadTexts: lpDS3DS1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpDS3DS1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellOperEntry.setDescription('An entry in the lpDS3DS1ChanCellOperTable.')
lpDS3DS1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3DS1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12), )
if mibBuilder.loadTexts: lpDS3DS1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS3DS1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellStatsEntry.setDescription('An entry in the lpDS3DS1ChanCellStatsTable.')
lpDS3DS1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpDS3DS1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpDS3DS1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3DS1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS3DS1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpDS3DS1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4))
lpDS3DS1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1), )
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1ChanTc components.')
lpDS3DS1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1ChanTc component.')
lpDS3DS1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1ChanTc components. These components can be added and deleted.')
lpDS3DS1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcStorageType.setDescription('This variable represents the storage type value for the lpDS3DS1ChanTc tables.')
lpDS3DS1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3DS1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcIndex.setDescription('This variable represents the index for the lpDS3DS1ChanTc tables.')
lpDS3DS1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 10), )
if mibBuilder.loadTexts: lpDS3DS1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
lpDS3DS1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcProvEntry.setDescription('An entry in the lpDS3DS1ChanTcProvTable.')
lpDS3DS1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
lpDS3DS1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
lpDS3DS1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 11), )
if mibBuilder.loadTexts: lpDS3DS1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
lpDS3DS1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcOpEntry.setDescription('An entry in the lpDS3DS1ChanTcOpTable.')
lpDS3DS1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
lpDS3DS1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
lpDS3DS1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 398), )
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpDS3DS1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneEntry.setDescription('An entry in the lpDS3DS1ChanTcSigOneTable.')
lpDS3DS1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneIndex.setDescription('This variable represents the lpDS3DS1ChanTcSigOneTable specific index for the lpDS3DS1ChanTcSigOneTable.')
lpDS3DS1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigOneValue.setDescription('This variable represents an individual value for the lpDS3DS1ChanTcSigOneTable.')
lpDS3DS1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 399), )
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpDS3DS1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoEntry.setDescription('An entry in the lpDS3DS1ChanTcSigTwoTable.')
lpDS3DS1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoIndex.setDescription('This variable represents the lpDS3DS1ChanTcSigTwoTable specific index for the lpDS3DS1ChanTcSigTwoTable.')
lpDS3DS1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the lpDS3DS1ChanTcSigTwoTable.')
lpDS3DS1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3))
lpDS3DS1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1), )
if mibBuilder.loadTexts: lpDS3DS1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS3DS1Test components.')
lpDS3DS1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1TestIndex"))
if mibBuilder.loadTexts: lpDS3DS1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestRowStatusEntry.setDescription('A single entry in the table represents a single lpDS3DS1Test component.')
lpDS3DS1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS3DS1Test components. These components cannot be added nor deleted.')
lpDS3DS1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS3DS1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestStorageType.setDescription('This variable represents the storage type value for the lpDS3DS1Test tables.')
lpDS3DS1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS3DS1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestIndex.setDescription('This variable represents the index for the lpDS3DS1Test tables.')
lpDS3DS1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 10), )
if mibBuilder.loadTexts: lpDS3DS1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpDS3DS1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1TestIndex"))
if mibBuilder.loadTexts: lpDS3DS1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestStateEntry.setDescription('An entry in the lpDS3DS1TestStateTable.')
lpDS3DS1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpDS3DS1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpDS3DS1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpDS3DS1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11), )
if mibBuilder.loadTexts: lpDS3DS1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpDS3DS1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1TestIndex"))
if mibBuilder.loadTexts: lpDS3DS1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestSetupEntry.setDescription('An entry in the lpDS3DS1TestSetupTable.')
lpDS3DS1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpDS3DS1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpDS3DS1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpDS3DS1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpDS3DS1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpDS3DS1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpDS3DS1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpDS3DS1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS3DS1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpDS3DS1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12), )
if mibBuilder.loadTexts: lpDS3DS1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpDS3DS1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS3DS1TestIndex"))
if mibBuilder.loadTexts: lpDS3DS1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestResultsEntry.setDescription('An entry in the lpDS3DS1TestResultsTable.')
lpDS3DS1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpDS3DS1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpDS3DS1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpDS3DS1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpDS3DS1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3DS1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpDS3DS1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpDS3DS1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3DS1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS3DS1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS3DS1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 5, 6, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS3DS1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS3DS1TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6))
lpE3RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1), )
if mibBuilder.loadTexts: lpE3RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RowStatusTable.setDescription('This entry controls the addition and deletion of lpE3 components.')
lpE3RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RowStatusEntry.setDescription('A single entry in the table represents a single lpE3 component.')
lpE3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE3 components. These components can be added and deleted.')
lpE3ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE3StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StorageType.setDescription('This variable represents the storage type value for the lpE3 tables.')
lpE3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpE3Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3Index.setDescription('This variable represents the index for the lpE3 tables.')
lpE3ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10), )
if mibBuilder.loadTexts: lpE3ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ProvTable.setDescription('This group contains all of the provisioning data for a E3 component.')
lpE3ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ProvEntry.setDescription('An entry in the lpE3ProvTable.')
lpE3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 300)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineLength.setDescription('This attribute defines the line length for equalization calculations for the E3 line. The line length range is between 0 and 300 metres (1 metres = 3.28 feet).')
lpE3ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ClockingSource.setDescription("This attribute defines the type of clocking source used for synchronizing the E3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means use of a signal phase-locked to the incoming E3 line rate; module means the use of a signal phase-locked to the CP reference clock. Note that the multiport cell-based cards have one common clock source for each of the three ports. For this reason, the following rules apply for the value of clockingSource across the board's three ports: All three clockingSource values must be 'local' OR All three clockingSource values must be 'module' OR One clockingSource value must be 'line' and the other two must be 'otherPort'. The default value for this attribute will be module if a CP clock is available, and local otherwise.")
lpE3ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the E3 component.')
lpE3Mapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("direct", 0), ("plcp", 1))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3Mapping.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3Mapping.setDescription('This attribute indicates if ATM cells will be mapped directly into the E3 payload, or whether PLCP mapping will be used. The PLCP component will appear under the E3 component when this attribute is set to plcp. This attribute will be ignored when set on frame- based cards.')
lpE3Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("g751", 0), ("g832", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3Framing.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3Framing.setDescription('This attribute indicates if the framing mode will be in accordance with the CCITT G.751 or G.832 specification. The G832 component will appear under the E3 component when this attribute is set to g832. This attribute may only be set on cell-based card types. Note also that this attribute may only be set to g751 if the mapping attribute is set to plcp. The default value of this attribute will be g751 for frame-based cards, and g832 for cell-based cards. Note: when E3 framing is changed from g832 to g751, the G832 component must be deleted.')
lpE3LinkAlarmActivationThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 2600)).clone(2200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3LinkAlarmActivationThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LinkAlarmActivationThreshold.setDescription('This attribute specifies the time interval between the detection of a sustained link failure and the activation of an alarm. It is provisionable for E3 cards.')
lpE3LinkAlarmScanInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(50, 250)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3LinkAlarmScanInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LinkAlarmScanInterval.setDescription('This attribute specifies the alarm scan timer polling interval. It determines how frequently the status of the link is monitored after a first link error interrupt. It is provisionable for E3 cards.')
lpE3CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 11), )
if mibBuilder.loadTexts: lpE3CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpE3CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CidDataEntry.setDescription('An entry in the lpE3CidDataTable.')
lpE3CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpE3AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 12), )
if mibBuilder.loadTexts: lpE3AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpE3AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3AdminInfoEntry.setDescription('An entry in the lpE3AdminInfoTable.')
lpE3Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpE3CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CommentText.setDescription('Any miscellaneous text about the facility.')
lpE3IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 13), )
if mibBuilder.loadTexts: lpE3IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpE3IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3IfEntryEntry.setDescription('An entry in the lpE3IfEntryTable.')
lpE3IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpE3IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpE3OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 14), )
if mibBuilder.loadTexts: lpE3OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpE3OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3OperStatusEntry.setDescription('An entry in the lpE3OperStatusTable.')
lpE3SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpE3StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15), )
if mibBuilder.loadTexts: lpE3StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpE3StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StateEntry.setDescription('An entry in the lpE3StateTable.')
lpE3AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE3OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE3UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE3AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpE3ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpE3ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpE3AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpE3StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpE3UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpE3OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16), )
if mibBuilder.loadTexts: lpE3OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3OperTable.setDescription('This group contains the common operational data for E3 component.')
lpE3OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3OperEntry.setDescription('An entry in the lpE3OperTable.')
lpE3LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LosAlarm.setDescription('This attribute displays whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects has been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is detected at the E3 line interface upon observing N continuous pulse positions with no pulses of either positive or negative polarity, where N is between 10 and 255. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared when the LOS defects are absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
lpE3LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when Severely Errored Frame (SEF) defects have been detected and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An E3 SEF defect is reported after detecting Frame Alignment Signal (FAS) errors on 4 consecutive E3 frames received on the incoming line. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when E3 framing has been achieved for a period of 10 seconds +/- 0.5 seconds. As long as SEF defects are detected, the node also transmits the far-end SEF/AIS (in G.751 E3) or FERF (in G.832) defect indicator over the outgoing line. The txRai attribute is set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
lpE3RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RxAisAlarm.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm when state has been entered. An AIS alarm state is entered when AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the incoming E3 line. An AIS defect is the occurrence of the AIS (unframed signal with a density of zeros below a certain threshold such as defined by ITU Recommendation G.775). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/ 10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the AIS alarm condition is cleared (after AIS has been no longer detected for a period of 10 seconds +/- 0.5 seconds). As long as AIS is detected on the incoming line, the node also transmits the far-end SEF/AIS (in G.751 E3) or FERF (in G.832) defect indicator over the outgoing line. The txRai attribute is set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
lpE3RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RxRaiAlarm.setDescription('This attribute displays whether a Remote Alarm Indication (RAI) alarm state has been entered. A RAI alarm state is entered when far- end SEF/AIS defects (or Far-End Receive Failure (FERF) defects in G.832 E3 Framing mode) have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the E3 incoming line. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the RAI alarm condition is cleared. The condition is cleared when the far-end defect indicator has not been detected for 10 seconds +/- 0.5 seconds. The declaration of a RAI Alarm is usually a signal that the far end facility is unable to gain synchronization. The rxRaiAlarm attribute is always set to off when the component has been locked and left offline.')
lpE3TxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TxAis.setDescription('This attribute displays whether an AIS alarm is being transmitted on the E3 line. AIS is transmitted on the outgoing line when the E3 component is locked and not used for operational testing.')
lpE3TxRai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TxRai.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TxRai.setDescription("This attribute displays whether the far-end SEF/AIS defect indicator is transmitted over the outgoing line when the E3 component has been unlocked or used in operational testing. When the E3 component is locked and not used in operational testing, this attribute is always set to off. The far-end SEF/AIS defect indicator is transmitted over the outgoing line when SEF/AIS defects are detected on the incoming line. In G.832 E3 Framing mode, the FERF bit is set to '1' to transmit the SEF/AIS defect indicator.")
lpE3StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17), )
if mibBuilder.loadTexts: lpE3StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StatsTable.setDescription('This group contains the common operational data for E3 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"))
if mibBuilder.loadTexts: lpE3StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3StatsEntry.setDescription('An entry in the lpE3StatsTable.')
lpE3RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3RunningTime.setDescription("This attribute indicates the total number of seconds since the E3 component has been activated and been in unlocked state or used for operational testing. All the other error counts that follow as well as each E3 subcomponent's error counts can be updated when this count is active.")
lpE3ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the E3 port has been in an error free state.')
lpE3LineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCV) detected. An E3 Line Code Violation is an HDB3 coded signal error. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3LineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LES) that have been counted. A LES is declared for interval seconds containing one or more Line Code Violations (LCV) or one or more Loss Of Signal (LOS) defects.')
lpE3LineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSES) that have been counted. A LSES is declared for second intervals containing more than 34 Line Code Violations (LCV) or one or more Loss of Signal (LOS) defects.')
lpE3LineLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LineLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineLosSec.setDescription('This attribute indicates the total number of Line LOS Seconds (LOSS) that have been counted. A LOSS is declared for second intervals containing one or more Loss of Signal (LOS) defects.')
lpE3LineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3LineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3LineFailures.setDescription('This attribute indicates the total number of times that a line failure (LOS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3PathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCV) detected. An E3 PCV is an error in the Frame Alignment (FA) signal, or, in G.832 Framing Mode, an error in the Frame Alignment signal or a BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3PathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PES) that have been counted. A PES is declared for second intervals containing one or more Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of Path Errored Seconds is inhibited when a Path Unavailable Second (PUAS) is counted over the monitored second.')
lpE3PathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSES) that have been counted. A PSES is declared for second intervals containing more than 22 (G.751 E3) or 34 (G.832 E3) Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSESs is inhibited when a Path Unavailable Second (PUAS) is counted over the monitored second.')
lpE3PathSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathSefAisSec.setDescription('This attribute indicates the total number of Path SEF/AIS Seconds (PSAS). A PSAS is declared for second intervals containing one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSAS is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
lpE3PathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the E3 path is unavailable. The E3 path becomes unavailable at the onset of 10 consecutive Path Severely Errored Seconds (PSES). The 10 PSESs are included in the unavailable time. Once unavailable, the E3 path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where PUAS is counted, counting of Path Code Violations (PCV), Path Errored Seconds (PES), Path Severely Errored Seconds (PSES) and Path SefAis Seconds (PSAS) is inhibited.')
lpE3PathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOF/AIS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2))
lpE3TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1), )
if mibBuilder.loadTexts: lpE3TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpE3Test components.')
lpE3TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3TestIndex"))
if mibBuilder.loadTexts: lpE3TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestRowStatusEntry.setDescription('A single entry in the table represents a single lpE3Test component.')
lpE3TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE3Test components. These components cannot be added nor deleted.')
lpE3TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE3TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestStorageType.setDescription('This variable represents the storage type value for the lpE3Test tables.')
lpE3TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE3TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestIndex.setDescription('This variable represents the index for the lpE3Test tables.')
lpE3TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 10), )
if mibBuilder.loadTexts: lpE3TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpE3TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3TestIndex"))
if mibBuilder.loadTexts: lpE3TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestStateEntry.setDescription('An entry in the lpE3TestStateTable.')
lpE3TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpE3TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpE3TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpE3TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11), )
if mibBuilder.loadTexts: lpE3TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpE3TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3TestIndex"))
if mibBuilder.loadTexts: lpE3TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestSetupEntry.setDescription('An entry in the lpE3TestSetupTable.')
lpE3TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpE3TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpE3TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpE3TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpE3TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpE3TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpE3TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpE3TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpE3TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12), )
if mibBuilder.loadTexts: lpE3TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpE3TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3TestIndex"))
if mibBuilder.loadTexts: lpE3TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestResultsEntry.setDescription('An entry in the lpE3TestResultsTable.')
lpE3TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpE3TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpE3TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpE3TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpE3TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpE3TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpE3TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpE3TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE3TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE3TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE3TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE3G832 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3))
lpE3G832RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1), )
if mibBuilder.loadTexts: lpE3G832RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832RowStatusTable.setDescription('This entry controls the addition and deletion of lpE3G832 components.')
lpE3G832RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3G832Index"))
if mibBuilder.loadTexts: lpE3G832RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832RowStatusEntry.setDescription('A single entry in the table represents a single lpE3G832 component.')
lpE3G832RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3G832RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE3G832 components. These components can be added and deleted.')
lpE3G832ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE3G832StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832StorageType.setDescription('This variable represents the storage type value for the lpE3G832 tables.')
lpE3G832Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE3G832Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832Index.setDescription('This variable represents the index for the lpE3G832 tables.')
lpE3G832ProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 10), )
if mibBuilder.loadTexts: lpE3G832ProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832ProvisionedTable.setDescription('This group contains the provisionable data for the G832 component.')
lpE3G832ProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3G832Index"))
if mibBuilder.loadTexts: lpE3G832ProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832ProvisionedEntry.setDescription('An entry in the lpE3G832ProvisionedTable.')
lpE3G832TrailTraceTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3G832TrailTraceTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832TrailTraceTransmitted.setDescription('This attribute indicates the E.164 address which is to be encoded in the trail access point identifier, which is transmitted using the Trail Trace (TR) field of the transmitted E3 Frame. Both the expected trail access point identifier and the transmitted trail access point identifier are provisionable attributes of the G832 component. The 16 byte Trail Trace frame is composed of one byte containing a frame start marker and a CRC-7 calculation over the previous frame, and 15 bytes for transporting an E.164 address. If less than the full 15 bytes are used, the address is padded with NULL characters.')
lpE3G832TrailTraceExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3G832TrailTraceExpected.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832TrailTraceExpected.setDescription('This attribute indicates the E.164 address which is expected in the trail access point identifier, which is transmitted using the Trail Trace (TR) field of the transmitted E3 Frame. Both the expected trail access point identifier and the transmitted trail access point identifier are provisionable attributes of the G832 component. The 16 byte Trail Trace frame is composed of one byte containing a frame start marker and a CRC-7 calculation over the previous frame, and 15 bytes for transporting an E.164 address. If less than the full 15 bytes are used, the address is padded with NULL characters.')
lpE3G832OperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11), )
if mibBuilder.loadTexts: lpE3G832OperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832OperationalTable.setDescription('This group contains the operational data for the G832 component.')
lpE3G832OperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3G832Index"))
if mibBuilder.loadTexts: lpE3G832OperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832OperationalEntry.setDescription('An entry in the lpE3G832OperationalTable.')
lpE3G832UnexpectedPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832UnexpectedPayloadType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832UnexpectedPayloadType.setDescription('This attribute displays whether the Unexpected Payload Type (UPT) alarm state has been entered. The UPT alarm state is entered when UPT defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The UPT defect is reported when a received frame fails to agree with the expected Payload Type. If the UPT defects are intermittently occurring, the UPT defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle.. The UPT alarm is cleared when the Payload Type in the received frame agrees with the expected Payload Type for a period of 10 seconds +/- 0.5 seconds. The unexpectedPayloadType attribute is always set to off when the E3 component has been locked and left offline.')
lpE3G832TrailTraceMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832TrailTraceMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832TrailTraceMismatch.setDescription('This attribute displays whether the Trail Trace Mismatch (TTM) alarm state has been entered. The TTM alarm state is entered when TTM defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The TTM defect is reported when the trail access point identifier contained in the Trail Trace (TR) field in the received frame fails to agree with the expected identifier. If the TTM defects are intermittently occurring, the TTM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The TTM alarm is cleared when the trail access point identifier in the received frame agrees with the expected identifier for a period of 10 seconds +/- 0.5 seconds. The trailTraceMismatch attribute is always set to off when the E3 component has been locked and left offline. Both the expected trail access identifier and the transmitted trail access identifier are provisionable attributes of the G832 component.')
lpE3G832TimingMarker = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notTraceable", 0), ("traceable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832TimingMarker.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832TimingMarker.setDescription('Indicates whether or not the timing source at the far-end node is traceable to a Primary Reference Clock. The timingMarker indication is controlled by the timing marker bit in the G832 MA byte. If the received timing marker bit is 1 for five consecutive frames, and five consecutive 0s are not received for two seconds, the timingMarker indication will be set to not traceable. If the received timing marker bit is 0 for five consecutive frames and five consecutive 1s are not received for two seconds, the timingMarker indication will be set to traceable.')
lpE3G832TrailTraceReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832TrailTraceReceived.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832TrailTraceReceived.setDescription('This attribute indicates the 15 byte E.164 address which is currently being received in the trail trace (TR) field of the E3 G832 frame. If this attribute differs from the provisioned trailTraceTransmitted string a trail trace mismatch (TTM) defect is reported, possibly resulting in a TTM alarm, as described for operational attribute trailTraceMismatch.')
lpE3G832StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12), )
if mibBuilder.loadTexts: lpE3G832StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832StatsTable.setDescription('This group contains the statistical data for the G832 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3G832StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3G832Index"))
if mibBuilder.loadTexts: lpE3G832StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832StatsEntry.setDescription('An entry in the lpE3G832StatsTable.')
lpE3G832FarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds that the E3 line has not suffered any G832 errors.')
lpE3G832FarEndCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndCodeViolations.setDescription('A count of E3 frames containing a Far-End Block Error (FEBE). A FEBE is reported over the FEBE bit each time the far-end terminal detects a BIP-8 error in a received E3 frame. For second intervals where Far End Unavailable Seconds (FEUAS) or Far End Severely Errored Seconds (FESES) are counted, counting of FECVs is inhibited. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3G832FarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndErroredSec.setDescription('This attribute indicates the total number of Far-End Errored Seconds (FEES). A FEES is declared for second intervals containing with one or more Far-End Coding Violations (FECV) or one or more Far-End Receive Failure (FERF) defects. A FERF defect occurs when the FERF bit in the received frame is set to one. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FEESs is inhibited.')
lpE3G832FarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndSevErroredSec.setDescription('This attribute indicates the total number of Far-End Severely Errored Seconds (FESESs). A FESES is declared for second intervals containing more than 34 Far-End Coding Violations (FECV) or one or more Far-End Receive Failure (FERF) defects. For second intervals where a Far-End Severely Errored Seconds (FESES) is counted, counting of FECVs is inhibited. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FESESs is inhibited.')
lpE3G832FarEndSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndSefAisSec.setDescription('This attribute indicates the total number of Far-End SEF/AIS Seconds (FESAS). A FESAS is declared for second intervals containing one or more Far-End Receive Failure (FERF) defects. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FESAS is inhibited.')
lpE3G832FarEndUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 3, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3G832FarEndUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3G832FarEndUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the E3 far-end path is unavailable. The E3 far-end path becomes unavailable at the onset of 10 consecutive Far End Severely Errored Seconds (FESES). It comes available at the onset of 10 contiguous seconds with no FESES. The unavailable time includes the initial 10 seconds to enter the unavailable state but not the 10 seconds to exit the state For second intervals where FEUAS is counted, counting of Far End Coding Violations (FECV), Far- End Errored Seconds (FEES), Far-End Severely Errored Seconds (FESES) and Far-End SefAis Seconds (FESAS) are inhibited.')
lpE3Plcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4))
lpE3PlcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1), )
if mibBuilder.loadTexts: lpE3PlcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpRowStatusTable.setDescription('This entry controls the addition and deletion of lpE3Plcp components.')
lpE3PlcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3PlcpIndex"))
if mibBuilder.loadTexts: lpE3PlcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpRowStatusEntry.setDescription('A single entry in the table represents a single lpE3Plcp component.')
lpE3PlcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE3Plcp components. These components cannot be added nor deleted.')
lpE3PlcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE3PlcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpStorageType.setDescription('This variable represents the storage type value for the lpE3Plcp tables.')
lpE3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpIndex.setDescription('This variable represents the index for the lpE3Plcp tables.')
lpE3PlcpOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 10), )
if mibBuilder.loadTexts: lpE3PlcpOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpOperationalTable.setDescription('This group contains the operational data for the PLCP component.')
lpE3PlcpOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3PlcpIndex"))
if mibBuilder.loadTexts: lpE3PlcpOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpOperationalEntry.setDescription('An entry in the lpE3PlcpOperationalTable.')
lpE3PlcpLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpLofAlarm.setDescription('This attribute displays whether a PLCP Loss Of Frame (LOF) failure alarm state has been entered. An LOF failure is declared when a PLCP LOF defect persists for 2.5 s +/- 0.5 s. An LOF defect occurs when an OOF (Out of Frame) state persists for more than 1 ms. If the OOF events are intermittent, the LOF defect counter is decremented at a rate of 1/12 (for DS3 PLCP) or 1/9 (for G.751 E3 PLCP) of the incrementing rate, with all measurements based on a 200 ms polling cycle. An OOF event (also known as a PLCP SEF event) is declared when an error is detected in both the A1 and A2 octets, or when two consecutive POHIDs are found in error. OOF is removed when two valid sets of framing octets and two valid and sequential POHID octets have been found. The LOF defect is removed when the defect counter reaches zero, i.e. when OOF events are absent for more than 12 ms (DS3 PLCP) or 9 ms (G.751 E3 PLCP). LOF failure alarm is cleared when LOF defect is absent for 10.0 s +/- 0.5 s The DS3 or E3 component goes into an operational state of disabled until the LOF failure alarm is cleared. The terminal declaring the LOF failure alarm will transmit a PLCP RAI signal to the far-end for the duration of the alarm. The lofAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
lpE3PlcpRxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpRxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpRxRaiAlarm.setDescription('This attribute displays whether a PLCP Remote Alarm Indication (RAI) failure alarm state has been entered. An RAI failure alarm occurs when ten consecutive PLCP RAI bits (bit 5 in the G1 byte) are high on the incoming line. An RAI failure alarm is cleared when ten consecutive RAI bits are set to 0. Note: Some standards call this alarm RFI. The rxRaiAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
lpE3PlcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11), )
if mibBuilder.loadTexts: lpE3PlcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpStatsTable.setDescription('This group contains the statistical data for the PLCP component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3PlcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3PlcpIndex"))
if mibBuilder.loadTexts: lpE3PlcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpStatsEntry.setDescription('An entry in the lpE3PlcpStatsTable.')
lpE3PlcpErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the near-end PLCP path layer had no errors.')
lpE3PlcpCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpCodingViolations.setDescription('This attribute indicates the total number of BIP-8 Errors, framing pattern octet errors, and path overhead identification errors detected in received PLCP frames. Counting of PLCP CV is inhibited for second intervals where PLCP Severely Errored Framing Seconds (SEFS) or PLCP Unavailable Seconds (UAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3PlcpErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Coding Violations (CV) or in which a PLCP Severely Errored Framing Second (SEFS) was counted. Counting of PLCP ES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpE3PlcpSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCPCVs or in which a PLCPSEFS was counted (i.e. a PLCP OOF event occurred). Counting of PLCP SES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpE3PlcpSevErroredFramingSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpSevErroredFramingSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpSevErroredFramingSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Severely Errored Frame (SEF) events. An SEF event is equivalent to a PLCP OOF (Out of Frame) event. Counting of PLCPP SEFSs is inhibited for second intervals where PLCP Unavailable Seconds (UAS) are counted.')
lpE3PlcpUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpUnavailSec.setDescription('This attribute indicates the number of seconds when the near-end PLCP layer is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP LOF (Loss of Frame) failure alarm state. The PLCP Path Layer becomes available again only after clearing this condition. For second intervals where PLCP UAS are counted, counting of PLCP Severely Errored Framing Seconds (SEFS), PLCP Coding Violations (CV), PLCP Errored Seconds (ES), PLCP Severely Errored Seconds (SES) and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
lpE3PlcpFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the far- end PLCP path layer had no errors.')
lpE3PlcpFarEndCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpFarEndCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpFarEndCodingViolations.setDescription('This attribute indicates the total number of PLCP Far-End Block Errors (FEBE) reported by the far-end terminal. Counting of FEBEs is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3PlcpFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpFarEndErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FEES is inhibited during second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
lpE3PlcpFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpFarEndSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FESES is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
lpE3PlcpFarEndUnavailableSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3PlcpFarEndUnavailableSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3PlcpFarEndUnavailableSec.setDescription('This attribute indicates the number of seconds during which the PLCP far end is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP RAI (Remote Alarm Indication). Service becomes available again after this condition is cleared. For second intervals where PLCP FEUAS are counted, counting of PLCP Far-End Coding Violations (FECV), PLCP Far- End Errored Seconds (FEES), and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
lpE3Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5))
lpE3CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1), )
if mibBuilder.loadTexts: lpE3CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellRowStatusTable.setDescription('This entry controls the addition and deletion of lpE3Cell components.')
lpE3CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3CellIndex"))
if mibBuilder.loadTexts: lpE3CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellRowStatusEntry.setDescription('A single entry in the table represents a single lpE3Cell component.')
lpE3CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE3Cell components. These components can be added and deleted.')
lpE3CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE3CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellStorageType.setDescription('This variable represents the storage type value for the lpE3Cell tables.')
lpE3CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE3CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellIndex.setDescription('This variable represents the index for the lpE3Cell tables.')
lpE3CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 10), )
if mibBuilder.loadTexts: lpE3CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpE3CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3CellIndex"))
if mibBuilder.loadTexts: lpE3CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellProvEntry.setDescription('An entry in the lpE3CellProvTable.')
lpE3CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpE3CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpE3CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE3CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpE3CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 11), )
if mibBuilder.loadTexts: lpE3CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpE3CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3CellIndex"))
if mibBuilder.loadTexts: lpE3CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellOperEntry.setDescription('An entry in the lpE3CellOperTable.')
lpE3CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE3CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12), )
if mibBuilder.loadTexts: lpE3CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE3CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE3CellIndex"))
if mibBuilder.loadTexts: lpE3CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellStatsEntry.setDescription('An entry in the lpE3CellStatsTable.')
lpE3CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpE3CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpE3CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE3CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE3CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 6, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE3CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE3CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpDS1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7))
lpDS1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1), )
if mibBuilder.loadTexts: lpDS1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1 components.')
lpDS1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RowStatusEntry.setDescription('A single entry in the table represents a single lpDS1 component.')
lpDS1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1 components. These components can be added and deleted.')
lpDS1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StorageType.setDescription('This variable represents the storage type value for the lpDS1 tables.')
lpDS1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: lpDS1Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1Index.setDescription('This variable represents the index for the lpDS1 tables.')
lpDS1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10), )
if mibBuilder.loadTexts: lpDS1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ProvTable.setDescription('This group contains all of the provisioning data for a DS1 component.')
lpDS1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ProvEntry.setDescription('An entry in the lpDS1ProvTable.')
lpDS1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5, 6))).clone(namedValues=NamedValues(("d4", 0), ("esf", 1), ("d4Cas", 4), ("esfCas", 5), ("unframed", 6))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1LineType.setDescription('This attribute defines the framing of the DS1 line. d4 defines a framing pattern of 12 frames per multiframe. esf defines a framing pattern of 24 frames per multiframe. d4Cas defines a framing pattern of 12 frames per multiframe with channel associated signalling. esfCas defines a framing pattern of 24 frames per multiframe with channel associated signalling. unframed defines an unknown framing pattern for clear channels. For cell-based cards only the default option esf is permitted.')
lpDS1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("bit7Stuffing", 0), ("b8zs", 1), ("ami", 2))).clone('b8zs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ZeroCoding.setDescription("This attribute defines the zero encoding on the DS1 line. bit7Stuffing sets bit 7 of every timeslot to a one to guarantee ones's density. This reduces the available bandwidth of the channel by 1/8. b8zs substitutes a pattern of bipolar violations if more than 7 zeros in a row are to be transported. ami specifies Alternate Mark Inversion, in which successive marks (ones) alternate between positive and negative polarity voltage signals, and spaces (zeros) are sent as a zero amplitude signal. When zeroCoding is set to ami and lineType is set to d4, it is recommended that raiAlarmType be set to SBit in order to avoid possible mimic RAI alarm. For cell-based cards only the default value b8zs is permitted.")
lpDS1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 3), ("srtsMode", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ClockingSource.setDescription('This attribute defines the source of the transmit clock for the DS1 line. When local is selected, the crystal on the port generates the clocking for the line. When line is selected, the port synchronizes to the clock from the facility. When module is selected, the ports clock synchronizes to the clock provided by the oscillator on the active CP. When otherPort is selected, the port synchronizes to the port with a clocking source of line. When srtsMode is selected, the port synchronization is taken from the SRTS (Synchronous Residual Time-Stamp) bits extracted from the AAL1 cells. This option is only available for unstructured AAL1 data services when the other ports on the card have their clocking source set to module. If the NetworkSynchronization (NS) component is present the default value of this attribute will be module otherwise it will default to local. Note that 3pDS1Atm cards have one common clock source for all ports and do not support the line clock source; all three ports must have the same value, either local or module.')
lpDS1RaiAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("sBit", 0), ("bit2", 1), ("fdl", 2))).clone('fdl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1RaiAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RaiAlarmType.setDescription("This attribute defines the method of sending a RAI (Remote Alarm Indication) alarm on a DS1 line. When SBit is selected, RAI alarm is sent by setting the S bit in frame 12. When Bit2 is selected, RAI alarm is sent by setting bit 2 in all timeslots to 0. When fdl is selected, RAI alarm is sent by a repeating pattern of 00 hex and FF hex on the FDL link. Note that for lineType of d4, only the SBit and the Bit2 methods are applicable. Whereas for lineType of esf, only the Bit2 and the fdl methods are applicable. SBit method is recommended if lineType is set to d4 and zeroCoding is set to ami. This will help to avoid potential mimic RAI alarm when 1's density is too low in the data transmitted. For cell-based cards only the default value fdl is permitted.")
lpDS1LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 655))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1LineLength.setDescription('This attribute defines the line length (in feet) for equalization calculations for the DS1 line. The value ranges between 0-655. For 8pDS1Atm cards the actual value used for equalization is rounded up to the nearest 110 feet; for all other card types the actual value used is rounded to the nearest 50 feet.')
lpDS1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 11), )
if mibBuilder.loadTexts: lpDS1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpDS1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1CidDataEntry.setDescription('An entry in the lpDS1CidDataTable.')
lpDS1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpDS1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 12), )
if mibBuilder.loadTexts: lpDS1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpDS1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AdminInfoEntry.setDescription('An entry in the lpDS1AdminInfoTable.')
lpDS1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpDS1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1CommentText.setDescription('Any miscellaneous text about the facility.')
lpDS1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 13), )
if mibBuilder.loadTexts: lpDS1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpDS1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1IfEntryEntry.setDescription('An entry in the lpDS1IfEntryTable.')
lpDS1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpDS1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpDS1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 14), )
if mibBuilder.loadTexts: lpDS1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpDS1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1OperStatusEntry.setDescription('An entry in the lpDS1OperStatusTable.')
lpDS1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpDS1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15), )
if mibBuilder.loadTexts: lpDS1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpDS1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StateEntry.setDescription('An entry in the lpDS1StateTable.')
lpDS1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpDS1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpDS1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpDS1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpDS1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpDS1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpDS1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16), )
if mibBuilder.loadTexts: lpDS1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
lpDS1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1OperEntry.setDescription('An entry in the lpDS1OperTable.')
lpDS1LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state has been entered. A LOS alarm is declared after LOS defects have been observed and accumulated for a period of 2 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). A LOS defect is detected upon observing all zeros for 150 ms (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: upon observing 175 +/- 75 pulse positions with no pulses of either positive or negative polarity). If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOS alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOS alarm state. The LOS alarm state is cleared when LOS defects are absent for 10 seconds +/- 0.5 seconds.')
lpDS1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RxAisAlarm.setDescription("This attribute displays whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period (for 8pDS1Atm cards: when both an Out Of Frame condition exists and a 1's density of at least 99.9% is present for a time T, where 3 ms T 75 ms; for 8pE1Atm cards: when both an Out Of Frame condition exists and fewer than three 0's have been received in 512 bit periods). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.")
lpDS1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1LofAlarm.setDescription('This attribute displays whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (for DS1: 2 out of 5 framing bits in error; for E1: 3 consecutive frame alignment patterns in error) have been detected for 3 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
lpDS1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RxRaiAlarm.setDescription('This attribute displays whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. For 3pDS1Atm, and 8pDS1Atm cards: alarm is declared immediately upon observing the defect is present, with no integration time. For 3pE1Atm, and 8pE1Atm cards: alarm state is entered when the RAI defect indicator has been observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds (for 3pDS1Atm, and 8pDS1Atm cards: alarm is cleared immediately upon observing the defect is absent, with no integration time). The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
lpDS1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TxAisAlarm.setDescription('This attribute displays whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the port is in a locked state.')
lpDS1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TxRaiAlarm.setDescription('This attribute displays whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the port detects a LOF alarm condition (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: RAI is transmitted when the port detects a LOS, LOF, or AIS condition).')
lpDS1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17), )
if mibBuilder.loadTexts: lpDS1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
lpDS1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"))
if mibBuilder.loadTexts: lpDS1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1StatsEntry.setDescription('An entry in the lpDS1StatsTable.')
lpDS1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1RunningTime.setDescription('The number of seconds since the port component was activated.')
lpDS1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ErrorFreeSec.setDescription('The number of seconds that the port has been in an error free state.')
lpDS1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ErroredSec.setDescription('An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
lpDS1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1SevErroredSec.setDescription('A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
lpDS1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1SevErroredFrmSec.setDescription('A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
lpDS1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1UnavailSec.setDescription('The total number of seconds that the interface is in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
lpDS1BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1BpvErrors.setDescription('The current count of Bipolar Violations. A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line.')
lpDS1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1CrcErrors.setDescription('If the interface is a DS1 line, it is the current count of CRC-6 errors. These will only be counted when the lineType is ESF. If the interface is an E1 line, it is the total number of CRC-4 errors. These will only be counted when crc4Mode is on.')
lpDS1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1FrmErrors.setDescription('The current count of frame errors. A frame error is an error in the framing bits')
lpDS1LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1LosStateChanges.setDescription('The total number of times that the line lost signal.')
lpDS1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip. This attribute is incremented for ports on the voice cards (for example the 1pDS1V and the 1pE1V function processors) only.')
lpDS1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2))
lpDS1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1), )
if mibBuilder.loadTexts: lpDS1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1Chan components.')
lpDS1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1Chan component.')
lpDS1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1Chan components. These components can be added and deleted.')
lpDS1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanStorageType.setDescription('This variable represents the storage type value for the lpDS1Chan tables.')
lpDS1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24)))
if mibBuilder.loadTexts: lpDS1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanIndex.setDescription('This variable represents the index for the lpDS1Chan tables.')
lpDS1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 10), )
if mibBuilder.loadTexts: lpDS1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
lpDS1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanProvEntry.setDescription('An entry in the lpDS1ChanProvTable.')
lpDS1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
lpDS1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependent on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56kbit/s is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
lpDS1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
lpDS1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 11), )
if mibBuilder.loadTexts: lpDS1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpDS1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCidDataEntry.setDescription('An entry in the lpDS1ChanCidDataTable.')
lpDS1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpDS1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 12), )
if mibBuilder.loadTexts: lpDS1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpDS1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanIfEntryEntry.setDescription('An entry in the lpDS1ChanIfEntryTable.')
lpDS1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpDS1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpDS1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 13), )
if mibBuilder.loadTexts: lpDS1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpDS1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanOperStatusEntry.setDescription('An entry in the lpDS1ChanOperStatusTable.')
lpDS1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpDS1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14), )
if mibBuilder.loadTexts: lpDS1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpDS1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanStateEntry.setDescription('An entry in the lpDS1ChanStateTable.')
lpDS1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpDS1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpDS1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpDS1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpDS1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpDS1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpDS1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpDS1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 15), )
if mibBuilder.loadTexts: lpDS1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
lpDS1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanOperEntry.setDescription('An entry in the lpDS1ChanOperTable.')
lpDS1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
lpDS1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 16), )
if mibBuilder.loadTexts: lpDS1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpDS1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"))
if mibBuilder.loadTexts: lpDS1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanAdminInfoEntry.setDescription('An entry in the lpDS1ChanAdminInfoTable.')
lpDS1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
lpDS1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
lpDS1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2))
lpDS1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1), )
if mibBuilder.loadTexts: lpDS1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1ChanTest components.')
lpDS1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1ChanTest component.')
lpDS1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1ChanTest components. These components cannot be added nor deleted.')
lpDS1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestStorageType.setDescription('This variable represents the storage type value for the lpDS1ChanTest tables.')
lpDS1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestIndex.setDescription('This variable represents the index for the lpDS1ChanTest tables.')
lpDS1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 10), )
if mibBuilder.loadTexts: lpDS1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpDS1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestStateEntry.setDescription('An entry in the lpDS1ChanTestStateTable.')
lpDS1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpDS1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpDS1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpDS1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11), )
if mibBuilder.loadTexts: lpDS1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpDS1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestSetupEntry.setDescription('An entry in the lpDS1ChanTestSetupTable.')
lpDS1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpDS1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpDS1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpDS1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpDS1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpDS1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpDS1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpDS1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpDS1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12), )
if mibBuilder.loadTexts: lpDS1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpDS1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTestIndex"))
if mibBuilder.loadTexts: lpDS1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestResultsEntry.setDescription('An entry in the lpDS1ChanTestResultsTable.')
lpDS1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpDS1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpDS1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpDS1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpDS1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpDS1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpDS1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpDS1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3))
lpDS1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1), )
if mibBuilder.loadTexts: lpDS1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1ChanCell components.')
lpDS1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1ChanCell component.')
lpDS1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1ChanCell components. These components can be added and deleted.')
lpDS1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellStorageType.setDescription('This variable represents the storage type value for the lpDS1ChanCell tables.')
lpDS1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellIndex.setDescription('This variable represents the index for the lpDS1ChanCell tables.')
lpDS1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 10), )
if mibBuilder.loadTexts: lpDS1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpDS1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellProvEntry.setDescription('An entry in the lpDS1ChanCellProvTable.')
lpDS1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpDS1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpDS1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpDS1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 11), )
if mibBuilder.loadTexts: lpDS1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpDS1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellOperEntry.setDescription('An entry in the lpDS1ChanCellOperTable.')
lpDS1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12), )
if mibBuilder.loadTexts: lpDS1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpDS1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanCellIndex"))
if mibBuilder.loadTexts: lpDS1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellStatsEntry.setDescription('An entry in the lpDS1ChanCellStatsTable.')
lpDS1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpDS1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpDS1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpDS1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpDS1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4))
lpDS1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1), )
if mibBuilder.loadTexts: lpDS1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1ChanTc components.')
lpDS1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1ChanTc component.')
lpDS1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1ChanTc components. These components can be added and deleted.')
lpDS1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcStorageType.setDescription('This variable represents the storage type value for the lpDS1ChanTc tables.')
lpDS1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcIndex.setDescription('This variable represents the index for the lpDS1ChanTc tables.')
lpDS1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 10), )
if mibBuilder.loadTexts: lpDS1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
lpDS1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcProvEntry.setDescription('An entry in the lpDS1ChanTcProvTable.')
lpDS1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
lpDS1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
lpDS1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 11), )
if mibBuilder.loadTexts: lpDS1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
lpDS1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcIndex"))
if mibBuilder.loadTexts: lpDS1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcOpEntry.setDescription('An entry in the lpDS1ChanTcOpTable.')
lpDS1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
lpDS1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
lpDS1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 398), )
if mibBuilder.loadTexts: lpDS1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpDS1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: lpDS1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigOneEntry.setDescription('An entry in the lpDS1ChanTcSigOneTable.')
lpDS1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpDS1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigOneIndex.setDescription('This variable represents the lpDS1ChanTcSigOneTable specific index for the lpDS1ChanTcSigOneTable.')
lpDS1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigOneValue.setDescription('This variable represents an individual value for the lpDS1ChanTcSigOneTable.')
lpDS1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 399), )
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpDS1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoEntry.setDescription('An entry in the lpDS1ChanTcSigTwoTable.')
lpDS1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoIndex.setDescription('This variable represents the lpDS1ChanTcSigTwoTable specific index for the lpDS1ChanTcSigTwoTable.')
lpDS1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the lpDS1ChanTcSigTwoTable.')
lpDS1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3))
lpDS1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1), )
if mibBuilder.loadTexts: lpDS1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1Test components.')
lpDS1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1TestIndex"))
if mibBuilder.loadTexts: lpDS1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1Test component.')
lpDS1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1Test components. These components cannot be added nor deleted.')
lpDS1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestStorageType.setDescription('This variable represents the storage type value for the lpDS1Test tables.')
lpDS1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestIndex.setDescription('This variable represents the index for the lpDS1Test tables.')
lpDS1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 10), )
if mibBuilder.loadTexts: lpDS1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpDS1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1TestIndex"))
if mibBuilder.loadTexts: lpDS1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestStateEntry.setDescription('An entry in the lpDS1TestStateTable.')
lpDS1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpDS1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpDS1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpDS1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11), )
if mibBuilder.loadTexts: lpDS1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpDS1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1TestIndex"))
if mibBuilder.loadTexts: lpDS1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestSetupEntry.setDescription('An entry in the lpDS1TestSetupTable.')
lpDS1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpDS1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpDS1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpDS1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpDS1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpDS1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpDS1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpDS1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpDS1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpDS1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12), )
if mibBuilder.loadTexts: lpDS1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpDS1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1TestIndex"))
if mibBuilder.loadTexts: lpDS1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestResultsEntry.setDescription('An entry in the lpDS1TestResultsTable.')
lpDS1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpDS1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpDS1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpDS1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpDS1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpDS1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpDS1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpDS1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpDS1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpDS1Dsp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4))
lpDS1DspRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1), )
if mibBuilder.loadTexts: lpDS1DspRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1Dsp components.')
lpDS1DspRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1DspIndex"))
if mibBuilder.loadTexts: lpDS1DspRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1Dsp component.')
lpDS1DspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1DspRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1Dsp components. These components cannot be added nor deleted.')
lpDS1DspComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1DspComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1DspStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1DspStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspStorageType.setDescription('This variable represents the storage type value for the lpDS1Dsp tables.')
lpDS1DspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1DspIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1DspIndex.setDescription('This variable represents the index for the lpDS1Dsp tables.')
lpDS1Audio = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5))
lpDS1AudioRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1), )
if mibBuilder.loadTexts: lpDS1AudioRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioRowStatusTable.setDescription('This entry controls the addition and deletion of lpDS1Audio components.')
lpDS1AudioRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpDS1AudioIndex"))
if mibBuilder.loadTexts: lpDS1AudioRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioRowStatusEntry.setDescription('A single entry in the table represents a single lpDS1Audio component.')
lpDS1AudioRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AudioRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpDS1Audio components. These components cannot be added nor deleted.')
lpDS1AudioComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AudioComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpDS1AudioStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpDS1AudioStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioStorageType.setDescription('This variable represents the storage type value for the lpDS1Audio tables.')
lpDS1AudioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 7, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpDS1AudioIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpDS1AudioIndex.setDescription('This variable represents the index for the lpDS1Audio tables.')
lpE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8))
lpE1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1), )
if mibBuilder.loadTexts: lpE1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RowStatusTable.setDescription('This entry controls the addition and deletion of lpE1 components.')
lpE1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RowStatusEntry.setDescription('A single entry in the table represents a single lpE1 component.')
lpE1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1 components. These components can be added and deleted.')
lpE1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StorageType.setDescription('This variable represents the storage type value for the lpE1 tables.')
lpE1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32)))
if mibBuilder.loadTexts: lpE1Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1Index.setDescription('This variable represents the index for the lpE1 tables.')
lpE1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10), )
if mibBuilder.loadTexts: lpE1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ProvTable.setDescription('This group contains all of the provisioning data for an E1 component.')
lpE1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ProvEntry.setDescription('An entry in the lpE1ProvTable.')
lpE1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 6))).clone(namedValues=NamedValues(("ccs", 2), ("cas", 3), ("unframed", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1LineType.setDescription('This attribute specifies the framing of the E1 line. When cas (channel associated signalling) is selected, timeslot 16 is reserved for multiframe signalling and only 30 timeslots are available for data. The signalling bits are not interpreted. When ccs (common channel signalling) is selected, timeslot 16 is not reserved for multiframe signalling and 31 timeslots are available for data. The signalling bits are not interpreted. When unframed is selected, a clear channel is defined whereby data from all timeslots including the framing data (in timeslot 0) and timeslot 16 are passed transparently. This value is valid only for AAL1 cards. For cell-based cards the ATM Forum specifies that timeslot 16 be reserved, leaving 30 timeslots available for data. The default value is cas except for the 8pE1Atm card, for which the default and only valid value is ccs.')
lpE1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 3), ("srtsMode", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ClockingSource.setDescription("This attribute defines the source of the transmit clock for the E1 line. When local is selected, the crystal on the port generates the clocking for the line. When line is selected, the port synchronizes to the clock from the facility. When module is selected, the ports clock synchronizes to the clock provided by the oscillator on the active CP. When otherPort is selected, the port synchronizes to the port with a clocking source of line. When srtsMode is selected, the port sychronization is taken from the SRTS (Synchronous Residual Time Stamp) bits within the ATM cell. If the NetworkSynchronization (NS) component is present the default value of this attribute will be module otherwise it will default to line except for the 3pE1Atm card which defaults to local. The 3pE1Atm card has one common clock source for all ports and does not support the line clock source; all three ports must have the same value, either local or module. The clockingSource values otherPort and srtsMode are only valid for the AAL1 cards. For the AAL1 cards either: all four ports' clockingSource values must be local OR all four ports' clockingSource values must be module OR one port's clockingSource value must be line and the other three must be otherPort. A port can only have srtsMode selected if the other ports are module or srtsMode.")
lpE1Crc4Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1Crc4Mode.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1Crc4Mode.setDescription('This attribute defines whether the CRC-4 checking and generation on the E1 line is enabled or disabled. The default CRC-4 mode is off except for the cell-based cards which default to on as per the ATM Forum.')
lpE1SendRaiOnAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1SendRaiOnAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1SendRaiOnAis.setDescription('This attribute defines whether the Remote Alarm Indicator (RAI) will be sent when receiving an AIS alarm. The value is yes by default; it can be changed to no only for ports on J2MV cards.')
lpE1RaiDeclareAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 20000), )).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1RaiDeclareAlarmTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RaiDeclareAlarmTime.setDescription('This attribute specifies the period of time that a Remote Alarm Indicator (RAI) must be present before declaring an RAI alarm. The value of auto sets the RAI declare time to the default value for E1 and E1C card types which do not have hardware support for RAI response. On E1C card types with hardware support, if the value of auto is set, RAI response is done according to the standards. If auto is set, the value of the raiClearAlarmTime attribute is ignored and auto is used. This attribute is for E1 and E1C card types only. For all other card types, the default value must be used. VALUES ( 0 = auto )')
lpE1RaiClearAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 20000), )).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1RaiClearAlarmTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RaiClearAlarmTime.setDescription('This attribute specifies the period of time that a Remote Alarm Indicator (RAI) has been absent before clearing an RAI alarm. The value of auto sets the RAI clear time to the default value for E1 and E1C card types which do not have hardware support for RAI response. On E1C card types with hardware support, if the value of auto is set, RAI response is done according to the standards. If auto is set, the value of the raiDeclareAlarmTime attribute is ignored and auto is used. This attribute is for E1 and E1C card types only. For all other card types, the default value must be used. VALUES ( 0 = auto )')
lpE1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 11), )
if mibBuilder.loadTexts: lpE1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpE1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1CidDataEntry.setDescription('An entry in the lpE1CidDataTable.')
lpE1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpE1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 12), )
if mibBuilder.loadTexts: lpE1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpE1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AdminInfoEntry.setDescription('An entry in the lpE1AdminInfoTable.')
lpE1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpE1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1CommentText.setDescription('Any miscellaneous text about the facility.')
lpE1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 13), )
if mibBuilder.loadTexts: lpE1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpE1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1IfEntryEntry.setDescription('An entry in the lpE1IfEntryTable.')
lpE1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpE1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpE1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 14), )
if mibBuilder.loadTexts: lpE1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpE1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1OperStatusEntry.setDescription('An entry in the lpE1OperStatusTable.')
lpE1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpE1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15), )
if mibBuilder.loadTexts: lpE1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpE1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StateEntry.setDescription('An entry in the lpE1StateTable.')
lpE1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpE1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpE1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpE1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpE1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpE1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpE1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16), )
if mibBuilder.loadTexts: lpE1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
lpE1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1OperEntry.setDescription('An entry in the lpE1OperTable.')
lpE1LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state has been entered. A LOS alarm is declared after LOS defects have been observed and accumulated for a period of 2 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). A LOS defect is detected upon observing all zeros for 150 ms (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: upon observing 175 +/- 75 pulse positions with no pulses of either positive or negative polarity). If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOS alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOS alarm state. The LOS alarm state is cleared when LOS defects are absent for 10 seconds +/- 0.5 seconds.')
lpE1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RxAisAlarm.setDescription("This attribute displays whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period (for 8pDS1Atm cards: when both an Out Of Frame condition exists and a 1's density of at least 99.9% is present for a time T, where 3 ms T 75 ms; for 8pE1Atm cards: when both an Out Of Frame condition exists and fewer than three 0's have been received in 512 bit periods). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.")
lpE1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1LofAlarm.setDescription('This attribute displays whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (for DS1: 2 out of 5 framing bits in error; for E1: 3 consecutive frame alignment patterns in error) have been detected for 3 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
lpE1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RxRaiAlarm.setDescription('This attribute displays whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. For 3pDS1Atm, and 8pDS1Atm cards: alarm is declared immediately upon observing the defect is present, with no integration time. For 3pE1Atm, and 8pE1Atm cards: alarm state is entered when the RAI defect indicator has been observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds (for 3pDS1Atm, and 8pDS1Atm cards: alarm is cleared immediately upon observing the defect is absent, with no integration time). The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
lpE1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TxAisAlarm.setDescription('This attribute displays whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the port is in a locked state.')
lpE1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TxRaiAlarm.setDescription('This attribute displays whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the port detects a LOF alarm condition (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: RAI is transmitted when the port detects a LOS, LOF, or AIS condition).')
lpE1E1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 17), )
if mibBuilder.loadTexts: lpE1E1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1E1OperTable.setDescription('This group contains all of the operational data for a E1 component that are not defined in the DSCommonOp group.')
lpE1E1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1E1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1E1OperEntry.setDescription('An entry in the lpE1E1OperTable.')
lpE1MultifrmLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1MultifrmLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1MultifrmLofAlarm.setDescription('This attribute indicates whether a multiframe LOF (loss of frame) alarm state is entered. A multiframe LOF alarm state is entered when a multiframe LOF defect (2 consecutive errors in the multiframe alignment signal) has been detected and accumulated for 2.5 seconds +/- 0.5 seconds. If the multiframe LOF defects are intermittently occurring, the multiframe LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The alarm is cleared when the defect is not detected for 10 seconds +/- 0.5 seconds. When the multiframe LOF alarm is on, a multiframe RAI alarm indicator is transmitted on the line. The 8pE1Atm card does not support the multiframe LOF alarm.')
lpE1RxMultifrmRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1RxMultifrmRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RxMultifrmRaiAlarm.setDescription('This attribute displays whether a multiframe RAI (remote alarm indicator) alarm state has been entered. A multiframe RAI alarm state is entered when a multiframe RAI alarm indicator (bit 6 of timeslot 16 in frame 0 is set to a one) is observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the multiframe RAI indicator is intermittently received, the multiframe RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The multiframe RAI alarm condition is cleared when the multiframe RAI alarm indication is not received for 10 seconds +/- 0.5 seconds. The multiframe RAI alarm is usually an indication that the far end facility is unable to gain multiframe synchronization. The 8pE1Atm card does not support the multiframe RAI alarm.')
lpE1TxMultifrmRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TxMultifrmRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TxMultifrmRaiAlarm.setDescription('This attribute displays whether a multiframe RAI (remote alarm indicator) alarm is being sent on the E1 line. This is transmitted when the E1 port detects a multiframe LOF condition. The 8pE1Atm card does not generate the multiframe RAI alarm.')
lpE1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18), )
if mibBuilder.loadTexts: lpE1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
lpE1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"))
if mibBuilder.loadTexts: lpE1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1StatsEntry.setDescription('An entry in the lpE1StatsTable.')
lpE1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1RunningTime.setDescription('The number of seconds since the port component was activated.')
lpE1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ErrorFreeSec.setDescription('The number of seconds that the port has been in an error free state.')
lpE1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ErroredSec.setDescription('An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
lpE1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1SevErroredSec.setDescription('A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
lpE1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1SevErroredFrmSec.setDescription('A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
lpE1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1UnavailSec.setDescription('The total number of seconds that the interface is in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
lpE1BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1BpvErrors.setDescription('The current count of Bipolar Violations. A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line.')
lpE1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1CrcErrors.setDescription('If the interface is a DS1 line, it is the current count of CRC-6 errors. These will only be counted when the lineType is ESF. If the interface is an E1 line, it is the total number of CRC-4 errors. These will only be counted when crc4Mode is on.')
lpE1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1FrmErrors.setDescription('The current count of frame errors. A frame error is an error in the framing bits')
lpE1LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1LosStateChanges.setDescription('The total number of times that the line lost signal.')
lpE1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 18, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip. This attribute is incremented for ports on the voice cards (for example the 1pDS1V and the 1pE1V function processors) only.')
lpE1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2))
lpE1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1), )
if mibBuilder.loadTexts: lpE1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1Chan components.')
lpE1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanRowStatusEntry.setDescription('A single entry in the table represents a single lpE1Chan component.')
lpE1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1Chan components. These components can be added and deleted.')
lpE1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanStorageType.setDescription('This variable represents the storage type value for the lpE1Chan tables.')
lpE1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: lpE1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanIndex.setDescription('This variable represents the index for the lpE1Chan tables.')
lpE1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 10), )
if mibBuilder.loadTexts: lpE1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
lpE1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanProvEntry.setDescription('An entry in the lpE1ChanProvTable.')
lpE1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
lpE1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependent on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56kbit/s is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
lpE1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
lpE1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 11), )
if mibBuilder.loadTexts: lpE1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpE1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCidDataEntry.setDescription('An entry in the lpE1ChanCidDataTable.')
lpE1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpE1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 12), )
if mibBuilder.loadTexts: lpE1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpE1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanIfEntryEntry.setDescription('An entry in the lpE1ChanIfEntryTable.')
lpE1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpE1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpE1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 13), )
if mibBuilder.loadTexts: lpE1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpE1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanOperStatusEntry.setDescription('An entry in the lpE1ChanOperStatusTable.')
lpE1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpE1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14), )
if mibBuilder.loadTexts: lpE1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpE1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanStateEntry.setDescription('An entry in the lpE1ChanStateTable.')
lpE1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpE1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpE1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpE1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpE1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpE1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpE1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpE1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 15), )
if mibBuilder.loadTexts: lpE1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
lpE1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanOperEntry.setDescription('An entry in the lpE1ChanOperTable.')
lpE1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
lpE1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 16), )
if mibBuilder.loadTexts: lpE1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpE1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"))
if mibBuilder.loadTexts: lpE1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanAdminInfoEntry.setDescription('An entry in the lpE1ChanAdminInfoTable.')
lpE1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
lpE1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
lpE1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2))
lpE1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1), )
if mibBuilder.loadTexts: lpE1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1ChanTest components.')
lpE1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTestIndex"))
if mibBuilder.loadTexts: lpE1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single lpE1ChanTest component.')
lpE1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1ChanTest components. These components cannot be added nor deleted.')
lpE1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestStorageType.setDescription('This variable represents the storage type value for the lpE1ChanTest tables.')
lpE1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestIndex.setDescription('This variable represents the index for the lpE1ChanTest tables.')
lpE1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 10), )
if mibBuilder.loadTexts: lpE1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpE1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTestIndex"))
if mibBuilder.loadTexts: lpE1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestStateEntry.setDescription('An entry in the lpE1ChanTestStateTable.')
lpE1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpE1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpE1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpE1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11), )
if mibBuilder.loadTexts: lpE1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpE1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTestIndex"))
if mibBuilder.loadTexts: lpE1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestSetupEntry.setDescription('An entry in the lpE1ChanTestSetupTable.')
lpE1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpE1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpE1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpE1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpE1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpE1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpE1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpE1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpE1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12), )
if mibBuilder.loadTexts: lpE1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpE1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTestIndex"))
if mibBuilder.loadTexts: lpE1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestResultsEntry.setDescription('An entry in the lpE1ChanTestResultsTable.')
lpE1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpE1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpE1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpE1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpE1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpE1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpE1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpE1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3))
lpE1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1), )
if mibBuilder.loadTexts: lpE1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1ChanCell components.')
lpE1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanCellIndex"))
if mibBuilder.loadTexts: lpE1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single lpE1ChanCell component.')
lpE1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1ChanCell components. These components can be added and deleted.')
lpE1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellStorageType.setDescription('This variable represents the storage type value for the lpE1ChanCell tables.')
lpE1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellIndex.setDescription('This variable represents the index for the lpE1ChanCell tables.')
lpE1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 10), )
if mibBuilder.loadTexts: lpE1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpE1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanCellIndex"))
if mibBuilder.loadTexts: lpE1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellProvEntry.setDescription('An entry in the lpE1ChanCellProvTable.')
lpE1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpE1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpE1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpE1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 11), )
if mibBuilder.loadTexts: lpE1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpE1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanCellIndex"))
if mibBuilder.loadTexts: lpE1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellOperEntry.setDescription('An entry in the lpE1ChanCellOperTable.')
lpE1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12), )
if mibBuilder.loadTexts: lpE1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpE1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanCellIndex"))
if mibBuilder.loadTexts: lpE1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellStatsEntry.setDescription('An entry in the lpE1ChanCellStatsTable.')
lpE1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpE1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpE1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpE1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpE1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4))
lpE1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1), )
if mibBuilder.loadTexts: lpE1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1ChanTc components.')
lpE1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcIndex"))
if mibBuilder.loadTexts: lpE1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single lpE1ChanTc component.')
lpE1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1ChanTc components. These components can be added and deleted.')
lpE1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcStorageType.setDescription('This variable represents the storage type value for the lpE1ChanTc tables.')
lpE1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcIndex.setDescription('This variable represents the index for the lpE1ChanTc tables.')
lpE1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 10), )
if mibBuilder.loadTexts: lpE1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
lpE1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcIndex"))
if mibBuilder.loadTexts: lpE1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcProvEntry.setDescription('An entry in the lpE1ChanTcProvTable.')
lpE1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
lpE1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
lpE1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 11), )
if mibBuilder.loadTexts: lpE1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
lpE1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcIndex"))
if mibBuilder.loadTexts: lpE1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcOpEntry.setDescription('An entry in the lpE1ChanTcOpTable.')
lpE1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
lpE1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
lpE1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 398), )
if mibBuilder.loadTexts: lpE1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpE1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: lpE1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigOneEntry.setDescription('An entry in the lpE1ChanTcSigOneTable.')
lpE1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpE1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigOneIndex.setDescription('This variable represents the lpE1ChanTcSigOneTable specific index for the lpE1ChanTcSigOneTable.')
lpE1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigOneValue.setDescription('This variable represents an individual value for the lpE1ChanTcSigOneTable.')
lpE1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 399), )
if mibBuilder.loadTexts: lpE1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
lpE1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: lpE1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigTwoEntry.setDescription('An entry in the lpE1ChanTcSigTwoTable.')
lpE1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: lpE1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigTwoIndex.setDescription('This variable represents the lpE1ChanTcSigTwoTable specific index for the lpE1ChanTcSigTwoTable.')
lpE1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the lpE1ChanTcSigTwoTable.')
lpE1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3))
lpE1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1), )
if mibBuilder.loadTexts: lpE1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1Test components.')
lpE1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1TestIndex"))
if mibBuilder.loadTexts: lpE1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestRowStatusEntry.setDescription('A single entry in the table represents a single lpE1Test component.')
lpE1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1Test components. These components cannot be added nor deleted.')
lpE1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestStorageType.setDescription('This variable represents the storage type value for the lpE1Test tables.')
lpE1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestIndex.setDescription('This variable represents the index for the lpE1Test tables.')
lpE1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 10), )
if mibBuilder.loadTexts: lpE1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpE1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1TestIndex"))
if mibBuilder.loadTexts: lpE1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestStateEntry.setDescription('An entry in the lpE1TestStateTable.')
lpE1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpE1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpE1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpE1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11), )
if mibBuilder.loadTexts: lpE1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpE1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1TestIndex"))
if mibBuilder.loadTexts: lpE1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestSetupEntry.setDescription('An entry in the lpE1TestSetupTable.')
lpE1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpE1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpE1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpE1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpE1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpE1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpE1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpE1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpE1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpE1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12), )
if mibBuilder.loadTexts: lpE1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpE1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1TestIndex"))
if mibBuilder.loadTexts: lpE1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestResultsEntry.setDescription('An entry in the lpE1TestResultsTable.')
lpE1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpE1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpE1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpE1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpE1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpE1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpE1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpE1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpE1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpE1Dsp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4))
lpE1DspRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1), )
if mibBuilder.loadTexts: lpE1DspRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1Dsp components.')
lpE1DspRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1DspIndex"))
if mibBuilder.loadTexts: lpE1DspRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspRowStatusEntry.setDescription('A single entry in the table represents a single lpE1Dsp component.')
lpE1DspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1DspRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1Dsp components. These components cannot be added nor deleted.')
lpE1DspComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1DspComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1DspStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1DspStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspStorageType.setDescription('This variable represents the storage type value for the lpE1Dsp tables.')
lpE1DspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1DspIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1DspIndex.setDescription('This variable represents the index for the lpE1Dsp tables.')
lpE1Audio = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5))
lpE1AudioRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1), )
if mibBuilder.loadTexts: lpE1AudioRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioRowStatusTable.setDescription('This entry controls the addition and deletion of lpE1Audio components.')
lpE1AudioRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpE1AudioIndex"))
if mibBuilder.loadTexts: lpE1AudioRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioRowStatusEntry.setDescription('A single entry in the table represents a single lpE1Audio component.')
lpE1AudioRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AudioRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpE1Audio components. These components cannot be added nor deleted.')
lpE1AudioComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AudioComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpE1AudioStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpE1AudioStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioStorageType.setDescription('This variable represents the storage type value for the lpE1Audio tables.')
lpE1AudioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 8, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpE1AudioIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpE1AudioIndex.setDescription('This variable represents the index for the lpE1Audio tables.')
lpV35 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9))
lpV35RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1), )
if mibBuilder.loadTexts: lpV35RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35RowStatusTable.setDescription('This entry controls the addition and deletion of lpV35 components.')
lpV35RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35RowStatusEntry.setDescription('A single entry in the table represents a single lpV35 component.')
lpV35RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpV35 components. These components can be added and deleted.')
lpV35ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpV35StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35StorageType.setDescription('This variable represents the storage type value for the lpV35 tables.')
lpV35Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: lpV35Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35Index.setDescription('This variable represents the index for the lpV35 tables.')
lpV35ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10), )
if mibBuilder.loadTexts: lpV35ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ProvTable.setDescription('This group contains all specific provisioning data for a V35 component.')
lpV35ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ProvEntry.setDescription('An entry in the lpV35ProvTable.')
lpV35LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35LinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35LinkMode.setDescription('This attribute defines the intended gender of the V.35 interface. The actual gender of the interface is determined by the physical connection to the patch panel. If the hardware setup does not match this attribute, an alarm will be generated. In dte mode, the RTS line signal is driven as specified by the attribute readyLineState when the interface passes its initial diagnostics. Then, the RTS line signal will be driven as specified in the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signals (RFS, DSR, and DCD) are compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified input line states are observed. In dce mode, the V35 component behaves similarly as when it is in dte mode. However, it will be driving the DCE line signals (RFS, DSR, and DCD) and monitoring the DTE line signal (RTS) as specified by the attributes readyLineState and dataTransferLineState.')
lpV35ReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35ReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ReadyLineState.setDescription('This attribute specifies the line signals originating from the V.35 interface that will always be turned on, provided the interface passes its diagnostics. This set of signals is generally required for maintaining the connection. Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. See also linkMode. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
lpV35DataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35DataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35DataTransferLineState.setDescription('This attribute specifies the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
lpV35LineStatusTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35LineStatusTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35LineStatusTimeOut.setDescription('This attribute defines the time that the line state must be stable (good or bad) before a line state change is declared.')
lpV35LineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(9600, 3840000)).clone(192000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35LineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35LineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. The clock rate is rounded up to the nearest available value. Note that the actual clock rates are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed. The actual lineSpeeds configurable on a V.35 DCE interface are: 3840000, 2560000, 2048000, 1920000, 1536000, 1344000, 1280000, 1024000, 960000, 768000, 672000, 640000, 512000, 448000, 384000, 336000, 320000, 256000, 224000, 192000, 168000, 128000, 112000, 64000, 56000, 48000, 32000, 19200, 9600. Note that linspeeds of 1024000 and 2048000 cannot be provisioned on cards that have ports provisioned at 3840000, 2560000, 1920000, 1280000, 960000, 640000 or 320000.')
lpV35ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("local", 0), ("module", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ClockingSource.setDescription('This attribute defines the source of synchronization of the outgoing clocks. This attribute is only used when the actualLinkMode is dce. If the value of the attribute is local, the outgoing clocks are synchronized to a local oscillator on the FP. If the value of the attribute is module, the outgoing clocks are synchronized to the oscillator on the active CP.')
lpV35DteDataClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("fromDce", 0), ("fromDte", 2))).clone('fromDce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35DteDataClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35DteDataClockSource.setDescription('This attribute is only used when the actualLinkMode is dce. It is used to determine the clock to be used to recover the receive data. A DTE interface uses TSET(DCE) and RSET(DCE) for timing. If the value of the attribute is fromDce, the DCE uses the internally generated transmit clock to supply both TSET(DCE) and RSET(DCE). If the value of the attribute is fromDte, the DCE still uses the internally generated transmit clock to supply TSET(DCE), but the receive timing is derived from TSET(DTE) on the link. The fromDte mode is recommended when the DTE is far away from the DCE interface. Note that TSET(DTE) is CCITT V.24 circuit 113; TSET(DCE) is CCITT V.24 circuit 114; and RSET(DCE) is CCITT V.24 circuit 115.')
lpV35ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 8), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the V35 component.')
lpV35EnableDynamicSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35EnableDynamicSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35EnableDynamicSpeed.setDescription('When set to yes, this attribute specifies that the transmit link speed should be set to the calculated receiver link speed. This attribute can be set to yes only if the linkMode is dce and the dteDataClockSource is fromDte.')
lpV35CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 11), )
if mibBuilder.loadTexts: lpV35CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpV35CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35CidDataEntry.setDescription('An entry in the lpV35CidDataTable.')
lpV35CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpV35AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 12), )
if mibBuilder.loadTexts: lpV35AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpV35AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35AdminInfoEntry.setDescription('An entry in the lpV35AdminInfoTable.')
lpV35Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpV35CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35CommentText.setDescription('Any miscellaneous text about the facility.')
lpV35IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 13), )
if mibBuilder.loadTexts: lpV35IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpV35IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35IfEntryEntry.setDescription('An entry in the lpV35IfEntryTable.')
lpV35IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpV35IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpV35OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 14), )
if mibBuilder.loadTexts: lpV35OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpV35OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35OperStatusEntry.setDescription('An entry in the lpV35OperStatusTable.')
lpV35SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpV35StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15), )
if mibBuilder.loadTexts: lpV35StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpV35StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35StateEntry.setDescription('An entry in the lpV35StateTable.')
lpV35AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpV35OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpV35UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpV35AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpV35ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpV35ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpV35AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpV35StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpV35UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpV35OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16), )
if mibBuilder.loadTexts: lpV35OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35OperTable.setDescription('This group contains all specific operational data for a V35 component.')
lpV35OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"))
if mibBuilder.loadTexts: lpV35OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35OperEntry.setDescription('An entry in the lpV35OperTable.')
lpV35ActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The interface behaves as a DCE or DTE according to the actualLinkMode.')
lpV35LineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35LineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35LineState.setDescription('This attribute contains the current state of the interface signals. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
lpV35ActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock.')
lpV35ActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35ActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35ActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock.')
lpV35DataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35DataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35DataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
lpV35Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2))
lpV35TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1), )
if mibBuilder.loadTexts: lpV35TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpV35Test components.')
lpV35TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35TestIndex"))
if mibBuilder.loadTexts: lpV35TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestRowStatusEntry.setDescription('A single entry in the table represents a single lpV35Test component.')
lpV35TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpV35Test components. These components cannot be added nor deleted.')
lpV35TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpV35TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestStorageType.setDescription('This variable represents the storage type value for the lpV35Test tables.')
lpV35TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpV35TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestIndex.setDescription('This variable represents the index for the lpV35Test tables.')
lpV35TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 10), )
if mibBuilder.loadTexts: lpV35TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpV35TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35TestIndex"))
if mibBuilder.loadTexts: lpV35TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestStateEntry.setDescription('An entry in the lpV35TestStateTable.')
lpV35TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpV35TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpV35TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpV35TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11), )
if mibBuilder.loadTexts: lpV35TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpV35TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35TestIndex"))
if mibBuilder.loadTexts: lpV35TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestSetupEntry.setDescription('An entry in the lpV35TestSetupTable.')
lpV35TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpV35TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpV35TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpV35TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpV35TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpV35TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpV35TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpV35TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpV35TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpV35TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12), )
if mibBuilder.loadTexts: lpV35TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpV35TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpV35TestIndex"))
if mibBuilder.loadTexts: lpV35TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestResultsEntry.setDescription('An entry in the lpV35TestResultsTable.')
lpV35TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpV35TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpV35TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpV35TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpV35TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpV35TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpV35TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpV35TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpV35TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpV35TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpV35TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 9, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpV35TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpV35TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpX21 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10))
lpX21RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1), )
if mibBuilder.loadTexts: lpX21RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21RowStatusTable.setDescription('This entry controls the addition and deletion of lpX21 components.')
lpX21RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21RowStatusEntry.setDescription('A single entry in the table represents a single lpX21 component.')
lpX21RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpX21 components. These components can be added and deleted.')
lpX21ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpX21StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21StorageType.setDescription('This variable represents the storage type value for the lpX21 tables.')
lpX21Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: lpX21Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21Index.setDescription('This variable represents the index for the lpX21 tables.')
lpX21ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10), )
if mibBuilder.loadTexts: lpX21ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ProvTable.setDescription('This group contains all specific provisioning data for an X21 component.')
lpX21ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ProvEntry.setDescription('An entry in the lpX21ProvTable.')
lpX21LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21LinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21LinkMode.setDescription('This attribute defines the intended gender of the X21 component (V.11 interface). The actual gender of the interface is determined by the physical connection to the patch panel. If the hardware setup does not match this attribute, an alarm will be generated. In dte mode, the control line signal is driven as specified by the attribute readyLineState when the interface passes its initial diagnostics. Then, the control line signal will be driven as specified in the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signal (indication) is compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified line states are observed. In dce mode, the X21 component behaves similarly as when it is in dte mode. However, it will be driving the DCE line signal (control) and monitoring the DTE line signal (indication) as specified by the attributes readyLineState and dataTransferLineState.')
lpX21ReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21ReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ReadyLineState.setDescription('This attribute specifies the line signals originating from the V.11 interface that will always be turned on, provided the interface passes its diagnostics. This set of signals is generally required to maintain the connection. Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. See also linkMode. Description of bits: indication(0) control(1)')
lpX21DataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21DataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21DataTransferLineState.setDescription('The state of the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: indication(0) control(1)')
lpX21LineStatusTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21LineStatusTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21LineStatusTimeOut.setDescription('This attribute defines the time the line state must be stable (good or bad) before a state change is declared.')
lpX21LineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(9600, 7680000)).clone(192000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21LineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21LineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. The clock rate is rounded up to the nearest available value. Note that the actual clock rates are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed. The actual lineSpeeds configurable on a V.11 DCE interface are: 7680000, 3840000, 2560000, 2048000, 1920000, 1536000, 1344000, 1280000, 1024000, 960000, 768000, 672000, 640000, 512000, 448000, 384000, 336000, 320000, 256000, 224000, 192000, 168000, 128000, 112000, 64000, 56000, 48000, 32000, 19200, 9600. Note that linspeeds of 1024000 and 2048000 cannot be provisioned on cards that have ports provisioned at 3840000, 2560000, 1920000, 1280000, 960000, 640000 or 320000. DESCRIPTION')
lpX21ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("local", 0), ("module", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ClockingSource.setDescription('This attribute defines the source of synchronization of the outgoing clocks. This attribute is only used when the actualLinkMode is dce. If the value of the attribute is local, the outgoing clocks are synchronized to a local oscillator on the FP. If the value of the attribute is module, the outgoing clocks are synchronized to the oscillator on the active CP.')
lpX21DteDataClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("fromDce", 0), ("fromDte", 2))).clone('fromDce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21DteDataClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21DteDataClockSource.setDescription('This attribute is only used when the actualLinkMode is dce. It is used to determine the clock to be used to recover the receive data. Note that a V.11 DTE interface uses the S clock (see X.21 standard) for both receive data and transmit data timing. The DTE interface always loops the received S clock back to the DCE as the X clock (see X.21 standard). If the value of the attribute is fromDce, the DCE V.11 interface uses the internally generated transmit clock as the S clock and for both receive and transmit data timing. The X clock is ignored. If the value of the attribute is fromDte, the DCE still uses the internally generated transmit clock as the S clock and for transmit data timing, but the receive data timing is derived from the X clock. The fromDte mode is recommended when the DTE is far away from the DCE interface.')
lpX21LineTerminationRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21LineTerminationRequired.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21LineTerminationRequired.setDescription('This attribute specifies whether termination is required for this interface. If the hardware setup does not match this attribute, an alarm will be generated.')
lpX21ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 9), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the X21 component.')
lpX21EnableDynamicSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21EnableDynamicSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21EnableDynamicSpeed.setDescription('When set to yes, this attribute specifies that the transmit link speed should be set to the calculated receiver link speed. This attribute can be set to yes only if the linkMode is dce and the dteDataClockSource is fromDte..')
lpX21CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 11), )
if mibBuilder.loadTexts: lpX21CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpX21CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21CidDataEntry.setDescription('An entry in the lpX21CidDataTable.')
lpX21CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpX21AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 12), )
if mibBuilder.loadTexts: lpX21AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpX21AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21AdminInfoEntry.setDescription('An entry in the lpX21AdminInfoTable.')
lpX21Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpX21CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21CommentText.setDescription('Any miscellaneous text about the facility.')
lpX21IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 13), )
if mibBuilder.loadTexts: lpX21IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpX21IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21IfEntryEntry.setDescription('An entry in the lpX21IfEntryTable.')
lpX21IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpX21IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpX21OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 14), )
if mibBuilder.loadTexts: lpX21OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpX21OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21OperStatusEntry.setDescription('An entry in the lpX21OperStatusTable.')
lpX21SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpX21StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15), )
if mibBuilder.loadTexts: lpX21StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpX21StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21StateEntry.setDescription('An entry in the lpX21StateTable.')
lpX21AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpX21OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpX21UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpX21AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpX21ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpX21ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpX21AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpX21StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpX21UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpX21OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16), )
if mibBuilder.loadTexts: lpX21OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21OperTable.setDescription('This group contains all specific operational data for an X21 component.')
lpX21OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"))
if mibBuilder.loadTexts: lpX21OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21OperEntry.setDescription('An entry in the lpX21OperTable.')
lpX21ActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The interface behaves as a DCE or DTE according to the actualLinkMode.')
lpX21LineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21LineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21LineState.setDescription('This attribute contains the current state of the interface signals. Description of bits: indication(0) control(1)')
lpX21ActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock.')
lpX21ActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21ActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21ActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock.')
lpX21DataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21DataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21DataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
lpX21Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2))
lpX21TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1), )
if mibBuilder.loadTexts: lpX21TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpX21Test components.')
lpX21TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21TestIndex"))
if mibBuilder.loadTexts: lpX21TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestRowStatusEntry.setDescription('A single entry in the table represents a single lpX21Test component.')
lpX21TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpX21Test components. These components cannot be added nor deleted.')
lpX21TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpX21TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestStorageType.setDescription('This variable represents the storage type value for the lpX21Test tables.')
lpX21TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpX21TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestIndex.setDescription('This variable represents the index for the lpX21Test tables.')
lpX21TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 10), )
if mibBuilder.loadTexts: lpX21TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpX21TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21TestIndex"))
if mibBuilder.loadTexts: lpX21TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestStateEntry.setDescription('An entry in the lpX21TestStateTable.')
lpX21TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpX21TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpX21TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpX21TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11), )
if mibBuilder.loadTexts: lpX21TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpX21TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21TestIndex"))
if mibBuilder.loadTexts: lpX21TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestSetupEntry.setDescription('An entry in the lpX21TestSetupTable.')
lpX21TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpX21TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpX21TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpX21TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpX21TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpX21TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpX21TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpX21TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpX21TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpX21TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12), )
if mibBuilder.loadTexts: lpX21TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpX21TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpX21TestIndex"))
if mibBuilder.loadTexts: lpX21TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestResultsEntry.setDescription('An entry in the lpX21TestResultsTable.')
lpX21TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpX21TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpX21TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpX21TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpX21TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpX21TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpX21TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpX21TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpX21TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpX21TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpX21TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 10, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpX21TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpX21TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpSonet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14))
lpSonetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1), )
if mibBuilder.loadTexts: lpSonetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRowStatusTable.setDescription('This entry controls the addition and deletion of lpSonet components.')
lpSonetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRowStatusEntry.setDescription('A single entry in the table represents a single lpSonet component.')
lpSonetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSonet components. These components can be added and deleted.')
lpSonetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSonetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStorageType.setDescription('This variable represents the storage type value for the lpSonet tables.')
lpSonetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpSonetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetIndex.setDescription('This variable represents the index for the lpSonet tables.')
lpSonetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 10), )
if mibBuilder.loadTexts: lpSonetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetProvTable.setDescription('This group contains all of the provisioning data for a Sonet or Sdh component.')
lpSonetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetProvEntry.setDescription('An entry in the lpSonetProvTable.')
lpSonetClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetClockingSource.setDescription('This attribute defines the type of clocking source used for synchronizing the OC-3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means the use of a signal phase-locked to the incoming OC-3 line rate; module means the use of a signal phase-locked to the CP reference clock. When adding a Sonet/Sdh component, the clockingSource attribute is set to module if the NetworkSynchronization component has been added and is set to local otherwise. Note that the multiport OC-3 cell-based cards has one common clock source for each of the three ports when either the clocking source local or module is selected. For this reason, it is not allowed to have at the same time the clockingSource attribute set to local on one port and module on another port. Furthermore, the clockingSource attribute cannot be set to module if the NetworkSynchronization component has not been added.')
lpSonetCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 11), )
if mibBuilder.loadTexts: lpSonetCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpSonetCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetCidDataEntry.setDescription('An entry in the lpSonetCidDataTable.')
lpSonetCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpSonetAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 12), )
if mibBuilder.loadTexts: lpSonetAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpSonetAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetAdminInfoEntry.setDescription('An entry in the lpSonetAdminInfoTable.')
lpSonetVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetVendor.setDescription('This is the name of the vendor supplying the facility.')
lpSonetCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetCommentText.setDescription('Any miscellaneous text about the facility.')
lpSonetIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 13), )
if mibBuilder.loadTexts: lpSonetIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpSonetIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetIfEntryEntry.setDescription('An entry in the lpSonetIfEntryTable.')
lpSonetIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpSonetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpSonetOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 14), )
if mibBuilder.loadTexts: lpSonetOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpSonetOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetOperStatusEntry.setDescription('An entry in the lpSonetOperStatusTable.')
lpSonetSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpSonetStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15), )
if mibBuilder.loadTexts: lpSonetStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpSonetStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStateEntry.setDescription('An entry in the lpSonetStateTable.')
lpSonetAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpSonetProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpSonetControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpSonetAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpSonetStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpSonetUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpSonetOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16), )
if mibBuilder.loadTexts: lpSonetOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetOperTable.setDescription('This group contains the common operational data for Sonet or Sdh component.')
lpSonetOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetOperEntry.setDescription('An entry in the lpSonetOperTable.')
lpSonetLosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLosAlarm.setDescription('This attribute indicates whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, or if an LOS defect is present when the criteria for LOF failure declaration have been met. A LOS defect is declared when 20+/-3 us of all-zeros pattern is detected. The LOS defect is cleared when two valid framing words are detected and no Loss Of Signal condition is detected during an interval of 20+/-3 us. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
lpSonetLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when LOF defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, except when an LOS defect or failure is present. An LOF defect is detected when getting contiguous errored frame alignment for at least 3 msec. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
lpSonetRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRxAisAlarm.setDescription('This attribute displays whether a Line Alarm Indication Signal (L- AIS) alarm state has been entered. An L-AIS alarm state is entered when L-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-AIS defect is the occurrence of the L-AIS signal in five contiguous STS (STM) frames (111 pattern in bits 6,7, and 8 of the K2 bytes). If the L-AIS defects are intermittently occurring, the L-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-AIS alarm condition is cleared. The condition is cleared after not detecting the L-AIS signal for a period of 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
lpSonetRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRxRfiAlarm.setDescription('This attribute displays whether a Line Remote Failure Indication (LRFI) alarm state has been entered. An L-RFI alarm state is entered when Line Remote Failure Indication (L-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-RDI defect is the occurrence of the L-RDI signal in five contiguous valid STS (STM) frame (110 pattern in bits 6,7, and 8 of the K2 bytes). If the L-RDI defects are intermittently occurring, the L-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-RFI alarm condition is cleared. The condition is cleared after not detecting the L-RDI signal for a period of 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the component has been locked and left offline.')
lpSonetTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTxAis.setDescription('This attribute displays whether the Line Alarm Indication Signal (L- AIS) signal is being transmitted on the outgoing line. This signal is transmitted when the Sonet/Sdh is locked and left offline.')
lpSonetTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTxRdi.setDescription('This attribute displays whether the Line Remote Defect Indicator (L-RDI) signal is being transmitted over the OC-3 line. The L-RDI signal is transmitted upon the detection of the LOS, LOF or L-AIS defect. This attribute is always set to off when the component has been locked and left offline.')
lpSonetUnusableTxClockRefAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetUnusableTxClockRefAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetUnusableTxClockRefAlarm.setDescription("This attribute displays whether an Unusable Transmit Clock Reference (UTCR) alarm state has been entered. A UTCR alarm state is entered when a Sonet/Sdh port provisioned to act as a transmit clock reference has received the code 'do not use for synchronization' in the S1 byte (in the SONET/ SDH line overhead) for 2.5 +/- 0.5 seconds. The condition is cleared after not detecting the 'do not use for synchronization' code for a period of 10 +/- 0.5 seconds or when the port is no longer provisioned to act as a transmit clock reference. A port is acting as a transmit clock reference if it is provisioned with a) a clockingSource of line, or b) it has been provisioned as a primaryReference, secondaryReference or tertiaryReference in the NetworkSynchronization component. The unusableTxClockRefAlarm attribute is always set to off when the component has been locked and left offline.")
lpSonetStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17), )
if mibBuilder.loadTexts: lpSonetStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStatsTable.setDescription('This group contains the statistics data for a Sonet or Sdh component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSonetStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"))
if mibBuilder.loadTexts: lpSonetStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetStatsEntry.setDescription('An entry in the lpSonetStatsTable.')
lpSonetRunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetRunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetRunningTime.setDescription('This attribute indicates the total number of seconds since the Sonet/ Sdh component has been activated and been in unlocked state. All the other error counts that follow can be updated when this count is active.')
lpSonetErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an near-end error free state.')
lpSonetSectCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectCodeViolations.setDescription('This attribute indicates the total number of Section Code Violations (SCVs) detected. A SCV corresponds to section BIP-8 error. SCV counting is inhibited for second intervals where a Section Severely Errored Second (SSES) is counted. The count wraps at its maximum value.')
lpSonetSectErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectErroredSec.setDescription('This attribute indicates the total number of Section Errored Seconds (SESs) that have been counted. A SES is declared for second intervals containing one or more SCVs or one or more Loss Of Signal (LOS) or Severely Errored Frame (SEF) defects. A SEF defect is the occurrence of 4 contiguous errored STS or STM frame alignment words.')
lpSonetSectSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectSevErroredSec.setDescription('This attribute indicates the total number of Section Severely Errored Seconds (SSESs) that have been counted. A SSES is declared for second intervals containing more than x SCVs or one or more LOS or SEF defects. The value of x is 155 for a 155 Mbits/sec interface.')
lpSonetSectLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectLosSec.setDescription('This attribute indicates the total number of Section LOS Seconds (SLOSSs) that have been counted. A SLOSS is declared for second intervals containing one or more LOS defects.')
lpSonetSectSevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectSevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectSevErroredFrmSec.setDescription('This attribute indicates the total number of Section Severely Errored Frame Seconds (SSEFSs) that have been counted. A SSEFS is declared for second intervals containing one or more SEF defects.')
lpSonetSectFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetSectFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetSectFailures.setDescription('This attribute indicates the total number of times that a section failure (LOS or LOF failure) has been declared.')
lpSonetLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCVs) detected. A LCV corresponds to a line BIP-24 errors. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. Counting of LCVs is also inhibited over second intervals where a Line Unavailable Second (LUAS) is counted. The count wraps at its maximum value.')
lpSonetLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LESs) that have been counted. A LES is declared for second intervals containing one or more LCVs or one or more line AIS defects. Counting of LES is inhibited over second intervals where a LUAS is counted.')
lpSonetLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSESs) that have been counted. A LSES is declared for second intervals containing more than x LCVs or one or more L- AIS defects. The value of x is 154 for a 155 Mbits/sec interface. Counting of LSES is inhibited over second intervals where a LUAS is counted.')
lpSonetLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineAisSec.setDescription('This attribute indicates the total number of Line AIS Seconds (LAISSs) that have been counted. A LAISS is declared for second intervals containing one or more L-AIS defects. Counting of LAISS is inhibited over second intervals where a LUAS is counted.')
lpSonetLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS line is unavailable. The STS line becomes unavailable at the onset of 10 consecutive LSESs. The 10 LSESs are included in the unavailable time. Once unavailable, the STS line becomes available at the onset of 10 contiguous seconds with no LSES. The 10 seconds with no LSES are excluded from the unavailable time. For second intervals where a Line Unavailable Second (LUAS) is counted, counting of LCV, LES, LSES and LAISS is inhibited.')
lpSonetLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetLineFailures.setDescription('This attribute indicates the total number of times that a line failure (L-AIS failure) has been declared.')
lpSonetFarEndLineErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an far-end error free state.')
lpSonetFarEndLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineCodeViolations.setDescription('This attribute indicates the total number of line FEBE detected from the incoming line. The counting of line FEBE is inhibited for second intervals where a Far-End Line Severely Errored Second (FELSES) is counted. Counting of FELCVs is also inhibited over second intervals where a Far-End Line Unavailable Second (FELUAS) is counted. The count wraps at its maximum value.')
lpSonetFarEndLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineErroredSec.setDescription('This attribute indicates the total number of Far-End Line Errored Seconds (FELESs) that have been counted. A FELES is declared for second intervals containing one or more Far-End Line CVs (FELCVs) or one or more L-RDI defects. Counting of FELES is inhibited over second intervals where a FELUAS is counted.')
lpSonetFarEndLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineSevErroredSec.setDescription('This attribute indicates the total number of Far-End Line Severely Errored Seconds (FELSESs) that have been counted. A FELSES is declared for second intervals containing more than x FELCVs or one or more L-RDI defects. The value of x is 154 for a 155 Mbits/ sec interface. Counting of FELSES is inhibited over second intervals where a FELUAS is counted.')
lpSonetFarEndLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineAisSec.setDescription('This attribute indicates the total number of Far-End Line AIS Seconds (FELAISSs) that have been counted. A FELAISS is declared for second intervals one or more L-RDI defects. Counting of FELAISS is inhibited over second intervals where a FELUAS is counted.')
lpSonetFarEndLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS far-end line is unavailable. The STS far-end line becomes unavailable at the onset of 10 consecutive FELSESs. The 10 FELSESs are included in the unavailable time. Once unavailable, the STS far-end line becomes available at the onset of 10 contiguous seconds with no FELSES. The 10 seconds with no FELSES are excluded from the unavailable time. For second intervals where a Far-End Line Unavailable Second (FELUAS) is counted, counting of FELCV, FELES, FELSES and FELAISS is inhibited.')
lpSonetFarEndLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 17, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetFarEndLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetFarEndLineFailures.setDescription('This attribute indicates the total number of times that a far-end line failure (L-RFI failure) has been declared.')
lpSonetPath = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2))
lpSonetPathRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1), )
if mibBuilder.loadTexts: lpSonetPathRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathRowStatusTable.setDescription('This entry controls the addition and deletion of lpSonetPath components.')
lpSonetPathRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathRowStatusEntry.setDescription('A single entry in the table represents a single lpSonetPath component.')
lpSonetPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSonetPath components. These components can be added and deleted.')
lpSonetPathComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSonetPathStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStorageType.setDescription('This variable represents the storage type value for the lpSonetPath tables.')
lpSonetPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: lpSonetPathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathIndex.setDescription('This variable represents the index for the lpSonetPath tables.')
lpSonetPathProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 10), )
if mibBuilder.loadTexts: lpSonetPathProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathProvTable.setDescription('This group contains all of the provisioning data for a Sonet/Sdh Path component.')
lpSonetPathProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathProvEntry.setDescription('An entry in the lpSonetPathProvTable.')
lpSonetPathApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the Path component.')
lpSonetPathCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 11), )
if mibBuilder.loadTexts: lpSonetPathCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpSonetPathCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCidDataEntry.setDescription('An entry in the lpSonetPathCidDataTable.')
lpSonetPathCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpSonetPathStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12), )
if mibBuilder.loadTexts: lpSonetPathStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpSonetPathStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStateEntry.setDescription('An entry in the lpSonetPathStateTable.')
lpSonetPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetPathOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetPathUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSonetPathAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpSonetPathProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpSonetPathControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpSonetPathAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpSonetPathStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpSonetPathUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpSonetPathIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 13), )
if mibBuilder.loadTexts: lpSonetPathIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpSonetPathIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathIfEntryEntry.setDescription('An entry in the lpSonetPathIfEntryTable.')
lpSonetPathIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpSonetPathIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpSonetPathOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 14), )
if mibBuilder.loadTexts: lpSonetPathOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpSonetPathOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathOperStatusEntry.setDescription('An entry in the lpSonetPathOperStatusTable.')
lpSonetPathSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpSonetPathOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15), )
if mibBuilder.loadTexts: lpSonetPathOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathOperTable.setDescription('This group contains the common operational data for Path component.')
lpSonetPathOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathOperEntry.setDescription('An entry in the lpSonetPathOperTable.')
lpSonetPathLopAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathLopAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathLopAlarm.setDescription('This attribute displays whether a Loss Of Pointer (LOP) alarm state has been entered. An LOP alarm state is entered when LOP defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOP defect occurs when no valid SPE or VC pointer was received in 8 contiguous frames. If the LOP defects are intermittently occurring, the LOP defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the LOP alarm condition is cleared. The condition is cleared when no more invalid pointer has been reported for 10 seconds +/- 0.5 seconds. The lopAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSonetPathRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathRxAisAlarm.setDescription("This attribute displays whether an Path Alarm Indication Signal (P- AIS) alarm state has been entered. An P-AIS alarm state is entered when P-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-AIS defect is the occurrence of the P-AIS signal in three contiguous valid STS or STM frames (all one's in bytes H1 and H2). If the P-AIS defects are intermittently occurring, the P-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-AIS alarm condition is cleared. The condition is cleared after no P-AIS defect has been detected for 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
lpSonetPathRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathRxRfiAlarm.setDescription('This attribute displays whether the Path Remote Failure Indication (P-RFI) alarm state has been entered. An P-RFI alarm state is entered when Path Remote Defect Indicator (P-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-RDI defect is the occurrence of the P-RDI signal in five contiguous valid STS or STM frames (bit 5 of the G1 byte set to 1). If the P-RDI defects are intermittently occurring, the P-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10)with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-RFI alarm condition is cleared. The condition is cleared after no P-RDI defect has been detected for 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSonetPathSignalLabelMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathSignalLabelMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathSignalLabelMismatch.setDescription("This attribute displays whether the Path Signal Label Mismatch (P- SLM) failure condition has been entered. An P-SLM failure condition is entered when P-SLM defects have been observed and accumulated for period of 2.5 seconds +/- 0.5 seconds. An P-SLM defect occurs when detecting an unexpected path signal label. The expected Path signal labels are 'Mapping for ATM' or 'Equipped - Non Specific Payload'. If the P-SLM defects are intermittently occurring, the P-SLM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the Path Signal Label Mismatch failure condition is cleared. The condition is cleared when an expected path signal label is received for 10 seconds +/- 0.5 seconds. The signalLabelMismatch attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
lpSonetPathTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathTxAis.setDescription('This attribute displays whether the Path Alarm Indication Signal (P- AIS) signal is being transmitted on the path. The P-AIS signal is transmitted when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSonetPathTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathTxRdi.setDescription('This attribute displays whether the Path Remote Defect Indicator (P-RDI) signal is being transmitted over the path signal. The P-RDI signal is transmitted over the outgoing line upon detection of LOP, P-AIS or the occurrence of the LCD state. This attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSonetPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16), )
if mibBuilder.loadTexts: lpSonetPathStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStatsTable.setDescription('This group contains the statistics data for a Sonet/Sdh Path component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSonetPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"))
if mibBuilder.loadTexts: lpSonetPathStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathStatsEntry.setDescription('An entry in the lpSonetPathStatsTable.')
lpSonetPathPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an near-end error free state.')
lpSonetPathPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a path BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. The count wraps at its maximum value.')
lpSonetPathPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more PCVs or one or more LOP or path AIS defects. Counting of PES is inhibited when PUAS is counted over the monitored second.')
lpSonetPathPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than x PCVs or one or more LOP or path AIS defects. The value of x is 2400 for a 155 Mbits/sec interface. Counting of PSES is inhibited when PUAS is counted over the monitored second.')
lpSonetPathPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathAisLopSec.setDescription('This attribute indicates the total number of path AIS and LOP Seconds (PALSs). A PALS is declared for second intervals containing one or more path AIS or LOP defects. Counting of PALS is inhibited when PUAS is counted over the monitored second.')
lpSonetPathPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM path is unavailable. The path becomes unavailable at the onset of 10 consecutive PSESs. The 10 PSESs are included in the unavailable time. Once unavailable, the path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where a Path Unavailable Second (PUAS) is counted, counting of PCV, PES, PSES and PALS is inhibited.')
lpSonetPathPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathPathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOP, P-AIS or Path Signal Label Mismatch failure) has been declared.')
lpSonetPathFarEndPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an far-end error free state.')
lpSonetPathFarEndPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathCodeViolations.setDescription('This attribute indicates the total number of Far-End Path Code Violations (FEPCVs) detected. Each FEPCV corresponds to a path FEBE. FEPCV counting is inhibited over second intervals where a Far-End Path Severely Errored Second (FEPSES) is counted. Counting of PCVs is also inhibited over second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted. The count wraps at its maximum value.')
lpSonetPathFarEndPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathErroredSec.setDescription('This attribute indicates the total number of Far-End Path Errored Seconds (FEPESs) that have been counted. A FEPES is declared for second intervals containing one or more FEPCVs or one or more path RDI (P-RDI) defects. Counting of FEPES is inhibited when FEPUAS is counted over the monitored second.')
lpSonetPathFarEndPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathSevErroredSec.setDescription('This attribute indicates the total number of Far-End Path Severely Errored Seconds (FEPSESs) that have been counted. A FEPSES is declared for second intervals containing more than x FEPCVs or one or more P-RDI defects. The value of x is 2400 for a 155 Mbits/ sec interface. Counting of FEPSESs is inhibited when FEPUAS is counted over the monitored second.')
lpSonetPathFarEndPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathAisLopSec.setDescription('This attribute indicates the total number of Far-End Path AIS and LOP Seconds (FEPALSs). A FEPALS is declared for second intervals containing one or more P-RDI defects. Counting of FEPALS is inhibited when FEPUAS is counted over the monitored second.')
lpSonetPathFarEndPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM far-end path is unavailable. The far-end path becomes unavailable at the onset of 10 consecutive FEPSESs. The 10 FEPSESs are included in the unavailable time. Once unavailable, the far-end path becomes available at the onset of 10 contiguous seconds with no FEPSES. The 10 seconds with no FEPSES are excluded from the unavailable time. For second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted, counting of FEPCV, FEPES, FEPSES and FEPALS is inhibited.')
lpSonetPathFarEndPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathFarEndPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathFarEndPathFailures.setDescription('This attribute indicates the total number of times that a STS/STM far-end path failure (P-RFI failure) has been declared.')
lpSonetPathCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2))
lpSonetPathCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1), )
if mibBuilder.loadTexts: lpSonetPathCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellRowStatusTable.setDescription('This entry controls the addition and deletion of lpSonetPathCell components.')
lpSonetPathCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathCellIndex"))
if mibBuilder.loadTexts: lpSonetPathCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellRowStatusEntry.setDescription('A single entry in the table represents a single lpSonetPathCell component.')
lpSonetPathCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSonetPathCell components. These components cannot be added nor deleted.')
lpSonetPathCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSonetPathCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellStorageType.setDescription('This variable represents the storage type value for the lpSonetPathCell tables.')
lpSonetPathCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpSonetPathCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellIndex.setDescription('This variable represents the index for the lpSonetPathCell tables.')
lpSonetPathCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 10), )
if mibBuilder.loadTexts: lpSonetPathCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpSonetPathCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathCellIndex"))
if mibBuilder.loadTexts: lpSonetPathCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellProvEntry.setDescription('An entry in the lpSonetPathCellProvTable.')
lpSonetPathCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpSonetPathCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpSonetPathCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetPathCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpSonetPathCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 11), )
if mibBuilder.loadTexts: lpSonetPathCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpSonetPathCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathCellIndex"))
if mibBuilder.loadTexts: lpSonetPathCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellOperEntry.setDescription('An entry in the lpSonetPathCellOperTable.')
lpSonetPathCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSonetPathCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12), )
if mibBuilder.loadTexts: lpSonetPathCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSonetPathCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetPathCellIndex"))
if mibBuilder.loadTexts: lpSonetPathCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellStatsEntry.setDescription('An entry in the lpSonetPathCellStatsTable.')
lpSonetPathCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpSonetPathCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpSonetPathCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSonetPathCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSonetPathCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 2, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetPathCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetPathCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpSonetTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3))
lpSonetTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1), )
if mibBuilder.loadTexts: lpSonetTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpSonetTest components.')
lpSonetTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetTestIndex"))
if mibBuilder.loadTexts: lpSonetTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestRowStatusEntry.setDescription('A single entry in the table represents a single lpSonetTest component.')
lpSonetTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSonetTest components. These components cannot be added nor deleted.')
lpSonetTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSonetTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestStorageType.setDescription('This variable represents the storage type value for the lpSonetTest tables.')
lpSonetTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpSonetTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestIndex.setDescription('This variable represents the index for the lpSonetTest tables.')
lpSonetTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 10), )
if mibBuilder.loadTexts: lpSonetTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpSonetTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetTestIndex"))
if mibBuilder.loadTexts: lpSonetTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestStateEntry.setDescription('An entry in the lpSonetTestStateTable.')
lpSonetTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpSonetTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpSonetTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpSonetTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11), )
if mibBuilder.loadTexts: lpSonetTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpSonetTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetTestIndex"))
if mibBuilder.loadTexts: lpSonetTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestSetupEntry.setDescription('An entry in the lpSonetTestSetupTable.')
lpSonetTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpSonetTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpSonetTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpSonetTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpSonetTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpSonetTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpSonetTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpSonetTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSonetTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpSonetTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12), )
if mibBuilder.loadTexts: lpSonetTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpSonetTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSonetTestIndex"))
if mibBuilder.loadTexts: lpSonetTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestResultsEntry.setDescription('An entry in the lpSonetTestResultsTable.')
lpSonetTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpSonetTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpSonetTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpSonetTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpSonetTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpSonetTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpSonetTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpSonetTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpSonetTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpSonetTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpSonetTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 14, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSonetTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpSonetTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpSdh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15))
lpSdhRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1), )
if mibBuilder.loadTexts: lpSdhRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRowStatusTable.setDescription('This entry controls the addition and deletion of lpSdh components.')
lpSdhRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRowStatusEntry.setDescription('A single entry in the table represents a single lpSdh component.')
lpSdhRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSdh components. These components can be added and deleted.')
lpSdhComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSdhStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStorageType.setDescription('This variable represents the storage type value for the lpSdh tables.')
lpSdhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)))
if mibBuilder.loadTexts: lpSdhIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhIndex.setDescription('This variable represents the index for the lpSdh tables.')
lpSdhProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 10), )
if mibBuilder.loadTexts: lpSdhProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhProvTable.setDescription('This group contains all of the provisioning data for a Sonet or Sdh component.')
lpSdhProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhProvEntry.setDescription('An entry in the lpSdhProvTable.')
lpSdhClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhClockingSource.setDescription('This attribute defines the type of clocking source used for synchronizing the OC-3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means the use of a signal phase-locked to the incoming OC-3 line rate; module means the use of a signal phase-locked to the CP reference clock. When adding a Sonet/Sdh component, the clockingSource attribute is set to module if the NetworkSynchronization component has been added and is set to local otherwise. Note that the multiport OC-3 cell-based cards has one common clock source for each of the three ports when either the clocking source local or module is selected. For this reason, it is not allowed to have at the same time the clockingSource attribute set to local on one port and module on another port. Furthermore, the clockingSource attribute cannot be set to module if the NetworkSynchronization component has not been added.')
lpSdhCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 11), )
if mibBuilder.loadTexts: lpSdhCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpSdhCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhCidDataEntry.setDescription('An entry in the lpSdhCidDataTable.')
lpSdhCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpSdhAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 12), )
if mibBuilder.loadTexts: lpSdhAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpSdhAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhAdminInfoEntry.setDescription('An entry in the lpSdhAdminInfoTable.')
lpSdhVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhVendor.setDescription('This is the name of the vendor supplying the facility.')
lpSdhCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhCommentText.setDescription('Any miscellaneous text about the facility.')
lpSdhIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 13), )
if mibBuilder.loadTexts: lpSdhIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpSdhIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhIfEntryEntry.setDescription('An entry in the lpSdhIfEntryTable.')
lpSdhIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpSdhIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpSdhOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 14), )
if mibBuilder.loadTexts: lpSdhOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpSdhOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhOperStatusEntry.setDescription('An entry in the lpSdhOperStatusTable.')
lpSdhSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpSdhStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15), )
if mibBuilder.loadTexts: lpSdhStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpSdhStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStateEntry.setDescription('An entry in the lpSdhStateTable.')
lpSdhAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpSdhProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpSdhControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpSdhAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpSdhStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpSdhUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpSdhOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16), )
if mibBuilder.loadTexts: lpSdhOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhOperTable.setDescription('This group contains the common operational data for Sonet or Sdh component.')
lpSdhOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhOperEntry.setDescription('An entry in the lpSdhOperTable.')
lpSdhLosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLosAlarm.setDescription('This attribute indicates whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, or if an LOS defect is present when the criteria for LOF failure declaration have been met. A LOS defect is declared when 20+/-3 us of all-zeros pattern is detected. The LOS defect is cleared when two valid framing words are detected and no Loss Of Signal condition is detected during an interval of 20+/-3 us. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
lpSdhLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when LOF defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, except when an LOS defect or failure is present. An LOF defect is detected when getting contiguous errored frame alignment for at least 3 msec. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
lpSdhRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRxAisAlarm.setDescription('This attribute displays whether a Line Alarm Indication Signal (L- AIS) alarm state has been entered. An L-AIS alarm state is entered when L-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-AIS defect is the occurrence of the L-AIS signal in five contiguous STS (STM) frames (111 pattern in bits 6,7, and 8 of the K2 bytes). If the L-AIS defects are intermittently occurring, the L-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-AIS alarm condition is cleared. The condition is cleared after not detecting the L-AIS signal for a period of 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
lpSdhRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRxRfiAlarm.setDescription('This attribute displays whether a Line Remote Failure Indication (LRFI) alarm state has been entered. An L-RFI alarm state is entered when Line Remote Failure Indication (L-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-RDI defect is the occurrence of the L-RDI signal in five contiguous valid STS (STM) frame (110 pattern in bits 6,7, and 8 of the K2 bytes). If the L-RDI defects are intermittently occurring, the L-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-RFI alarm condition is cleared. The condition is cleared after not detecting the L-RDI signal for a period of 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the component has been locked and left offline.')
lpSdhTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTxAis.setDescription('This attribute displays whether the Line Alarm Indication Signal (L- AIS) signal is being transmitted on the outgoing line. This signal is transmitted when the Sonet/Sdh is locked and left offline.')
lpSdhTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTxRdi.setDescription('This attribute displays whether the Line Remote Defect Indicator (L-RDI) signal is being transmitted over the OC-3 line. The L-RDI signal is transmitted upon the detection of the LOS, LOF or L-AIS defect. This attribute is always set to off when the component has been locked and left offline.')
lpSdhUnusableTxClockRefAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhUnusableTxClockRefAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhUnusableTxClockRefAlarm.setDescription("This attribute displays whether an Unusable Transmit Clock Reference (UTCR) alarm state has been entered. A UTCR alarm state is entered when a Sonet/Sdh port provisioned to act as a transmit clock reference has received the code 'do not use for synchronization' in the S1 byte (in the SONET/ SDH line overhead) for 2.5 +/- 0.5 seconds. The condition is cleared after not detecting the 'do not use for synchronization' code for a period of 10 +/- 0.5 seconds or when the port is no longer provisioned to act as a transmit clock reference. A port is acting as a transmit clock reference if it is provisioned with a) a clockingSource of line, or b) it has been provisioned as a primaryReference, secondaryReference or tertiaryReference in the NetworkSynchronization component. The unusableTxClockRefAlarm attribute is always set to off when the component has been locked and left offline.")
lpSdhStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17), )
if mibBuilder.loadTexts: lpSdhStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStatsTable.setDescription('This group contains the statistics data for a Sonet or Sdh component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSdhStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"))
if mibBuilder.loadTexts: lpSdhStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhStatsEntry.setDescription('An entry in the lpSdhStatsTable.')
lpSdhRunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhRunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhRunningTime.setDescription('This attribute indicates the total number of seconds since the Sonet/ Sdh component has been activated and been in unlocked state. All the other error counts that follow can be updated when this count is active.')
lpSdhErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an near-end error free state.')
lpSdhSectCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectCodeViolations.setDescription('This attribute indicates the total number of Section Code Violations (SCVs) detected. A SCV corresponds to section BIP-8 error. SCV counting is inhibited for second intervals where a Section Severely Errored Second (SSES) is counted. The count wraps at its maximum value.')
lpSdhSectErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectErroredSec.setDescription('This attribute indicates the total number of Section Errored Seconds (SESs) that have been counted. A SES is declared for second intervals containing one or more SCVs or one or more Loss Of Signal (LOS) or Severely Errored Frame (SEF) defects. A SEF defect is the occurrence of 4 contiguous errored STS or STM frame alignment words.')
lpSdhSectSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectSevErroredSec.setDescription('This attribute indicates the total number of Section Severely Errored Seconds (SSESs) that have been counted. A SSES is declared for second intervals containing more than x SCVs or one or more LOS or SEF defects. The value of x is 155 for a 155 Mbits/sec interface.')
lpSdhSectLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectLosSec.setDescription('This attribute indicates the total number of Section LOS Seconds (SLOSSs) that have been counted. A SLOSS is declared for second intervals containing one or more LOS defects.')
lpSdhSectSevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectSevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectSevErroredFrmSec.setDescription('This attribute indicates the total number of Section Severely Errored Frame Seconds (SSEFSs) that have been counted. A SSEFS is declared for second intervals containing one or more SEF defects.')
lpSdhSectFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhSectFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhSectFailures.setDescription('This attribute indicates the total number of times that a section failure (LOS or LOF failure) has been declared.')
lpSdhLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCVs) detected. A LCV corresponds to a line BIP-24 errors. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. Counting of LCVs is also inhibited over second intervals where a Line Unavailable Second (LUAS) is counted. The count wraps at its maximum value.')
lpSdhLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LESs) that have been counted. A LES is declared for second intervals containing one or more LCVs or one or more line AIS defects. Counting of LES is inhibited over second intervals where a LUAS is counted.')
lpSdhLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSESs) that have been counted. A LSES is declared for second intervals containing more than x LCVs or one or more L- AIS defects. The value of x is 154 for a 155 Mbits/sec interface. Counting of LSES is inhibited over second intervals where a LUAS is counted.')
lpSdhLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineAisSec.setDescription('This attribute indicates the total number of Line AIS Seconds (LAISSs) that have been counted. A LAISS is declared for second intervals containing one or more L-AIS defects. Counting of LAISS is inhibited over second intervals where a LUAS is counted.')
lpSdhLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS line is unavailable. The STS line becomes unavailable at the onset of 10 consecutive LSESs. The 10 LSESs are included in the unavailable time. Once unavailable, the STS line becomes available at the onset of 10 contiguous seconds with no LSES. The 10 seconds with no LSES are excluded from the unavailable time. For second intervals where a Line Unavailable Second (LUAS) is counted, counting of LCV, LES, LSES and LAISS is inhibited.')
lpSdhLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhLineFailures.setDescription('This attribute indicates the total number of times that a line failure (L-AIS failure) has been declared.')
lpSdhFarEndLineErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an far-end error free state.')
lpSdhFarEndLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineCodeViolations.setDescription('This attribute indicates the total number of line FEBE detected from the incoming line. The counting of line FEBE is inhibited for second intervals where a Far-End Line Severely Errored Second (FELSES) is counted. Counting of FELCVs is also inhibited over second intervals where a Far-End Line Unavailable Second (FELUAS) is counted. The count wraps at its maximum value.')
lpSdhFarEndLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineErroredSec.setDescription('This attribute indicates the total number of Far-End Line Errored Seconds (FELESs) that have been counted. A FELES is declared for second intervals containing one or more Far-End Line CVs (FELCVs) or one or more L-RDI defects. Counting of FELES is inhibited over second intervals where a FELUAS is counted.')
lpSdhFarEndLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineSevErroredSec.setDescription('This attribute indicates the total number of Far-End Line Severely Errored Seconds (FELSESs) that have been counted. A FELSES is declared for second intervals containing more than x FELCVs or one or more L-RDI defects. The value of x is 154 for a 155 Mbits/ sec interface. Counting of FELSES is inhibited over second intervals where a FELUAS is counted.')
lpSdhFarEndLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineAisSec.setDescription('This attribute indicates the total number of Far-End Line AIS Seconds (FELAISSs) that have been counted. A FELAISS is declared for second intervals one or more L-RDI defects. Counting of FELAISS is inhibited over second intervals where a FELUAS is counted.')
lpSdhFarEndLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS far-end line is unavailable. The STS far-end line becomes unavailable at the onset of 10 consecutive FELSESs. The 10 FELSESs are included in the unavailable time. Once unavailable, the STS far-end line becomes available at the onset of 10 contiguous seconds with no FELSES. The 10 seconds with no FELSES are excluded from the unavailable time. For second intervals where a Far-End Line Unavailable Second (FELUAS) is counted, counting of FELCV, FELES, FELSES and FELAISS is inhibited.')
lpSdhFarEndLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 17, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhFarEndLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhFarEndLineFailures.setDescription('This attribute indicates the total number of times that a far-end line failure (L-RFI failure) has been declared.')
lpSdhPath = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2))
lpSdhPathRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1), )
if mibBuilder.loadTexts: lpSdhPathRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathRowStatusTable.setDescription('This entry controls the addition and deletion of lpSdhPath components.')
lpSdhPathRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathRowStatusEntry.setDescription('A single entry in the table represents a single lpSdhPath component.')
lpSdhPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSdhPath components. These components can be added and deleted.')
lpSdhPathComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSdhPathStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStorageType.setDescription('This variable represents the storage type value for the lpSdhPath tables.')
lpSdhPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: lpSdhPathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathIndex.setDescription('This variable represents the index for the lpSdhPath tables.')
lpSdhPathProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 10), )
if mibBuilder.loadTexts: lpSdhPathProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathProvTable.setDescription('This group contains all of the provisioning data for a Sonet/Sdh Path component.')
lpSdhPathProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathProvEntry.setDescription('An entry in the lpSdhPathProvTable.')
lpSdhPathApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the Path component.')
lpSdhPathCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 11), )
if mibBuilder.loadTexts: lpSdhPathCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpSdhPathCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCidDataEntry.setDescription('An entry in the lpSdhPathCidDataTable.')
lpSdhPathCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpSdhPathStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12), )
if mibBuilder.loadTexts: lpSdhPathStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpSdhPathStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStateEntry.setDescription('An entry in the lpSdhPathStateTable.')
lpSdhPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhPathOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhPathUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpSdhPathAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpSdhPathProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpSdhPathControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpSdhPathAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpSdhPathStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpSdhPathUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpSdhPathIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 13), )
if mibBuilder.loadTexts: lpSdhPathIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpSdhPathIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathIfEntryEntry.setDescription('An entry in the lpSdhPathIfEntryTable.')
lpSdhPathIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpSdhPathIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpSdhPathOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 14), )
if mibBuilder.loadTexts: lpSdhPathOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpSdhPathOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathOperStatusEntry.setDescription('An entry in the lpSdhPathOperStatusTable.')
lpSdhPathSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpSdhPathOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15), )
if mibBuilder.loadTexts: lpSdhPathOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathOperTable.setDescription('This group contains the common operational data for Path component.')
lpSdhPathOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathOperEntry.setDescription('An entry in the lpSdhPathOperTable.')
lpSdhPathLopAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathLopAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathLopAlarm.setDescription('This attribute displays whether a Loss Of Pointer (LOP) alarm state has been entered. An LOP alarm state is entered when LOP defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOP defect occurs when no valid SPE or VC pointer was received in 8 contiguous frames. If the LOP defects are intermittently occurring, the LOP defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the LOP alarm condition is cleared. The condition is cleared when no more invalid pointer has been reported for 10 seconds +/- 0.5 seconds. The lopAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSdhPathRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathRxAisAlarm.setDescription("This attribute displays whether an Path Alarm Indication Signal (P- AIS) alarm state has been entered. An P-AIS alarm state is entered when P-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-AIS defect is the occurrence of the P-AIS signal in three contiguous valid STS or STM frames (all one's in bytes H1 and H2). If the P-AIS defects are intermittently occurring, the P-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-AIS alarm condition is cleared. The condition is cleared after no P-AIS defect has been detected for 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
lpSdhPathRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathRxRfiAlarm.setDescription('This attribute displays whether the Path Remote Failure Indication (P-RFI) alarm state has been entered. An P-RFI alarm state is entered when Path Remote Defect Indicator (P-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-RDI defect is the occurrence of the P-RDI signal in five contiguous valid STS or STM frames (bit 5 of the G1 byte set to 1). If the P-RDI defects are intermittently occurring, the P-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10)with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-RFI alarm condition is cleared. The condition is cleared after no P-RDI defect has been detected for 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSdhPathSignalLabelMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathSignalLabelMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathSignalLabelMismatch.setDescription("This attribute displays whether the Path Signal Label Mismatch (P- SLM) failure condition has been entered. An P-SLM failure condition is entered when P-SLM defects have been observed and accumulated for period of 2.5 seconds +/- 0.5 seconds. An P-SLM defect occurs when detecting an unexpected path signal label. The expected Path signal labels are 'Mapping for ATM' or 'Equipped - Non Specific Payload'. If the P-SLM defects are intermittently occurring, the P-SLM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the Path Signal Label Mismatch failure condition is cleared. The condition is cleared when an expected path signal label is received for 10 seconds +/- 0.5 seconds. The signalLabelMismatch attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
lpSdhPathTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathTxAis.setDescription('This attribute displays whether the Path Alarm Indication Signal (P- AIS) signal is being transmitted on the path. The P-AIS signal is transmitted when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSdhPathTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathTxRdi.setDescription('This attribute displays whether the Path Remote Defect Indicator (P-RDI) signal is being transmitted over the path signal. The P-RDI signal is transmitted over the outgoing line upon detection of LOP, P-AIS or the occurrence of the LCD state. This attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
lpSdhPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16), )
if mibBuilder.loadTexts: lpSdhPathStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStatsTable.setDescription('This group contains the statistics data for a Sonet/Sdh Path component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSdhPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"))
if mibBuilder.loadTexts: lpSdhPathStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathStatsEntry.setDescription('An entry in the lpSdhPathStatsTable.')
lpSdhPathPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an near-end error free state.')
lpSdhPathPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a path BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. The count wraps at its maximum value.')
lpSdhPathPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more PCVs or one or more LOP or path AIS defects. Counting of PES is inhibited when PUAS is counted over the monitored second.')
lpSdhPathPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than x PCVs or one or more LOP or path AIS defects. The value of x is 2400 for a 155 Mbits/sec interface. Counting of PSES is inhibited when PUAS is counted over the monitored second.')
lpSdhPathPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathAisLopSec.setDescription('This attribute indicates the total number of path AIS and LOP Seconds (PALSs). A PALS is declared for second intervals containing one or more path AIS or LOP defects. Counting of PALS is inhibited when PUAS is counted over the monitored second.')
lpSdhPathPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM path is unavailable. The path becomes unavailable at the onset of 10 consecutive PSESs. The 10 PSESs are included in the unavailable time. Once unavailable, the path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where a Path Unavailable Second (PUAS) is counted, counting of PCV, PES, PSES and PALS is inhibited.')
lpSdhPathPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathPathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOP, P-AIS or Path Signal Label Mismatch failure) has been declared.')
lpSdhPathFarEndPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an far-end error free state.')
lpSdhPathFarEndPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathCodeViolations.setDescription('This attribute indicates the total number of Far-End Path Code Violations (FEPCVs) detected. Each FEPCV corresponds to a path FEBE. FEPCV counting is inhibited over second intervals where a Far-End Path Severely Errored Second (FEPSES) is counted. Counting of PCVs is also inhibited over second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted. The count wraps at its maximum value.')
lpSdhPathFarEndPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathErroredSec.setDescription('This attribute indicates the total number of Far-End Path Errored Seconds (FEPESs) that have been counted. A FEPES is declared for second intervals containing one or more FEPCVs or one or more path RDI (P-RDI) defects. Counting of FEPES is inhibited when FEPUAS is counted over the monitored second.')
lpSdhPathFarEndPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathSevErroredSec.setDescription('This attribute indicates the total number of Far-End Path Severely Errored Seconds (FEPSESs) that have been counted. A FEPSES is declared for second intervals containing more than x FEPCVs or one or more P-RDI defects. The value of x is 2400 for a 155 Mbits/ sec interface. Counting of FEPSESs is inhibited when FEPUAS is counted over the monitored second.')
lpSdhPathFarEndPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathAisLopSec.setDescription('This attribute indicates the total number of Far-End Path AIS and LOP Seconds (FEPALSs). A FEPALS is declared for second intervals containing one or more P-RDI defects. Counting of FEPALS is inhibited when FEPUAS is counted over the monitored second.')
lpSdhPathFarEndPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM far-end path is unavailable. The far-end path becomes unavailable at the onset of 10 consecutive FEPSESs. The 10 FEPSESs are included in the unavailable time. Once unavailable, the far-end path becomes available at the onset of 10 contiguous seconds with no FEPSES. The 10 seconds with no FEPSES are excluded from the unavailable time. For second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted, counting of FEPCV, FEPES, FEPSES and FEPALS is inhibited.')
lpSdhPathFarEndPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathFarEndPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathFarEndPathFailures.setDescription('This attribute indicates the total number of times that a STS/STM far-end path failure (P-RFI failure) has been declared.')
lpSdhPathCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2))
lpSdhPathCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1), )
if mibBuilder.loadTexts: lpSdhPathCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellRowStatusTable.setDescription('This entry controls the addition and deletion of lpSdhPathCell components.')
lpSdhPathCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathCellIndex"))
if mibBuilder.loadTexts: lpSdhPathCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellRowStatusEntry.setDescription('A single entry in the table represents a single lpSdhPathCell component.')
lpSdhPathCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSdhPathCell components. These components cannot be added nor deleted.')
lpSdhPathCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSdhPathCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellStorageType.setDescription('This variable represents the storage type value for the lpSdhPathCell tables.')
lpSdhPathCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpSdhPathCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellIndex.setDescription('This variable represents the index for the lpSdhPathCell tables.')
lpSdhPathCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 10), )
if mibBuilder.loadTexts: lpSdhPathCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpSdhPathCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathCellIndex"))
if mibBuilder.loadTexts: lpSdhPathCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellProvEntry.setDescription('An entry in the lpSdhPathCellProvTable.')
lpSdhPathCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpSdhPathCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpSdhPathCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhPathCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpSdhPathCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 11), )
if mibBuilder.loadTexts: lpSdhPathCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpSdhPathCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathCellIndex"))
if mibBuilder.loadTexts: lpSdhPathCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellOperEntry.setDescription('An entry in the lpSdhPathCellOperTable.')
lpSdhPathCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSdhPathCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12), )
if mibBuilder.loadTexts: lpSdhPathCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpSdhPathCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhPathCellIndex"))
if mibBuilder.loadTexts: lpSdhPathCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellStatsEntry.setDescription('An entry in the lpSdhPathCellStatsTable.')
lpSdhPathCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpSdhPathCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpSdhPathCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSdhPathCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpSdhPathCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 2, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhPathCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhPathCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpSdhTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3))
lpSdhTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1), )
if mibBuilder.loadTexts: lpSdhTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpSdhTest components.')
lpSdhTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhTestIndex"))
if mibBuilder.loadTexts: lpSdhTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestRowStatusEntry.setDescription('A single entry in the table represents a single lpSdhTest component.')
lpSdhTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpSdhTest components. These components cannot be added nor deleted.')
lpSdhTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpSdhTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestStorageType.setDescription('This variable represents the storage type value for the lpSdhTest tables.')
lpSdhTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpSdhTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestIndex.setDescription('This variable represents the index for the lpSdhTest tables.')
lpSdhTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 10), )
if mibBuilder.loadTexts: lpSdhTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpSdhTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhTestIndex"))
if mibBuilder.loadTexts: lpSdhTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestStateEntry.setDescription('An entry in the lpSdhTestStateTable.')
lpSdhTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpSdhTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpSdhTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpSdhTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11), )
if mibBuilder.loadTexts: lpSdhTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpSdhTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhTestIndex"))
if mibBuilder.loadTexts: lpSdhTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestSetupEntry.setDescription('An entry in the lpSdhTestSetupTable.')
lpSdhTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpSdhTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpSdhTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpSdhTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpSdhTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpSdhTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpSdhTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpSdhTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpSdhTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpSdhTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12), )
if mibBuilder.loadTexts: lpSdhTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpSdhTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpSdhTestIndex"))
if mibBuilder.loadTexts: lpSdhTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestResultsEntry.setDescription('An entry in the lpSdhTestResultsTable.')
lpSdhTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpSdhTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpSdhTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpSdhTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpSdhTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpSdhTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpSdhTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpSdhTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpSdhTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpSdhTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpSdhTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 15, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpSdhTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpSdhTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpJT2 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16))
lpJT2RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1), )
if mibBuilder.loadTexts: lpJT2RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RowStatusTable.setDescription('This entry controls the addition and deletion of lpJT2 components.')
lpJT2RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RowStatusEntry.setDescription('A single entry in the table represents a single lpJT2 component.')
lpJT2RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RowStatus.setDescription('This variable is used as the basis for SNMP naming of lpJT2 components. These components can be added and deleted.')
lpJT2ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpJT2StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StorageType.setDescription('This variable represents the storage type value for the lpJT2 tables.')
lpJT2Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: lpJT2Index.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2Index.setDescription('This variable represents the index for the lpJT2 tables.')
lpJT2CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 10), )
if mibBuilder.loadTexts: lpJT2CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpJT2CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CidDataEntry.setDescription('An entry in the lpJT2CidDataTable.')
lpJT2CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpJT2ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 11), )
if mibBuilder.loadTexts: lpJT2ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ProvTable.setDescription('This group contains all of the JT2 specific provisioning data for a JT2 component.')
lpJT2ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ProvEntry.setDescription('An entry in the lpJT2ProvTable.')
lpJT2ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ClockingSource.setDescription("This attribute defines the source of the transmit clock for the JT2 line. When the clocking source is selected from local, the oscillator on the port generates the clocking for the line. When the clocking source is selected from line, the port synchronizes to the clock recovered from the incoming line signal. When the clocking source is selected from module, the port's clock synchronizes to the clock provided by the oscillator on the active CP. Note:- that when one port is set to local, the other port must also be set to local, and when one port is set to module, the other port must also be set to module. If one of the ports is set to line, the other port must be set to otherPort. Also, if a CP reference clock is available when the JT2 component is added, the clocking source defaults to module, whereas if a CP reference clock is not available when the component is added, the clocking source defaults to local.")
lpJT2LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 480))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2LineLength.setDescription('This attribute defines the line length for equalization calculations for the JT2 line. The range is between 0 and 480 feet (1 metre = 3.28 feet).')
lpJT2ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 11, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the JT2 component.')
lpJT2IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 12), )
if mibBuilder.loadTexts: lpJT2IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpJT2IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2IfEntryEntry.setDescription('An entry in the lpJT2IfEntryTable.')
lpJT2IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpJT2IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpJT2OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 13), )
if mibBuilder.loadTexts: lpJT2OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpJT2OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2OperStatusEntry.setDescription('An entry in the lpJT2OperStatusTable.')
lpJT2SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpJT2StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14), )
if mibBuilder.loadTexts: lpJT2StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpJT2StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StateEntry.setDescription('An entry in the lpJT2StateTable.')
lpJT2AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpJT2OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpJT2UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpJT2AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpJT2ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpJT2ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpJT2AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpJT2StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpJT2UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpJT2OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15), )
if mibBuilder.loadTexts: lpJT2OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2OperTable.setDescription('This group contains the JT2 specific operational data for a JT2 component in a digital hierarchy interface.')
lpJT2OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2OperEntry.setDescription('An entry in the lpJT2OperTable.')
lpJT2LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state is entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is declared at the JT2 line interface when the input data is zero for 20 - 32 clock cycles. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. An LOS failure alarm is cleared when the LOS defect is absent for a period of 10 seconds +/- 0.5 seconds. The JT2 port goes into an operationalState of disabled for the duration of the LOS alarm condition. While the port is in the LOS alarm state, the port also transmits the far-end RAI defect indicator on the out-going JT2 line.')
lpJT2LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2LofAlarm.setDescription('This attribute indicates whether a LOF (Loss of Frame) alarm state is entered. A LOF alarm state is entered when LOF defects are observed and accumulated for 2.5 seconds +/- 0.5 seconds or more. A LOF defect occurs when seven or more consecutive incorrect frame alignment patterns (4 multiframes) are received. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The LOF alarm is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled for the duration of the LOF alarm condition. While the port is in the LOF alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
lpJT2RxAisPhysicalAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2RxAisPhysicalAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RxAisPhysicalAlarm.setDescription('This attribute indicates whether a Physical AIS alarm state is entered. A Physical AIS alarm state is entered when a Physical AIS defect is observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. A Physical AIS defect is declared when the incoming signal has two or less zeros in a sequence of 3,156 bits (0.5 ms). If the physical AIS defects are intermittently occurring, the physical AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. A Physical AIS alarm is cleared when the Physical AIS defect is absent for a period of 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled until the AIS alarm condition is cleared. While the port is in the Physical AIS alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
lpJT2RxAisPayloadAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2RxAisPayloadAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RxAisPayloadAlarm.setDescription('This attribute indicates whether a Payload AIS alarm state is entered. A Payload AIS alarm state is entered when a Payload AIS defect persists for a period of 2.5 seconds +/- 0.5 seconds. A Payload AIS defect is declared when the incoming signal of the 6312 kbit/s frame payload (TS1 - TS96) has two or less zeros in a sequence of 3,072 bits (0.5 ms). If the payload AIS defects are intermittently occurring, the payload AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. A Payload AIS failure alarm is cleared when the Payload AIS defect is absent for a period of 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled until the AIS alarm condition is cleared. While the port is in the Payload AIS alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
lpJT2RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RxRaiAlarm.setDescription('This attribute indicates whether a Received RAI alarm state is entered. A received RAI alarm state is entered when the RAI signal is detected on the incoming JT2 Line (when 16 or more consecutive RAI patterns of 1111111100000000 are received on the 4 kbit/s data channel (m-bits) within the framing bits of the JT2 frame). The JT2 port goes into an operationalState of Disabled until the RAI alarm condition is cleared. The RAI alarm is cleared when four or more consecutive non-RAI patterns (anything other than 1111111100000000) are received.')
lpJT2TxAisPhysicalAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TxAisPhysicalAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TxAisPhysicalAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm is being transmitted on the outgoing JT2 line. Currently the JT2 port only transmits a Physical AIS (no Payload AIS) on the outgoing JT2 line. Since there is no Idle signal defined for JT2, the AIS signal is transmitted when the JT2 port is in the operationalState of locked. The AIS signal may also be transmitted for diagnostic testing.')
lpJT2TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TxRaiAlarm.setDescription('This attribute indicates whether an RAI defect indication pattern is being sent on the out-going JT2 line. The RAI alarm pattern is transmitted in the 4 kbit/s data channel (m-bits) when the port detects a LOS, AIS or LOF alarm condition.')
lpJT2StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16), )
if mibBuilder.loadTexts: lpJT2StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StatsTable.setDescription('This group contains the statistical data for a JT2 component in a digital hierarchy interface.')
lpJT2StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2StatsEntry.setDescription('An entry in the lpJT2StatsTable.')
lpJT2RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2RunningTime.setDescription("This attribute indicates the number of seconds since the JT2 component was activated and placed in an unlocked state or used for operational testing. All the other error counts that follow as well as each JT2 subcomponent's error counts can be updated when this count is active.")
lpJT2ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the JT2 port has been in an error free state.')
lpJT2ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2ErroredSec.setDescription('This attribute indicates the total number of errored seconds for the JT2 port. An errored second is declared when a second with one or more Code Violation Error events, or one or more LOF or LOS defects occur. A code violation error may be a cyclic redundancy check (CRC) error or a bipolar violation (BPV) error.')
lpJT2SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2SevErroredSec.setDescription('This attribute indicates the total number of severely errored seconds for the JT2 port. A severely errored second occurs when a second with 255 or more Code Violation Error events or one or more LOF or LOS defects occur.')
lpJT2SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2SevErroredFrmSec.setDescription('This attribute indicates the total number of severely errored framing seconds for the JT2 port. A severely errored framing second occurs when a second with one or more Framing Errors occur.')
lpJT2UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2UnavailSec.setDescription('This attribute indicates the total number of seconds that the interface has been in an unavailable state. An unavailable state occurs at the onset of 10 consecutive Severely Errored Seconds. When the unavailable state is entered, the 10 Severely Errored Seconds are immediately transfered to the count of unavailableSeconds by incrementing the count of unavailSec by 10 and decrementing the count of sevErroredSec by 10. Whilst in the unavailable state, an unavailableSecond is counted for each SES or SEFS that occurs, and the count of SES and SEFS are both inhibited. The unavailable state is cleared at the onset of 10 consecutive seconds which are not Severely Errored Seconds.')
lpJT2BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2BpvErrors.setDescription('This attribute indicates the total count of bipolar violations (BPV). A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line. The value of this attribute will wrap to zero when it reaches its maximum value.')
lpJT2CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CrcErrors.setDescription('This attribute indicates the total number of cyclic redundancy check (CRC-5) errors detected on the incoming JT2 line. The value of this attribute will wrap to 0 when its maximum value is reached.')
lpJT2FrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2FrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2FrameErrors.setDescription('This attribute indicates the total number of Framing Errors that have occured on the JT2 port. A Framing Error is an error in the framing bits. The value of this attribute will wrap to 0 when its maximum value is reached.')
lpJT2LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2LosStateChanges.setDescription('This attribute indicates the total number of times that the incoming signal on the JT2 line has been lost. The value of this attribute will wrap to 0 when its maximum value is reached.')
lpJT2AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 17), )
if mibBuilder.loadTexts: lpJT2AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpJT2AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 17, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"))
if mibBuilder.loadTexts: lpJT2AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2AdminInfoEntry.setDescription('An entry in the lpJT2AdminInfoTable.')
lpJT2Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 17, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2Vendor.setDescription('This is the name of the vendor supplying the facility.')
lpJT2CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 17, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CommentText.setDescription('Any miscellaneous text about the facility.')
lpJT2Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2))
lpJT2TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1), )
if mibBuilder.loadTexts: lpJT2TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestRowStatusTable.setDescription('This entry controls the addition and deletion of lpJT2Test components.')
lpJT2TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2TestIndex"))
if mibBuilder.loadTexts: lpJT2TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestRowStatusEntry.setDescription('A single entry in the table represents a single lpJT2Test component.')
lpJT2TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpJT2Test components. These components cannot be added nor deleted.')
lpJT2TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpJT2TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestStorageType.setDescription('This variable represents the storage type value for the lpJT2Test tables.')
lpJT2TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpJT2TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestIndex.setDescription('This variable represents the index for the lpJT2Test tables.')
lpJT2TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 10), )
if mibBuilder.loadTexts: lpJT2TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpJT2TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2TestIndex"))
if mibBuilder.loadTexts: lpJT2TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestStateEntry.setDescription('An entry in the lpJT2TestStateTable.')
lpJT2TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpJT2TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpJT2TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpJT2TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11), )
if mibBuilder.loadTexts: lpJT2TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpJT2TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2TestIndex"))
if mibBuilder.loadTexts: lpJT2TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestSetupEntry.setDescription('An entry in the lpJT2TestSetupTable.')
lpJT2TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpJT2TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpJT2TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpJT2TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpJT2TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpJT2TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpJT2TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpJT2TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpJT2TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12), )
if mibBuilder.loadTexts: lpJT2TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpJT2TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2TestIndex"))
if mibBuilder.loadTexts: lpJT2TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestResultsEntry.setDescription('An entry in the lpJT2TestResultsTable.')
lpJT2TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpJT2TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpJT2TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpJT2TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpJT2TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpJT2TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpJT2TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpJT2TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpJT2TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpJT2TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpJT2TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2TestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpJT2Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3))
lpJT2CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1), )
if mibBuilder.loadTexts: lpJT2CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellRowStatusTable.setDescription('This entry controls the addition and deletion of lpJT2Cell components.')
lpJT2CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2CellIndex"))
if mibBuilder.loadTexts: lpJT2CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellRowStatusEntry.setDescription('A single entry in the table represents a single lpJT2Cell component.')
lpJT2CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpJT2Cell components. These components cannot be added nor deleted.')
lpJT2CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpJT2CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellStorageType.setDescription('This variable represents the storage type value for the lpJT2Cell tables.')
lpJT2CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpJT2CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellIndex.setDescription('This variable represents the index for the lpJT2Cell tables.')
lpJT2CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 10), )
if mibBuilder.loadTexts: lpJT2CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
lpJT2CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2CellIndex"))
if mibBuilder.loadTexts: lpJT2CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellProvEntry.setDescription('An entry in the lpJT2CellProvTable.')
lpJT2CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
lpJT2CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
lpJT2CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpJT2CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
lpJT2CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 11), )
if mibBuilder.loadTexts: lpJT2CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
lpJT2CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2CellIndex"))
if mibBuilder.loadTexts: lpJT2CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellOperEntry.setDescription('An entry in the lpJT2CellOperTable.')
lpJT2CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpJT2CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12), )
if mibBuilder.loadTexts: lpJT2CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
lpJT2CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2Index"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpJT2CellIndex"))
if mibBuilder.loadTexts: lpJT2CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellStatsEntry.setDescription('An entry in the lpJT2CellStatsTable.')
lpJT2CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
lpJT2CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
lpJT2CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpJT2CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
lpJT2CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 16, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpJT2CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lpJT2CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
lpHssi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17))
lpHssiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1), )
if mibBuilder.loadTexts: lpHssiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiRowStatusTable.setDescription('This entry controls the addition and deletion of lpHssi components.')
lpHssiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiRowStatusEntry.setDescription('A single entry in the table represents a single lpHssi component.')
lpHssiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpHssi components. These components can be added and deleted.')
lpHssiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpHssiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiStorageType.setDescription('This variable represents the storage type value for the lpHssi tables.')
lpHssiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: lpHssiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiIndex.setDescription('This variable represents the index for the lpHssi tables.')
lpHssiProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10), )
if mibBuilder.loadTexts: lpHssiProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiProvTable.setDescription('This group contains the specific provisioning data for a Hssi component.')
lpHssiProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiProvEntry.setDescription('An entry in the lpHssiProvTable.')
lpHssiLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiLinkMode.setDescription('This attribute defines the intended gender of the HSSI port. The actual gender of the port is determined by the hardware setup. In dte mode, the ta line signal is driven as specified by the attribute readyLineState when the HSSI port passes its diagnostics. The ta line signal is then driven as specified by the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signal ca is compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified input line states are observed. In dce mode, the Hssi component behaves similarly as when it is in dte mode. However, it will be driving the dce line signal (ca) and monitoring the dte line signal (ta) as specified by the attributes readyLineState and dataTransferLineState.')
lpHssiReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiReadyLineState.setDescription('This attribute specifies the line signal originating from the HSSI interface that will always be turned on, provided the HSSI interface passes it diagnostics. This set of signal is generally required for maintaining the connection. Note that both dte and dce signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the operational attribute actualLinkMode. See also linkMode. Description of bits: ca(0) ta(1)')
lpHssiDataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiDataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiDataTransferLineState.setDescription('This attribute specifies the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both dte and dce signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the operational attribute actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: ca(0) ta(1)')
lpHssiLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000000, 50000000)).clone(45000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiLineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. Note that the actual clock rate are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed.')
lpHssiApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 10, 1, 7), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the Hssi component.')
lpHssiCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 11), )
if mibBuilder.loadTexts: lpHssiCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
lpHssiCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiCidDataEntry.setDescription('An entry in the lpHssiCidDataTable.')
lpHssiCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
lpHssiAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 12), )
if mibBuilder.loadTexts: lpHssiAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
lpHssiAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiAdminInfoEntry.setDescription('An entry in the lpHssiAdminInfoTable.')
lpHssiVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiVendor.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiVendor.setDescription('This is the name of the vendor supplying the facility.')
lpHssiCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiCommentText.setDescription('Any miscellaneous text about the facility.')
lpHssiIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 13), )
if mibBuilder.loadTexts: lpHssiIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
lpHssiIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiIfEntryEntry.setDescription('An entry in the lpHssiIfEntryTable.')
lpHssiIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
lpHssiIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
lpHssiOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 14), )
if mibBuilder.loadTexts: lpHssiOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
lpHssiOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 14, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiOperStatusEntry.setDescription('An entry in the lpHssiOperStatusTable.')
lpHssiSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
lpHssiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15), )
if mibBuilder.loadTexts: lpHssiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
lpHssiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiStateEntry.setDescription('An entry in the lpHssiStateTable.')
lpHssiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpHssiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpHssiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
lpHssiAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
lpHssiProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
lpHssiControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
lpHssiAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
lpHssiStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
lpHssiUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
lpHssiOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16), )
if mibBuilder.loadTexts: lpHssiOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiOperTable.setDescription('This group contains all specific operational data for a Hssi component.')
lpHssiOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"))
if mibBuilder.loadTexts: lpHssiOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiOperEntry.setDescription('An entry in the lpHssiOperTable.')
lpHssiActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The port behaves as a dce or dte according to the actualLinkMode.')
lpHssiLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiLineState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiLineState.setDescription('This attribute contains the state of the interface signals. Description of bits: ca(0) ta(1) tm(2) la(3) lb(4)')
lpHssiActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock. Note the reported transmit speed is in an error of +/- 10000 bit/s')
lpHssiActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock. Note the reported receive speed is in an error of +/- 10000 bit/s')
lpHssiDataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiDataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiDataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
lpHssiTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2))
lpHssiTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1), )
if mibBuilder.loadTexts: lpHssiTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestRowStatusTable.setDescription('This entry controls the addition and deletion of lpHssiTest components.')
lpHssiTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiTestIndex"))
if mibBuilder.loadTexts: lpHssiTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestRowStatusEntry.setDescription('A single entry in the table represents a single lpHssiTest component.')
lpHssiTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpHssiTest components. These components cannot be added nor deleted.')
lpHssiTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpHssiTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestStorageType.setDescription('This variable represents the storage type value for the lpHssiTest tables.')
lpHssiTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpHssiTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestIndex.setDescription('This variable represents the index for the lpHssiTest tables.')
lpHssiTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 10), )
if mibBuilder.loadTexts: lpHssiTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
lpHssiTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiTestIndex"))
if mibBuilder.loadTexts: lpHssiTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestStateEntry.setDescription('An entry in the lpHssiTestStateTable.')
lpHssiTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
lpHssiTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
lpHssiTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
lpHssiTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11), )
if mibBuilder.loadTexts: lpHssiTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
lpHssiTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiTestIndex"))
if mibBuilder.loadTexts: lpHssiTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestSetupEntry.setDescription('An entry in the lpHssiTestSetupTable.')
lpHssiTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
lpHssiTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestType.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
lpHssiTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
lpHssiTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
lpHssiTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
lpHssiTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
lpHssiTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
lpHssiTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpHssiTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
lpHssiTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12), )
if mibBuilder.loadTexts: lpHssiTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
lpHssiTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpHssiTestIndex"))
if mibBuilder.loadTexts: lpHssiTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestResultsEntry.setDescription('An entry in the lpHssiTestResultsTable.')
lpHssiTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
lpHssiTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
lpHssiTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestCauseOfTermination.setDescription('This attribute records the reason the test is terminated.')
lpHssiTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
lpHssiTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
lpHssiTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
lpHssiTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
lpHssiTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpHssiTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
lpHssiTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestErroredFrmRx.setDescription('This attribute counts the errored frames received during the test period. This counter is not expected to reach its maximum value. The counter wraps to 0 if it exceeds its maximum value. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpHssiTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 17, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpHssiTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: lpHssiTestBitErrorRate.setDescription('This attribute indicates the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component tries to estimate the number of bit errors in any errored frame which is identifiable. The statistics are updated accordingly. A lost frame (possibly due to an error on the flag sequence) is not used for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa; and syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results. This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface.')
lpEng = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23))
lpEngRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1), )
if mibBuilder.loadTexts: lpEngRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngRowStatusTable.setDescription('This entry controls the addition and deletion of lpEng components.')
lpEngRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"))
if mibBuilder.loadTexts: lpEngRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngRowStatusEntry.setDescription('A single entry in the table represents a single lpEng component.')
lpEngRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEng components. These components cannot be added nor deleted.')
lpEngComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngStorageType.setDescription('This variable represents the storage type value for the lpEng tables.')
lpEngIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngIndex.setDescription('This variable represents the index for the lpEng tables.')
lpEngDs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2))
lpEngDsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1), )
if mibBuilder.loadTexts: lpEngDsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngDs components.')
lpEngDsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsIndex"))
if mibBuilder.loadTexts: lpEngDsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsRowStatusEntry.setDescription('A single entry in the table represents a single lpEngDs component.')
lpEngDsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngDsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngDs components. These components can be added and deleted.')
lpEngDsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngDsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngDsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngDsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsStorageType.setDescription('This variable represents the storage type value for the lpEngDs tables.')
lpEngDsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("accounting", 0), ("alarm", 1), ("log", 2), ("debug", 3), ("scn", 4), ("trap", 5), ("stats", 6))))
if mibBuilder.loadTexts: lpEngDsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsIndex.setDescription('This variable represents the index for the lpEngDs tables.')
lpEngDsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 10), )
if mibBuilder.loadTexts: lpEngDsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOperTable.setDescription('This group contains operational attributes for the DataStream components under Lp Engineering.')
lpEngDsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsIndex"))
if mibBuilder.loadTexts: lpEngDsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOperEntry.setDescription('An entry in the lpEngDsOperTable.')
lpEngDsAgentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngDsAgentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsAgentQueueSize.setDescription("This attribute indicates the maximum size of the DCS Agent queue size maximum for a DCS data stream on the LP. It is the maximum size to which the Agent's currentQueueSize can grow. When the queue is full and more data is offered to the Agent, it will be discarded. The following are the system defaults (in number of records): - alarm: 100 - accounting: 10000 - debug: 0 - log: 50 - scn: 200 - trap: 50 - stats: 0 To override the system defaults, see Lp Eng Ds Ov's agentQueueSize attribute.")
lpEngDsOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2))
lpEngDsOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1), )
if mibBuilder.loadTexts: lpEngDsOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvRowStatusTable.setDescription('This entry controls the addition and deletion of lpEngDsOv components.')
lpEngDsOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsOvIndex"))
if mibBuilder.loadTexts: lpEngDsOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvRowStatusEntry.setDescription('A single entry in the table represents a single lpEngDsOv component.')
lpEngDsOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngDsOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of lpEngDsOv components. These components can be added and deleted.')
lpEngDsOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngDsOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
lpEngDsOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lpEngDsOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvStorageType.setDescription('This variable represents the storage type value for the lpEngDsOv tables.')
lpEngDsOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: lpEngDsOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvIndex.setDescription('This variable represents the index for the lpEngDsOv tables.')
lpEngDsOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 10), )
if mibBuilder.loadTexts: lpEngDsOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvProvTable.setDescription('This group contains provisionable attributes for the DataStream Ov components under Lp Engineering. DESCRIPTION')
lpEngDsOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsIndex"), (0, "Nortel-Magellan-Passport-LogicalProcessorMIB", "lpEngDsOvIndex"))
if mibBuilder.loadTexts: lpEngDsOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvProvEntry.setDescription('An entry in the lpEngDsOvProvTable.')
lpEngDsOvAgentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 12, 23, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lpEngDsOvAgentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: lpEngDsOvAgentQueueSize.setDescription("This attribute specifies the maximum size of the DCS Agent's queue for this data stream on this LP. For more details on the defaults and other information, refer to the parent component's agentQueueSize attribute. The size should be set to 0 if absolutely no data is to be accepted from applications. There are threshold alarms based on the value of the Agent's currentQueueSize attribute (a Set when the queue becomes 75% full and a Clear after dropping back to 50% full). To properly determine what to set this to, consult the 'Magellan Passport Engineering Notes and Guidelines'.")
logicalProcessorGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 1))
logicalProcessorGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 1, 5))
logicalProcessorGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 1, 5, 2))
logicalProcessorGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 1, 5, 2, 2))
logicalProcessorCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 3))
logicalProcessorCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 3, 5))
logicalProcessorCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 3, 5, 2))
logicalProcessorCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 11, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpDS3OperStatusEntry=lpDS3OperStatusEntry, lpSonetPathOperStatusEntry=lpSonetPathOperStatusEntry, lpSdhPathRxRfiAlarm=lpSdhPathRxRfiAlarm, lpDS3DS1ChanRowStatusTable=lpDS3DS1ChanRowStatusTable, lpSdhAdminState=lpSdhAdminState, lpE1RxAisAlarm=lpE1RxAisAlarm, lpV35TestDisplayInterval=lpV35TestDisplayInterval, lpHssiTestStorageType=lpHssiTestStorageType, lpSonetUnknownStatus=lpSonetUnknownStatus, lpSonetPathIfEntryEntry=lpSonetPathIfEntryEntry, lpDS1ChanCellRowStatusEntry=lpDS1ChanCellRowStatusEntry, lpSonetStatsTable=lpSonetStatsTable, lpE1RxRaiAlarm=lpE1RxRaiAlarm, lpSdhTestAdminState=lpSdhTestAdminState, lpDS3DS1ChanTcIndex=lpDS3DS1ChanTcIndex, lpHssiProvTable=lpHssiProvTable, lpDS3TestBitsTx=lpDS3TestBitsTx, lpJT2ControlStatus=lpJT2ControlStatus, lpE3PlcpErroredSec=lpE3PlcpErroredSec, lpSonetOperEntry=lpSonetOperEntry, lpSdhFarEndLineCodeViolations=lpSdhFarEndLineCodeViolations, lpE1ChanTcSigOneValue=lpE1ChanTcSigOneValue, lpOperEntry=lpOperEntry, lpSonetStatsEntry=lpSonetStatsEntry, lpSdhFarEndLineUnavailSec=lpSdhFarEndLineUnavailSec, lpV35TestSetupEntry=lpV35TestSetupEntry, lpE1ChanStorageType=lpE1ChanStorageType, lpDS3DS1StateEntry=lpDS3DS1StateEntry, lpDS3UsageState=lpDS3UsageState, lpV35RowStatusTable=lpV35RowStatusTable, lpE3Cell=lpE3Cell, lpE1TestOperationalState=lpE1TestOperationalState, lpSdhTestDisplayInterval=lpSdhTestDisplayInterval, lpSonetPathCellOperTable=lpSonetPathCellOperTable, lpDS3DS1ChanCellLcdAlarm=lpDS3DS1ChanCellLcdAlarm, lpCidDataTable=lpCidDataTable, lpSdhTest=lpSdhTest, lpE1ChanOperStatusTable=lpE1ChanOperStatusTable, lpSonetAdminInfoEntry=lpSonetAdminInfoEntry, lpHssiTestUsageState=lpHssiTestUsageState, lpE1ChanTcSignalOneDuration=lpE1ChanTcSignalOneDuration, lpSonetTestRowStatusEntry=lpSonetTestRowStatusEntry, lpSonetUsageState=lpSonetUsageState, lpDS3PlcpOperationalTable=lpDS3PlcpOperationalTable, lpDS3AvailabilityStatus=lpDS3AvailabilityStatus, lpDS3PlcpStatsTable=lpDS3PlcpStatsTable, lpSdhPathPathErroredSec=lpSdhPathPathErroredSec, lpE1LosStateChanges=lpE1LosStateChanges, lpDS1ChanTcSigOneEntry=lpDS1ChanTcSigOneEntry, lpSonetTestElapsedTime=lpSonetTestElapsedTime, lpSonetPathRowStatus=lpSonetPathRowStatus, lpJT2UsageState=lpJT2UsageState, lpDS3PathFailures=lpDS3PathFailures, lpE3PathErroredSec=lpE3PathErroredSec, lpDS3LineFailures=lpDS3LineFailures, lpDS3DS1ChanTestUsageState=lpDS3DS1ChanTestUsageState, lpDS3TestStorageType=lpDS3TestStorageType, lpSdhTestTimeRemaining=lpSdhTestTimeRemaining, lpE3IfAdminStatus=lpE3IfAdminStatus, lpX21ActualRxLineSpeed=lpX21ActualRxLineSpeed, lpDS3CBitStorageType=lpDS3CBitStorageType, lpDS1ChanStateEntry=lpDS1ChanStateEntry, lpDS3CBitOperationalEntry=lpDS3CBitOperationalEntry, lpDS3DS1ChanIfAdminStatus=lpDS3DS1ChanIfAdminStatus, lpDS3TestResultsTable=lpDS3TestResultsTable, lpDS1ChanTcSigTwoIndex=lpDS1ChanTcSigTwoIndex, lpV35TestFrmRx=lpV35TestFrmRx, lpHssiDataTransferLineState=lpHssiDataTransferLineState, lpE1ChanCellScrambleCellPayload=lpE1ChanCellScrambleCellPayload, lpDS3DS1AdminInfoTable=lpDS3DS1AdminInfoTable, lpSonetTestRowStatusTable=lpSonetTestRowStatusTable, lpDS3CBitCbitUnavailSec=lpDS3CBitCbitUnavailSec, lpE1ChanComponentName=lpE1ChanComponentName, lpJT2TestResultsTable=lpJT2TestResultsTable, lpDS3TestBytesTx=lpDS3TestBytesTx, lpDS1StatsEntry=lpDS1StatsEntry, lpE3PlcpFarEndSevErroredSec=lpE3PlcpFarEndSevErroredSec, lpE1IfAdminStatus=lpE1IfAdminStatus, lpE1ChanTestIndex=lpE1ChanTestIndex, lpSdhTestSetupEntry=lpSdhTestSetupEntry, lpDS3DS1ZeroCoding=lpDS3DS1ZeroCoding, lpSonetPathPathErroredSec=lpSonetPathPathErroredSec, lpSonetPathCellStatsEntry=lpSonetPathCellStatsEntry, lpSonetPathPathErrorFreeSec=lpSonetPathPathErrorFreeSec, lpV35TestIndex=lpV35TestIndex, lpSdhFarEndLineErrorFreeSec=lpSdhFarEndLineErrorFreeSec, lpV35TestRowStatus=lpV35TestRowStatus, lpDS3DS1ChanStateEntry=lpDS3DS1ChanStateEntry, lpE1ChanTestErroredFrmRx=lpE1ChanTestErroredFrmRx, lpSonetPathCellStatsTable=lpSonetPathCellStatsTable, lpE3PlcpUnavailSec=lpE3PlcpUnavailSec, lpSdhPathRowStatusEntry=lpSdhPathRowStatusEntry, lpX21ProvTable=lpX21ProvTable, lpSpareCardStatus=lpSpareCardStatus, lpDS1ChanCellOperEntry=lpDS1ChanCellOperEntry, lpDS3DS1ClockingSource=lpDS3DS1ClockingSource, lpDS1AdminState=lpDS1AdminState, lpDS3DS1ChanTcSigOneEntry=lpDS3DS1ChanTcSigOneEntry, lpJT2StateEntry=lpJT2StateEntry, lpDS1TestFrmTx=lpDS1TestFrmTx, lpDS1ChanIfAdminStatus=lpDS1ChanIfAdminStatus, lpMemoryUsageAvgIndex=lpMemoryUsageAvgIndex, lpSdhStatsEntry=lpSdhStatsEntry, lpDS1AvailabilityStatus=lpDS1AvailabilityStatus, lpSonetAdminInfoTable=lpSonetAdminInfoTable, lpEngDsOvStorageType=lpEngDsOvStorageType, lpDS3Vendor=lpDS3Vendor, lpJT2TestFrmRx=lpJT2TestFrmRx, lpE3G832TrailTraceMismatch=lpE3G832TrailTraceMismatch, lpE3=lpE3, lpDS1ChanTestUsageState=lpDS1ChanTestUsageState, lpJT2CellProvTable=lpJT2CellProvTable, lpX21TestDuration=lpX21TestDuration, lpSdhVendor=lpSdhVendor, lpSdhPathIfAdminStatus=lpSdhPathIfAdminStatus, lpSonetPathCustomerIdentifier=lpSonetPathCustomerIdentifier, lpE3PlcpIndex=lpE3PlcpIndex, lpHssiRowStatusTable=lpHssiRowStatusTable, lpE1ChanRowStatus=lpE1ChanRowStatus, lpSdhTestResultsEntry=lpSdhTestResultsEntry, lpHssiTestRowStatus=lpHssiTestRowStatus, lpEngDsOvIndex=lpEngDsOvIndex, lpDS1RaiAlarmType=lpDS1RaiAlarmType, lpE3TestResultsTable=lpE3TestResultsTable, lpSonetPathStatsTable=lpSonetPathStatsTable, lpDS3LineCodeViolations=lpDS3LineCodeViolations, lpE1TestRowStatusEntry=lpE1TestRowStatusEntry, lpDS3DS1TestFrmPatternType=lpDS3DS1TestFrmPatternType, lpHssiIfIndex=lpHssiIfIndex, lpDS1ChanOperStatusTable=lpDS1ChanOperStatusTable, lpDS1StatsTable=lpDS1StatsTable, lpHssiStandbyStatus=lpHssiStandbyStatus, lpHssiTestCustomizedPattern=lpHssiTestCustomizedPattern, lpV35TestPurpose=lpV35TestPurpose, lpE3PlcpFarEndErroredSec=lpE3PlcpFarEndErroredSec, lpDS1ChanCellRowStatusTable=lpDS1ChanCellRowStatusTable, lpDS1ChanCellOperTable=lpDS1ChanCellOperTable, lpDS3DS1SnmpOperStatus=lpDS3DS1SnmpOperStatus, lpSdhTestElapsedTime=lpSdhTestElapsedTime, lpDS1TestCustomizedPattern=lpDS1TestCustomizedPattern, lpDS1ChanAdminState=lpDS1ChanAdminState, lpDS1ChanCellLcdAlarm=lpDS1ChanCellLcdAlarm, lpE1TestDataStartDelay=lpE1TestDataStartDelay, lpHssiProvEntry=lpHssiProvEntry, lpE3G832RowStatusEntry=lpE3G832RowStatusEntry, lpSonetPathCellAlarmActDelay=lpSonetPathCellAlarmActDelay, lpSonetOperStatusTable=lpSonetOperStatusTable, lpX21TestFrmPatternType=lpX21TestFrmPatternType, lpDS3Test=lpDS3Test, lpX21TestErroredFrmRx=lpX21TestErroredFrmRx, lpDS3DS1TestFrmTx=lpDS3DS1TestFrmTx, lpV35LinkMode=lpV35LinkMode, lpDS3DS1ChanProvTable=lpDS3DS1ChanProvTable, lpDS1AlarmStatus=lpDS1AlarmStatus, lpJT2StatsTable=lpJT2StatsTable, lpDS1ChanCellCorrectableHeaderErrors=lpDS1ChanCellCorrectableHeaderErrors, lpE1DspComponentName=lpE1DspComponentName, lpDS1ChanTcRowStatus=lpDS1ChanTcRowStatus, lpE1ChanUsageState=lpE1ChanUsageState, lpDS1TestResultsEntry=lpDS1TestResultsEntry, lpHssiOperStatusTable=lpHssiOperStatusTable, lpDS1SevErroredSec=lpDS1SevErroredSec, lpE1TestDisplayInterval=lpE1TestDisplayInterval, lpE1ChanCustomerIdentifier=lpE1ChanCustomerIdentifier, lpV35LineStatusTimeOut=lpV35LineStatusTimeOut, lpJT2CellOperEntry=lpJT2CellOperEntry, lpE3RowStatusEntry=lpE3RowStatusEntry, lpE3TestRowStatus=lpE3TestRowStatus, lpE1LineType=lpE1LineType, lpSonetLosAlarm=lpSonetLosAlarm, lpHssiCustomerIdentifier=lpHssiCustomerIdentifier, lpDS1ChanCellStatsEntry=lpDS1ChanCellStatsEntry, lpSdhSectCodeViolations=lpSdhSectCodeViolations, lpE1FrmErrors=lpE1FrmErrors, lpE1ChanTcSigOneIndex=lpE1ChanTcSigOneIndex, lpHssiTestType=lpHssiTestType, lpE1RxMultifrmRaiAlarm=lpE1RxMultifrmRaiAlarm, lpJT2RunningTime=lpJT2RunningTime, lpE1TxRaiAlarm=lpE1TxRaiAlarm, lpE3CellRowStatus=lpE3CellRowStatus, lpDS3PlcpOperationalEntry=lpDS3PlcpOperationalEntry, lpE3PlcpStatsTable=lpE3PlcpStatsTable, lpSdhPathStateTable=lpSdhPathStateTable, lpDS3PlcpStatsEntry=lpDS3PlcpStatsEntry, lpSonetLineSevErroredSec=lpSonetLineSevErroredSec, lpE1TxAisAlarm=lpE1TxAisAlarm, lpE1UsageState=lpE1UsageState, lpHssiRowStatusEntry=lpHssiRowStatusEntry, lpDS3DS1StateTable=lpDS3DS1StateTable, lpE1SevErroredSec=lpE1SevErroredSec, lpE3G832FarEndErrorFreeSec=lpE3G832FarEndErrorFreeSec, lpE1E1OperTable=lpE1E1OperTable, lpE3IfEntryTable=lpE3IfEntryTable, lpE3PlcpOperationalEntry=lpE3PlcpOperationalEntry, lpDS3DS1ChanUsageState=lpDS3DS1ChanUsageState, lpDS3DS1Vendor=lpDS3DS1Vendor, lpDS3CellSevErroredSec=lpDS3CellSevErroredSec, lpE3LineCodeViolations=lpE3LineCodeViolations, lpDS1RowStatus=lpDS1RowStatus, lpJT2TestStorageType=lpJT2TestStorageType, lpSdhPathOperEntry=lpSdhPathOperEntry, lpDS3DS1TestDisplayInterval=lpDS3DS1TestDisplayInterval, lpSonetStorageType=lpSonetStorageType, lpDS3DS1CustomerIdentifier=lpDS3DS1CustomerIdentifier, lpSonetSnmpOperStatus=lpSonetSnmpOperStatus, lpDS1ChanTcRowStatusTable=lpDS1ChanTcRowStatusTable, lpHssiTestBytesRx=lpHssiTestBytesRx, lpDS1ChanTestCustomizedPattern=lpDS1ChanTestCustomizedPattern, lpDS1CidDataEntry=lpDS1CidDataEntry, lpDS1TestAdminState=lpDS1TestAdminState, lpDS3DS1ChanTestDuration=lpDS3DS1ChanTestDuration, lpSdhPathFarEndPathFailures=lpSdhPathFarEndPathFailures, lpDS3DS1ChanTestResultsTable=lpDS3DS1ChanTestResultsTable, lpDS3DS1ChanCellRowStatusTable=lpDS3DS1ChanCellRowStatusTable, lpE1TestFrmTx=lpE1TestFrmTx, lpE3CellReceiveCellUtilization=lpE3CellReceiveCellUtilization, lpSdhClockingSource=lpSdhClockingSource, lpDS3DS1ChanCellIndex=lpDS3DS1ChanCellIndex, lpSdhRowStatusTable=lpSdhRowStatusTable, lpDS3DS1Chan=lpDS3DS1Chan, lpDS1ChanTestSetupEntry=lpDS1ChanTestSetupEntry, lpDS1ChanTcEgressConditioning=lpDS1ChanTcEgressConditioning, lpJT2=lpJT2, lpSonetPathRowStatusTable=lpSonetPathRowStatusTable, lpSonetRxRfiAlarm=lpSonetRxRfiAlarm, lpDS1IfEntryTable=lpDS1IfEntryTable, lpJT2AdminInfoTable=lpJT2AdminInfoTable, lpDS1ChanCidDataTable=lpDS1ChanCidDataTable, lpV35ProceduralStatus=lpV35ProceduralStatus, lpDS3DS1ChanTcEgressConditioning=lpDS3DS1ChanTcEgressConditioning, lpE1RowStatus=lpE1RowStatus, lpDS3DS1AdminState=lpDS3DS1AdminState, lpDS3PlcpFarEndCodingViolations=lpDS3PlcpFarEndCodingViolations, lpE1E1OperEntry=lpE1E1OperEntry, lpV35AdminState=lpV35AdminState, lpSonetRowStatusTable=lpSonetRowStatusTable, lpV35TestResultsTable=lpV35TestResultsTable, lpSonetErrorFreeSec=lpSonetErrorFreeSec, lpE1ChanTcSigTwoIndex=lpE1ChanTcSigTwoIndex, lpDS1ChanStandbyStatus=lpDS1ChanStandbyStatus, lpSonetTestPurpose=lpSonetTestPurpose, lpV35RowStatus=lpV35RowStatus, lpSonetTestStateTable=lpSonetTestStateTable, lpDS3DS1ChanTcProvTable=lpDS3DS1ChanTcProvTable, lpDS3DS1TestSetupEntry=lpDS3DS1TestSetupEntry, lpE1AlarmStatus=lpE1AlarmStatus, lpV35TestFrmPatternType=lpV35TestFrmPatternType, lpHssiTestBitsTx=lpHssiTestBitsTx, lpE3PlcpFarEndCodingViolations=lpE3PlcpFarEndCodingViolations, lpDS3DS1TestElapsedTime=lpDS3DS1TestElapsedTime, lpDS3CellReceiveCellUtilization=lpDS3CellReceiveCellUtilization, lpEngIndex=lpEngIndex, lpE1ChanTcProvEntry=lpE1ChanTcProvEntry, lpHssiTestElapsedTime=lpHssiTestElapsedTime)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpDS1CrcErrors=lpDS1CrcErrors, lpV35ControlStatus=lpV35ControlStatus, lpSonetFarEndLineCodeViolations=lpSonetFarEndLineCodeViolations, lpHssiStorageType=lpHssiStorageType, lpSdhUsageState=lpSdhUsageState, lpE3CellStatsTable=lpE3CellStatsTable, lpSdhPathCellIndex=lpSdhPathCellIndex, lpSonetProceduralStatus=lpSonetProceduralStatus, lpE1ChanCellReceiveCellUtilization=lpE1ChanCellReceiveCellUtilization, lpV35TestStorageType=lpV35TestStorageType, lpDS3StorageType=lpDS3StorageType, lpHssiTestAdminState=lpHssiTestAdminState, lpE1TestStateEntry=lpE1TestStateEntry, lpSdhPathFarEndPathErroredSec=lpSdhPathFarEndPathErroredSec, lpE3G832RowStatusTable=lpE3G832RowStatusTable, lpJT2CellScrambleCellPayload=lpJT2CellScrambleCellPayload, lpDS3DS1ChanCellStatsTable=lpDS3DS1ChanCellStatsTable, lpDS3DS1CidDataEntry=lpDS3DS1CidDataEntry, lpV35IfAdminStatus=lpV35IfAdminStatus, lpDS3DS1RowStatusEntry=lpDS3DS1RowStatusEntry, lpDS1RxAisAlarm=lpDS1RxAisAlarm, lpE1OperStatusTable=lpE1OperStatusTable, lpSonetClockingSource=lpSonetClockingSource, lpE3TestPurpose=lpE3TestPurpose, lpSdhPathRxAisAlarm=lpSdhPathRxAisAlarm, lpDS3DS1ChanTcSignalOneDuration=lpDS3DS1ChanTcSignalOneDuration, lpJT2TestUsageState=lpJT2TestUsageState, lpJT2CellReceiveCellUtilization=lpJT2CellReceiveCellUtilization, lpEngDsComponentName=lpEngDsComponentName, lpDS1ChanTestDuration=lpDS1ChanTestDuration, lpDS1ChanOperStatusEntry=lpDS1ChanOperStatusEntry, lpSdhPathTxRdi=lpSdhPathTxRdi, lpMemoryUsageEntry=lpMemoryUsageEntry, lpDS3PlcpUnavailSec=lpDS3PlcpUnavailSec, lpSdhPathCidDataEntry=lpSdhPathCidDataEntry, lpDS3DS1ChanActualChannelSpeed=lpDS3DS1ChanActualChannelSpeed, lpV35TestSetupTable=lpV35TestSetupTable, lpX21Test=lpX21Test, lpE3ComponentName=lpE3ComponentName, lpE1StatsEntry=lpE1StatsEntry, lpDS3TestUsageState=lpDS3TestUsageState, lpDS3Cell=lpDS3Cell, lpDS1TestCauseOfTermination=lpDS1TestCauseOfTermination, lpDS3DS1ChanCidDataEntry=lpDS3DS1ChanCidDataEntry, lpSonetPathCell=lpSonetPathCell, lpV35TestRowStatusTable=lpV35TestRowStatusTable, lpDS1ChanTestRowStatusTable=lpDS1ChanTestRowStatusTable, lpE3CellStorageType=lpE3CellStorageType, lpDS3CBitFarEndSevErroredSec=lpDS3CBitFarEndSevErroredSec, lpE3CellRowStatusEntry=lpE3CellRowStatusEntry, lpDS1ChanTcComponentName=lpDS1ChanTcComponentName, lpDS1DspRowStatusTable=lpDS1DspRowStatusTable, lpSonetPathCellTransmitCellUtilization=lpSonetPathCellTransmitCellUtilization, lpE3TestCauseOfTermination=lpE3TestCauseOfTermination, lpE3Framing=lpE3Framing, lpSdhRunningTime=lpSdhRunningTime, lpE1AudioStorageType=lpE1AudioStorageType, lpDS1ChanTcSigTwoEntry=lpDS1ChanTcSigTwoEntry, lpE1ChanCellRowStatusEntry=lpE1ChanCellRowStatusEntry, lpDS3DS1ChanTcOpTable=lpDS3DS1ChanTcOpTable, lpDS3CBitLoopedbackToFarEnd=lpDS3CBitLoopedbackToFarEnd, lpSdhPathFarEndPathAisLopSec=lpSdhPathFarEndPathAisLopSec, lpDS3DS1StatsTable=lpDS3DS1StatsTable, lpX21DataXferStateChanges=lpX21DataXferStateChanges, lpE1TestRowStatus=lpE1TestRowStatus, lpDS3DS1CrcErrors=lpDS3DS1CrcErrors, lpX21CustomerIdentifier=lpX21CustomerIdentifier, lpDS3DS1ChanIndex=lpDS3DS1ChanIndex, lpDS1ChanCellRowStatus=lpDS1ChanCellRowStatus, lpE1ChanUnknownStatus=lpE1ChanUnknownStatus, lpDS1ChanComponentName=lpDS1ChanComponentName, lpUtilTable=lpUtilTable, lpDS3CellCorrectableHeaderErrors=lpDS3CellCorrectableHeaderErrors, logicalProcessorGroupBE01A=logicalProcessorGroupBE01A, lpE3TestErroredFrmRx=lpE3TestErroredFrmRx, lpDS3CBitRowStatusEntry=lpDS3CBitRowStatusEntry, lpSonetLineFailures=lpSonetLineFailures, lpJT2TestFrmTx=lpJT2TestFrmTx, lpDS1ChanTestFrmPatternType=lpDS1ChanTestFrmPatternType, lpHssiTestDisplayInterval=lpHssiTestDisplayInterval, lpDS3DS1ChanCellOperEntry=lpDS3DS1ChanCellOperEntry, lpDS3CBit=lpDS3CBit, lpJT2ApplicationFramerName=lpJT2ApplicationFramerName, lpSonet=lpSonet, lpDS3DS1TestTimeRemaining=lpDS3DS1TestTimeRemaining, lpDS3DS1ChanTestCustomizedPattern=lpDS3DS1ChanTestCustomizedPattern, lpJT2Cell=lpJT2Cell, lpE1ChanTcStorageType=lpE1ChanTcStorageType, lpHssiAdminInfoTable=lpHssiAdminInfoTable, lpE1ChanTimeslots=lpE1ChanTimeslots, lpDS1ChanCellScrambleCellPayload=lpDS1ChanCellScrambleCellPayload, lpMemoryCapacityTable=lpMemoryCapacityTable, lpDS1=lpDS1, lpDS3DS1ChanTestRowStatus=lpDS3DS1ChanTestRowStatus, lpDS1ChanTestStorageType=lpDS1ChanTestStorageType, lpSdhPathSnmpOperStatus=lpSdhPathSnmpOperStatus, lpMsgBlockUsageAvgMin=lpMsgBlockUsageAvgMin, lpRestartOnCpSwitch=lpRestartOnCpSwitch, lpV35EnableDynamicSpeed=lpV35EnableDynamicSpeed, lpSdhPathCellStatsTable=lpSdhPathCellStatsTable, lpV35ProvEntry=lpV35ProvEntry, lpE1RowStatusEntry=lpE1RowStatusEntry, lpDS1ChanTcSignalOneDuration=lpDS1ChanTcSignalOneDuration, lpE3G832FarEndErroredSec=lpE3G832FarEndErroredSec, lpEng=lpEng, lpDS3RowStatusEntry=lpDS3RowStatusEntry, lpDS1DspStorageType=lpDS1DspStorageType, lpDS3TestRowStatusEntry=lpDS3TestRowStatusEntry, lpDS1OperStatusEntry=lpDS1OperStatusEntry, lpDS3DS1ChanTestCauseOfTermination=lpDS3DS1ChanTestCauseOfTermination, lpHssiTestRowStatusTable=lpHssiTestRowStatusTable, lpDS3DS1ChanSnmpOperStatus=lpDS3DS1ChanSnmpOperStatus, lpJT2CellOperTable=lpJT2CellOperTable, lpE1AudioRowStatusEntry=lpE1AudioRowStatusEntry, lpEngDsOvProvTable=lpEngDsOvProvTable, lpV35TestFrmSize=lpV35TestFrmSize, lpSdhPathCellComponentName=lpSdhPathCellComponentName, lpSonetPathAdminState=lpSonetPathAdminState, lpX21TestIndex=lpX21TestIndex, lpSonetPathCellComponentName=lpSonetPathCellComponentName, lpDS3DS1ErrorFreeSec=lpDS3DS1ErrorFreeSec, lpJT2CellStorageType=lpJT2CellStorageType, lpHssiTestPurpose=lpHssiTestPurpose, lpHssiAvailabilityStatus=lpHssiAvailabilityStatus, lpE3ControlStatus=lpE3ControlStatus, lpDS3DS1TestFrmRx=lpDS3DS1TestFrmRx, lpE3TestBytesRx=lpE3TestBytesRx, lpDS3TestBitErrorRate=lpDS3TestBitErrorRate, lpHssiStateTable=lpHssiStateTable, lpE3StatsTable=lpE3StatsTable, lpSonetFarEndLineErroredSec=lpSonetFarEndLineErroredSec, lpSdhPathStatsEntry=lpSdhPathStatsEntry, lpSdhTestBitErrorRate=lpSdhTestBitErrorRate, lpDS1RunningTime=lpDS1RunningTime, lpDS1TestUsageState=lpDS1TestUsageState, lpDS3PlcpSevErroredFramingSec=lpDS3PlcpSevErroredFramingSec, lpSdhTestErroredFrmRx=lpSdhTestErroredFrmRx, lpDS3PlcpRowStatusTable=lpDS3PlcpRowStatusTable, lpDS1AudioIndex=lpDS1AudioIndex, lpSdhFarEndLineAisSec=lpSdhFarEndLineAisSec, lpE1ChanCidDataTable=lpE1ChanCidDataTable, lpE1AudioRowStatus=lpE1AudioRowStatus, lpHssiStateEntry=lpHssiStateEntry, lpV35TestDataStartDelay=lpV35TestDataStartDelay, lpV35StateEntry=lpV35StateEntry, lpV35SnmpOperStatus=lpV35SnmpOperStatus, lpSonetPathStateEntry=lpSonetPathStateEntry, lpDS3IfIndex=lpDS3IfIndex, lpSonetPathCellLcdAlarm=lpSonetPathCellLcdAlarm, lpDS1TestBitErrorRate=lpDS1TestBitErrorRate, lpDS3ProvEntry=lpDS3ProvEntry, lpE3TestDataStartDelay=lpE3TestDataStartDelay, lpV35CustomerIdentifier=lpV35CustomerIdentifier, lpSdhSectSevErroredSec=lpSdhSectSevErroredSec, lpV35StandbyStatus=lpV35StandbyStatus, lpJT2CellRowStatusTable=lpJT2CellRowStatusTable, lpDS1ChanCellProvEntry=lpDS1ChanCellProvEntry, lpSdhOperTable=lpSdhOperTable, lpEngRowStatusTable=lpEngRowStatusTable, lpDS1ChanVendor=lpDS1ChanVendor, lpEngRowStatusEntry=lpEngRowStatusEntry, lpSdhPathAdminState=lpSdhPathAdminState, lpDS3DS1ChanTest=lpDS3DS1ChanTest, lpSdhPathSignalLabelMismatch=lpSdhPathSignalLabelMismatch, lpSonetPathRowStatusEntry=lpSonetPathRowStatusEntry, lpSonetTestFrmRx=lpSonetTestFrmRx, lpSdhPathStandbyStatus=lpSdhPathStandbyStatus, lpSdhPathCellRowStatusEntry=lpSdhPathCellRowStatusEntry, lpDS3DS1TestDataStartDelay=lpDS3DS1TestDataStartDelay, lpJT2LosAlarm=lpJT2LosAlarm, lpSonetPathStandbyStatus=lpSonetPathStandbyStatus, lpSonetTestStateEntry=lpSonetTestStateEntry, lpJT2TxAisPhysicalAlarm=lpJT2TxAisPhysicalAlarm, lpSdhTestPurpose=lpSdhTestPurpose, lpHssiComponentName=lpHssiComponentName, lpX21TestFrmTx=lpX21TestFrmTx, lpX21LineTerminationRequired=lpX21LineTerminationRequired, lpE3CellCorrectableHeaderErrors=lpE3CellCorrectableHeaderErrors, lpDS3CellRowStatusTable=lpDS3CellRowStatusTable, lpDS1ControlStatus=lpDS1ControlStatus, lpHssiTestBitsRx=lpHssiTestBitsRx, lpDS3DS1Test=lpDS3DS1Test, lpE1ChanIndex=lpE1ChanIndex, lpSdhTestComponentName=lpSdhTestComponentName, lpHssiTestRowStatusEntry=lpHssiTestRowStatusEntry, lpE3LosAlarm=lpE3LosAlarm, lpDS3ProvTable=lpDS3ProvTable, lpDS3TestDuration=lpDS3TestDuration, lpDS3PlcpRowStatusEntry=lpDS3PlcpRowStatusEntry, lpDS3DS1ProceduralStatus=lpDS3DS1ProceduralStatus, lpV35ComponentName=lpV35ComponentName, lpDS1DspComponentName=lpDS1DspComponentName, lpDS3PlcpStorageType=lpDS3PlcpStorageType, lpTimeInterval=lpTimeInterval, lpJT2TestPurpose=lpJT2TestPurpose, lpSonetPathOperEntry=lpSonetPathOperEntry, lpDS3DS1ChanStateTable=lpDS3DS1ChanStateTable, lpDS1TestTimeRemaining=lpDS1TestTimeRemaining, lpE1ChanCellStatsEntry=lpE1ChanCellStatsEntry, lpSonetTestIndex=lpSonetTestIndex, lpDS1AudioStorageType=lpDS1AudioStorageType, lpV35Vendor=lpV35Vendor, lpDS1StandbyStatus=lpDS1StandbyStatus, lpDS1ChanOperationalState=lpDS1ChanOperationalState, lpE1ChanAdminInfoEntry=lpE1ChanAdminInfoEntry, lpSdhStateTable=lpSdhStateTable, lpE3PlcpFarEndUnavailableSec=lpE3PlcpFarEndUnavailableSec, lpX21StandbyStatus=lpX21StandbyStatus, lpHssiIndex=lpHssiIndex, lpJT2TestStateTable=lpJT2TestStateTable, lpJT2TestType=lpJT2TestType, lpSonetPathStatsEntry=lpSonetPathStatsEntry, lpE3TestType=lpE3TestType, lpSdhTestDataStartDelay=lpSdhTestDataStartDelay, lpDS1TestFrmPatternType=lpDS1TestFrmPatternType, lpSdhPathCellStorageType=lpSdhPathCellStorageType, lpV35Test=lpV35Test, lpSonetPathComponentName=lpSonetPathComponentName, lpE1Dsp=lpE1Dsp, lpE1ChanTcSigOneTable=lpE1ChanTcSigOneTable, lpSdhTestResultsTable=lpSdhTestResultsTable, lpDS1AdminInfoTable=lpDS1AdminInfoTable, lpMemoryUsageAvgValue=lpMemoryUsageAvgValue, lpX21UsageState=lpX21UsageState, lpX21TestRowStatus=lpX21TestRowStatus, lpJT2LineLength=lpJT2LineLength, lpDS3TestRowStatus=lpDS3TestRowStatus, lpE1ChanActualChannelSpeed=lpE1ChanActualChannelSpeed, lpE3CellSevErroredSec=lpE3CellSevErroredSec, lpDS3DS1OperEntry=lpDS3DS1OperEntry, lpDS1TestElapsedTime=lpDS1TestElapsedTime, lpJT2CellCorrectableHeaderErrors=lpJT2CellCorrectableHeaderErrors, lpSdhLineUnavailSec=lpSdhLineUnavailSec, lpDS1ChanOperEntry=lpDS1ChanOperEntry, lpJT2TestRowStatusEntry=lpJT2TestRowStatusEntry, lpE3OperationalState=lpE3OperationalState, lpMemoryUsageAvgMaxIndex=lpMemoryUsageAvgMaxIndex, lpV35TestStateTable=lpV35TestStateTable, lpCpuUtilAvgMax=lpCpuUtilAvgMax, lpDS3DS1TestComponentName=lpDS3DS1TestComponentName, lpE1ChanCellOperTable=lpE1ChanCellOperTable, lpDS1ZeroCoding=lpDS1ZeroCoding, lpHssiTestStateEntry=lpHssiTestStateEntry, lpDS1TestDuration=lpDS1TestDuration, lpE1ChanTcSigTwoTable=lpE1ChanTcSigTwoTable, lpLinkToApplicationsTable=lpLinkToApplicationsTable, lpDS3CellLcdAlarm=lpDS3CellLcdAlarm, lpE1ChanTestComponentName=lpE1ChanTestComponentName, lpX21AlarmStatus=lpX21AlarmStatus, lpSonetRowStatusEntry=lpSonetRowStatusEntry, lpX21TestBytesRx=lpX21TestBytesRx, lpSdhPathApplicationFramerName=lpSdhPathApplicationFramerName, lpJT2TestCauseOfTermination=lpJT2TestCauseOfTermination, lpE1ChanTestCauseOfTermination=lpE1ChanTestCauseOfTermination)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpX21TestStorageType=lpX21TestStorageType, lpSdhLosAlarm=lpSdhLosAlarm, lpEngDsOvRowStatusTable=lpEngDsOvRowStatusTable, lpLocalMsgBlockUsageAvg=lpLocalMsgBlockUsageAvg, lpAlarmStatus=lpAlarmStatus, lpEngDsRowStatusEntry=lpEngDsRowStatusEntry, lpX21TestPurpose=lpX21TestPurpose, lpJT2TestAdminState=lpJT2TestAdminState, lpDS1ChanTcProvTable=lpDS1ChanTcProvTable, lpDS3DS1ChanTestStateEntry=lpDS3DS1ChanTestStateEntry, lpX21CidDataEntry=lpX21CidDataEntry, lpCpuUtilAvgMin=lpCpuUtilAvgMin, lpJT2CellComponentName=lpJT2CellComponentName, lpDS3Plcp=lpDS3Plcp, lpSdhOperStatusEntry=lpSdhOperStatusEntry, lpDS3DS1ChanTcReplacementData=lpDS3DS1ChanTcReplacementData, lpE3G832FarEndSefAisSec=lpE3G832FarEndSefAisSec, lpV35TestCauseOfTermination=lpV35TestCauseOfTermination, lpE3G832UnexpectedPayloadType=lpE3G832UnexpectedPayloadType, lpSdhCidDataEntry=lpSdhCidDataEntry, lpDS1UnavailSec=lpDS1UnavailSec, lpE1ChanTcOpEntry=lpE1ChanTcOpEntry, lpE3PlcpRowStatusEntry=lpE3PlcpRowStatusEntry, lpE1ChanCellComponentName=lpE1ChanCellComponentName, lpHssiLineState=lpHssiLineState, lpDS3DS1ChanCustomerIdentifier=lpDS3DS1ChanCustomerIdentifier, lpMemoryUsageValue=lpMemoryUsageValue, lpDS1ChanTcOpEntry=lpDS1ChanTcOpEntry, lpUsageState=lpUsageState, lpE1TestCauseOfTermination=lpE1TestCauseOfTermination, lpDS3DS1TestIndex=lpDS3DS1TestIndex, lpSonetPathPathCodeViolations=lpSonetPathPathCodeViolations, lpDS3AlarmStatus=lpDS3AlarmStatus, lpDS3CBitRowStatus=lpDS3CBitRowStatus, lpE1TestBitsTx=lpE1TestBitsTx, lpE1ChanTestStorageType=lpE1ChanTestStorageType, lpDS3CBitRowStatusTable=lpDS3CBitRowStatusTable, lpSdhPathIfIndex=lpSdhPathIfIndex, lpSdhLineAisSec=lpSdhLineAisSec, lpX21TestDataStartDelay=lpX21TestDataStartDelay, lpDS3TestTimeRemaining=lpDS3TestTimeRemaining, lpDS3DS1SevErroredSec=lpDS3DS1SevErroredSec, lpE1ChanIfEntryEntry=lpE1ChanIfEntryEntry, lpSonetCommentText=lpSonetCommentText, lpProceduralStatus=lpProceduralStatus, lpHssiReadyLineState=lpHssiReadyLineState, lpDS3DS1ChanTimeslots=lpDS3DS1ChanTimeslots, lpSdhFarEndLineErroredSec=lpSdhFarEndLineErroredSec, lpCustomerIdentifier=lpCustomerIdentifier, lpDS3LosAlarm=lpDS3LosAlarm, lpDS1TestBytesTx=lpDS1TestBytesTx, lpV35UnknownStatus=lpV35UnknownStatus, lpE3TestOperationalState=lpE3TestOperationalState, lpX21RowStatusTable=lpX21RowStatusTable, lpDS3AdminInfoEntry=lpDS3AdminInfoEntry, lpX21TestBytesTx=lpX21TestBytesTx, lpDS3DS1AdminInfoEntry=lpDS3DS1AdminInfoEntry, lpE3CidDataTable=lpE3CidDataTable, lpE1ChanCellOperEntry=lpE1ChanCellOperEntry, lpDS3CBitFarEndAlarm=lpDS3CBitFarEndAlarm, lpSonetTxRdi=lpSonetTxRdi, lpJT2TestBitsTx=lpJT2TestBitsTx, lpHssiTestErroredFrmRx=lpHssiTestErroredFrmRx, lpDS3DS1ChanRowStatusEntry=lpDS3DS1ChanRowStatusEntry, lpDS3TestComponentName=lpDS3TestComponentName, lpE3G832ProvisionedTable=lpE3G832ProvisionedTable, lpE3TestDisplayInterval=lpE3TestDisplayInterval, lpJT2ProvTable=lpJT2ProvTable, lpE3ApplicationFramerName=lpE3ApplicationFramerName, lpE3LofAlarm=lpE3LofAlarm, lpE1ChanOperEntry=lpE1ChanOperEntry, lpDS1ChanCustomerIdentifier=lpDS1ChanCustomerIdentifier, lpJT2Test=lpJT2Test, lpJT2BpvErrors=lpJT2BpvErrors, lpSonetFarEndLineSevErroredSec=lpSonetFarEndLineSevErroredSec, lpIndex=lpIndex, lpE3TestAdminState=lpE3TestAdminState, lpE1ChanCellStatsTable=lpE1ChanCellStatsTable, lpDS3ApplicationFramerName=lpDS3ApplicationFramerName, lpSdhUnusableTxClockRefAlarm=lpSdhUnusableTxClockRefAlarm, lpE1ChanTestRowStatus=lpE1ChanTestRowStatus, lpE3CellScrambleCellPayload=lpE3CellScrambleCellPayload, lpSdhPathFarEndPathSevErroredSec=lpSdhPathFarEndPathSevErroredSec, lpDS3DS1ProvTable=lpDS3DS1ProvTable, lpDS3DS1ChanTestIndex=lpDS3DS1ChanTestIndex, lpJT2OperEntry=lpJT2OperEntry, lpJT2LofAlarm=lpJT2LofAlarm, lpDS3OperTable=lpDS3OperTable, lpJT2Index=lpJT2Index, lpSdhIndex=lpSdhIndex, lpSdhTxAis=lpSdhTxAis, lpDS3PathSefAisSec=lpDS3PathSefAisSec, lpDS3PlcpFarEndErrorFreeSec=lpDS3PlcpFarEndErrorFreeSec, lpE3G832FarEndUnavailSec=lpE3G832FarEndUnavailSec, lpDS3CidDataEntry=lpDS3CidDataEntry, lpE3PlcpCodingViolations=lpE3PlcpCodingViolations, lpSonetPathProvTable=lpSonetPathProvTable, lpLocalMsgBlockUsageMax=lpLocalMsgBlockUsageMax, lpE3OperEntry=lpE3OperEntry, lpDS3Index=lpDS3Index, lpDS3DS1ChanStandbyStatus=lpDS3DS1ChanStandbyStatus, lpX21TestUsageState=lpX21TestUsageState, lpSonetControlStatus=lpSonetControlStatus, lpE1TestErroredFrmRx=lpE1TestErroredFrmRx, lpDS3DS1ChanCidDataTable=lpDS3DS1ChanCidDataTable, lpDS3DS1ChanTestRowStatusTable=lpDS3DS1ChanTestRowStatusTable, lpDS3Mapping=lpDS3Mapping, lpSonetTxAis=lpSonetTxAis, lpV35TestResultsEntry=lpV35TestResultsEntry, lpDS3DS1ChanComponentName=lpDS3DS1ChanComponentName, lpDS1ChanTcSigOneValue=lpDS1ChanTcSigOneValue, lpV35IfEntryTable=lpV35IfEntryTable, lpDS3DS1ChanCellAlarmActDelay=lpDS3DS1ChanCellAlarmActDelay, lpSdhSectLosSec=lpSdhSectLosSec, lpE1IfEntryEntry=lpE1IfEntryEntry, lpE1ChanTestType=lpE1ChanTestType, lpE3UnknownStatus=lpE3UnknownStatus, lpX21TestBitsRx=lpX21TestBitsRx, lpHssiOperStatusEntry=lpHssiOperStatusEntry, lpX21TestDisplayInterval=lpX21TestDisplayInterval, lpDS3PlcpErrorFreeSec=lpDS3PlcpErrorFreeSec, lpE1ChanTestRowStatusTable=lpE1ChanTestRowStatusTable, lpE1ChanCellUncorrectableHecErrors=lpE1ChanCellUncorrectableHecErrors, lpDS3DS1ChanTestType=lpDS3DS1ChanTestType, lpV35TestBytesTx=lpV35TestBytesTx, lpE1IfIndex=lpE1IfIndex, lpDS3DS1TestPurpose=lpDS3DS1TestPurpose, lpSdhAlarmStatus=lpSdhAlarmStatus, lpDS3DS1=lpDS3DS1, lpDS1DspRowStatus=lpDS1DspRowStatus, lpV35IfEntryEntry=lpV35IfEntryEntry, lpSonetPathTxRdi=lpSonetPathTxRdi, lpV35RowStatusEntry=lpV35RowStatusEntry, lpDS3CellAlarmActDelay=lpDS3CellAlarmActDelay, lpDS3CellScrambleCellPayload=lpDS3CellScrambleCellPayload, lpJT2TestDataStartDelay=lpJT2TestDataStartDelay, lpDS3DS1TestDuration=lpDS3DS1TestDuration, lpE3IfEntryEntry=lpE3IfEntryEntry, lpSonetPathCellIndex=lpSonetPathCellIndex, lpSonetStateEntry=lpSonetStateEntry, lpE1RaiClearAlarmTime=lpE1RaiClearAlarmTime, lpDS3DS1ChanTestFrmRx=lpDS3DS1ChanTestFrmRx, lpDS1ChanAdminInfoTable=lpDS1ChanAdminInfoTable, lpJT2TestCustomizedPattern=lpJT2TestCustomizedPattern, lpDS3TestOperationalState=lpDS3TestOperationalState, lpE1TestSetupEntry=lpE1TestSetupEntry, lpDS1RowStatusTable=lpDS1RowStatusTable, lpDS1IfAdminStatus=lpDS1IfAdminStatus, lpE1ChanAdminInfoTable=lpE1ChanAdminInfoTable, lpSonetPathSignalLabelMismatch=lpSonetPathSignalLabelMismatch, lpE1Audio=lpE1Audio, lpEngStorageType=lpEngStorageType, lpE3ClockingSource=lpE3ClockingSource, lpE1ChanTestAdminState=lpE1ChanTestAdminState, lpDS3TestFrmTx=lpDS3TestFrmTx, lpDS1ChanTestRowStatus=lpDS1ChanTestRowStatus, lpDS1ErrorFreeSec=lpDS1ErrorFreeSec, lpJT2TestRowStatusTable=lpJT2TestRowStatusTable, lpE1AudioIndex=lpE1AudioIndex, lpDS1TestIndex=lpDS1TestIndex, lpDS1TestPurpose=lpDS1TestPurpose, lpX21Index=lpX21Index, lpDS3DS1TxRaiAlarm=lpDS3DS1TxRaiAlarm, lpE1ChanRowStatusEntry=lpE1ChanRowStatusEntry, lpX21CidDataTable=lpX21CidDataTable, lpDS1TestStateTable=lpDS1TestStateTable, lpSdhIfEntryEntry=lpSdhIfEntryEntry, lpE1ChanTimeslotDataRate=lpE1ChanTimeslotDataRate, lpE1TestCustomizedPattern=lpE1TestCustomizedPattern, lpE1ChanCellRowStatus=lpE1ChanCellRowStatus, lpDS1AdminInfoEntry=lpDS1AdminInfoEntry, lpE1ChanTestSetupEntry=lpE1ChanTestSetupEntry, lpHssiTestFrmPatternType=lpHssiTestFrmPatternType, lpE1TestPurpose=lpE1TestPurpose, lpV35TestRowStatusEntry=lpV35TestRowStatusEntry, lpX21OperationalState=lpX21OperationalState, lpDS1ChanTcSigOneIndex=lpDS1ChanTcSigOneIndex, lpDS3CellStorageType=lpDS3CellStorageType, lpE1UnavailSec=lpE1UnavailSec, lpJT2TestBitErrorRate=lpJT2TestBitErrorRate, lpE1TestType=lpE1TestType, lpJT2AvailabilityStatus=lpJT2AvailabilityStatus, lpDS3DS1LofAlarm=lpDS3DS1LofAlarm, lpE1ChanApplicationFramerName=lpE1ChanApplicationFramerName, lpSdhProceduralStatus=lpSdhProceduralStatus, lpSonetPathPathAisLopSec=lpSonetPathPathAisLopSec, lpDS3DS1ChanTestBytesTx=lpDS3DS1ChanTestBytesTx, lpSdhPathIfEntryTable=lpSdhPathIfEntryTable, lpSdhTestIndex=lpSdhTestIndex, lpE3UsageState=lpE3UsageState, logicalProcessorCapabilities=logicalProcessorCapabilities, lpDS3DS1ChanAvailabilityStatus=lpDS3DS1ChanAvailabilityStatus, lpDS1ProvTable=lpDS1ProvTable, lpDS3DS1TestCauseOfTermination=lpDS3DS1TestCauseOfTermination, lpDS1ChanTestBitsRx=lpDS1ChanTestBitsRx, lpDS3PlcpRxRaiAlarm=lpDS3PlcpRxRaiAlarm, lpX21LineSpeed=lpX21LineSpeed, lpJT2RxAisPhysicalAlarm=lpJT2RxAisPhysicalAlarm, lpJT2AdminInfoEntry=lpJT2AdminInfoEntry, lpHssiLinkMode=lpHssiLinkMode, lpMemoryUsageAvgMaxValue=lpMemoryUsageAvgMaxValue, lpE1StorageType=lpE1StorageType, lpHssiTestSetupEntry=lpHssiTestSetupEntry, lpJT2RowStatus=lpJT2RowStatus, lpDS1ChanTestType=lpDS1ChanTestType, lpE3CellAlarmActDelay=lpE3CellAlarmActDelay, lpE3TestResultsEntry=lpE3TestResultsEntry, lpMemoryCapacityIndex=lpMemoryCapacityIndex, lpDS3CellTransmitCellUtilization=lpDS3CellTransmitCellUtilization, lpDS1ChanTestBitErrorRate=lpDS1ChanTestBitErrorRate, lpStorageType=lpStorageType, lpDS1TestDataStartDelay=lpDS1TestDataStartDelay, lpSdhCidDataTable=lpSdhCidDataTable, lpDS1TestFrmSize=lpDS1TestFrmSize, lpE1LofAlarm=lpE1LofAlarm, lpMemoryUsageAvgTable=lpMemoryUsageAvgTable, lpDS3CBitCbitErroredSec=lpDS3CBitCbitErroredSec, lpE1TestSetupTable=lpE1TestSetupTable, lpJT2CommentText=lpJT2CommentText, lpDS3DS1ProvEntry=lpDS3DS1ProvEntry, lpSdhFarEndLineSevErroredSec=lpSdhFarEndLineSevErroredSec, lpEngDsOvRowStatus=lpEngDsOvRowStatus, lpX21LineState=lpX21LineState, lpDS1BpvErrors=lpDS1BpvErrors, lpV35OperStatusTable=lpV35OperStatusTable, lpDS3ClockingSource=lpDS3ClockingSource, lpDS3PlcpComponentName=lpDS3PlcpComponentName, lpSdhTestBitsRx=lpSdhTestBitsRx, lpE3LineLosSec=lpE3LineLosSec, lpE3PlcpStorageType=lpE3PlcpStorageType, lpV35DteDataClockSource=lpV35DteDataClockSource, lpDS3DS1TestRowStatusTable=lpDS3DS1TestRowStatusTable, lpMemoryUsageAvgMinIndex=lpMemoryUsageAvgMinIndex, lpDS3CBitFarEndErrorFreeSec=lpDS3CBitFarEndErrorFreeSec, lpE1OperTable=lpE1OperTable, lpHssiTestTimeRemaining=lpHssiTestTimeRemaining, lpDS3TestCustomizedPattern=lpDS3TestCustomizedPattern, lpSdhPathCellProvEntry=lpSdhPathCellProvEntry, lpHssiIfEntryEntry=lpHssiIfEntryEntry, lpRowStatus=lpRowStatus, lpMemoryUsageAvgMaxEntry=lpMemoryUsageAvgMaxEntry, lpSonetSectLosSec=lpSonetSectLosSec, lpDS1ChanTestPurpose=lpDS1ChanTestPurpose, lpHssi=lpHssi, lpE3RowStatus=lpE3RowStatus, lpE1ChanAdminState=lpE1ChanAdminState, lpV35TestBitsRx=lpV35TestBitsRx, lpSdhTestRowStatus=lpSdhTestRowStatus, lpDS1ChanTestElapsedTime=lpDS1ChanTestElapsedTime, lpDS3CBitComponentName=lpDS3CBitComponentName, lpSonetSectCodeViolations=lpSonetSectCodeViolations, lpMemoryUsageAvgMinEntry=lpMemoryUsageAvgMinEntry, lpHssiTestFrmRx=lpHssiTestFrmRx, lpDS1ChanTestDisplayInterval=lpDS1ChanTestDisplayInterval)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpDS3PlcpLofAlarm=lpDS3PlcpLofAlarm, lpDS3DS1ChanCellStatsEntry=lpDS3DS1ChanCellStatsEntry, lpE3AvailabilityStatus=lpE3AvailabilityStatus, lpDS3CellIndex=lpDS3CellIndex, lpSonetLineAisSec=lpSonetLineAisSec, lpDS1OperTable=lpDS1OperTable, lpDS1ChanRowStatus=lpDS1ChanRowStatus, lpSonetPathCellCorrectSingleBitHeaderErrors=lpSonetPathCellCorrectSingleBitHeaderErrors, lpDS3DS1UnavailSec=lpDS3DS1UnavailSec, lpSdhTestBytesRx=lpSdhTestBytesRx, lpDS3TestRowStatusTable=lpDS3TestRowStatusTable, lpV35=lpV35, lpSdhPathOperStatusTable=lpSdhPathOperStatusTable, lpDS3DS1ErroredSec=lpDS3DS1ErroredSec, lpSonetAvailabilityStatus=lpSonetAvailabilityStatus, lpDS1ChanTestBitsTx=lpDS1ChanTestBitsTx, lpDS3PlcpSevErroredSec=lpDS3PlcpSevErroredSec, lpSonetTestType=lpSonetTestType, lpDS1StateTable=lpDS1StateTable, lpHssiTestFrmTx=lpHssiTestFrmTx, lpX21TestBitErrorRate=lpX21TestBitErrorRate, lpSdhCommentText=lpSdhCommentText, lpHssiTestStateTable=lpHssiTestStateTable, lpSdhSnmpOperStatus=lpSdhSnmpOperStatus, lpSonetPathOperationalState=lpSonetPathOperationalState, lpE1TestBitErrorRate=lpE1TestBitErrorRate, lpDS3DS1ChanTcRowStatus=lpDS3DS1ChanTcRowStatus, lpSdhPathCidDataTable=lpSdhPathCidDataTable, lpDS3DS1RxRaiAlarm=lpDS3DS1RxRaiAlarm, lpV35ActualLinkMode=lpV35ActualLinkMode, lpJT2TxRaiAlarm=lpJT2TxRaiAlarm, lpDS1ChanTcProvEntry=lpDS1ChanTcProvEntry, lpE1RunningTime=lpE1RunningTime, lpDS3StatsTable=lpDS3StatsTable, lpE1ChanTestTimeRemaining=lpE1ChanTestTimeRemaining, lpSdhIfIndex=lpSdhIfIndex, lpDS3TestFrmRx=lpDS3TestFrmRx, lpDS3DS1ChanCommentText=lpDS3DS1ChanCommentText, lpDS3DS1IfEntryEntry=lpDS3DS1IfEntryEntry, lpSdhLineErroredSec=lpSdhLineErroredSec, lpX21ProvEntry=lpX21ProvEntry, lpDS3DS1TestBytesRx=lpDS3DS1TestBytesRx, lpDS3DS1ChanTcSigTwoIndex=lpDS3DS1ChanTcSigTwoIndex, lpSdhPathCellScrambleCellPayload=lpSdhPathCellScrambleCellPayload, lpDS3DS1TestErroredFrmRx=lpDS3DS1TestErroredFrmRx, lpJT2CellTransmitCellUtilization=lpJT2CellTransmitCellUtilization, lpDS3CustomerIdentifier=lpDS3CustomerIdentifier, lpDS3PathUnavailSec=lpDS3PathUnavailSec, lpDS3DS1ChanAdminInfoTable=lpDS3DS1ChanAdminInfoTable, lpX21ActualTxLineSpeed=lpX21ActualTxLineSpeed, lpStateTable=lpStateTable, lpLocalMsgBlockCapacity=lpLocalMsgBlockCapacity, lpE1ChanTestFrmRx=lpE1ChanTestFrmRx, lpDS3TestIndex=lpDS3TestIndex, lpV35TestAdminState=lpV35TestAdminState, lpX21ActualLinkMode=lpX21ActualLinkMode, lpE3PathCodeViolations=lpE3PathCodeViolations, lpE1ChanCellSevErroredSec=lpE1ChanCellSevErroredSec, lpSdhStandbyStatus=lpSdhStandbyStatus, lpE3G832StatsEntry=lpE3G832StatsEntry, lpSdhUnknownStatus=lpSdhUnknownStatus, lpSonetPathCellProvTable=lpSonetPathCellProvTable, lpSdhTestFrmTx=lpSdhTestFrmTx, lpDS3AdminState=lpDS3AdminState, lpDS1ChanTcSigOneTable=lpDS1ChanTcSigOneTable, lpSpareCard=lpSpareCard, lpSdhOperEntry=lpSdhOperEntry, lpE3G832Index=lpE3G832Index, lpDS3CellProvEntry=lpDS3CellProvEntry, lpDS1TestSetupTable=lpDS1TestSetupTable, lpDS3StateEntry=lpDS3StateEntry, lpSdhRxAisAlarm=lpSdhRxAisAlarm, lpDS3DS1ChanStorageType=lpDS3DS1ChanStorageType, lpE3ProvEntry=lpE3ProvEntry, lpDS3CellRowStatusEntry=lpDS3CellRowStatusEntry, lpX21=lpX21, lpJT2RxAisPayloadAlarm=lpJT2RxAisPayloadAlarm, lpDS3TestDataStartDelay=lpDS3TestDataStartDelay, lpE1ChanTestBitErrorRate=lpE1ChanTestBitErrorRate, lpE3OperStatusTable=lpE3OperStatusTable, lpE3PlcpStatsEntry=lpE3PlcpStatsEntry, lpE3TestElapsedTime=lpE3TestElapsedTime, lpJT2TestBytesRx=lpJT2TestBytesRx, lpE1ChanProvEntry=lpE1ChanProvEntry, lpDS3DS1RunningTime=lpDS3DS1RunningTime, lpDS3IfEntryEntry=lpDS3IfEntryEntry, lpE1CommentText=lpE1CommentText, lpDS3DS1TestRowStatus=lpDS3DS1TestRowStatus, lpDS3DS1RowStatusTable=lpDS3DS1RowStatusTable, lpV35OperationalState=lpV35OperationalState, lpE3G832ProvisionedEntry=lpE3G832ProvisionedEntry, lpE3LineErroredSec=lpE3LineErroredSec, lpE1ChanTcComponentName=lpE1ChanTcComponentName, lpSonetTestDisplayInterval=lpSonetTestDisplayInterval, lpJT2StandbyStatus=lpJT2StandbyStatus, lpE3CellComponentName=lpE3CellComponentName, lpSonetPathFarEndPathSevErroredSec=lpSonetPathFarEndPathSevErroredSec, lpSonetComponentName=lpSonetComponentName, lpSdhPathStateEntry=lpSdhPathStateEntry, lpDS3DS1ChanTestErroredFrmRx=lpDS3DS1ChanTestErroredFrmRx, lpDS3PlcpRowStatus=lpDS3PlcpRowStatus, lpDS3DS1ChanUnknownStatus=lpDS3DS1ChanUnknownStatus, lpV35TestComponentName=lpV35TestComponentName, lpSdhPathPathUnavailSec=lpSdhPathPathUnavailSec, lpHssiUsageState=lpHssiUsageState, lpDS1ChanActualChannelSpeed=lpDS1ChanActualChannelSpeed, lpX21OperStatusEntry=lpX21OperStatusEntry, lpE1ChanIfIndex=lpE1ChanIfIndex, lpX21TestOperationalState=lpX21TestOperationalState, lpE3CellTransmitCellUtilization=lpE3CellTransmitCellUtilization, lpJT2ClockingSource=lpJT2ClockingSource, lpE1CustomerIdentifier=lpE1CustomerIdentifier, lpX21IfIndex=lpX21IfIndex, lpE1ChanOperTable=lpE1ChanOperTable, lpJT2AdminState=lpJT2AdminState, lpSdhPathRowStatus=lpSdhPathRowStatus, lpE1CidDataEntry=lpE1CidDataEntry, lpMainCard=lpMainCard, lpE3G832StatsTable=lpE3G832StatsTable, lpDS1TestComponentName=lpDS1TestComponentName, lpJT2CellRowStatus=lpJT2CellRowStatus, lpDS3DS1UnknownStatus=lpDS3DS1UnknownStatus, lpE3RxAisAlarm=lpE3RxAisAlarm, lpV35CidDataEntry=lpV35CidDataEntry, lpDS3CBitOperationalTable=lpDS3CBitOperationalTable, lpSonetTestBitsRx=lpSonetTestBitsRx, lpEngComponentName=lpEngComponentName, lpE1DspRowStatus=lpE1DspRowStatus, lpDS1ChanStateTable=lpDS1ChanStateTable, lpE1StateTable=lpE1StateTable, lpHssiActualRxLineSpeed=lpHssiActualRxLineSpeed, lpX21TestSetupEntry=lpX21TestSetupEntry, lpDS1ChanAlarmStatus=lpDS1ChanAlarmStatus, lpDS3TestStateTable=lpDS3TestStateTable, lpJT2OperTable=lpJT2OperTable, lpDS3DS1ChanIfEntryEntry=lpDS3DS1ChanIfEntryEntry, lpSonetPath=lpSonetPath, lpDS3DS1ChanTestBytesRx=lpDS3DS1ChanTestBytesRx, lpX21TestSetupTable=lpX21TestSetupTable, lpDS3DS1ChanTestBitsTx=lpDS3DS1ChanTestBitsTx, lpSdhPathFarEndPathCodeViolations=lpSdhPathFarEndPathCodeViolations, lpDS3DS1StandbyStatus=lpDS3DS1StandbyStatus, lpDS3DS1ChanIfIndex=lpDS3DS1ChanIfIndex, lpSonetProvTable=lpSonetProvTable, lpE1ChanStateTable=lpE1ChanStateTable, logicalProcessorMIB=logicalProcessorMIB, lpDS3CBitFarEndSefAisSec=lpDS3CBitFarEndSefAisSec, lpSdhTestCauseOfTermination=lpSdhTestCauseOfTermination, lpE3RxRaiAlarm=lpE3RxRaiAlarm, lpHssiCidDataTable=lpHssiCidDataTable, lpDS3DS1ChanCellRowStatusEntry=lpDS3DS1ChanCellRowStatusEntry, lpDS3LineErroredSec=lpDS3LineErroredSec, lpV35IfIndex=lpV35IfIndex, lpE1ChanCellAlarmActDelay=lpE1ChanCellAlarmActDelay, lpHssiRowStatus=lpHssiRowStatus, lpE3TxAis=lpE3TxAis, lpE3G832OperationalTable=lpE3G832OperationalTable, lpSdhPathOperTable=lpSdhPathOperTable, lpE3PathSevErroredSec=lpE3PathSevErroredSec, lpDS1ChanTestSetupTable=lpDS1ChanTestSetupTable, lpE1ChanTcSigTwoValue=lpE1ChanTcSigTwoValue, lpE1StateEntry=lpE1StateEntry, lpSdhRxRfiAlarm=lpSdhRxRfiAlarm, lpDS1ChanCellSevErroredSec=lpDS1ChanCellSevErroredSec, lpSonetStateTable=lpSonetStateTable, lpDS3DS1StatsEntry=lpDS3DS1StatsEntry, lpSdhTestFrmPatternType=lpSdhTestFrmPatternType, lpDS1DspRowStatusEntry=lpDS1DspRowStatusEntry, lpDS3IfAdminStatus=lpDS3IfAdminStatus, lpE1ChanTestRowStatusEntry=lpE1ChanTestRowStatusEntry, lpDS3DS1IfAdminStatus=lpDS3DS1IfAdminStatus, lpX21ReadyLineState=lpX21ReadyLineState, lpHssiOperTable=lpHssiOperTable, lpDS3DS1ChanCellUncorrectableHecErrors=lpDS3DS1ChanCellUncorrectableHecErrors, lpE1ClockingSource=lpE1ClockingSource, lpX21StorageType=lpX21StorageType, lpSdhStateEntry=lpSdhStateEntry, lpSdhPathAlarmStatus=lpSdhPathAlarmStatus, lpDS3DS1OperationalState=lpDS3DS1OperationalState, lpDS1ChanTcReplacementData=lpDS1ChanTcReplacementData, lpJT2OperationalState=lpJT2OperationalState, lpE3G832TimingMarker=lpE3G832TimingMarker, lpV35CommentText=lpV35CommentText, lpDS3DS1TestStateEntry=lpDS3DS1TestStateEntry, lpJT2RowStatusTable=lpJT2RowStatusTable, lpSonetPathCellRowStatusEntry=lpSonetPathCellRowStatusEntry, lpProvTable=lpProvTable, lpJT2CellCorrectSingleBitHeaderErrors=lpJT2CellCorrectSingleBitHeaderErrors, lpDS1ChanCellTransmitCellUtilization=lpDS1ChanCellTransmitCellUtilization, lpSdhPathProceduralStatus=lpSdhPathProceduralStatus, lpDS3DS1CidDataTable=lpDS3DS1CidDataTable, lpE1AdminInfoEntry=lpE1AdminInfoEntry, lpDS3TestPurpose=lpDS3TestPurpose, lpE1StandbyStatus=lpE1StandbyStatus, lpDS3OperEntry=lpDS3OperEntry, lpDS3DS1ChanCellProvTable=lpDS3DS1ChanCellProvTable, lpDS1Index=lpDS1Index, lpSonetTestRowStatus=lpSonetTestRowStatus, lpDS3CBitStatsTable=lpDS3CBitStatsTable, lpDS1LosAlarm=lpDS1LosAlarm, lpDS3DS1CommentText=lpDS3DS1CommentText, lpDS1CustomerIdentifier=lpDS1CustomerIdentifier, lpX21TestComponentName=lpX21TestComponentName, lpE3TestBytesTx=lpE3TestBytesTx, lpDS1TestBitsTx=lpDS1TestBitsTx, lpE1ChanAlarmStatus=lpE1ChanAlarmStatus, lpHssiVendor=lpHssiVendor, lpDS3DS1IfIndex=lpDS3DS1IfIndex, lpX21LineStatusTimeOut=lpX21LineStatusTimeOut, lpJT2OperStatusTable=lpJT2OperStatusTable, lpJT2CellProvEntry=lpJT2CellProvEntry, lpDS3DS1TxAisAlarm=lpDS3DS1TxAisAlarm, lpDS3LineLosSec=lpDS3LineLosSec, lpHssiTestComponentName=lpHssiTestComponentName, lpEngDsOperEntry=lpEngDsOperEntry, lpE3PathFailures=lpE3PathFailures, lpHssiTestResultsEntry=lpHssiTestResultsEntry, lpDS3DS1ChanTimeslotDataRate=lpDS3DS1ChanTimeslotDataRate, lpSonetAlarmStatus=lpSonetAlarmStatus, lpSonetPathIndex=lpSonetPathIndex, lpJT2ComponentName=lpJT2ComponentName, lpDS1Audio=lpDS1Audio, lpDS1DspIndex=lpDS1DspIndex, lpDS3StateTable=lpDS3StateTable, lpSonetPathIfIndex=lpSonetPathIfIndex, lpE1CrcErrors=lpE1CrcErrors, lpDS3DS1AlarmStatus=lpDS3DS1AlarmStatus, lpE3CommentText=lpE3CommentText, lpSdhTestRowStatusTable=lpSdhTestRowStatusTable, lpCidDataEntry=lpCidDataEntry, lpDS1ChanTimeslotDataRate=lpDS1ChanTimeslotDataRate, lpDS1ChanTest=lpDS1ChanTest, lpSonetIfEntryTable=lpSonetIfEntryTable, lpE1ChanTestResultsTable=lpE1ChanTestResultsTable, lpDS3DS1AvailabilityStatus=lpDS3DS1AvailabilityStatus, lpDS3TestType=lpDS3TestType, lpDS3DS1TestSetupTable=lpDS3DS1TestSetupTable, lpE3PathSefAisSec=lpE3PathSefAisSec, lpDS3TestResultsEntry=lpDS3TestResultsEntry, lpE3CellUncorrectableHecErrors=lpE3CellUncorrectableHecErrors, lpSonetIfEntryEntry=lpSonetIfEntryEntry, lpX21OperTable=lpX21OperTable, lpMsgBlockUsage=lpMsgBlockUsage, lpDS1ChanCellReceiveCellUtilization=lpDS1ChanCellReceiveCellUtilization, lpE3G832RowStatus=lpE3G832RowStatus, lpSonetTestFrmSize=lpSonetTestFrmSize, lpSdhLofAlarm=lpSdhLofAlarm, lpComponentName=lpComponentName, lpSdhIfEntryTable=lpSdhIfEntryTable, lpE1TestStorageType=lpE1TestStorageType, lpDS1ChanProvEntry=lpDS1ChanProvEntry, lpDS3DS1TestAdminState=lpDS3DS1TestAdminState, lpMemoryUsageIndex=lpMemoryUsageIndex, lpDS3DS1TestStorageType=lpDS3DS1TestStorageType)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpSonetStandbyStatus=lpSonetStandbyStatus, lpDS3DS1ChanOperStatusEntry=lpDS3DS1ChanOperStatusEntry, lpE1ChanRowStatusTable=lpE1ChanRowStatusTable, lpE3LinkAlarmScanInterval=lpE3LinkAlarmScanInterval, lpDS1ChanControlStatus=lpDS1ChanControlStatus, lpHssiLineSpeed=lpHssiLineSpeed, lpDS1AudioRowStatusEntry=lpDS1AudioRowStatusEntry, lpDS1TxAisAlarm=lpDS1TxAisAlarm, lpE1ErrorFreeSec=lpE1ErrorFreeSec, lpE1ChanCellCorrectSingleBitHeaderErrors=lpE1ChanCellCorrectSingleBitHeaderErrors, lpE1ChanTestDataStartDelay=lpE1ChanTestDataStartDelay, lpE1TxMultifrmRaiAlarm=lpE1TxMultifrmRaiAlarm, lpDS3PlcpFarEndUnavailableSec=lpDS3PlcpFarEndUnavailableSec, lpSonetPathIfAdminStatus=lpSonetPathIfAdminStatus, lpSonetPathCellRowStatus=lpSonetPathCellRowStatus, lpDS1ChanTestFrmSize=lpDS1ChanTestFrmSize, lpJT2IfAdminStatus=lpJT2IfAdminStatus, lpE1ChanTcEgressConditioning=lpE1ChanTcEgressConditioning, lpSdhPath=lpSdhPath, lpV35TestErroredFrmRx=lpV35TestErroredFrmRx, lpDS1StateEntry=lpDS1StateEntry, lpDS3TxIdle=lpDS3TxIdle, lpLinkToApplicationsEntry=lpLinkToApplicationsEntry, lpDS3DS1ChanTestElapsedTime=lpDS3DS1ChanTestElapsedTime, lpDS1FrmErrors=lpDS1FrmErrors, lpE1DspStorageType=lpE1DspStorageType, lpDS3CidDataTable=lpDS3CidDataTable, lpDS3DS1ChanTestSetupTable=lpDS3DS1ChanTestSetupTable, lpJT2FrameErrors=lpJT2FrameErrors, lpE3TestFrmSize=lpE3TestFrmSize, lpE1ComponentName=lpE1ComponentName, lpDS1ChanIndex=lpDS1ChanIndex, lpSdhLineFailures=lpSdhLineFailures, lpSdhPathUsageState=lpSdhPathUsageState, lpSonetPathCellScrambleCellPayload=lpSonetPathCellScrambleCellPayload, lpDS3TestStateEntry=lpDS3TestStateEntry, lpEngDsStorageType=lpEngDsStorageType, lpDS3DS1TestBitsRx=lpDS3DS1TestBitsRx, lpV35TestFrmTx=lpV35TestFrmTx, lpSonetIfIndex=lpSonetIfIndex, lpSonetIndex=lpSonetIndex, lpDS1ChanProceduralStatus=lpDS1ChanProceduralStatus, lpDS3DS1IfEntryTable=lpDS3DS1IfEntryTable, lpCpuUtil=lpCpuUtil, lpE1ChanProceduralStatus=lpE1ChanProceduralStatus, lpX21TestTimeRemaining=lpX21TestTimeRemaining, lpDS3DS1ChanTestStorageType=lpDS3DS1ChanTestStorageType, lpDS1AudioRowStatus=lpDS1AudioRowStatus, lpJT2TestSetupEntry=lpJT2TestSetupEntry, lpDS3DS1ChanTcSigTwoValue=lpDS3DS1ChanTcSigTwoValue, lpX21ClockingSource=lpX21ClockingSource, lpDS1ChanTestAdminState=lpDS1ChanTestAdminState, lpSonetOperTable=lpSonetOperTable, lpDS1ChanTcSigTwoTable=lpDS1ChanTcSigTwoTable, lpE3CellRowStatusTable=lpE3CellRowStatusTable, lpHssiTestOperationalState=lpHssiTestOperationalState, lpDS3DS1TestBitErrorRate=lpDS3DS1TestBitErrorRate, lpSdhPathStorageType=lpSdhPathStorageType, lpDS3DS1ChanProceduralStatus=lpDS3DS1ChanProceduralStatus, lpE1ChanStandbyStatus=lpE1ChanStandbyStatus, lpJT2TestDisplayInterval=lpJT2TestDisplayInterval, lpE1Chan=lpE1Chan, lpDS3DS1ChanTcIngressConditioning=lpDS3DS1ChanTcIngressConditioning, lpJT2Vendor=lpJT2Vendor, lpDS1LineType=lpDS1LineType, lpE1ChanTestResultsEntry=lpE1ChanTestResultsEntry, lpDS3CBitCbitCodeViolations=lpDS3CBitCbitCodeViolations, lpSonetPathUsageState=lpSonetPathUsageState, lpE1ChanTestStateEntry=lpE1ChanTestStateEntry, lpDS3DS1ChanRowStatus=lpDS3DS1ChanRowStatus, lpLinkToApplicationsValue=lpLinkToApplicationsValue, lpDS3CellOperTable=lpDS3CellOperTable, lpJT2TestRowStatus=lpJT2TestRowStatus, lpE3PlcpErrorFreeSec=lpE3PlcpErrorFreeSec, lpDS3OperStatusTable=lpDS3OperStatusTable, lpDS1ComponentName=lpDS1ComponentName, lpSonetLofAlarm=lpSonetLofAlarm, lpSdhPathCellCorrectableHeaderErrors=lpSdhPathCellCorrectableHeaderErrors, lpDS3PlcpIndex=lpDS3PlcpIndex, lpDS3DS1ChanTestStateTable=lpDS3DS1ChanTestStateTable, lpSonetCustomerIdentifier=lpSonetCustomerIdentifier, lpAvailabilityStatus=lpAvailabilityStatus, lpSdhTestFrmSize=lpSdhTestFrmSize, lpSonetPathFarEndPathErrorFreeSec=lpSonetPathFarEndPathErrorFreeSec, lpX21AdminInfoEntry=lpX21AdminInfoEntry, lpSonetPathAvailabilityStatus=lpSonetPathAvailabilityStatus, lpDS3DS1ChanTestDataStartDelay=lpDS3DS1ChanTestDataStartDelay, lpDS1RxRaiAlarm=lpDS1RxRaiAlarm, lpHssiTestBitErrorRate=lpHssiTestBitErrorRate, lpDS3DS1OperTable=lpDS3DS1OperTable, lpDS3DS1ChanTcSigTwoEntry=lpDS3DS1ChanTcSigTwoEntry, lpDS1Chan=lpDS1Chan, lpDS3DS1ChanAdminState=lpDS3DS1ChanAdminState, lpE1ChanCellIndex=lpE1ChanCellIndex, lpDS1ChanUnknownStatus=lpDS1ChanUnknownStatus, lpE1ChanTcIngressConditioning=lpE1ChanTcIngressConditioning, lpJT2ProvEntry=lpJT2ProvEntry, lpMemoryCapacityValue=lpMemoryCapacityValue, lpDS3DS1OperStatusTable=lpDS3DS1OperStatusTable, lpDS1UnknownStatus=lpDS1UnknownStatus, lpDS1RowStatusEntry=lpDS1RowStatusEntry, lpE1ChanCellProvTable=lpE1ChanCellProvTable, lpE3TestSetupEntry=lpE3TestSetupEntry, lpE3AlarmStatus=lpE3AlarmStatus, lpHssiDataXferStateChanges=lpHssiDataXferStateChanges, lpE3AdminState=lpE3AdminState, lpE1ChanTestStateTable=lpE1ChanTestStateTable, lpSdhLineCodeViolations=lpSdhLineCodeViolations, lpDS1TestStateEntry=lpDS1TestStateEntry, lpSdhOperStatusTable=lpSdhOperStatusTable, lpE1ChanTestElapsedTime=lpE1ChanTestElapsedTime, lpDS3DS1ChanTcRowStatusTable=lpDS3DS1ChanTcRowStatusTable, lpJT2CellLcdAlarm=lpJT2CellLcdAlarm, lpE1Index=lpE1Index, lpDS3DS1TestCustomizedPattern=lpDS3DS1TestCustomizedPattern, lpJT2CustomerIdentifier=lpJT2CustomerIdentifier, lpX21TestRowStatusTable=lpX21TestRowStatusTable, lpV35ClockingSource=lpV35ClockingSource, lpV35AdminInfoTable=lpV35AdminInfoTable, lpDS3ProceduralStatus=lpDS3ProceduralStatus, lpDS3DS1Index=lpDS3DS1Index, lpE3StatsEntry=lpE3StatsEntry, lpDS1ProvEntry=lpDS1ProvEntry, lpV35ActualTxLineSpeed=lpV35ActualTxLineSpeed, lpDS3CBitCbitSevErroredSec=lpDS3CBitCbitSevErroredSec, lpDS3DS1ChanTestBitErrorRate=lpDS3DS1ChanTestBitErrorRate, lpE3Vendor=lpE3Vendor, lpSdhPathPathAisLopSec=lpSdhPathPathAisLopSec, lpDS3ControlStatus=lpDS3ControlStatus, lpSonetFarEndLineErrorFreeSec=lpSonetFarEndLineErrorFreeSec, lpDS1ChanTestResultsEntry=lpDS1ChanTestResultsEntry, logicalProcessorGroupBE01=logicalProcessorGroupBE01, lpDS3IfEntryTable=lpDS3IfEntryTable, lpV35StorageType=lpV35StorageType, lpDS3DS1StorageType=lpDS3DS1StorageType, lpSonetPathRxRfiAlarm=lpSonetPathRxRfiAlarm, lpDS3CBitFarEndFailures=lpDS3CBitFarEndFailures, lpE1TestBytesTx=lpE1TestBytesTx, lpDS3DS1ChanTestTimeRemaining=lpDS3DS1ChanTestTimeRemaining, lpDS3DS1TestResultsEntry=lpDS3DS1TestResultsEntry, lpSdhTestCustomizedPattern=lpSdhTestCustomizedPattern, lpDS3RunningTime=lpDS3RunningTime, lpE3StorageType=lpE3StorageType, lpX21DataTransferLineState=lpX21DataTransferLineState, lpDS3TestSetupEntry=lpDS3TestSetupEntry, lpDS3CBitCbitErrorFreeSec=lpDS3CBitCbitErrorFreeSec, lpSdhTestSetupTable=lpSdhTestSetupTable, lpDS3DS1ChanTestAdminState=lpDS3DS1ChanTestAdminState, lpDS3DS1ChanCellOperTable=lpDS3DS1ChanCellOperTable, lpCapEntry=lpCapEntry, lpSonetTestFrmTx=lpSonetTestFrmTx, lpSdhIfAdminStatus=lpSdhIfAdminStatus, lpDS1TestRowStatus=lpDS1TestRowStatus, lpDS3TestErroredFrmRx=lpDS3TestErroredFrmRx, lpX21TestType=lpX21TestType, lpJT2RowStatusEntry=lpJT2RowStatusEntry, lpDS3LineLength=lpDS3LineLength, lpCapTable=lpCapTable, lpE3TestFrmPatternType=lpE3TestFrmPatternType, lpE1ChanTestUsageState=lpE1ChanTestUsageState, lpHssiCommentText=lpHssiCommentText, lpDS1CidDataTable=lpDS1CidDataTable, lpE3RunningTime=lpE3RunningTime, lpJT2UnavailSec=lpJT2UnavailSec, lpDS3TxRai=lpDS3TxRai, lpDS1ChanTcIndex=lpDS1ChanTcIndex, lpV35OperEntry=lpV35OperEntry, lpE3CellLcdAlarm=lpE3CellLcdAlarm, lpE1ChanTcRowStatusTable=lpE1ChanTcRowStatusTable, lpSdhSectErroredSec=lpSdhSectErroredSec, lpSdhPathCellOperTable=lpSdhPathCellOperTable, lpDS3TestDisplayInterval=lpDS3TestDisplayInterval, lpDS1ChanRowStatusEntry=lpDS1ChanRowStatusEntry, lpJT2CellStatsTable=lpJT2CellStatsTable, lpDS1LosStateChanges=lpDS1LosStateChanges, lpSonetPathFarEndPathFailures=lpSonetPathFarEndPathFailures, lpE1TestRowStatusTable=lpE1TestRowStatusTable, lpHssiCidDataEntry=lpHssiCidDataEntry, lpSonetPathIfEntryTable=lpSonetPathIfEntryTable, lpE1UnknownStatus=lpE1UnknownStatus, lpE1TestAdminState=lpE1TestAdminState, lpDS1ChanTestIndex=lpDS1ChanTestIndex, lpE3TestSetupTable=lpE3TestSetupTable, lpJT2ProceduralStatus=lpJT2ProceduralStatus, lpE3TestBitErrorRate=lpE3TestBitErrorRate, lpE1AudioComponentName=lpE1AudioComponentName, lpE1ChanTestFrmPatternType=lpE1ChanTestFrmPatternType, lpEngDsOvRowStatusEntry=lpEngDsOvRowStatusEntry, lpE1MultifrmLofAlarm=lpE1MultifrmLofAlarm, lpE1ChanTestBytesRx=lpE1ChanTestBytesRx, lpSdhPathControlStatus=lpSdhPathControlStatus, lpHssiIfEntryTable=lpHssiIfEntryTable, lpX21SnmpOperStatus=lpX21SnmpOperStatus, lpE3G832StorageType=lpE3G832StorageType, lpDS3CbitParity=lpDS3CbitParity, lpE1ChanTestBytesTx=lpE1ChanTestBytesTx, lpSdhPathCellProvTable=lpSdhPathCellProvTable, lpE1SlipErrors=lpE1SlipErrors, lpRowStatusTable=lpRowStatusTable, lpEngDsOv=lpEngDsOv, lpE1SendRaiOnAis=lpE1SendRaiOnAis, lpE1TestTimeRemaining=lpE1TestTimeRemaining, lpDS3OperationalState=lpDS3OperationalState, lpDS3TestBitsRx=lpDS3TestBitsRx, lpUnknownStatus=lpUnknownStatus, lpE1ChanTestBitsTx=lpE1ChanTestBitsTx, lpSdhPathStatsTable=lpSdhPathStatsTable, lpV35TestType=lpV35TestType, lpDS1TestResultsTable=lpDS1TestResultsTable, lpE3StateTable=lpE3StateTable, lpE3TestStorageType=lpE3TestStorageType, lpDS1ChanTcSigTwoValue=lpDS1ChanTcSigTwoValue, lpSdhPathCellSevErroredSec=lpSdhPathCellSevErroredSec, lpJT2CellSevErroredSec=lpJT2CellSevErroredSec, lpE1TestDuration=lpE1TestDuration, lpEngDsOvProvEntry=lpEngDsOvProvEntry, lpX21RowStatusEntry=lpX21RowStatusEntry, lpDS3DS1ChanTcSigTwoTable=lpDS3DS1ChanTcSigTwoTable, lpDS3DS1ChanTcRowStatusEntry=lpDS3DS1ChanTcRowStatusEntry, lpDS3DS1ChanAlarmStatus=lpDS3DS1ChanAlarmStatus, lpX21IfAdminStatus=lpX21IfAdminStatus, lpSdhPathComponentName=lpSdhPathComponentName, lpE3TestFrmRx=lpE3TestFrmRx, lpHssiTestIndex=lpHssiTestIndex, lpJT2TestErroredFrmRx=lpJT2TestErroredFrmRx, lpSdhLineSevErroredSec=lpSdhLineSevErroredSec, lpE3ProceduralStatus=lpE3ProceduralStatus, lpE3TestCustomizedPattern=lpE3TestCustomizedPattern, lpSdhRowStatus=lpSdhRowStatus, lpSdhCustomerIdentifier=lpSdhCustomerIdentifier, lpE3StandbyStatus=lpE3StandbyStatus, lpE1ChanTestPurpose=lpE1ChanTestPurpose, lpE3CellProvTable=lpE3CellProvTable, lpEngDsRowStatus=lpEngDsRowStatus, lpX21EnableDynamicSpeed=lpX21EnableDynamicSpeed, lpE3TestStateTable=lpE3TestStateTable, lpSonetPathCellCorrectableHeaderErrors=lpSonetPathCellCorrectableHeaderErrors, lpDS3DS1ChanTestRowStatusEntry=lpDS3DS1ChanTestRowStatusEntry, lpX21DteDataClockSource=lpX21DteDataClockSource, lpDS3CBitFarEndErroredSec=lpDS3CBitFarEndErroredSec, lpDS3DS1OperStatusEntry=lpDS3DS1OperStatusEntry, lpE1ChanCellRowStatusTable=lpE1ChanCellRowStatusTable, lpE1TestElapsedTime=lpE1TestElapsedTime, lpDS3DS1ChanOperEntry=lpDS3DS1ChanOperEntry, lpSdhPathTxAis=lpSdhPathTxAis, lpDS3TestSetupTable=lpDS3TestSetupTable, lpDS3DS1ControlStatus=lpDS3DS1ControlStatus, lpSonetPathCidDataTable=lpSonetPathCidDataTable, lpSonetTestErroredFrmRx=lpSonetTestErroredFrmRx, lpJT2LosStateChanges=lpJT2LosStateChanges, lpSdhPathLopAlarm=lpSdhPathLopAlarm, lpSdhTestStateTable=lpSdhTestStateTable, lpDS1SlipErrors=lpDS1SlipErrors, lpSdhTxRdi=lpSdhTxRdi)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpX21TestRowStatusEntry=lpX21TestRowStatusEntry, lp=lp, lpSonetPathOperTable=lpSonetPathOperTable, lpSonetPathApplicationFramerName=lpSonetPathApplicationFramerName, lpDS3DS1ChanTcSigOneValue=lpDS3DS1ChanTcSigOneValue, lpSdhStatsTable=lpSdhStatsTable, lpE3PlcpRowStatus=lpE3PlcpRowStatus, lpDS1SevErroredFrmSec=lpDS1SevErroredFrmSec, lpDS1ChanIfEntryTable=lpDS1ChanIfEntryTable, lpDS1ChanTestErroredFrmRx=lpDS1ChanTestErroredFrmRx, lpSdhAdminInfoTable=lpSdhAdminInfoTable, lpDS3PlcpCodingViolations=lpDS3PlcpCodingViolations, lpDS1ChanTestComponentName=lpDS1ChanTestComponentName, lpE1ChanTcRowStatus=lpE1ChanTcRowStatus, lpDS3StatsEntry=lpDS3StatsEntry, lpDS1OperStatusTable=lpDS1OperStatusTable, lpDS1TestType=lpDS1TestType, lpSonetPathCellProvEntry=lpSonetPathCellProvEntry, lpDS1ChanTestBytesTx=lpDS1ChanTestBytesTx, lpE3Test=lpE3Test, lpDS1ChanIfIndex=lpDS1ChanIfIndex, lpSonetCidDataEntry=lpSonetCidDataEntry, lpDS1ChanOperTable=lpDS1ChanOperTable, lpSdhAdminInfoEntry=lpSdhAdminInfoEntry, lpMemoryUsageAvgMaxTable=lpMemoryUsageAvgMaxTable, lpDS3DS1ChanCellReceiveCellUtilization=lpDS3DS1ChanCellReceiveCellUtilization, lpSdhPathPathSevErroredSec=lpSdhPathPathSevErroredSec, lpSdhTestType=lpSdhTestType, lpDS3PlcpErroredSec=lpDS3PlcpErroredSec, lpE1ChanTcSigTwoEntry=lpE1ChanTcSigTwoEntry, lpDS3DS1ChanTestPurpose=lpDS3DS1ChanTestPurpose, lpDS3DS1ChanCellRowStatus=lpDS3DS1ChanCellRowStatus, lpE3CidDataEntry=lpE3CidDataEntry, lpHssiUnknownStatus=lpHssiUnknownStatus, lpSonetPathTxAis=lpSonetPathTxAis, lpE1ChanVendor=lpE1ChanVendor, lpDS3LineSevErroredSec=lpDS3LineSevErroredSec, lpE1ChanCellTransmitCellUtilization=lpE1ChanCellTransmitCellUtilization, lpSdhPathPathErrorFreeSec=lpSdhPathPathErrorFreeSec, lpJT2CellAlarmActDelay=lpJT2CellAlarmActDelay, lpDS3CBitFarEndCodeViolations=lpDS3CBitFarEndCodeViolations, lpE1OperEntry=lpE1OperEntry, lpSdhTestFrmRx=lpSdhTestFrmRx, lpE1TestFrmSize=lpE1TestFrmSize, lpDS3DS1ChanTestDisplayInterval=lpDS3DS1ChanTestDisplayInterval, lpE3CellIndex=lpE3CellIndex, lpE3PlcpLofAlarm=lpE3PlcpLofAlarm, lpDS3DS1ChanProvEntry=lpDS3DS1ChanProvEntry, lpDS3TxAis=lpDS3TxAis, lpJT2CellRowStatusEntry=lpJT2CellRowStatusEntry, lpX21Vendor=lpX21Vendor, lpSonetSectSevErroredSec=lpSonetSectSevErroredSec, lpDS3SnmpOperStatus=lpDS3SnmpOperStatus, lpJT2TestResultsEntry=lpJT2TestResultsEntry, lpV35OperStatusEntry=lpV35OperStatusEntry, lpDS1ChanCell=lpDS1ChanCell, lpDS3DS1ChanTcOpEntry=lpDS3DS1ChanTcOpEntry, lpHssiTestBytesTx=lpHssiTestBytesTx, lpV35TestCustomizedPattern=lpV35TestCustomizedPattern, lpX21TestResultsTable=lpX21TestResultsTable, lpSdhProvTable=lpSdhProvTable, lpE3TxRai=lpE3TxRai, lpDS3DS1ChanVendor=lpDS3DS1ChanVendor, lpDS3PathCodeViolations=lpDS3PathCodeViolations, lpE3LineSevErroredSec=lpE3LineSevErroredSec, lpDS1ChanTcRowStatusEntry=lpDS1ChanTcRowStatusEntry, lpActiveCard=lpActiveCard, lpDS3RowStatus=lpDS3RowStatus, lpSonetVendor=lpSonetVendor, lpSonetTestCustomizedPattern=lpSonetTestCustomizedPattern, lpCpuUtilAvg=lpCpuUtilAvg, lpE1TestComponentName=lpE1TestComponentName, lpDS1ChanTestFrmRx=lpDS1ChanTestFrmRx, lpSonetTestDataStartDelay=lpSonetTestDataStartDelay, lpV35OperTable=lpV35OperTable, lpE1ChanTcIndex=lpE1ChanTcIndex, lpSdhPathCellRowStatus=lpSdhPathCellRowStatus, lpSonetProvEntry=lpSonetProvEntry, lpE3LinkAlarmActivationThreshold=lpE3LinkAlarmActivationThreshold, lpX21AvailabilityStatus=lpX21AvailabilityStatus, lpSonetPathSnmpOperStatus=lpSonetPathSnmpOperStatus, lpE3TestFrmTx=lpE3TestFrmTx, lpX21TestAdminState=lpX21TestAdminState, lpSdhPathRowStatusTable=lpSdhPathRowStatusTable, lpDS1ChanCellUncorrectableHecErrors=lpDS1ChanCellUncorrectableHecErrors, lpSonetRowStatus=lpSonetRowStatus, lpSonetTestResultsTable=lpSonetTestResultsTable, lpStateEntry=lpStateEntry, lpSdhAvailabilityStatus=lpSdhAvailabilityStatus, lpE3ErrorFreeSec=lpE3ErrorFreeSec, lpX21TestStateEntry=lpX21TestStateEntry, lpE3TestBitsTx=lpE3TestBitsTx, lpSdhPathCellStatsEntry=lpSdhPathCellStatsEntry, lpDS1ChanTestBytesRx=lpDS1ChanTestBytesRx, lpSdhPathPathFailures=lpSdhPathPathFailures, lpX21OperEntry=lpX21OperEntry, lpProvEntry=lpProvEntry, lpE3G832TrailTraceTransmitted=lpE3G832TrailTraceTransmitted, lpJT2CrcErrors=lpJT2CrcErrors, lpX21LinkMode=lpX21LinkMode, lpE3G832TrailTraceExpected=lpE3G832TrailTraceExpected, lpHssiTestResultsTable=lpHssiTestResultsTable, lpDS3CellProvTable=lpDS3CellProvTable, lpDS1ChanTestFrmTx=lpDS1ChanTestFrmTx, lpDS1ChanCellIndex=lpDS1ChanCellIndex, lpJT2TestFrmSize=lpJT2TestFrmSize, lpDS1ChanAdminInfoEntry=lpDS1ChanAdminInfoEntry, lpHssiIfAdminStatus=lpHssiIfAdminStatus, lpMsgBlockUsageAvg=lpMsgBlockUsageAvg, lpDS1IfIndex=lpDS1IfIndex, lpSdhPathPathCodeViolations=lpSdhPathPathCodeViolations, lpSonetTestCauseOfTermination=lpSonetTestCauseOfTermination, lpDS3DS1ComponentName=lpDS3DS1ComponentName, logicalProcessorCapabilitiesBE=logicalProcessorCapabilitiesBE, lpDS3CBitFarEndUnavailSec=lpDS3CBitFarEndUnavailSec, lpE3PlcpRowStatusTable=lpE3PlcpRowStatusTable, lpE3TestUsageState=lpE3TestUsageState, lpDS3PathSevErroredSec=lpDS3PathSevErroredSec, lpE1TestBitsRx=lpE1TestBitsRx, lpDS3TestFrmSize=lpDS3TestFrmSize, lpDS1TestRowStatusTable=lpDS1TestRowStatusTable, lpE1TestFrmRx=lpE1TestFrmRx, lpJT2TestStateEntry=lpJT2TestStateEntry, lpDS1AudioRowStatusTable=lpDS1AudioRowStatusTable, lpSonetLineUnavailSec=lpSonetLineUnavailSec, lpE1ChanCell=lpE1ChanCell, lpE3PathUnavailSec=lpE3PathUnavailSec, lpDS3DS1TestRowStatusEntry=lpDS3DS1TestRowStatusEntry, lpDS1ChanTestOperationalState=lpDS1ChanTestOperationalState, lpDS3StandbyStatus=lpDS3StandbyStatus, lpHssiProceduralStatus=lpHssiProceduralStatus, lpDS1ChanTcStorageType=lpDS1ChanTcStorageType, lpE1ChanTestBitsRx=lpE1ChanTestBitsRx, lpX21IfEntryEntry=lpX21IfEntryEntry, lpJT2SevErroredSec=lpJT2SevErroredSec, lpDS1ChanTestTimeRemaining=lpDS1ChanTestTimeRemaining, lpDS3DS1TestFrmSize=lpDS3DS1TestFrmSize, lpE1RaiDeclareAlarmTime=lpE1RaiDeclareAlarmTime, lpE1DspRowStatusEntry=lpE1DspRowStatusEntry, lpSonetSectErroredSec=lpSonetSectErroredSec, lpEngDsAgentQueueSize=lpEngDsAgentQueueSize, lpDS1ChanAvailabilityStatus=lpDS1ChanAvailabilityStatus, lpSonetPathCellRowStatusTable=lpSonetPathCellRowStatusTable, lpE3TestComponentName=lpE3TestComponentName, lpE3CellCorrectSingleBitHeaderErrors=lpE3CellCorrectSingleBitHeaderErrors, lpDS1Test=lpDS1Test, lpDS1ChanApplicationFramerName=lpDS1ChanApplicationFramerName, lpE3G832TrailTraceReceived=lpE3G832TrailTraceReceived, lpE1ChanTestFrmTx=lpE1ChanTestFrmTx, lpSdhPathCellCorrectSingleBitHeaderErrors=lpSdhPathCellCorrectSingleBitHeaderErrors, lpSdhTestStateEntry=lpSdhTestStateEntry, lpE1ChanCellStorageType=lpE1ChanCellStorageType, lpDS3DS1TestStateTable=lpDS3DS1TestStateTable, lpJT2TestDuration=lpJT2TestDuration, lpSdhOperationalState=lpSdhOperationalState, lpDS3TestFrmPatternType=lpDS3TestFrmPatternType, lpE3AdminInfoEntry=lpE3AdminInfoEntry, lpDS3CellRowStatus=lpDS3CellRowStatus, lpJT2TestComponentName=lpJT2TestComponentName, lpE1StatsTable=lpE1StatsTable, lpJT2IfEntryEntry=lpJT2IfEntryEntry, lpDS1ChanTcIngressConditioning=lpDS1ChanTcIngressConditioning, lpDS1TestSetupEntry=lpDS1TestSetupEntry, lpV35TestBytesRx=lpV35TestBytesRx, lpSonetUnusableTxClockRefAlarm=lpSonetUnusableTxClockRefAlarm, lpE3PlcpComponentName=lpE3PlcpComponentName, lpDS1TestBitsRx=lpDS1TestBitsRx, lpSonetTestStorageType=lpSonetTestStorageType, lpDS3DS1ChanTcSigOneIndex=lpDS3DS1ChanTcSigOneIndex, lpSdhTestBytesTx=lpSdhTestBytesTx, lpJT2TestTimeRemaining=lpJT2TestTimeRemaining, lpHssiAdminState=lpHssiAdminState, lpE1ChanTc=lpE1ChanTc, lpDS3DS1LineType=lpDS3DS1LineType, lpSdhProvEntry=lpSdhProvEntry, lpDS3TestAdminState=lpDS3TestAdminState, lpSonetPathLopAlarm=lpSonetPathLopAlarm, lpE3LineFailures=lpE3LineFailures, lpE1ChanOperStatusEntry=lpE1ChanOperStatusEntry, lpE3TestDuration=lpE3TestDuration, lpMainCardStatus=lpMainCardStatus, lpDS1ChanStorageType=lpDS1ChanStorageType, lpDS1ClockingSource=lpDS1ClockingSource, lpEngDsOperTable=lpEngDsOperTable, lpSdhPathOperStatusEntry=lpSdhPathOperStatusEntry, lpSdhFarEndLineFailures=lpSdhFarEndLineFailures, lpE3PlcpRxRaiAlarm=lpE3PlcpRxRaiAlarm, lpSdhPathCellRowStatusTable=lpSdhPathCellRowStatusTable, lpJT2TestFrmPatternType=lpJT2TestFrmPatternType, lpE3PlcpFarEndErrorFreeSec=lpE3PlcpFarEndErrorFreeSec, lpE1TestBytesRx=lpE1TestBytesRx, lpSonetPathCellUncorrectableHecErrors=lpSonetPathCellUncorrectableHecErrors, lpJT2RxRaiAlarm=lpJT2RxRaiAlarm, lpSonetPathPathSevErroredSec=lpSonetPathPathSevErroredSec, lpSonetPathFarEndPathUnavailSec=lpSonetPathFarEndPathUnavailSec, lpSonetLineCodeViolations=lpSonetLineCodeViolations, lpHssiAdminInfoEntry=lpHssiAdminInfoEntry, lpSonetTestOperationalState=lpSonetTestOperationalState, lpDS3AdminInfoTable=lpDS3AdminInfoTable, lpE1IfEntryTable=lpE1IfEntryTable, lpDS1StorageType=lpDS1StorageType, lpHssiOperationalState=lpHssiOperationalState, lpSdhRowStatusEntry=lpSdhRowStatusEntry, lpV35AdminInfoEntry=lpV35AdminInfoEntry, lpSonetCidDataTable=lpSonetCidDataTable, lpDS3CellOperEntry=lpDS3CellOperEntry, lpMemoryUsageAvgMinTable=lpMemoryUsageAvgMinTable, lpE3Plcp=lpE3Plcp, lpSdhPathCellAlarmActDelay=lpSdhPathCellAlarmActDelay, lpSonetAdminState=lpSonetAdminState, lpE1TestUsageState=lpE1TestUsageState, lpDS1AudioComponentName=lpDS1AudioComponentName, lpSdhPathCustomerIdentifier=lpSdhPathCustomerIdentifier, lpJT2OperStatusEntry=lpJT2OperStatusEntry, lpX21IfEntryTable=lpX21IfEntryTable, lpDS3DS1TestType=lpDS3DS1TestType, lpE3G832FarEndCodeViolations=lpE3G832FarEndCodeViolations, lpE3OperTable=lpE3OperTable, lpE3CellProvEntry=lpE3CellProvEntry, lpDS1TestOperationalState=lpDS1TestOperationalState, lpDS1ChanSnmpOperStatus=lpDS1ChanSnmpOperStatus, lpDS3DS1ChanTcComponentName=lpDS3DS1ChanTcComponentName, lpDS3TestCauseOfTermination=lpDS3TestCauseOfTermination, lpV35TestStateEntry=lpV35TestStateEntry, lpDS1TestStorageType=lpDS1TestStorageType, lpJT2StorageType=lpJT2StorageType, lpE3TestTimeRemaining=lpE3TestTimeRemaining, lpDS3TestElapsedTime=lpDS3TestElapsedTime, lpE1ChanStateEntry=lpE1ChanStateEntry, lpDS3LofAlarm=lpDS3LofAlarm, lpSdhSectFailures=lpSdhSectFailures, lpE3TestRowStatusTable=lpE3TestRowStatusTable, lpDS3DS1ChanCellCorrectSingleBitHeaderErrors=lpDS3DS1ChanCellCorrectSingleBitHeaderErrors, lpHssiTestDuration=lpHssiTestDuration, lpX21ProceduralStatus=lpX21ProceduralStatus, lpE1ProvTable=lpE1ProvTable, lpE1=lpE1, lpX21TestResultsEntry=lpX21TestResultsEntry, lpSonetPathOperStatusTable=lpSonetPathOperStatusTable, lpE1ChanTcReplacementData=lpE1ChanTcReplacementData, lpX21AdminInfoTable=lpX21AdminInfoTable, lpSdhPathCell=lpSdhPathCell, lpE3TestBitsRx=lpE3TestBitsRx, lpE1BpvErrors=lpE1BpvErrors, lpDS1ChanUsageState=lpDS1ChanUsageState, lpV35TestOperationalState=lpV35TestOperationalState, lpSonetPathUnknownStatus=lpSonetPathUnknownStatus, lpSdhPathOperationalState=lpSdhPathOperationalState, lpJT2CellStatsEntry=lpJT2CellStatsEntry, lpSonetTestSetupEntry=lpSonetTestSetupEntry, lpEngRowStatus=lpEngRowStatus, lpDS3DS1TestResultsTable=lpDS3DS1TestResultsTable, lpJT2CidDataTable=lpJT2CidDataTable, lpSonetRxAisAlarm=lpSonetRxAisAlarm)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpE1DspIndex=lpE1DspIndex, lpE3LineLength=lpE3LineLength, lpSonetRunningTime=lpSonetRunningTime, lpE3G832FarEndSevErroredSec=lpE3G832FarEndSevErroredSec, lpDS3CellUncorrectableHecErrors=lpDS3CellUncorrectableHecErrors, lpMemoryUsageTable=lpMemoryUsageTable, lpE3CellOperTable=lpE3CellOperTable, lpDS1SnmpOperStatus=lpDS1SnmpOperStatus, lpJT2ErroredSec=lpJT2ErroredSec, lpDS1ChanCommentText=lpDS1ChanCommentText, lpE1ChanTcOpTable=lpE1ChanTcOpTable, lpDS1Dsp=lpDS1Dsp, lpHssiActualTxLineSpeed=lpHssiActualTxLineSpeed, lpUtilEntry=lpUtilEntry, lpSdhTestRowStatusEntry=lpSdhTestRowStatusEntry, lpDS3DS1TestBytesTx=lpDS3DS1TestBytesTx, lpV35TestElapsedTime=lpV35TestElapsedTime, lpE1Vendor=lpE1Vendor, lpSdhPathIndex=lpSdhPathIndex, lpDS3RxIdle=lpDS3RxIdle, lpE3PlcpSevErroredSec=lpE3PlcpSevErroredSec, lpE1ChanOperationalState=lpE1ChanOperationalState, lpX21TestElapsedTime=lpX21TestElapsedTime, lpSonetTest=lpSonetTest, lpHssiSnmpOperStatus=lpHssiSnmpOperStatus, lpSdhPathFarEndPathErrorFreeSec=lpSdhPathFarEndPathErrorFreeSec, lpE1ChanCellCorrectableHeaderErrors=lpE1ChanCellCorrectableHeaderErrors, lpX21StateEntry=lpX21StateEntry, lpE1ProceduralStatus=lpE1ProceduralStatus, lpDS1TestErroredFrmRx=lpDS1TestErroredFrmRx, lpV35DataTransferLineState=lpV35DataTransferLineState, lpSonetPathStorageType=lpSonetPathStorageType, lpDS3PlcpFarEndErroredSec=lpDS3PlcpFarEndErroredSec, lpE3PlcpSevErroredFramingSec=lpE3PlcpSevErroredFramingSec, lpSdhPathCellLcdAlarm=lpSdhPathCellLcdAlarm, lpHssiTestSetupTable=lpHssiTestSetupTable, lpV35TestBitsTx=lpV35TestBitsTx, lpDS1ChanTestStateEntry=lpDS1ChanTestStateEntry, lpE3TestIndex=lpE3TestIndex, lpDS1IfEntryEntry=lpDS1IfEntryEntry, lpDS3RxRaiAlarm=lpDS3RxRaiAlarm, lpSonetTestResultsEntry=lpSonetTestResultsEntry, lpHssiTestCauseOfTermination=lpHssiTestCauseOfTermination, lpSonetTestComponentName=lpSonetTestComponentName, lpDS3DS1ChanCellStorageType=lpDS3DS1ChanCellStorageType, lpSonetTestTimeRemaining=lpSonetTestTimeRemaining, lpDS1ChanCellStatsTable=lpDS1ChanCellStatsTable, lpDS3CellStatsEntry=lpDS3CellStatsEntry, lpSonetTestBytesTx=lpSonetTestBytesTx, lpDS3UnknownStatus=lpDS3UnknownStatus, lpDS3DS1ChanTc=lpDS3DS1ChanTc, lpE3SnmpOperStatus=lpE3SnmpOperStatus, lpSonetPathPathUnavailSec=lpSonetPathPathUnavailSec, lpE1ChanControlStatus=lpE1ChanControlStatus, lpSonetOperStatusEntry=lpSonetOperStatusEntry, lpMsgBlockUsageAvgMax=lpMsgBlockUsageAvgMax, lpX21UnknownStatus=lpX21UnknownStatus, lpDS3DS1UsageState=lpDS3DS1UsageState, lpDS3PathErroredSec=lpDS3PathErroredSec, lpE1ChanIfAdminStatus=lpE1ChanIfAdminStatus, lpSdhTestStorageType=lpSdhTestStorageType, lpE1ChanTestFrmSize=lpE1ChanTestFrmSize, lpJT2TestOperationalState=lpJT2TestOperationalState, lpDS1ChanTimeslots=lpDS1ChanTimeslots, lpSonetIfAdminStatus=lpSonetIfAdminStatus, lpSonetPathAlarmStatus=lpSonetPathAlarmStatus, logicalProcessorCapabilitiesBE01=logicalProcessorCapabilitiesBE01, lpDS1ChanTestCauseOfTermination=lpDS1ChanTestCauseOfTermination, lpE1ChanCommentText=lpE1ChanCommentText, lpDS1CommentText=lpDS1CommentText, lpMsgBlockCapacity=lpMsgBlockCapacity, lpDS1ChanCellStorageType=lpDS1ChanCellStorageType, lpSonetFarEndLineFailures=lpSonetFarEndLineFailures, logicalProcessorCapabilitiesBE01A=logicalProcessorCapabilitiesBE01A, lpDS3CellComponentName=lpDS3CellComponentName, lpE1ChanTestCustomizedPattern=lpE1ChanTestCustomizedPattern, lpEngDs=lpEngDs, lpDS1ChanCellComponentName=lpDS1ChanCellComponentName, lpE3G832OperationalEntry=lpE3G832OperationalEntry, lpJT2TestElapsedTime=lpJT2TestElapsedTime, lpJT2UnknownStatus=lpJT2UnknownStatus, lpJT2CellIndex=lpJT2CellIndex, lpSonetTestFrmPatternType=lpSonetTestFrmPatternType, lpE3AdminInfoTable=lpE3AdminInfoTable, lpSonetFarEndLineAisSec=lpSonetFarEndLineAisSec, lpV35AlarmStatus=lpV35AlarmStatus, lpDS3DS1ChanOperTable=lpDS3DS1ChanOperTable, lpE1ChanAvailabilityStatus=lpE1ChanAvailabilityStatus, lpE3StateEntry=lpE3StateEntry, lpDS1ChanCellProvTable=lpDS1ChanCellProvTable, lpDS3CellStatsTable=lpDS3CellStatsTable, lpDS3DS1ChanCellCorrectableHeaderErrors=lpDS3DS1ChanCellCorrectableHeaderErrors, lpX21CommentText=lpX21CommentText, lpSonetPathRxAisAlarm=lpSonetPathRxAisAlarm, lpControlStatus=lpControlStatus, lpE1ChanTest=lpE1ChanTest, lpE1AudioRowStatusTable=lpE1AudioRowStatusTable, lpMemoryUsageAvgEntry=lpMemoryUsageAvgEntry, lpE3RowStatusTable=lpE3RowStatusTable, lpE3CellStatsEntry=lpE3CellStatsEntry, lpHssiOperEntry=lpHssiOperEntry, lpDS1TestRowStatusEntry=lpDS1TestRowStatusEntry, lpEngDsOvAgentQueueSize=lpEngDsOvAgentQueueSize, lpAdminState=lpAdminState, lpE1ChanCellProvEntry=lpE1ChanCellProvEntry, lpSonetTestAdminState=lpSonetTestAdminState, lpX21OperStatusTable=lpX21OperStatusTable, lpJT2TestIndex=lpJT2TestIndex, lpSdhErrorFreeSec=lpSdhErrorFreeSec, lpHssiActualLinkMode=lpHssiActualLinkMode, lpE1ChanTestDuration=lpE1ChanTestDuration, lpV35LineState=lpV35LineState, lpV35TestDuration=lpV35TestDuration, lpSonetTestUsageState=lpSonetTestUsageState, lpDS1OperationalState=lpDS1OperationalState, lpSonetTestBitsTx=lpSonetTestBitsTx, lpDS3DS1ChanTestSetupEntry=lpDS3DS1ChanTestSetupEntry, lpJT2IfIndex=lpJT2IfIndex, lpE3CustomerIdentifier=lpE3CustomerIdentifier, lpJT2SevErroredFrmSec=lpJT2SevErroredFrmSec, lpSdhPathCellReceiveCellUtilization=lpSdhPathCellReceiveCellUtilization, lpDS3DS1ChanTestBitsRx=lpDS3DS1ChanTestBitsRx, lpSonetLineErroredSec=lpSonetLineErroredSec, lpDS3DS1ChanOperationalState=lpDS3DS1ChanOperationalState, lpDS3CBitLoopbackAtFarEndRequested=lpDS3CBitLoopbackAtFarEndRequested, lpDS1ChanTestStateTable=lpDS1ChanTestStateTable, lpDS1ChanTestDataStartDelay=lpDS1ChanTestDataStartDelay, lpDS1ChanTestResultsTable=lpDS1ChanTestResultsTable, lpE1ChanTestOperationalState=lpE1ChanTestOperationalState, lpSdhPathProvTable=lpSdhPathProvTable, lpDS1ChanCellCorrectSingleBitHeaderErrors=lpDS1ChanCellCorrectSingleBitHeaderErrors, lpSonetPathStateTable=lpSonetPathStateTable, lpDS3DS1ChanTestFrmPatternType=lpDS3DS1ChanTestFrmPatternType, lpV35AvailabilityStatus=lpV35AvailabilityStatus, lpE1TestStateTable=lpE1TestStateTable, lpSdhPathFarEndPathUnavailSec=lpSdhPathFarEndPathUnavailSec, lpSdhPathCellTransmitCellUtilization=lpSdhPathCellTransmitCellUtilization, lpE3ProvTable=lpE3ProvTable, lpX21ControlStatus=lpX21ControlStatus, lpSdhPathAvailabilityStatus=lpSdhPathAvailabilityStatus, lpSonetPathFarEndPathErroredSec=lpSonetPathFarEndPathErroredSec, lpHssiControlStatus=lpHssiControlStatus, lpEngDsOvComponentName=lpEngDsOvComponentName, lpDS1TestFrmRx=lpDS1TestFrmRx, lpDS1OperEntry=lpDS1OperEntry, lpHssiTest=lpHssiTest, lpSdhPathIfEntryEntry=lpSdhPathIfEntryEntry, lpDS3RxAisAlarm=lpDS3RxAisAlarm, lpDS3DS1ChanTestResultsEntry=lpDS3DS1ChanTestResultsEntry, lpE1DspRowStatusTable=lpE1DspRowStatusTable, lpSonetPathPathFailures=lpSonetPathPathFailures, lpE1CidDataTable=lpE1CidDataTable, lpDS3DS1ChanCellComponentName=lpDS3DS1ChanCellComponentName, lpDS1ChanProvTable=lpDS1ChanProvTable, lpV35TestTimeRemaining=lpV35TestTimeRemaining, lpX21RowStatus=lpX21RowStatus, lpJT2StatsEntry=lpJT2StatsEntry, lpE1ChanTestSetupTable=lpE1ChanTestSetupTable, lpJT2SnmpOperStatus=lpJT2SnmpOperStatus, lpDS3DS1ChanOperStatusTable=lpDS3DS1ChanOperStatusTable, lpJT2CellUncorrectableHecErrors=lpJT2CellUncorrectableHecErrors, lpE1AvailabilityStatus=lpE1AvailabilityStatus, lpMemoryCapacityEntry=lpMemoryCapacityEntry, lpDS1TestBytesRx=lpDS1TestBytesRx, lpSonetTestSetupTable=lpSonetTestSetupTable, lpJT2AlarmStatus=lpJT2AlarmStatus, lpE3Mapping=lpE3Mapping, lpE3TestRowStatusEntry=lpE3TestRowStatusEntry, lpDS3DS1ChanControlStatus=lpDS3DS1ChanControlStatus, lpV35CidDataTable=lpV35CidDataTable, lpE1SevErroredFrmSec=lpE1SevErroredFrmSec, lpE1AdminInfoTable=lpE1AdminInfoTable, lpDS3DS1ChanCellProvEntry=lpDS3DS1ChanCellProvEntry, lpDS1ChanIfEntryEntry=lpDS1ChanIfEntryEntry, lpDS3=lpDS3, lpDS1TxRaiAlarm=lpDS1TxRaiAlarm, lpE3PlcpOperationalTable=lpE3PlcpOperationalTable, lpE1AdminState=lpE1AdminState, lpSdhPathProvEntry=lpSdhPathProvEntry, lpDS3DS1TestUsageState=lpDS3DS1TestUsageState, lpE1ChanTcSigOneEntry=lpE1ChanTcSigOneEntry, lpRowStatusEntry=lpRowStatusEntry, lpScheduledSwitchover=lpScheduledSwitchover, lpDS3RowStatusTable=lpDS3RowStatusTable, lpDS3CBitIndex=lpDS3CBitIndex, lpV35Index=lpV35Index, lpJT2StateTable=lpJT2StateTable, lpLocalMsgBlockUsage=lpLocalMsgBlockUsage, lpSonetPathCellStorageType=lpSonetPathCellStorageType, lpDS3ErrorFreeSec=lpDS3ErrorFreeSec, lpV35ApplicationFramerName=lpV35ApplicationFramerName, lpEngDsIndex=lpEngDsIndex, lpOperationalState=lpOperationalState, lpDS3DS1RowStatus=lpDS3DS1RowStatus, lpE1SnmpOperStatus=lpE1SnmpOperStatus, lpX21TestStateTable=lpX21TestStateTable, lpX21TestBitsTx=lpX21TestBitsTx, lpDS1Vendor=lpDS1Vendor, lpDS3TestBytesRx=lpDS3TestBytesRx, lpX21TestCustomizedPattern=lpX21TestCustomizedPattern, lpDS1ChanCidDataEntry=lpDS1ChanCidDataEntry, lpSdhTestUsageState=lpSdhTestUsageState, lpDS3DS1ChanTcStorageType=lpDS3DS1ChanTcStorageType, lpJT2CidDataEntry=lpJT2CidDataEntry, lpOperTable=lpOperTable, lpV35TestBitErrorRate=lpV35TestBitErrorRate, lpE1ChanCellLcdAlarm=lpE1ChanCellLcdAlarm, lpE1TestResultsTable=lpE1TestResultsTable, lpDS3DS1ChanIfEntryTable=lpDS3DS1ChanIfEntryTable, lpDS3DS1ChanAdminInfoEntry=lpDS3DS1ChanAdminInfoEntry, lpSdhComponentName=lpSdhComponentName, lpJT2TestSetupTable=lpJT2TestSetupTable, lpMemoryUsageAvgMinValue=lpMemoryUsageAvgMinValue, lpDS3ComponentName=lpDS3ComponentName, lpDS3DS1ChanTestFrmTx=lpDS3DS1ChanTestFrmTx, lpDS3CommentText=lpDS3CommentText, lpE3G832ComponentName=lpE3G832ComponentName, lpDS3DS1SevErroredFrmSec=lpDS3DS1SevErroredFrmSec, lpDS3DS1ChanTestFrmSize=lpDS3DS1ChanTestFrmSize, lpE1LosAlarm=lpE1LosAlarm, lpJT2TestBytesTx=lpJT2TestBytesTx, lpDS3DS1TestOperationalState=lpDS3DS1TestOperationalState, lpDS3DS1ChanTestOperationalState=lpDS3DS1ChanTestOperationalState, lpSonetTestDuration=lpSonetTestDuration, lpE1ChanSnmpOperStatus=lpE1ChanSnmpOperStatus, lpDS3DS1ChanCell=lpDS3DS1ChanCell, lpJT2ErrorFreeSec=lpJT2ErrorFreeSec, lpE1ErroredSec=lpE1ErroredSec, lpDS1ChanTestRowStatusEntry=lpDS1ChanTestRowStatusEntry, lpDS3DS1ChanCellTransmitCellUtilization=lpDS3DS1ChanCellTransmitCellUtilization, lpSdhPathCellUncorrectableHecErrors=lpSdhPathCellUncorrectableHecErrors, lpE3IfIndex=lpE3IfIndex, lpDS1ChanRowStatusTable=lpDS1ChanRowStatusTable, lpX21AdminState=lpX21AdminState, lpSonetPathProceduralStatus=lpSonetPathProceduralStatus, lpSonetOperationalState=lpSonetOperationalState, lpV35ActualRxLineSpeed=lpV35ActualRxLineSpeed, logicalProcessorGroupBE=logicalProcessorGroupBE, lpSonetPathControlStatus=lpSonetPathControlStatus, lpX21TestCauseOfTermination=lpX21TestCauseOfTermination, lpE1OperStatusEntry=lpE1OperStatusEntry, lpSdhPathUnknownStatus=lpSdhPathUnknownStatus, lpSdhControlStatus=lpSdhControlStatus, lpJT2TestBitsRx=lpJT2TestBitsRx, lpV35StateTable=lpV35StateTable, lpDS3PlcpFarEndSevErroredSec=lpDS3PlcpFarEndSevErroredSec, lpDS3DS1TestBitsTx=lpDS3DS1TestBitsTx, lpSonetPathCellOperEntry=lpSonetPathCellOperEntry, lpDS3DS1SlipErrors=lpDS3DS1SlipErrors, lpE1OperationalState=lpE1OperationalState, lpSonetTestBytesRx=lpSonetTestBytesRx, lpE1ControlStatus=lpE1ControlStatus, lpDS3DS1ChanTcSigOneTable=lpDS3DS1ChanTcSigOneTable, lpSonetPathFarEndPathCodeViolations=lpSonetPathFarEndPathCodeViolations)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-LogicalProcessorMIB", lpDS3DS1RxAisAlarm=lpDS3DS1RxAisAlarm, lpDS3DS1ChanCellSevErroredSec=lpDS3DS1ChanCellSevErroredSec, lpV35DataXferStateChanges=lpV35DataXferStateChanges, lpSdhTestDuration=lpSdhTestDuration, lpSonetPathFarEndPathAisLopSec=lpSonetPathFarEndPathAisLopSec, lpE1ChanTcProvTable=lpE1ChanTcProvTable, lpDS1ChanTcOpTable=lpDS1ChanTcOpTable, lpE1RowStatusTable=lpE1RowStatusTable, lpE1ProvEntry=lpE1ProvEntry, lpSonetPathCidDataEntry=lpSonetPathCidDataEntry, lpSonetPathCellReceiveCellUtilization=lpSonetPathCellReceiveCellUtilization, lpSdhTestOperationalState=lpSdhTestOperationalState, lpDS1UsageState=lpDS1UsageState, lpHssiTestFrmSize=lpHssiTestFrmSize, lpV35LineSpeed=lpV35LineSpeed, lpE1ChanIfEntryTable=lpE1ChanIfEntryTable, lpX21ComponentName=lpX21ComponentName, lpE1TestIndex=lpE1TestIndex, lpSonetSectSevErroredFrmSec=lpSonetSectSevErroredFrmSec, lpDS3DS1ChanCellScrambleCellPayload=lpDS3DS1ChanCellScrambleCellPayload, lpJT2IfEntryTable=lpJT2IfEntryTable, lpE1ChanCidDataEntry=lpE1ChanCidDataEntry, lpSdhStorageType=lpSdhStorageType, lpSonetPathProvEntry=lpSonetPathProvEntry, lpE1ChanProvTable=lpE1ChanProvTable, lpV35ReadyLineState=lpV35ReadyLineState, lpE3CellOperEntry=lpE3CellOperEntry, lpLogicalProcessorType=lpLogicalProcessorType, lpLocalMsgBlockUsageMin=lpLocalMsgBlockUsageMin, lpSonetFarEndLineUnavailSec=lpSonetFarEndLineUnavailSec, lpE1TestFrmPatternType=lpE1TestFrmPatternType, lpSonetTestBitErrorRate=lpSonetTestBitErrorRate, lpDS3DS1ChanTcProvEntry=lpDS3DS1ChanTcProvEntry, lpX21TestFrmSize=lpX21TestFrmSize, lpDS1ChanCellAlarmActDelay=lpDS1ChanCellAlarmActDelay, lpSonetSectFailures=lpSonetSectFailures, lpDS3CBitStatsEntry=lpDS3CBitStatsEntry, lpDS1LineLength=lpDS1LineLength, lpX21StateTable=lpX21StateTable, lpHssiApplicationFramerName=lpHssiApplicationFramerName, lpV35TestUsageState=lpV35TestUsageState, lpHssiTestDataStartDelay=lpHssiTestDataStartDelay, lpDS1ChanTc=lpDS1ChanTc, lpX21ApplicationFramerName=lpX21ApplicationFramerName, lpSdhTestBitsTx=lpSdhTestBitsTx, lpX21TestFrmRx=lpX21TestFrmRx, lpHssiAlarmStatus=lpHssiAlarmStatus, lpV35UsageState=lpV35UsageState, lpSdhSectSevErroredFrmSec=lpSdhSectSevErroredFrmSec, lpE3G832=lpE3G832, lpDS3CellCorrectSingleBitHeaderErrors=lpDS3CellCorrectSingleBitHeaderErrors, lpDS1TestDisplayInterval=lpDS1TestDisplayInterval, lpDS3DS1ChanApplicationFramerName=lpDS3DS1ChanApplicationFramerName, logicalProcessorGroup=logicalProcessorGroup, lpDS1LofAlarm=lpDS1LofAlarm, lpE3Index=lpE3Index, lpDS3DS1FrmErrors=lpDS3DS1FrmErrors, lpV35ProvTable=lpV35ProvTable, lpE1Test=lpE1Test, lpSonetPathCellSevErroredSec=lpSonetPathCellSevErroredSec, lpStandbyStatus=lpStandbyStatus, lpEngDsRowStatusTable=lpEngDsRowStatusTable, lpSdh=lpSdh, lpSdhPathCellOperEntry=lpSdhPathCellOperEntry, lpE1ChanTestDisplayInterval=lpE1ChanTestDisplayInterval, lpDS1ErroredSec=lpDS1ErroredSec, lpE3OperStatusEntry=lpE3OperStatusEntry, lpE1ChanTcRowStatusEntry=lpE1ChanTcRowStatusEntry, lpE1TestResultsEntry=lpE1TestResultsEntry, lpDS3DS1ChanTestComponentName=lpDS3DS1ChanTestComponentName, lpE3TestStateEntry=lpE3TestStateEntry, lpE1Crc4Mode=lpE1Crc4Mode, lpDS1ProceduralStatus=lpDS1ProceduralStatus)

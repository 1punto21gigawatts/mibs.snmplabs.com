#
# PySNMP MIB module NRC-MultiGate (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NRC-MultiGate
# Produced by pysmi-0.3.4 at Wed May  1 14:24:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
experimental, Gauge32, TimeTicks, iso, ModuleIdentity, IpAddress, ObjectIdentity, Counter64, MibIdentifier, Bits, NotificationType, Integer32, Unsigned32, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, mgmt = mibBuilder.importSymbols("SNMPv2-SMI", "experimental", "Gauge32", "TimeTicks", "iso", "ModuleIdentity", "IpAddress", "ObjectIdentity", "Counter64", "MibIdentifier", "Bits", "NotificationType", "Integer32", "Unsigned32", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mgmt")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
nrc = MibIdentifier((1, 3, 6, 1, 4, 1, 315))
hub1 = MibIdentifier((1, 3, 6, 1, 4, 1, 315, 1))
snmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 3, 29))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 2, 1, 17))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class BridgeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class Timeout(Integer32):
    pass

hub1AutoPartition = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1AutoPartition.setStatus('mandatory')
if mibBuilder.loadTexts: hub1AutoPartition.setDescription("The value 'enabled' indicates that the HUB should auto partition ports. The value 'disabled' will disable this feature.")
hub1ReconnectOnTransmission = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1ReconnectOnTransmission.setStatus('mandatory')
if mibBuilder.loadTexts: hub1ReconnectOnTransmission.setDescription("The value 'enabled' indicates that the HUB will reconnect an auto partitioned port if the HUB receives a packet from a partitioned port. The value 'disabled' indicates that the HUB will reconnect a partitioned port if there is any traffic to or from the port.")
hub1IncludeOutOfWinColl = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1IncludeOutOfWinColl.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IncludeOutOfWinColl.setDescription("A value of 'enabled' will cause Out Of Window Collisions to be counted along with In Window Collisions (as defined by IEEE 802.3) when determining if the collision count has exceeded hub1CollisionLimit and a port should be auto partitioned. A value of 'disabled' indicates that Out Of Window Collisions should NOT be counted when determining if the collision count has exceeded hub1CollisionLimit and a and a port should be auto partitioned.")
hub1LoopbackPartition = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1LoopbackPartition.setStatus('mandatory')
if mibBuilder.loadTexts: hub1LoopbackPartition.setDescription("A value of 'enabled' will cause the HUB to automatically partition a port where a lack of loopback from the transeiver is detected. A value of 'disabled' will disable this feature. Note: Setting this variable will only effect HUB operation when hub1PortType value equals 'thinNet-10Base2'. For all other hub1PortType values, a value of 'enabled' will have no effect.")
hub1CollisionLimit = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(31, 63))).clone(namedValues=NamedValues(("low", 31), ("high", 63)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1CollisionLimit.setStatus('mandatory')
if mibBuilder.loadTexts: hub1CollisionLimit.setDescription('If consecutive collisions exceeding the value of this variable are detected on a port, the port will be auto partitioned 31 is the IEEE 802.3 consecutive collision limit.')
hub1CarrierRecoverTime = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5))).clone(namedValues=NamedValues(("short", 3), ("long", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1CarrierRecoverTime.setStatus('mandatory')
if mibBuilder.loadTexts: hub1CarrierRecoverTime.setDescription("Time to recover carrier. A value of 'short' will use 3 bit times (IEEE 802.3 specification). A value of 'long' will use 5 bit times.")
hub1EventCounterFlags = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1EventCounterFlags.setStatus('mandatory')
if mibBuilder.loadTexts: hub1EventCounterFlags.setDescription("A bit mask indicating which error types will cause an increment in the hub1PortEventCount Counter. Each bit has the following significance where each bit is listed from most significant bit of the first octet, to least significant bit of the second octet. High (first) Octet bit 8 - not used - 7 - not used - 6 Out Of Window Collision Count Enable 5 Receive Collision Count Enable 4 Transmit Collision Count Enable 3 - not used - 2 - not used - 1 - not used - Low (second) Octet bit 8 Bad Link Count Enable 7 Partition Count Enable 6 Receive Count Enable 5 Pygmy Packet Enable 4 Non SFD Enable 3 Phase Lock Error Enable 2 Elasticity Buffer Error Enable 1 Jabber Enable When setting the value of this variable, the entire bit mask must be specified and the '-not used-' bits must not be set.")
hub1EventRecordFlags = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1EventRecordFlags.setStatus('mandatory')
if mibBuilder.loadTexts: hub1EventRecordFlags.setDescription("A bit mask indicating which error types will cause corresponding bits in hub1PortEventRecordValue to be set when an error is detected. Each bit has the following significance where bits are listed from most significant bit to least significant bit. bit 8 Bad Link Enable 7 Partition Enable 6 Out Of Window Collision Enable 5 Pygmy Packet Enable 4 Non SFD Enable 3 Phase Lock Error Enable 2 Elasticity Buffer Error Enable 1 Jabber Enable When a particular bit is set, all ports will start to log the specified error in the hub1PortEventRecordValue column of the port's row of the hub1PortTable. For example, if bit 1 (Jabber Enable) is set, then for every port, a detected Jabber Error would cause bit 1 of hub1PortEventRecordValue to be set. When setting the value of this variable, the entire bit mask must be specified. When this mask is set, hub1PortRecordValue for all ports is cleared.")
hub1BridgingMode = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bridging", 1), ("bypass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1BridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: hub1BridgingMode.setDescription("Operational mode of the bridge: bridging Packets are being selectively forwarded according to the internal dynamically built tables. bypass All packets are being repeated between the backbone and the repeater ports. The bridge logic is disabled. After setting this variable the HUB must be reset for the new value to take effect. NOTE: FOIRL Hubs can only have the value 'bypass' for this variable. Attempts to set this variable to 'bridging' on FOIRL hubs will be rejected.")
hub1ProtocolFilterMode = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("filter", 2), ("pass", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1ProtocolFilterMode.setStatus('mandatory')
if mibBuilder.loadTexts: hub1ProtocolFilterMode.setDescription('Filtering Mode of the Hub: off The protocol filtering logic is disabled. filter The protocol filtering logic is enabled and packets with the protocol types indicated in hubFilterProtocols will not be forwarded by the bridge. pass The packet filtering logic is enabled and packets with the protocol types indicated in hubFilterProtocols will be the ONLY packets that the bridge will forward.')
hub1FilterProtocols = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1FilterProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: hub1FilterProtocols.setDescription('Protocol types to be filtered or passed by the bridging logic. This is a variable length array of between 0 and 16 2-byte entries, each entry containing the 2-byte protocol identifier as seen in the Ethernet header. Attempts to configure this variable with an OCTET STRING of odd length will be rejected.')
hub1ConsoleBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1ConsoleBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: hub1ConsoleBaudRate.setDescription('The baud rate of the console port. Legal values are 9600, 4800, 2400, and 1200.')
hub1Reset = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1Reset.setStatus('mandatory')
if mibBuilder.loadTexts: hub1Reset.setDescription("Setting this object to 'reset' will cause the Hub1 to perform a hardware reset within approximately 5 seconds. Setting this object to 'no-reset will have no effect. The value 'no-reset will be returned whenever this object is retrieved. The primary purpose for including this variable in the Hub1 MIB is to allow SNMP managers to modify the operational mode of the Hub1. Changing the variable hub1BridgingMode has no effect on the Hub until the Hub is reset.")
hub1SoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1SoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hub1SoftwareVersion.setDescription("The version of software running on the Hub. On versions of the Hub that support dynamic download, this variable may be set to cause a new version of the software to be loaded the next time the Hub is reset (as in setting the variable hub1Reset or power cycling the unit). The version should be specified in the following format: 'MM.mm.rr' Where MM is the major number, mm is the minor number, and rr is the revision level (for example 2.0.16). On versions of the Hub that do not support dynamic download, setting this variable will result in an error.")
hub1PortTable = MibTable((1, 3, 6, 1, 4, 1, 315, 1, 15), )
if mibBuilder.loadTexts: hub1PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortTable.setDescription('A table of port specific information for the NRC HUB 1 product. This table supplements the Repeater MIB Ports Table.')
hub1PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 315, 1, 15, 1), ).setIndexNames((0, "NRC-MultiGate", "hub1PortIndex"))
if mibBuilder.loadTexts: hub1PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortEntry.setDescription('A list of information for every port.')
hub1PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortIndex.setDescription('Port number that corresponds to the index value in the Repeater MIB variable rptrPortIndex.')
hub1PortForceReconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("force-reconnect", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1PortForceReconnect.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortForceReconnect.setDescription("Setting this variable to the value 'force- reconnect' will cause the port to be reconnected assuming that it is currently in the 'Partition' state. If the port is not in a 'Partition' state, setting variable to the value 'force-reconnect' will not have any effect. Setting this variable to anything other than 'force- reconnect will and an undefined effect. When retrieving this variable, the value 'idle' will always be returned.")
hub1PortPartitionReason = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-partitioned", 1), ("other", 2), ("consecutive-collision-limit", 3), ("excessive-len-of-collision-limit", 4), ("data-loopback-failure", 5), ("process-forced-reconnection", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortPartitionReason.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortPartitionReason.setDescription("Reason for port being in the partitioned state. If the port is currently not partitioned, this variable will have the value 'not-partitioned'.")
hub1PortLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortLinkState.setDescription("This variable's meaning varies depending on the type of HUB: 10Base2 Not Applicable. A value of 'unknown' will always be returned. 10BaseT Link Test is being received ('up') or not being received ('down'). Fiber Light Monitoring (LMON) is being detected ('up') or not being detected ('down').")
hub1PortLinkEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1PortLinkEnable.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortLinkEnable.setDescription('Enabling this variable has the following effect depending on the type of HUB: 10Base2 No Effect 10BaseT Link Test Enabled Fiber LMON Test Enabled')
hub1PortPolarityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("reversed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortPolarityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortPolarityStatus.setDescription("Current port Polarity status. NOTE: a value of 'ok' will always be returned for 10Base2 and FOIRL HUBs")
hub1PortName = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hub1PortName.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortName.setDescription('Administrator assigned ASCII port name.')
hub1PortEventCount = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortEventCount.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortEventCount.setDescription('Counter of all error events that were detected on this port and at the same time were marked for collection in the hub1EventCounterFlags variable. This is a 16 bit wrapping counter.')
hub1PortRecordValue = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortRecordValue.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortRecordValue.setDescription('Bit Mask that has bits set for each error event that was detected on this port and at the same time was marked for collection in the hub1EventRecordFlags variable. Each bit has the following meaning, where the bits are listed from most significant to least significant: bit 8 Bad Link Count Error 7 Partition Count Error 6 Receive Count Error 5 Pygmy Packet Error 4 Non SFD Error 3 Phase Lock Error 2 Elasticity Buffer Error 1 Jabber Error Each read of this variable causes the variable to be cleared.')
hub1PortType = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("twistedPair-10BaseT", 2), ("thinNet-10Base2", 3), ("fiber-FOIRL", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1PortType.setStatus('mandatory')
if mibBuilder.loadTexts: hub1PortType.setDescription('The type of port')
hub1IFTable = MibTable((1, 3, 6, 1, 4, 1, 315, 1, 16), )
if mibBuilder.loadTexts: hub1IFTable.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFTable.setDescription('A table that contains HUB 1 specific supplements to the MIB-II interfaces table.')
hub1IFEntry = MibTableRow((1, 3, 6, 1, 4, 1, 315, 1, 16, 1), ).setIndexNames((0, "NRC-MultiGate", "hub1IFIndex"))
if mibBuilder.loadTexts: hub1IFEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFEntry.setDescription('Entries in the HUB 1 supplement table.')
hub1IFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFIndex.setDescription('Interface index that corresponds to ifIndex in the interfaces table from MIB II.')
hub1IFInAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInAlignmentErrors.setDescription('The number of alignment errors detected by this interface.')
hub1IFInCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInCrcErrors.setDescription('The number of CRC errors detected by this interface.')
hub1IFInCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInCollisions.setDescription('The number of collisions detected by this interface.')
hub1IFInMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInMtuExceededDiscards.setDescription('The number of frames discarded by this interface on receive due to an excessive size.')
hub1IFInShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInShortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInShortErrors.setDescription('The number of frames discarded by this interface because they were less than the Ethernet minumum frame size of 64 bytes.')
hub1IFInOverrunDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFInOverrunDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFInOverrunDiscards.setDescription('The number of frames discarded by this interface due to a LAN Controller FIFO overflow on receive.')
hub1IFOutUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFOutUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFOutUnderruns.setDescription('The number of frames which had to be retransmitted by this interface due to a LAN Controller FIFO underrun error on transmit.')
hub1IFOutLostCts = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFOutLostCts.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFOutLostCts.setDescription('The number of times Carrier Transmit Sense (CTS) was lost on this interface during frame transmission. The hub will attempt to retransmit frames when transmission fails due to lost CTS.')
hub1IFOutLostCrs = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFOutLostCrs.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFOutLostCrs.setDescription('The number of times Carrier Receive Sense (CRS) was lost on this interface during frame transmission. The hub will attempt to retransmit frames when transmission fails due to lost CRS.')
hub1IFOutMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFOutMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFOutMtuExceededDiscards.setDescription('The number of frames discarded by this interface on transmit due to an excessive size.')
hub1IFOutCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFOutCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFOutCollisions.setDescription('The number of collisions detected by this interface while attempting to transmit a packet.')
hub1IFChannelUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 315, 1, 16, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(90, 90)).setFixedLength(90)).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1IFChannelUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: hub1IFChannelUtilization.setDescription('Utilization statistics for the last 60 seconds of operation of the bridging logic associated with this interface. The OCTET STRING is a series of 45 16-bit words, each word representing the percentage utilization for a 1.33 second sample period. The first 16 bit word in this series represents the oldest sample. Percentages are calculated by passing each 16 bit sample through the following equation: ((Sample) * 100) / 0xffff to yield the percent channel utilization (a number ranging from 0 to 100).')
hub1LastFailureReason = MibScalar((1, 3, 6, 1, 4, 1, 315, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hub1LastFailureReason.setStatus('mandatory')
if mibBuilder.loadTexts: hub1LastFailureReason.setDescription('The last error that caused a Hub failure. A value of zero (0) indicates that there has not been a Hub failure since the novram was last erased. A non-zero value indicates the reason for the last Hub failure. A normal Hub reset or power cycle will not change the value of this variable (it will still indicate the reason for the last known failure.')
rptrBasicPackage = MibIdentifier((1, 3, 6, 1, 3, 29, 1))
rptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 3, 29, 2))
rptrAddrTrackPackage = MibIdentifier((1, 3, 6, 1, 3, 29, 3))
rptrRptrInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 1, 1))
rptrGroupInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 1, 2))
rptrPortInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 1, 3))
rptrMonitorRptrInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 2, 1))
rptrMonitorGroupInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 2, 2))
rptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 2, 3))
rptrAddrTrackRptrInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 3, 1))
rptrAddrTrackGroupInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 3, 2))
rptrAddrTrackPortInfo = MibIdentifier((1, 3, 6, 1, 3, 29, 3, 3))
rptrGroupCapacity = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupCapacity.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2, aRepeaterGroupCapacity.')
if mibBuilder.loadTexts: rptrGroupCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupCapacity.setDescription('The rptrGroupCapacity is the number of groups that can be contained within the repeater. Within each managed repeater, the groups are uniquely numbered in the range from 1 to rptrGroupCapacity. Some groups may not be present in the repeater, in which case the actual number of groups present will be less than rptrGroupCapacity. The number of groups present will never be greater than rptrGroupCapacity. Note: In practice, this will generally be the number of field-replaceable units (i.e., modules, cards, or boards) that can fit in the physical repeater enclosure, and the group numbers will correspond to numbers marked on the physical enclosure.')
rptrOperStatus = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("rptrFailure", 3), ("groupFailure", 4), ("portFailure", 5), ("generalFailure", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrOperStatus.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2, aRepeaterHealthState.')
if mibBuilder.loadTexts: rptrOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrOperStatus.setDescription("The rptrOperStatus object indicates the operational state of the repeater. The rptrHealthText object may be consulted for more specific information about the state of the repeater's health. In the case of multiple kinds of failures (e.g., repeater failure and port failure), the value of this attribute shall reflect the highest priority failure in the following order: rptrFailure(3) groupFailure(4) portFailure(5) generalFailure(6).")
rptrHealthText = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrHealthText.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.2, aRepeaterHealthText.')
if mibBuilder.loadTexts: rptrHealthText.setStatus('mandatory')
if mibBuilder.loadTexts: rptrHealthText.setDescription('The health text object is a text string that provides information relevant to the operational state of the repeater. Agents may use this string to provide detailed information on current failures, including how they were detected, and/or instructions for problem resolution. The contents are agent-specific.')
rptrReset = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrReset.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.3, acResetRepeater.')
if mibBuilder.loadTexts: rptrReset.setStatus('mandatory')
if mibBuilder.loadTexts: rptrReset.setDescription('Setting this object to reset(2) causes a transition to the START state of Fig 9-2 in section 9 [IEEE 802.3 Std]. Setting this object to noReset(1) has no effect. The agent will always return the value noReset(1) when this object is read. This action does not reset the management counters defined in this document nor does it affect the portAdminStatus parameters. Included in this action is the execution of a disruptive Self-Test with the following characteristics: a) The nature of the tests is not specified. b) The test resets the repeater but without affecting management information about the repeater. c) The test does not inject packets onto any segment. d) Packets received during the test may or may not be transferred. e) The test does not interfere with management functions. As a result of this action a rptrResetEvent trap should be sent.')
rptrNonDisruptTest = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noSelfTest", 1), ("selfTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrNonDisruptTest.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.3.3, acExecuteNonDisruptiveSelfTest.')
if mibBuilder.loadTexts: rptrNonDisruptTest.setStatus('mandatory')
if mibBuilder.loadTexts: rptrNonDisruptTest.setDescription('Setting this object to selfTest(2) causes the repeater to perform a agent-specific, non- disruptive self-test that has the following characteristics: a) The nature of the tests is not specified. b) The test does not change the state of the repeater or management information about the repeater. c) The test does not inject packets onto any segment. d) The test does not prevent the relay of any packets. e) The test does not interfere with management functions. After performing this test the agent will update the repeater health information and send a rptrHealth trap. Setting this object to noSelfTest(1) has no effect. The agent will always return the value noSelfTest(1) when this object is read.')
rptrTotalPartitionedPorts = MibScalar((1, 3, 6, 1, 3, 29, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: rptrTotalPartitionedPorts.setDescription('This object returns the total number of ports in the repeater whose current state meets all three of the following criteria: rptrPortOperStatus does not have the value notPresent(3), rptrPortAdminStatus is enabled(1), and rptrPortAutoPartitionState is autoPartitioned(2).')
rptrGroupTable = MibTable((1, 3, 6, 1, 3, 29, 1, 2, 1), )
if mibBuilder.loadTexts: rptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupTable.setDescription('Table of descriptive and status information about the groups of ports.')
rptrGroupEntry = MibTableRow((1, 3, 6, 1, 3, 29, 1, 2, 1, 1), ).setIndexNames((0, "NRC-MultiGate", "rptrGroupIndex"))
if mibBuilder.loadTexts: rptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupEntry.setDescription('An entry in the table, containing information about a single group of ports.')
rptrGroupIndex = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.5.2, aGroupID.')
if mibBuilder.loadTexts: rptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupIndex.setDescription('This object identifies the group within the repeater for which this entry contains information. This value is never greater than rptrGroupCapacity.')
rptrGroupDescr = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupDescr.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupDescr.setDescription("A textual description of the group. This value should include the full name and version identification of the group's hardware type and indicate how the group is differentiated from other groups in the repeater. Plug-in Module, Rev A' or 'Barney Rubble 10BASE-T 4-port SIMM socket Version 2.1' are examples of valid group descriptions. It is mandatory that this only contain printable ASCII characters.")
rptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value is allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this object could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port FOIRL Plug-in Module.'")
rptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater. It is an implementation-specific matter as to whether the agent effectively removes notPresent entries from the table. A status of operational(2) indicates that the group is functioning, and a status of malfunctioning(3) indicates that the group is malfunctioning in some way.')
rptrGroupLastOperStatusChange = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupLastOperStatusChange.setDescription("An object that contains the value of sysUpTime at the time that the value of the rptrGroupOperStatus object for this group last changed. A value of zero indicates that the group's oper status has not changed since the agent last restarted.")
rptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrGroupPortCapacity.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.5.2, aGroupPortCapacity.')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: rptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-1024. Within each group, the ports are uniquely numbered in the range from 1 to rptrGroupPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
rptrPortTable = MibTable((1, 3, 6, 1, 3, 29, 1, 3, 1), )
if mibBuilder.loadTexts: rptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortTable.setDescription('Table of descriptive and status information about the ports.')
rptrPortEntry = MibTableRow((1, 3, 6, 1, 3, 29, 1, 3, 1, 1), ).setIndexNames((0, "NRC-MultiGate", "rptrPortGroupIndex"), (0, "NRC-MultiGate", "rptrPortIndex"))
if mibBuilder.loadTexts: rptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
rptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
rptrPortIndex = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortIndex.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aPortID.')
if mibBuilder.loadTexts: rptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This value can never be greater than rptrGroupPortCapacity for the associated group.')
rptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rptrPortAdminStatus.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aPortAdminState and 19.2.6.3, acPortAdminControl.')
if mibBuilder.loadTexts: rptrPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. (In effect, when a port is disabled, the value of rptrPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the rptrPortAutoPartitionState becomes notAutoPartitioned(1), regardless of its pre-disabling state.)")
rptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setReference('Reference IEEE 802.3 Rptr Mgt, 19.2.6.2, aAutoPartitionState.')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Section 9 [IEEE 802.3 Std]. They are not differentiated here.")
rptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 3, 29, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rptrPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: rptrPortOperStatus.setDescription("This object indicates the port's operational status. The notPresent(3) status indicates the port is physically removed (note this may or may not be possible depending on the type of port.) The operational(1) status indicates that the port is enabled (see rptrPortAdminStatus) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState). If this object has the value operational(1) and rptrPortAdminStatus is set to disabled(2), it is expected that this object's value will change to notOperational(2) soon after.")
dot1dBase = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 1))
dot1dTp = MibIdentifier((1, 3, 6, 1, 2, 1, 17, 4))
dot1dBaseBridgeAddress = MibScalar((1, 3, 6, 1, 2, 1, 17, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setReference('P802.1d/D9, July 14, 1989: Sections 6.4.1.1.3 and 3.12.5')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique. When concatenated with dot1dStpPriority a unique BridgeIdentifier is formed which is used in the Spanning Tree Protocol.')
dot1dBaseNumPorts = MibScalar((1, 3, 6, 1, 2, 1, 17, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseNumPorts.setReference('P802.1d/D9, July 14, 1989: Section 6.4.1.1.3')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setDescription('The number of ports controlled by this bridging entity.')
dot1dBaseType = MibScalar((1, 3, 6, 1, 2, 1, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparent-only", 2), ("sourceroute-only", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseType.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseType.setDescription('Indicates what type of bridging this bridge can perform. If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.')
dot1dBasePortTable = MibTable((1, 3, 6, 1, 2, 1, 17, 1, 4), )
if mibBuilder.loadTexts: dot1dBasePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortTable.setDescription('A table that contains generic information about every port that is associated with this bridge. Transparent, source-route, and srt ports are included.')
dot1dBasePortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 1, 4, 1), ).setIndexNames((0, "NRC-MultiGate", "dot1dBasePort"))
if mibBuilder.loadTexts: dot1dBasePortEntry.setReference('P802.1d/D9, July 14, 1989: Section 6.4.2, 6.6.1')
if mibBuilder.loadTexts: dot1dBasePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortEntry.setDescription('A list of information for each port of the bridge.')
dot1dBasePort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePort.setDescription('The port number of the port for which this entry contains bridge management information.')
dot1dBasePortIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in [4,6], for the interface corresponding to this port.')
dot1dBasePortCircuit = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 1, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortCircuit.setDescription('For a port which (potentially) has the same value of dot1dBasePortIfIndex as another port on the same bridge, this object contains the name of an object instance unique to this port. For example, in the case where multiple ports correspond one- to-one with multiple X.25 virtual circuits, this value might identify an (e.g., the first) object instance associated with the X.25 virtual circuit corresponding to this port. For a port which has a unique value of dot1dBasePortIfIndex, this object can have the value { 0 0 }.')
dot1dBasePortDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setDescription('The number of frames discarded by this port due to excessive transit delay through the bridge. It is incremented by both transparent and source route bridges.')
dot1dBasePortMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setDescription('The number of frames discarded by this port due to an excessive size. It is incremented by both transparent and source route bridges.')
dot1dTpLearnedEntryDiscards = MibScalar((1, 3, 6, 1, 2, 1, 17, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setDescription('The total number of Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
dot1dTpAgingTime = MibScalar((1, 3, 6, 1, 2, 1, 17, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTpAgingTime.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpAgingTime.setDescription('The timeout period in seconds for aging out dynamically learned forwarding information.')
dot1dTpFdbTable = MibTable((1, 3, 6, 1, 2, 1, 17, 4, 3), )
if mibBuilder.loadTexts: dot1dTpFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpFdbTable.setDescription('A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame.')
dot1dTpFdbEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 4, 3, 1), ).setIndexNames((0, "NRC-MultiGate", "dot1dTpFdbAddress"))
if mibBuilder.loadTexts: dot1dTpFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpFdbEntry.setDescription('Information about a specific unicast MAC address for which the bridge has some forwarding and/or filtering information.')
dot1dTpFdbAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 3, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpFdbAddress.setReference('P802.1d/D9, July 14, 1989: Section 3.9.1, 3.9.2')
if mibBuilder.loadTexts: dot1dTpFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpFdbAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
dot1dTpFdbPort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpFdbPort.setDescription("Either the value '0', or the port number of the port on which a frame having a source address equal to the value of the corresponding instance of dot1dTpFdbAddress has been seen. A value of '0' indicates that the port number has not been learned but that the bridge does have some forwarding/filtering information about this address (e.g. in the dot1dStaticTable). Implementors are encouraged to assign the port value to this object whenever it is learned even for addresses for which the corresponding value of dot1dTpFdbStatus is not learned(3).")
dot1dTpFdbStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("learned", 3), ("self", 4), ("mgmt", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) : none of the following. This would include the case where some other MIB object (not the corresponding instance of dot1dTpFdbPort, nor an entry in the dot1dStaticTable) is being used to determine if and how frames addressed to the value of the corresponding instance of dot1dTpFdbAddress are being forwarded. invalid(2) : this entry is not longer valid (e.g., it was learned but has since aged-out), but has not yet been flushed from the table. learned(3) : the value of the corresponding instance of dot1dTpFdbPort was learned, and is being used. self(4) : the value of the corresponding instance of dot1dTpFdbAddress represents one of the bridge's addresses. The corresponding instance of dot1dTpFdbPort indicates which of the bridge's ports has this address. mgmt(5) : the value of the corresponding instance of dot1dTpFdbAddress is also the value of an existing instance of dot1dStaticAddress.")
dot1dTpPortTable = MibTable((1, 3, 6, 1, 2, 1, 17, 4, 4), )
if mibBuilder.loadTexts: dot1dTpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
dot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 17, 4, 4, 1), ).setIndexNames((0, "NRC-MultiGate", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortEntry.setDescription('A list of information for each port of a transparent bridge.')
dot1dTpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPort.setDescription('The port number of the port for which this entry contains Transparent bridging management information.')
dot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
dot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
dot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
dot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 2, 1, 17, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
mibBuilder.exportSymbols("NRC-MultiGate", hub1IFOutLostCts=hub1IFOutLostCts, rptrPortOperStatus=rptrPortOperStatus, hub1IFInMtuExceededDiscards=hub1IFInMtuExceededDiscards, dot1dBridge=dot1dBridge, rptrMonitorGroupInfo=rptrMonitorGroupInfo, hub1PortPolarityStatus=hub1PortPolarityStatus, hub1IFIndex=hub1IFIndex, rptrGroupPortCapacity=rptrGroupPortCapacity, hub1PortPartitionReason=hub1PortPartitionReason, dot1dBaseBridgeAddress=dot1dBaseBridgeAddress, snmpDot3RptrMgt=snmpDot3RptrMgt, hub1ConsoleBaudRate=hub1ConsoleBaudRate, hub1PortLinkState=hub1PortLinkState, hub1PortEntry=hub1PortEntry, rptrPortTable=rptrPortTable, hub1=hub1, rptrAddrTrackPortInfo=rptrAddrTrackPortInfo, hub1Reset=hub1Reset, rptrBasicPackage=rptrBasicPackage, rptrGroupLastOperStatusChange=rptrGroupLastOperStatusChange, hub1PortTable=hub1PortTable, dot1dTpPortInDiscards=dot1dTpPortInDiscards, hub1ProtocolFilterMode=hub1ProtocolFilterMode, hub1PortForceReconnect=hub1PortForceReconnect, dot1dTpFdbPort=dot1dTpFdbPort, hub1EventRecordFlags=hub1EventRecordFlags, hub1PortName=hub1PortName, rptrPortEntry=rptrPortEntry, dot1dTpAgingTime=dot1dTpAgingTime, hub1CollisionLimit=hub1CollisionLimit, hub1IFInShortErrors=hub1IFInShortErrors, hub1PortType=hub1PortType, rptrAddrTrackRptrInfo=rptrAddrTrackRptrInfo, rptrMonitorPortInfo=rptrMonitorPortInfo, dot1dTpPortEntry=dot1dTpPortEntry, hub1EventCounterFlags=hub1EventCounterFlags, dot1dTpPortOutFrames=dot1dTpPortOutFrames, dot1dTpLearnedEntryDiscards=dot1dTpLearnedEntryDiscards, hub1PortRecordValue=hub1PortRecordValue, rptrAddrTrackPackage=rptrAddrTrackPackage, rptrGroupInfo=rptrGroupInfo, dot1dTpPortMaxInfo=dot1dTpPortMaxInfo, nrc=nrc, hub1IFTable=hub1IFTable, rptrGroupOperStatus=rptrGroupOperStatus, rptrGroupCapacity=rptrGroupCapacity, rptrHealthText=rptrHealthText, Timeout=Timeout, dot1dBasePortEntry=dot1dBasePortEntry, hub1IFOutCollisions=hub1IFOutCollisions, enterprises=enterprises, dot1dTpPortInFrames=dot1dTpPortInFrames, dot1dBasePortDelayExceededDiscards=dot1dBasePortDelayExceededDiscards, hub1BridgingMode=hub1BridgingMode, rptrGroupDescr=rptrGroupDescr, rptrGroupObjectID=rptrGroupObjectID, dot1dTp=dot1dTp, hub1LoopbackPartition=hub1LoopbackPartition, dot1dBasePortTable=dot1dBasePortTable, dot1dTpFdbStatus=dot1dTpFdbStatus, rptrOperStatus=rptrOperStatus, dot1dBaseType=dot1dBaseType, hub1IFInAlignmentErrors=hub1IFInAlignmentErrors, dot1dBaseNumPorts=dot1dBaseNumPorts, rptrPortInfo=rptrPortInfo, dot1dTpPortTable=dot1dTpPortTable, hub1IFChannelUtilization=hub1IFChannelUtilization, mib_2=mib_2, hub1PortLinkEnable=hub1PortLinkEnable, dot1dBase=dot1dBase, rptrPortAdminStatus=rptrPortAdminStatus, hub1SoftwareVersion=hub1SoftwareVersion, dot1dBasePortMtuExceededDiscards=dot1dBasePortMtuExceededDiscards, rptrReset=rptrReset, rptrTotalPartitionedPorts=rptrTotalPartitionedPorts, hub1IFEntry=hub1IFEntry, hub1IFInCrcErrors=hub1IFInCrcErrors, rptrGroupEntry=rptrGroupEntry, BridgeId=BridgeId, hub1IFOutUnderruns=hub1IFOutUnderruns, dot1dTpFdbAddress=dot1dTpFdbAddress, hub1IFOutLostCrs=hub1IFOutLostCrs, hub1LastFailureReason=hub1LastFailureReason, hub1IFInCollisions=hub1IFInCollisions, rptrPortGroupIndex=rptrPortGroupIndex, hub1IFInOverrunDiscards=hub1IFInOverrunDiscards, rptrNonDisruptTest=rptrNonDisruptTest, dot1dBasePort=dot1dBasePort, hub1IncludeOutOfWinColl=hub1IncludeOutOfWinColl, rptrMonitorPackage=rptrMonitorPackage, hub1PortEventCount=hub1PortEventCount, rptrRptrInfo=rptrRptrInfo, hub1AutoPartition=hub1AutoPartition, hub1FilterProtocols=hub1FilterProtocols, rptrGroupTable=rptrGroupTable, dot1dBasePortIfIndex=dot1dBasePortIfIndex, hub1CarrierRecoverTime=hub1CarrierRecoverTime, dot1dTpPort=dot1dTpPort, rptrAddrTrackGroupInfo=rptrAddrTrackGroupInfo, hub1ReconnectOnTransmission=hub1ReconnectOnTransmission, dot1dTpFdbTable=dot1dTpFdbTable, MacAddress=MacAddress, rptrMonitorRptrInfo=rptrMonitorRptrInfo, dot1dBasePortCircuit=dot1dBasePortCircuit, hub1PortIndex=hub1PortIndex, rptrPortAutoPartitionState=rptrPortAutoPartitionState, hub1IFOutMtuExceededDiscards=hub1IFOutMtuExceededDiscards, rptrPortIndex=rptrPortIndex, dot1dTpFdbEntry=dot1dTpFdbEntry, rptrGroupIndex=rptrGroupIndex)

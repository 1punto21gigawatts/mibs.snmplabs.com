#
# PySNMP MIB module RBN-DHCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RBN-DHCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:52:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
rbnMgmt, = mibBuilder.importSymbols("RBN-SMI", "rbnMgmt")
RbnSlot, = mibBuilder.importSymbols("RBN-TC", "RbnSlot")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Counter32, MibIdentifier, ModuleIdentity, Integer32, Unsigned32, iso, IpAddress, Bits, NotificationType, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibIdentifier", "ModuleIdentity", "Integer32", "Unsigned32", "iso", "IpAddress", "Bits", "NotificationType", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "TimeTicks")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
rbnDhcpMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 2352, 2, 30))
rbnDhcpMib.setRevisions(('2010-03-10 17:00', '2005-10-14 17:00', '2004-05-03 17:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rbnDhcpMib.setRevisionsDescriptions(('Added rbnDhcpLeaseFileStorageSlot, rbnDhcpLeaseFileErrorType, and rbnDhcpLeaseFileFailure.', 'Added new rbnDhcpRangeThresholdTable table.', 'Initial version.',))
if mibBuilder.loadTexts: rbnDhcpMib.setLastUpdated('201003101700Z')
if mibBuilder.loadTexts: rbnDhcpMib.setOrganization('Redback Networks, Inc.')
if mibBuilder.loadTexts: rbnDhcpMib.setContactInfo(' RedBack Networks, Inc. Postal: 300 Holger Way San Jose, CA 95134-1362 USA Phone: +1 408 750 5000 Fax: +1 408 750 5599 E-mail: mib-info@redback.com')
if mibBuilder.loadTexts: rbnDhcpMib.setDescription('Defines the objects necessary to obtain information about DHCP Servers for interfaces within a context.')
rbnDhcpMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0))
rbnDhcpMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1))
rbnDhcpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2))
rbnDhcpIntfThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1), )
if mibBuilder.loadTexts: rbnDhcpIntfThresholdTable.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdTable.setDescription('The purpose of this table is to allow monitoring of per interface DHCP server thresholds through SNMP. This table contains the objects which characterize DHCP server thresholds. Each row in the table corresponds to information about the leases in a DHCP server range for a particular interface and the corresponding capacity, usage and falling and rising thresholds. Objects defined in this table are only accessible within the context identified in the SNMP protocol (i.e. the community string in v1/v2c or the contextName in v3).')
rbnDhcpIntfThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1), ).setIndexNames((1, "RBN-DHCP-MIB", "rbnDhcpIntfThresholdName"))
if mibBuilder.loadTexts: rbnDhcpIntfThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdEntry.setDescription('A conceptual row in the rbnDhcpIntfThresholdTable.')
rbnDhcpIntfThresholdName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80)))
if mibBuilder.loadTexts: rbnDhcpIntfThresholdName.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdName.setDescription('The name of the interface. An entry configured by other means may have been given a name whose length is greater than 80. Names which exceed this length are not accessible via SNMP operations.')
rbnDhcpIntfThresholdContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdContextName.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdContextName.setDescription('The name of the context which contains the interface.')
rbnDhcpIntfThresholdSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdSize.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdSize.setDescription('The number of leases that have been reserved for the DHCP server in this interface.')
rbnDhcpIntfThresholdAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdAvailable.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdAvailable.setDescription('The number of leases that are available in this interface.')
rbnDhcpIntfThresholdInuse = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdInuse.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdInuse.setDescription('The number of leases that are in use in this interface.')
rbnDhcpIntfThresholdFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingThreshold.setDescription('The falling threshold is a value which specifies that any enabled falling threshold events are to be generated when the value of the currently available leases drops to the falling threshold value via an allocation of a lease from the pool. The number of available leases is reported in rbnDhcpIntfThresholdAvailable. A falling threshold event is either a notification or a log message or both. Falling threshold events are enabled if either or both of rbnDhcpIntfThresholdFallingSendTrap and rbnDhcpIntfThresholdFallingLogMessage are true. Note, this is a falling threshold, so a falling threshold event will only be triggered on a transition of the value of rbnDhcpIntfThresholdAvailable dropping from (rbnDhcpIntfThresholdFallingThreshold+1) to rbnDhcpIntfThresholdFallingThreshold.')
rbnDhcpIntfThresholdFallingSendTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingSendTrap.setDescription('If true, upon detection of reaching a falling threshold, a trap will be sent. See the definition of the rbnDhcpIntfThresholdFallingThresholdMet notification for the information included in the trap.')
rbnDhcpIntfThresholdFallingLogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingLogMessage.setDescription('If true, upon detection of reaching a falling threshold, a message will be logged. See the definition of the rbnDhcpIntfThresholdFallingThresholdMet notification for the information included in the trap.')
rbnDhcpIntfThresholdRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingThreshold.setDescription('The rising threshold is a value which specifies that any enabled rising threshold events are to be generated when the value of the currently available leases reaches the rising threshold value via a returning of a lease to the pool. The number of available leases is reported in rbnDhcpIntfThresholdAvailable. A rising threshold event is either a notification or a log message or both. Rising threshold events are enabled if either or both of rbnDhcpIntfThresholdRisingSendTrap and rbnDhcpIntfThresholdRisingLogMessage are true. Note, this is a rising threshold, so a rising threshold event will only be triggered on a transition of the value of rbnDhcpIntfThresholdAvailable increasing from (rbnDhcpIntfThresholdRisingThreshold-1) to rbnDhcpIntfThresholdRisingThreshold.')
rbnDhcpIntfThresholdRisingSendTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingSendTrap.setDescription('If true, upon detection of reaching a rising threshold, a trap will be sent. See the definition of the rbnDhcpIntfThresholdRisingThresholdMet notification for the information included in the trap.')
rbnDhcpIntfThresholdRisingLogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingLogMessage.setDescription('If true, upon detection of reaching a rising threshold, a message will be logged. See the definition of the rbnDhcpIntfThresholdRisingThresholdMet notification for the information included in the trap.')
rbnDhcpRangeThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3), )
if mibBuilder.loadTexts: rbnDhcpRangeThresholdTable.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdTable.setDescription('The purpose of this table is to allow monitoring of DHCP server ranges within interfaces. This table contains the objects which characterize DHCP server ranges. Each row in the table corresponds to information about the leases in a DHCP server for a particular range within a particular interface and the corresponding capacity, usage and falling and rising thresholds. Objects defined in this table are only accessible within the context identified in the SNMP protocol (i.e. the community string in v1/v2c or the contextName in v3).')
rbnDhcpRangeThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1), ).setIndexNames((0, "RBN-DHCP-MIB", "rbnDhcpRangeThresholdInterfaceIdx"), (0, "RBN-DHCP-MIB", "rbnDhcpRangeThresholdAddr"))
if mibBuilder.loadTexts: rbnDhcpRangeThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdEntry.setDescription('A conceptual row in the rbnDhcpRangeThresholdTable.')
rbnDhcpRangeThresholdInterfaceIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 1), Unsigned32())
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInterfaceIdx.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInterfaceIdx.setDescription('The index of the interface containing the DHCP range.')
rbnDhcpRangeThresholdAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 2), IpAddress())
if mibBuilder.loadTexts: rbnDhcpRangeThresholdAddr.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdAddr.setDescription('The start address of the DHCP range.')
rbnDhcpRangeThresholdEndAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdEndAddr.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdEndAddr.setDescription('The end address of the DHCP range.')
rbnDhcpRangeThresholdContextName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdContextName.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdContextName.setDescription('The name of the context which contains the interface.')
rbnDhcpRangeThresholdInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInterfaceName.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInterfaceName.setDescription('The name of the interface containing the DHCP range.')
rbnDhcpRangeThresholdSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdSize.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdSize.setDescription('The number of leases that have been reserved for the DHCP server in this range.')
rbnDhcpRangeThresholdAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdAvailable.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdAvailable.setDescription('The number of leases that are available in this range.')
rbnDhcpRangeThresholdInuse = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInuse.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdInuse.setDescription('The number of leases that are in use in this range.')
rbnDhcpRangeThresholdFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingThreshold.setDescription('The falling threshold is a value which specifies that any enabled falling threshold events are to be generated when the value of the currently available leases drops to the falling threshold value via an allocation of a lease from the range. The number of available leases is reported in rbnDhcpRangeThresholdAvailable. A falling threshold event is either a notification or a log message or both. Falling threshold events are enabled if either or both of rbnDhcpRangeThresholdFallingSendTrap and rbnDhcpRangeThresholdFallingLogMessage are true. Note, this is a falling threshold, so a falling threshold event will only be triggered on a transition of the value of rbnDhcpRangeThresholdAvailable dropping from (rbnDhcpRangeThresholdFallingThreshold+1) to rbnDhcpRangeThresholdFallingThreshold.')
rbnDhcpRangeThresholdFallingSendTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingSendTrap.setDescription('If true, upon detection of reaching a falling threshold, a trap will be sent. See the definition of the rbnDhcpRangeThresholdFallingThresholdMet notification for the information included in the trap.')
rbnDhcpRangeThresholdFallingLogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingLogMessage.setDescription('If true, upon detection of reaching a falling threshold, a message will be logged. See the definition of the rbnDhcpRangeThresholdFallingThresholdMet notification for the information included in the trap.')
rbnDhcpRangeThresholdRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingThreshold.setDescription('The rising threshold is a value which specifies that any enabled rising threshold events are to be generated when the value of the currently available leases reaches the rising threshold value via a returning of a lease to the range. The number of available leases is reported in rbnDhcpRangeThresholdAvailable. A rising threshold event is either a notification or a log message or both. Rising threshold events are enabled if either or both of rbnDhcpRangeThresholdRisingSendTrap and rbnDhcpRangeThresholdRisingLogMessage are true. Note, this is a rising threshold, so a rising threshold event will only be triggered on a transition of the value of rbnDhcpRangeThresholdAvailable increasing from (rbnDhcpRangeThresholdRisingThreshold-1) to rbnDhcpRangeThresholdRisingThreshold.')
rbnDhcpRangeThresholdRisingSendTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingSendTrap.setDescription('If true, upon detection of reaching a rising threshold, a trap will be sent. See the definition of the rbnDhcpRangeThresholdRisingThresholdMet notification for the information included in the trap.')
rbnDhcpRangeThresholdRisingLogMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 3, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingLogMessage.setDescription('If true, upon detection of reaching a rising threshold, a message will be logged. See the definition of the rbnDhcpRangeThresholdRisingThresholdMet notification for the information included in the trap.')
rbnDhcpCtxThreshold = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2))
rbnDhcpCtxThresholdName = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdName.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdName.setDescription('This object identifies the context in which a falling or rising per context threshold event occurs')
rbnDhcpCtxThresholdSize = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdSize.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdSize.setDescription('The total number of leases in all DHCP ranges of all interfaces in the context valid in the current view.')
rbnDhcpCtxThresholdAvailable = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdAvailable.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdAvailable.setDescription('The total number of leases available in all DHCP ranges of all interfaces in the context valid in the current view.')
rbnDhcpCtxThresholdInuse = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdInuse.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdInuse.setDescription('The total number of leases in use in all DHCP ranges of all interfaces in the context valid in the current view.')
rbnDhcpCtxThresholdFallingThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingThreshold.setDescription('The falling threshold value for the context valid in the current view. Just as rbnDhcpIntfThresholdFallingThreshold is the per interface falling threshold, this object is the per context falling threshold. When the sum of the all available DHCP leases in all interfaces of the context valid in the current view reaches the value of this object a falling threshold action of a trap, a log message, or both will be generated. This is a falling threshold, so the evaluation of whether to perform the action occurs upon allocation of a lease from the available pool of leases from any interface within the context. The action of whether to send a trap and/or log message is specified by the values of rbnDhcpCtxThresholdFallingSendTrap and rbnDhcpCtxThresholdFallingLogMessage. If there is no per context rising threshold, the value of this object will be zero and the values of rbnDhcpCtxThresholdFallingSendTrap and rbnDhcpCtxThresholdFallingLogMessage will be false.')
rbnDhcpCtxThresholdFallingSendTrap = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingSendTrap.setDescription('If true, upon detection of reaching the per context falling threshold, a trap will be sent. See the definition of the rbnDhcpCtxThresholdFallingThresholdMet for the information included in the trap.')
rbnDhcpCtxThresholdFallingLogMessage = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingLogMessage.setDescription('If true, upon detection of reaching the per context falling threshold, a message will be logged. The information contained in the message logged is the same as that included in the rbnDhcpCtxThresholdFallingThresholdMet trap.')
rbnDhcpCtxThresholdRisingThreshold = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 196608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingThreshold.setDescription('The rising threshold value for the context valid in the current view. Just as rbnDhcpIntfThresholdRisingThreshold is the per interface rising threshold, this object is the per context rising threshold. When the sum of the all available DHCP leases in all interfaces of the context valid in the current view reaches the value of this object a rising threshold action of a trap, a log message, or both will be generated. This is a rising threshold, so the evaluation of whether to perform the action occurs upon return of a lease to the available pool of leases defined in any interface within the context. The action of whether to send a trap and/or log message is specified by the values of rbnDhcpCtxThresholdRisingSendTrap and rbnDhcpCtxThresholdRisingLogMessage. If there is no per context rising threshold, the value of this object will be zero and the values of rbnDhcpCtxThresholdRisingSendTrap and rbnDhcpCtxThresholdRisingLogMessage will be false.')
rbnDhcpCtxThresholdRisingSendTrap = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingSendTrap.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingSendTrap.setDescription('If true, upon detection of reaching the per context rising threshold, a trap will be sent. See the definition of the rbnDhcpCtxThresholdRisingThresholdMet for the information included in the trap.')
rbnDhcpCtxThresholdRisingLogMessage = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 2, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingLogMessage.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingLogMessage.setDescription('If true, upon detection of reaching the per context rising threshold, a message will be logged. The information contained in the message logged is the same as that included in the rbnDhcpCtxThresholdRisingThresholdMet trap.')
rbnDhcpLeaseFileStorageSlot = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 4), RbnSlot()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rbnDhcpLeaseFileStorageSlot.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpLeaseFileStorageSlot.setDescription('The slot number of the storage device containing the DHCP lease file.')
rbnDhcpLeaseFileErrorType = MibScalar((1, 3, 6, 1, 4, 1, 2352, 2, 30, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("storageDeviceDegraded", 1), ("storageDeviceFailed", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rbnDhcpLeaseFileErrorType.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpLeaseFileErrorType.setDescription('Error types of DHCP lease file failure.')
rbnDhcpIntfThresholdFallingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 1)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingThreshold"))
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdFallingThresholdMet.setDescription('A notification indicating that a per interface falling threshold has been reached.')
rbnDhcpIntfThresholdRisingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 2)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingThreshold"))
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdRisingThresholdMet.setDescription('A notification indicating that a per interface rising threshold has been reached.')
rbnDhcpCtxThresholdFallingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 3)).setObjects(("RBN-DHCP-MIB", "rbnDhcpCtxThresholdName"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingThreshold"))
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdFallingThresholdMet.setDescription('A notification indicating that the per context falling threshold has been reached.')
rbnDhcpCtxThresholdRisingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 4)).setObjects(("RBN-DHCP-MIB", "rbnDhcpCtxThresholdName"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingThreshold"))
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdRisingThresholdMet.setDescription('A notification indicating that the per context rising threshold has been reached.')
rbnDhcpRangeThresholdFallingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 5)).setObjects(("RBN-DHCP-MIB", "rbnDhcpRangeThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdInterfaceName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdEndAddr"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdFallingThreshold"))
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdFallingThresholdMet.setDescription('A notification indicating that a per subnet falling threshold has been reached.')
rbnDhcpRangeThresholdRisingThresholdMet = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 6)).setObjects(("RBN-DHCP-MIB", "rbnDhcpRangeThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdInterfaceName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdEndAddr"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdRisingThreshold"))
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingThresholdMet.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdRisingThresholdMet.setDescription('A notification indicating that a per subnet rising threshold has been reached.')
rbnDhcpLeaseFileFailure = NotificationType((1, 3, 6, 1, 4, 1, 2352, 2, 30, 0, 7)).setObjects(("RBN-DHCP-MIB", "rbnDhcpLeaseFileStorageSlot"), ("RBN-DHCP-MIB", "rbnDhcpLeaseFileErrorType"))
if mibBuilder.loadTexts: rbnDhcpLeaseFileFailure.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpLeaseFileFailure.setDescription('A notification indicating that the system has stopped reading/updating the DHCP lease file.')
rbnDhcpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 1))
rbnDhcpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2))
rbnDhcpThresholdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 1)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdSize"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdInuse"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdName"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdSize"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdInuse"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingLogMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpThresholdGroup = rbnDhcpThresholdGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpThresholdGroup.setDescription('The collection of objects providing DHCP range information.')
rbnDhcpThresholdNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 2)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingThresholdMet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpThresholdNotifyGroup = rbnDhcpThresholdNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpThresholdNotifyGroup.setDescription('The collection of notifications related to a DHCP range.')
rbnDhcpIntfThresholdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 3)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdSize"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdInuse"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingLogMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpIntfThresholdGroup = rbnDhcpIntfThresholdGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdGroup.setDescription('The collection of objects providing DHCP range information.')
rbnDhcpCtxThresholdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 4)).setObjects(("RBN-DHCP-MIB", "rbnDhcpCtxThresholdName"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdSize"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdInuse"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingLogMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpCtxThresholdGroup = rbnDhcpCtxThresholdGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdGroup.setDescription('The collection of objects providing DHCP range information.')
rbnDhcpRangeThresholdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 5)).setObjects(("RBN-DHCP-MIB", "rbnDhcpRangeThresholdEndAddr"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdContextName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdInterfaceName"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdSize"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdInuse"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdAvailable"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdFallingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdFallingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdFallingLogMessage"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdRisingThreshold"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdRisingSendTrap"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdRisingLogMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpRangeThresholdGroup = rbnDhcpRangeThresholdGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdGroup.setDescription('The collection of objects providing DHCP range information.')
rbnDhcpIntfThresholdNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 6)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdFallingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdRisingThresholdMet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpIntfThresholdNotifyGroup = rbnDhcpIntfThresholdNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpIntfThresholdNotifyGroup.setDescription('The collection of notifications related to a DHCP range.')
rbnDhcpCtxThresholdNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 7)).setObjects(("RBN-DHCP-MIB", "rbnDhcpCtxThresholdFallingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdRisingThresholdMet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpCtxThresholdNotifyGroup = rbnDhcpCtxThresholdNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpCtxThresholdNotifyGroup.setDescription('The collection of notifications related to a DHCP range.')
rbnDhcpRangeThresholdNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 8)).setObjects(("RBN-DHCP-MIB", "rbnDhcpRangeThresholdFallingThresholdMet"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdRisingThresholdMet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpRangeThresholdNotifyGroup = rbnDhcpRangeThresholdNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpRangeThresholdNotifyGroup.setDescription('The collection of notifications related to a DHCP range.')
rbnDhcpLeaseFileFailureTrapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 9)).setObjects(("RBN-DHCP-MIB", "rbnDhcpLeaseFileStorageSlot"), ("RBN-DHCP-MIB", "rbnDhcpLeaseFileErrorType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpLeaseFileFailureTrapGroup = rbnDhcpLeaseFileFailureTrapGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpLeaseFileFailureTrapGroup.setDescription('The collection of objects related to DHCP lease file failures.')
rbnDhcpLeaseFileFailureNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 2, 10)).setObjects(("RBN-DHCP-MIB", "rbnDhcpLeaseFileFailure"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpLeaseFileFailureNotifyGroup = rbnDhcpLeaseFileFailureNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpLeaseFileFailureNotifyGroup.setDescription('The collection of notifications related to DHCP lease file failures.')
rbnDhcpThresholdCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 1, 1)).setObjects(("RBN-DHCP-MIB", "rbnDhcpThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpThresholdNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpThresholdCompliance = rbnDhcpThresholdCompliance.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpThresholdCompliance.setDescription('The compliance statement for threshold objects in the Redback DHCP MIB.')
rbnDhcpThresholdCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 1, 2)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdNotifyGroup"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdNotifyGroup"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpThresholdCompliance2 = rbnDhcpThresholdCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: rbnDhcpThresholdCompliance2.setDescription('The compliance statement for threshold objects in the Redback DHCP MIB.')
rbnDhcpThresholdCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 2352, 2, 30, 2, 1, 3)).setObjects(("RBN-DHCP-MIB", "rbnDhcpIntfThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdGroup"), ("RBN-DHCP-MIB", "rbnDhcpIntfThresholdNotifyGroup"), ("RBN-DHCP-MIB", "rbnDhcpCtxThresholdNotifyGroup"), ("RBN-DHCP-MIB", "rbnDhcpRangeThresholdNotifyGroup"), ("RBN-DHCP-MIB", "rbnDhcpLeaseFileFailureTrapGroup"), ("RBN-DHCP-MIB", "rbnDhcpLeaseFileFailureNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rbnDhcpThresholdCompliance3 = rbnDhcpThresholdCompliance3.setStatus('current')
if mibBuilder.loadTexts: rbnDhcpThresholdCompliance3.setDescription('The compliance statement for threshold objects in the Redback DHCP MIB.')
mibBuilder.exportSymbols("RBN-DHCP-MIB", rbnDhcpRangeThresholdContextName=rbnDhcpRangeThresholdContextName, rbnDhcpThresholdCompliance=rbnDhcpThresholdCompliance, rbnDhcpIntfThresholdFallingLogMessage=rbnDhcpIntfThresholdFallingLogMessage, rbnDhcpRangeThresholdEndAddr=rbnDhcpRangeThresholdEndAddr, rbnDhcpCtxThresholdName=rbnDhcpCtxThresholdName, rbnDhcpCtxThresholdRisingSendTrap=rbnDhcpCtxThresholdRisingSendTrap, rbnDhcpCtxThresholdGroup=rbnDhcpCtxThresholdGroup, rbnDhcpIntfThresholdTable=rbnDhcpIntfThresholdTable, rbnDhcpRangeThresholdFallingThresholdMet=rbnDhcpRangeThresholdFallingThresholdMet, rbnDhcpRangeThresholdRisingLogMessage=rbnDhcpRangeThresholdRisingLogMessage, rbnDhcpCtxThresholdFallingSendTrap=rbnDhcpCtxThresholdFallingSendTrap, rbnDhcpLeaseFileStorageSlot=rbnDhcpLeaseFileStorageSlot, rbnDhcpLeaseFileFailureTrapGroup=rbnDhcpLeaseFileFailureTrapGroup, rbnDhcpIntfThresholdFallingThresholdMet=rbnDhcpIntfThresholdFallingThresholdMet, rbnDhcpMIBObjects=rbnDhcpMIBObjects, rbnDhcpRangeThresholdAvailable=rbnDhcpRangeThresholdAvailable, rbnDhcpRangeThresholdRisingThreshold=rbnDhcpRangeThresholdRisingThreshold, rbnDhcpIntfThresholdNotifyGroup=rbnDhcpIntfThresholdNotifyGroup, rbnDhcpRangeThresholdRisingSendTrap=rbnDhcpRangeThresholdRisingSendTrap, rbnDhcpLeaseFileFailure=rbnDhcpLeaseFileFailure, rbnDhcpRangeThresholdFallingThreshold=rbnDhcpRangeThresholdFallingThreshold, rbnDhcpCtxThresholdRisingThresholdMet=rbnDhcpCtxThresholdRisingThresholdMet, rbnDhcpLeaseFileFailureNotifyGroup=rbnDhcpLeaseFileFailureNotifyGroup, rbnDhcpIntfThresholdGroup=rbnDhcpIntfThresholdGroup, rbnDhcpRangeThresholdNotifyGroup=rbnDhcpRangeThresholdNotifyGroup, rbnDhcpThresholdCompliance3=rbnDhcpThresholdCompliance3, rbnDhcpIntfThresholdRisingSendTrap=rbnDhcpIntfThresholdRisingSendTrap, rbnDhcpRangeThresholdAddr=rbnDhcpRangeThresholdAddr, rbnDhcpLeaseFileErrorType=rbnDhcpLeaseFileErrorType, rbnDhcpCtxThresholdRisingThreshold=rbnDhcpCtxThresholdRisingThreshold, rbnDhcpRangeThresholdFallingLogMessage=rbnDhcpRangeThresholdFallingLogMessage, rbnDhcpCtxThresholdAvailable=rbnDhcpCtxThresholdAvailable, rbnDhcpIntfThresholdRisingLogMessage=rbnDhcpIntfThresholdRisingLogMessage, rbnDhcpIntfThresholdInuse=rbnDhcpIntfThresholdInuse, rbnDhcpIntfThresholdAvailable=rbnDhcpIntfThresholdAvailable, rbnDhcpRangeThresholdRisingThresholdMet=rbnDhcpRangeThresholdRisingThresholdMet, rbnDhcpMIBNotifications=rbnDhcpMIBNotifications, rbnDhcpIntfThresholdContextName=rbnDhcpIntfThresholdContextName, rbnDhcpThresholdGroup=rbnDhcpThresholdGroup, rbnDhcpCtxThresholdFallingThresholdMet=rbnDhcpCtxThresholdFallingThresholdMet, rbnDhcpMIBConformance=rbnDhcpMIBConformance, rbnDhcpIntfThresholdFallingThreshold=rbnDhcpIntfThresholdFallingThreshold, rbnDhcpCtxThresholdRisingLogMessage=rbnDhcpCtxThresholdRisingLogMessage, rbnDhcpIntfThresholdRisingThresholdMet=rbnDhcpIntfThresholdRisingThresholdMet, rbnDhcpThresholdCompliance2=rbnDhcpThresholdCompliance2, rbnDhcpCtxThresholdFallingLogMessage=rbnDhcpCtxThresholdFallingLogMessage, rbnDhcpCtxThreshold=rbnDhcpCtxThreshold, rbnDhcpRangeThresholdGroup=rbnDhcpRangeThresholdGroup, rbnDhcpCompliances=rbnDhcpCompliances, PYSNMP_MODULE_ID=rbnDhcpMib, rbnDhcpCtxThresholdInuse=rbnDhcpCtxThresholdInuse, rbnDhcpRangeThresholdInuse=rbnDhcpRangeThresholdInuse, rbnDhcpCtxThresholdNotifyGroup=rbnDhcpCtxThresholdNotifyGroup, rbnDhcpThresholdNotifyGroup=rbnDhcpThresholdNotifyGroup, rbnDhcpIntfThresholdFallingSendTrap=rbnDhcpIntfThresholdFallingSendTrap, rbnDhcpRangeThresholdTable=rbnDhcpRangeThresholdTable, rbnDhcpGroups=rbnDhcpGroups, rbnDhcpRangeThresholdInterfaceIdx=rbnDhcpRangeThresholdInterfaceIdx, rbnDhcpIntfThresholdSize=rbnDhcpIntfThresholdSize, rbnDhcpIntfThresholdRisingThreshold=rbnDhcpIntfThresholdRisingThreshold, rbnDhcpIntfThresholdName=rbnDhcpIntfThresholdName, rbnDhcpCtxThresholdSize=rbnDhcpCtxThresholdSize, rbnDhcpRangeThresholdEntry=rbnDhcpRangeThresholdEntry, rbnDhcpCtxThresholdFallingThreshold=rbnDhcpCtxThresholdFallingThreshold, rbnDhcpIntfThresholdEntry=rbnDhcpIntfThresholdEntry, rbnDhcpRangeThresholdFallingSendTrap=rbnDhcpRangeThresholdFallingSendTrap, rbnDhcpRangeThresholdSize=rbnDhcpRangeThresholdSize, rbnDhcpMib=rbnDhcpMib, rbnDhcpRangeThresholdInterfaceName=rbnDhcpRangeThresholdInterfaceName)

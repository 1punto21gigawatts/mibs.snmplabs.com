#
# PySNMP MIB module Fore-Callrecord-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-Callrecord-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:16:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
software, EntryStatus = mibBuilder.importSymbols("Fore-Common-MIB", "software", "EntryStatus")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Counter64, ObjectIdentity, IpAddress, Unsigned32, TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, iso, Bits, Integer32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter64", "ObjectIdentity", "IpAddress", "Unsigned32", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "iso", "Bits", "Integer32", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
crGroup = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1))
if mibBuilder.loadTexts: crGroup.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: crGroup.setOrganization('FORE')
if mibBuilder.loadTexts: crGroup.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: crGroup.setDescription('Fore call recording mib.')
crXfrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1))
crConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2))
crStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3))
perfConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 4))
crFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5))
class CrXfrTrapStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("crXfrNoError", 1), ("crXfrNoResponseFromServer", 2), ("crXfrAccessViolation", 3), ("crXfrDiskFullorAllocationExceeded", 4), ("crXfrOtherError", 5))

crXfrTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1), )
if mibBuilder.loadTexts: crXfrTable.setStatus('current')
if mibBuilder.loadTexts: crXfrTable.setDescription(' A table of feature-specific information pertaining to Callrecord transfers.')
crXfrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1), ).setIndexNames((0, "Fore-Callrecord-MIB", "crXfrIndex"))
if mibBuilder.loadTexts: crXfrEntry.setStatus('current')
if mibBuilder.loadTexts: crXfrEntry.setDescription(' A table entry containing information for Callrecord transfers from the switch(fabric) for a particular feature.')
crXfrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("callrecord", 1), ("performance", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrIndex.setStatus('current')
if mibBuilder.loadTexts: crXfrIndex.setDescription(' The index for a particular feature within the crXfrTable.')
crXfrPrimaryUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 2), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrPrimaryUrl.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryUrl.setDescription("This is the specification of the Primary URL for callrecord transfers. The URL is in the form: //<ip-address>[:port][<pathname>[<filename>]] This includes the IP address host to contact, and optionally the port on that host, the directory on that host to put the data into and the filename. The pathname and filename are each strings of characters with the following special tokens: Token Description _____ _______________________________________________________ %T SwitchType - identifies the type of switch. eg `vss' for Vector %N SwitchNumber - `SerialNumber.SwitchIndex' for a non-enclosure switch(fabric) or `EnclosureNumber.SwitchIndex' of a multi-fabric switch within an enclosure. The SwitchIndex is the slot number of the fabric within the enclosure(starting at 0). In the case of a non-enclosure switch, the SwitchIndex is always 0. %I SwitchIP - switch's IP address eg `169.144.1.90' %D DateTime - formatted as `YYMMDDhhmm'. %R RecordingInterval - elapsed time in minutes. %C CRType - identifies the contents of the file. - `account' for callrecord data - `stats' for Performance data %F FileStatus - status of the file. - `co' for file that switch(fabric) is currently writing to - `cc' for file that switch(fabric) has completed writing to If the pathname is not specified, the default file is transferred to the login directory specified by crXfrUserid. The following string will be used as the default filename in the case where the URL ends with a `/'(i.e. without any filename): %T_%C.%D.%R.%N.%F If multiple switches are to write to the same location, the pathname or filename should contain either a %I or a %N token. A %D token in the filename portion will separate each RecordingInterval worth of data into a different file with the name being the time the file was created. The following example would record every switch type and switch IP into a separate directory with a file at each RecordingInterval: //169.144.1.5/usr/auditlog/%T/%I/%D Given a Work Group switch with an IP address of 169.44.4.4, this would produce files in the following directory tree structure: /usr/auditlog/ASX200WG/169.44.4.4/9608252355 If the filename specified is not made up of the above tokens, then it is used as a prefix to the default filename. If the file transfer attempt fails, the switch will generate a trap and attempt a transfer to crXfrSecondaryUrl. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrSecondaryUrl = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 3), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrSecondaryUrl.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryUrl.setDescription("This is the specification of the Secondary URL for callrecord transfers. The URL is in the form: //<ip-address>[:port][<pathname>[<filename>]] Please refer to the crXfrPrimaryUrl for more details. This URL is to be used only if the transfer to crXfrPrimaryUrl is not successful. If the file transfer attempt to this URL also fails, the switch will generate a trap. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrRecordingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 4), Integer32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrRecordingInterval.setStatus('current')
if mibBuilder.loadTexts: crXfrRecordingInterval.setDescription("The interval (in minutes) at which the the relevant information is transferred to the host. The default setting will be 5 minutes. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 5), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrUserId.setStatus('obsolete')
if mibBuilder.loadTexts: crXfrUserId.setDescription("The userid to be used for the data transfer sessions to the primary and secondary data servers. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 6), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrPassword.setStatus('obsolete')
if mibBuilder.loadTexts: crXfrPassword.setDescription("The password to be used for the data transfer sessions to the primary and secondary data servers. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval. Note this object is write-only and reading it will result in implementation-specific results.")
crXfrTransferStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("primaryInProgress", 1), ("secondaryInProgress", 2), ("primarySucceeded", 3), ("secondarySucceeded", 4), ("bothFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrTransferStatus.setStatus('current')
if mibBuilder.loadTexts: crXfrTransferStatus.setDescription('A message describing the status of the current file transfer. If the data transfer is not successful, refer to the crXfrPrimaryTrapStatus or crXfrSecondaryTrapStatus.')
crXfrStatusText = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrStatusText.setStatus('current')
if mibBuilder.loadTexts: crXfrStatusText.setDescription('A message describing the status of the last file transfer.')
crXfrPrimaryTrapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 9), CrXfrTrapStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrPrimaryTrapStatus.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryTrapStatus.setDescription("The trap status of the file transfer to the primary URL. The trap status will be set to `crXfrNoError' at the start of the data transfer process and if the condition persists, a trap will be generated and the crXfrPrimaryTrapStatus updated to reflect the error condition.")
crXfrSecondaryTrapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 10), CrXfrTrapStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrSecondaryTrapStatus.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryTrapStatus.setDescription("The trap status of the file transfer to the secondary URL. The trap status will be set to `crXfrNoError' at the start of the data transfer process and if the condition persists, a trap will be generated and the crXfrSecondaryTrapStatus updated to reflect the error condition.")
crXfrPrimaryXfrFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrPrimaryXfrFailed.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryXfrFailed.setDescription('The number of failed data transfers to the primary data server')
crXfrSecondaryXfrFailed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crXfrSecondaryXfrFailed.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryXfrFailed.setDescription('The number of failed data transfers to the secondary data server')
crXfrEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 13), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrEntryStatus.setStatus('current')
if mibBuilder.loadTexts: crXfrEntryStatus.setDescription('The status of this entry in the crXfr table.')
crXfrPrimaryUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 14), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrPrimaryUserId.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryUserId.setDescription("The userid to be used for the data transfer session to the primary data server. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrPrimaryPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 15), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrPrimaryPassword.setStatus('current')
if mibBuilder.loadTexts: crXfrPrimaryPassword.setDescription("The password to be used for the data transfer session to the primary data server. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval. Note this object is write-only and reading it will result in implementation-specific results.")
crXfrSecondaryUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 16), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrSecondaryUserId.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryUserId.setDescription("The userid to be used for the data transfer session to the secondary data server. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval.")
crXfrSecondaryPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 1, 1, 1, 17), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crXfrSecondaryPassword.setStatus('current')
if mibBuilder.loadTexts: crXfrSecondaryPassword.setDescription("The password to be used for the data transfer session to the secondary data server. If crAdminStatus is `on' and this value is changed, the change goes into effect at the next aligned crXfrRecordingInterval. Note this object is write-only and reading it will result in implementation-specific results.")
crAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crAdminStatus.setStatus('current')
if mibBuilder.loadTexts: crAdminStatus.setDescription('Specifies whether Callrecord is On or Off. By default, it is set to Off. If it is changed, the change takes effect immediately. ')
crMemoryAllocated = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crMemoryAllocated.setStatus('obsolete')
if mibBuilder.loadTexts: crMemoryAllocated.setDescription("A percentage specifying what portion of the mainheap (connection or user space) is to be reserved for Callrecords. The default setting will be 15%. This variable can be set to any value between 1% and 50%. Configuration of this value will affect memory available to signaling, routing and may result in increased call blocking. Engineering information will be provided as part of the deployment procedures. A change in this MIB value will be effective only after the next Callrecord initialization. (i.e. when the crAdminStatus changes from `off' to `on' the switch(fabric) is rebooted)")
crMemOflowAction = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rejectCall", 1), ("dontRecordCall", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crMemOflowAction.setStatus('current')
if mibBuilder.loadTexts: crMemOflowAction.setDescription('This specifies the action that the switch(fabric) should take if the memory allocated for Callrecord runs out. rejectCall(1) specifies that the call should be rejected. dontRecordCall(2) specifies that the call should be allowed with no callrecord being generated for that call. The default setting will be rejectCall(1). If it is changed, the change takes effect immediately. ')
crAdminMinRecords = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crAdminMinRecords.setStatus('current')
if mibBuilder.loadTexts: crAdminMinRecords.setDescription('This specifies the minimum number of call records which will be stored in the pool memory. Specifying a value of 0 implies that the default value for this variable will be set. ')
crAdminMaxRecords = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crAdminMaxRecords.setStatus('current')
if mibBuilder.loadTexts: crAdminMaxRecords.setDescription('This specifies the maximum number of call records which could be stored in the pool memory. A value of 0 implies that the Call Records pool size is only limited by the amount of memory in the system. ')
crOperRecords = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crOperRecords.setStatus('current')
if mibBuilder.loadTexts: crOperRecords.setDescription('This specifies the number of call records which are currently stored in the pool memory.')
crAdminMinDTBs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crAdminMinDTBs.setStatus('current')
if mibBuilder.loadTexts: crAdminMinDTBs.setDescription('This specifies the minimum number of data transfer buffers which will be stored in the pool memory. Specifying a value of 0 implies that the default value for this variable will be set. ')
crAdminMaxDTBs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: crAdminMaxDTBs.setStatus('current')
if mibBuilder.loadTexts: crAdminMaxDTBs.setDescription('This specifies the maximum number of data transfer buffers which could be stored in the pool memory. A value of 0 implies that the DTB pool size is only limited by the amount of memory in the system. ')
crOperDTBs = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crOperDTBs.setStatus('current')
if mibBuilder.loadTexts: crOperDTBs.setDescription('This specifies the number of data transfer buffers which are currently stored in the pool memory.')
crOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("shutting-down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: crOperStatus.setStatus('current')
if mibBuilder.loadTexts: crOperStatus.setDescription('Specifies whether Callrecord is Operationally active, inactive or is in the processs of shutting down. Shutting sown occurs when call recording has been administratively disabled but is currently in the midst of an ftp transfer.')
crCounterCollectionInterval = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crCounterCollectionInterval.setStatus('current')
if mibBuilder.loadTexts: crCounterCollectionInterval.setDescription('The interval (in seconds) at which the relevant hardware counters will be collected and maintained. These counter values will be transferred to the host at every crXfrRecordingInterval minutes. The default setting will be the value configured for crXfrRecordingInterval in seconds. Valid values for this variable would range from 10 seconds to crXfrRecordingInterval value in seconds. Modifying this value is only applicable for the ASX 4000 platform. Setting this value to greater than the crXfrRecordingInterval value in seconds implies that hardware counters will only be collected every crXfrRecordingInterval minutes. If crAdminStatus is on and this value is changed, the change goes into effect at the next crCounterCollectionInterval.')
crCallsRejected = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crCallsRejected.setStatus('current')
if mibBuilder.loadTexts: crCallsRejected.setDescription('The number of calls rejected due to failure to allocate a callrecord.')
crCallsNotRecorded = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crCallsNotRecorded.setStatus('current')
if mibBuilder.loadTexts: crCallsNotRecorded.setDescription('The number of calls accepted even when there was a failure to allocate a callrecord.')
crCallsOpened = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crCallsOpened.setStatus('current')
if mibBuilder.loadTexts: crCallsOpened.setDescription("The number of calls for which a `start' callrecord was successfully generated.")
crIntervalsSkipped = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crIntervalsSkipped.setStatus('current')
if mibBuilder.loadTexts: crIntervalsSkipped.setDescription('The number of skipped data transfers due to preceding data transfers not complete within the recording interval')
crTermCallsLost = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crTermCallsLost.setStatus('current')
if mibBuilder.loadTexts: crTermCallsLost.setDescription('The number of terminated callrecords lost due to failure to allocate a data transfer buffer')
crUpTime = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crUpTime.setStatus('current')
if mibBuilder.loadTexts: crUpTime.setDescription(' The time in hundredths of a second since Callrecord has been on at the primary, secondary or both sides. This value along with the counters are reset when the crAdminStatus is modified.')
crCurrentCallsRecorded = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 3, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crCurrentCallsRecorded.setStatus('current')
if mibBuilder.loadTexts: crCurrentCallsRecorded.setDescription(' The total number of calls currently being recorded.')
perfAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: perfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: perfAdminStatus.setDescription('Specifies whether performance monitoring is On or Off. By default, it is set to Off. If it is changed, the change takes effect immediately. ')
crFilterTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1), )
if mibBuilder.loadTexts: crFilterTable.setStatus('current')
if mibBuilder.loadTexts: crFilterTable.setDescription(' A table of filters for which call records are to be generated.')
crFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1), ).setIndexNames((0, "Fore-Callrecord-MIB", "crFilterPort"), (0, "Fore-Callrecord-MIB", "crFilterVpi"), (0, "Fore-Callrecord-MIB", "crFilterVci"))
if mibBuilder.loadTexts: crFilterEntry.setStatus('current')
if mibBuilder.loadTexts: crFilterEntry.setDescription(' A table entry containing a filter for applying to call recording.')
crFilterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crFilterPort.setStatus('current')
if mibBuilder.loadTexts: crFilterPort.setDescription(' The Port index for a particular feature within the crFilterTable is to be set.A Value of 16777215 signifies ANY PORT. ')
crFilterVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crFilterVpi.setStatus('current')
if mibBuilder.loadTexts: crFilterVpi.setDescription(' The Vpi index for a particular feature within the crFilterTable is to be set.A Value of 16777215 signifies ANY VPI. However the ANY VPI value can only be used if the port specified is ANY PORT. ')
crFilterVci = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: crFilterVci.setStatus('current')
if mibBuilder.loadTexts: crFilterVci.setDescription(' The Vci index for a particular feature within the crFilterTable is to be set. A Value of 16777215 signifies ANY VCI. However the value of ANY VCI can only be used if the port specified is ANY PORT and the vpi specified is ANY VPI. ')
crFilterPVCSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterPVCSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterPVCSupport.setDescription('Specifies if PVCs on this interface are to be recorded. ')
crFilterPVPSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterPVPSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterPVPSupport.setDescription('Specifies if PVPs on this interface are to be recorded. ')
crFilterSVCSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterSVCSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterSVCSupport.setDescription('Specifies if SVCs on this interface are to be recorded. ')
crFilterSVPSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterSVPSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterSVPSupport.setDescription('Specifies if SVPs on this interface are to be recorded. ')
crFilterSPVCSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterSPVCSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterSPVCSupport.setDescription('Specifies if SPVCs on this interface are to be recorded. ')
crFilterSPVPSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterSPVPSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterSPVPSupport.setDescription('Specifies if SPVPs on this interface are to be recorded. ')
crFilterFailedCallSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("unspecified", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterFailedCallSupport.setStatus('current')
if mibBuilder.loadTexts: crFilterFailedCallSupport.setDescription('Specifies if Failed Calls on this interface are to be recorded. ')
crFilterEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 2, 2, 3, 1, 5, 1, 1, 11), EntryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: crFilterEntryStatus.setStatus('current')
if mibBuilder.loadTexts: crFilterEntryStatus.setDescription('The SNMP status of this Expansion entry.')
mibBuilder.exportSymbols("Fore-Callrecord-MIB", crXfrIndex=crXfrIndex, crFilterGroup=crFilterGroup, CrXfrTrapStatus=CrXfrTrapStatus, crCounterCollectionInterval=crCounterCollectionInterval, crAdminMinRecords=crAdminMinRecords, crXfrSecondaryUserId=crXfrSecondaryUserId, crFilterPort=crFilterPort, crXfrGroup=crXfrGroup, crFilterSVPSupport=crFilterSVPSupport, crFilterVci=crFilterVci, crCallsNotRecorded=crCallsNotRecorded, crAdminMaxDTBs=crAdminMaxDTBs, crXfrPrimaryUrl=crXfrPrimaryUrl, crAdminMinDTBs=crAdminMinDTBs, perfConfGroup=perfConfGroup, crXfrPassword=crXfrPassword, crConfGroup=crConfGroup, crAdminStatus=crAdminStatus, crCallsOpened=crCallsOpened, crFilterTable=crFilterTable, crFilterPVCSupport=crFilterPVCSupport, crCurrentCallsRecorded=crCurrentCallsRecorded, crIntervalsSkipped=crIntervalsSkipped, perfAdminStatus=perfAdminStatus, crXfrStatusText=crXfrStatusText, crFilterSPVPSupport=crFilterSPVPSupport, crXfrTransferStatus=crXfrTransferStatus, crXfrTable=crXfrTable, crMemoryAllocated=crMemoryAllocated, crFilterVpi=crFilterVpi, crGroup=crGroup, crUpTime=crUpTime, crFilterSVCSupport=crFilterSVCSupport, crXfrEntry=crXfrEntry, crCallsRejected=crCallsRejected, crXfrPrimaryXfrFailed=crXfrPrimaryXfrFailed, PYSNMP_MODULE_ID=crGroup, crXfrSecondaryTrapStatus=crXfrSecondaryTrapStatus, crXfrPrimaryUserId=crXfrPrimaryUserId, crOperRecords=crOperRecords, crFilterEntry=crFilterEntry, crXfrEntryStatus=crXfrEntryStatus, crFilterSPVCSupport=crFilterSPVCSupport, crXfrPrimaryTrapStatus=crXfrPrimaryTrapStatus, crXfrPrimaryPassword=crXfrPrimaryPassword, crFilterFailedCallSupport=crFilterFailedCallSupport, crStatsGroup=crStatsGroup, crXfrSecondaryPassword=crXfrSecondaryPassword, crXfrRecordingInterval=crXfrRecordingInterval, crAdminMaxRecords=crAdminMaxRecords, crXfrUserId=crXfrUserId, crMemOflowAction=crMemOflowAction, crOperDTBs=crOperDTBs, crOperStatus=crOperStatus, crFilterPVPSupport=crFilterPVPSupport, crFilterEntryStatus=crFilterEntryStatus, crXfrSecondaryXfrFailed=crXfrSecondaryXfrFailed, crTermCallsLost=crTermCallsLost, crXfrSecondaryUrl=crXfrSecondaryUrl)

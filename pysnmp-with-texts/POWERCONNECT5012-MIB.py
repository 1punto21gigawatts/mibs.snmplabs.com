#
# PySNMP MIB module POWERCONNECT5012-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/POWERCONNECT5012-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:41:33 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, ObjectIdentity, MibIdentifier, Unsigned32, TimeTicks, enterprises, Counter32, iso, Counter64, Bits, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, mib_2, IpAddress, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "Unsigned32", "TimeTicks", "enterprises", "Counter32", "iso", "Counter64", "Bits", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "mib-2", "IpAddress", "Integer32")
PhysAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "DisplayString", "TextualConvention")
dell = MibIdentifier((1, 3, 6, 1, 4, 1, 674))
dellLan = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895))
powerconnect5012 = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2))
class OwnerString(DisplayString):
    pass

class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

dellCommGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1))
dellHostGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2))
dellMiscGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 3))
dellSpanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 4))
dellConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11))
dellVlanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13))
dellPortTrunkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14))
commTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1), )
if mibBuilder.loadTexts: commTable.setStatus('mandatory')
if mibBuilder.loadTexts: commTable.setDescription('A list of SNMP Community Entries ')
commEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "commIndex"))
if mibBuilder.loadTexts: commEntry.setStatus('mandatory')
if mibBuilder.loadTexts: commEntry.setDescription('A list of SNMP Community properties')
commIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: commIndex.setStatus('mandatory')
if mibBuilder.loadTexts: commIndex.setDescription('An index that uniquely identifies an entry in the Community Table. Eight entries are currently supported.')
commName = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commName.setStatus('mandatory')
if mibBuilder.loadTexts: commName.setDescription('The name of this SNMP Community Entry.')
commGet = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commGet.setStatus('mandatory')
if mibBuilder.loadTexts: commGet.setDescription('The GET permission for the community. A (1) indicates a GET enable. A (2) indicates a GET disable.')
commSet = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commSet.setStatus('mandatory')
if mibBuilder.loadTexts: commSet.setDescription('The SET permission for the community. A (1) indicates a SET enable. A (2) indicates a SET disable.')
commTrap = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commTrap.setStatus('mandatory')
if mibBuilder.loadTexts: commTrap.setDescription('The TRAP permission for the community. A (1) indicates a TRAP enable. A (2) indicates a TRAP disable.')
commStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: commStatus.setStatus('mandatory')
if mibBuilder.loadTexts: commStatus.setDescription('The RowStatus for the community entry.')
hostTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1), )
if mibBuilder.loadTexts: hostTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostTable.setDescription('A list of SNMP Trusted Host Entries ')
hostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "hostIndex"))
if mibBuilder.loadTexts: hostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostEntry.setDescription('A list of SNMP Host properties')
hostIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIndex.setStatus('mandatory')
if mibBuilder.loadTexts: hostIndex.setDescription('An index that uniquely identifies an entry in the Host Table. Sixteen entries are currently supported.')
hostName = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostName.setStatus('mandatory')
if mibBuilder.loadTexts: hostName.setDescription('The name of this Host Entry.')
hostIP = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostIP.setStatus('mandatory')
if mibBuilder.loadTexts: hostIP.setDescription('The IP Address for the host.')
hostComm = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostComm.setStatus('mandatory')
if mibBuilder.loadTexts: hostComm.setDescription('The name of the community this host belongs to.')
hostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hostStatus.setDescription('The RowStatus for the community entry.')
hostAuthorization = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostAuthorization.setStatus('mandatory')
if mibBuilder.loadTexts: hostAuthorization.setDescription('If enabled, the host must be in the hostTable in order to access the device via SNMP.')
miscBaud = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: miscBaud.setStatus('mandatory')
if mibBuilder.loadTexts: miscBaud.setDescription('The Serial port BAUD Rate.')
miscReset = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: miscReset.setStatus('mandatory')
if mibBuilder.loadTexts: miscReset.setDescription('Physically resets the unit - use with care. A (1) resets the unit, a (2) does nothing.')
miscStatisticsReset = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: miscStatisticsReset.setStatus('mandatory')
if mibBuilder.loadTexts: miscStatisticsReset.setDescription('Resets the units statistics. A (1) resets the unit, a (2) does nothing.')
miscSwitchOperState = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("ok", 3), ("noncritical", 4), ("critical", 5), ("nonrecoverable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: miscSwitchOperState.setStatus('current')
if mibBuilder.loadTexts: miscSwitchOperState.setDescription('Global operation state of the switch.')
spanOnOff = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: spanOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: spanOnOff.setDescription('Enable/Disable Spanning Tree. A (1) enables, a (2) disables.')
configVerSwPrimary = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configVerSwPrimary.setStatus('mandatory')
if mibBuilder.loadTexts: configVerSwPrimary.setDescription('The software image version string')
configVerHwChipSet = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configVerHwChipSet.setStatus('mandatory')
if mibBuilder.loadTexts: configVerHwChipSet.setDescription('The hardware chipset version string')
configBootMode = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flash", 1), ("net", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configBootMode.setStatus('mandatory')
if mibBuilder.loadTexts: configBootMode.setDescription('Defines the method used for downloading the image when reset.')
configBootFtpServerIp = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configBootFtpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: configBootFtpServerIp.setDescription("The FTP server's IP address used for downloading the boot image")
configBootImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configBootImageFileName.setStatus('mandatory')
if mibBuilder.loadTexts: configBootImageFileName.setDescription('The path and filename of the boot image to download')
configPortTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6), )
if mibBuilder.loadTexts: configPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: configPortTable.setDescription('A list of interface entries used for enterprise specific configuration. The number of entries is given by the value of ifNumber. All interface entries are assumed to be Ethernet interafaces.')
configPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "configPort"))
if mibBuilder.loadTexts: configPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configPortEntry.setDescription('An enterprise specific interface entry.')
configPort = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPort.setStatus('mandatory')
if mibBuilder.loadTexts: configPort.setDescription('A unique value for each interface that correlates to ifIndex. Its value ranges between 1 and the value of ifNumber.')
configPortDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half-duplex", 1), ("full-duplex", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: configPortDuplex.setDescription("The port's duplex desired state.")
configPortRuntFilt = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortRuntFilt.setStatus('mandatory')
if mibBuilder.loadTexts: configPortRuntFilt.setDescription('Defines whether the port will drop runt packets')
configPortSrcSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortSrcSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: configPortSrcSecurity.setDescription("The desired state for an interface's source security.")
configPortDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("rate10Meg", 1), ("rate100Meg", 2), ("rate1Gig", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: configPortDataRate.setDescription("The port's desired transmission data rate.")
configForwardingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("store-and-forward", 1), ("cut-through", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configForwardingMode.setStatus('mandatory')
if mibBuilder.loadTexts: configForwardingMode.setDescription("Indicates whether the packets will receive the entire packet before forwarding. 'store-and-forward' receives the entire packet before forwarding. 'cut-through' may forward the packet before the entire packet is received.")
configPortDuplexOper = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("half-duplex", 1), ("full-duplex", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPortDuplexOper.setStatus('mandatory')
if mibBuilder.loadTexts: configPortDuplexOper.setDescription("The port's duplex state.")
configPortDataRateOper = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("rate10Meg", 1), ("rate100Meg", 2), ("rate1Gig", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPortDataRateOper.setStatus('mandatory')
if mibBuilder.loadTexts: configPortDataRateOper.setDescription("The port's transmission data rate.")
configPortStateOper = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPortStateOper.setStatus('mandatory')
if mibBuilder.loadTexts: configPortStateOper.setDescription("The port's current state.")
configPortFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: configPortFlowControl.setDescription('The port will avoid transmitting a new packet for the period of time specified in a received PAUSE packet when enabled.')
configPortDefaultVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortDefaultVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: configPortDefaultVlanId.setDescription('The port will add this vlan id tag to any incoming packet which is lacking a vlan id tag.')
configPortComments = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortComments.setStatus('mandatory')
if mibBuilder.loadTexts: configPortComments.setDescription('May contain any comments related to a given port such as a user name or LAN segment.')
configPortAutoNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortAutoNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: configPortAutoNegotiation.setDescription("The port will perform auto-negotiation to determine the port's duplex and data rate. When auto-negotiation is enabled, the negotiated duplex and data rate can be determined by configPortDuplexOper and configPortDataRateOper mib objects respectively.")
configPortHOLBlocking = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortHOLBlocking.setStatus('mandatory')
if mibBuilder.loadTexts: configPortHOLBlocking.setDescription('When enabled, the port will prevent head-of-line blocking from occuring. If the current port is to forward a packet to a port which is beleived to be blocked, the packet will be dropped instead of forwarded.')
configPortFlowControlOper = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPortFlowControlOper.setStatus('mandatory')
if mibBuilder.loadTexts: configPortFlowControlOper.setDescription("The port's current flow control state.")
configPortGBIC = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortGBIC.setStatus('mandatory')
if mibBuilder.loadTexts: configPortGBIC.setDescription('Port Type.')
configPortFastLink = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortFastLink.setStatus('mandatory')
if mibBuilder.loadTexts: configPortFastLink.setDescription("The port's FastLink option.")
configPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 6, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("high", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: configPortPriority.setDescription("The port's current flow control state.")
configRmonOnOff = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRmonOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: configRmonOnOff.setDescription('Enable or disable Remote Montioring, RMON.')
configMirroringOnOff = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMirroringOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: configMirroringOnOff.setDescription('Enable or disable port mirroring.')
configMirrorSrc = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMirrorSrc.setStatus('mandatory')
if mibBuilder.loadTexts: configMirrorSrc.setDescription('When mirroring is enabled (configMirroringOnOff = enabled), this identifies the mirroring source port. This value has a valid range of 1 to ifNumber when enbaled.')
configMirrorMon = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMirrorMon.setStatus('mandatory')
if mibBuilder.loadTexts: configMirrorMon.setDescription('When mirroring is enabled (configMirroringOnOff = enabled), this identifies the mirroring monitoring port. This value has a valid range of 1 to ifNumber when enabled.')
configIpAssignmentMode = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manual", 1), ("bootP", 2), ("dhcp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpAssignmentMode.setStatus('mandatory')
if mibBuilder.loadTexts: configIpAssignmentMode.setDescription('Indicates whether the device address is assigned by the user (manual), BootP, or DHCP.')
configPhysAddress = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configPhysAddress.setDescription("The interface's address at the protocol layer immediately 'below' the network layer in the protocol stack. This is the physical address for the end-station.")
configPasswordUser = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: configPasswordUser.setStatus('mandatory')
if mibBuilder.loadTexts: configPasswordUser.setDescription('The user password.')
configPasswordAdmin = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: configPasswordAdmin.setStatus('mandatory')
if mibBuilder.loadTexts: configPasswordAdmin.setDescription('The adminstrator password')
configIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configIpAddress.setDescription('The IP Address for the RDU box.')
configNetMask = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: configNetMask.setDescription('The network mask for the RDU box.')
configGateway = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 18), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configGateway.setStatus('mandatory')
if mibBuilder.loadTexts: configGateway.setDescription('The Gatway Address for the RDU box.')
configSave = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("save", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configSave.setStatus('mandatory')
if mibBuilder.loadTexts: configSave.setDescription('Physically saves the current configuration to nvram. - use with care. (1) saves the configuration (2) does nothing.')
configVerifyPassword = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: configVerifyPassword.setStatus('mandatory')
if mibBuilder.loadTexts: configVerifyPassword.setDescription('Verify the password is valid. If invalid a BAD_VALUE error is returned.')
configVerBootRomImage = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configVerBootRomImage.setStatus('mandatory')
if mibBuilder.loadTexts: configVerBootRomImage.setDescription('The Boot ROM version string')
configRestoreDefaults = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restore", 1), ("noop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRestoreDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: configRestoreDefaults.setDescription('Restores the configuration of the unit to the original settings.')
configIGMPOnOff = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIGMPOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: configIGMPOnOff.setDescription('Enable or disable the IGMP protocol within the switch.')
configWebOnOff = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configWebOnOff.setStatus('mandatory')
if mibBuilder.loadTexts: configWebOnOff.setDescription('Enable or disable the Web Interface.')
configHighPriorityOptimization = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configHighPriorityOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: configHighPriorityOptimization.setDescription('Enable or disable high priority optimization.')
configDynamicAddressLearning = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDynamicAddressLearning.setStatus('mandatory')
if mibBuilder.loadTexts: configDynamicAddressLearning.setDescription('The ablility to learn dynamic addresses automatically. With this parameter disabled, a new address detected on a port will cause that port to be disabled, force a configuration save, and issue a trap alerting management stations of the intrusion.')
configUserAuthenticationMode = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 1), ("localThenRemote", 2), ("remoteThenLocal", 3), ("remote", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configUserAuthenticationMode.setStatus('mandatory')
if mibBuilder.loadTexts: configUserAuthenticationMode.setDescription('Determines whether the user password will be authenticated by the switch, a remote RADIUS server, or some combination of the two.')
configRadiusServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 28), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRadiusServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configRadiusServerIpAddress.setDescription('The IP Address of the RADIUS server used for remote user authentication.')
configRadiusSharedSecret = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRadiusSharedSecret.setStatus('mandatory')
if mibBuilder.loadTexts: configRadiusSharedSecret.setDescription('A string of characters used in the RADIUS password encryption process.')
configTelnetConsole = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTelnetConsole.setStatus('mandatory')
if mibBuilder.loadTexts: configTelnetConsole.setDescription('Enable or disable the telnet console.')
configDiffServTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 31), )
if mibBuilder.loadTexts: configDiffServTable.setStatus('mandatory')
if mibBuilder.loadTexts: configDiffServTable.setDescription('A list of DSCP Priorities.')
configDiffServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 31, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "configDiffServDSCP"))
if mibBuilder.loadTexts: configDiffServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configDiffServEntry.setDescription('An enterprise specific DSCP entry.')
configDiffServDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 31, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configDiffServDSCP.setStatus('mandatory')
if mibBuilder.loadTexts: configDiffServDSCP.setDescription('A DSCP value.')
configDiffServPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 31, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("high", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDiffServPriority.setStatus('mandatory')
if mibBuilder.loadTexts: configDiffServPriority.setDescription("The DSCP's current priority setting.")
configTftpServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 32), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTftpServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configTftpServerIpAddress.setDescription('The IP Address of the tftp server used to upload and download configuration files. This object is to be used in conjunction with configTftpServerFileName and configTftpOperation.')
configTftpServerFileName = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 33), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTftpServerFileName.setStatus('mandatory')
if mibBuilder.loadTexts: configTftpServerFileName.setDescription('The filename, including the path, used to store or retrieve a configuration file from the tftp server. This object is to be used in conjunction with configTftpServerIpAddress and configTftpOperation.')
configTftpOperation = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("download", 1), ("upload", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configTftpOperation.setStatus('mandatory')
if mibBuilder.loadTexts: configTftpOperation.setDescription('The tftp operation to perform. Either download a configuration to the unit or upload the current configuration to the tftp server. This object is to be used in conjunction with configTftpServerIpAddress and configTftpServerFileName.')
configIpFilter = MibScalar((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpFilter.setStatus('mandatory')
if mibBuilder.loadTexts: configIpFilter.setDescription('Determines if access to the device is limited to only those IP addresses specified in the configIpFilterTable.')
configIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 36), )
if mibBuilder.loadTexts: configIpFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: configIpFilterTable.setDescription('A list of IP addresses allowed access to this device.')
configIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 36, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "configIpFilterIpAddress"))
if mibBuilder.loadTexts: configIpFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configIpFilterEntry.setDescription('An enterprise specific IP filter entry.')
configIpFilterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 36, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configIpFilterIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: configIpFilterIpAddress.setDescription('An IP address which is allowed access to this device.')
configIpFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 11, 36, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6))).clone(namedValues=NamedValues(("active", 1), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configIpFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configIpFilterStatus.setDescription('The status of an entry in the IP filter Table. Only a subset of the rowstatus variables (active, destroy) are available.')
vlanTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 1), )
if mibBuilder.loadTexts: vlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTable.setDescription('A list of the VLANs')
vlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 1, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "vlanId"))
if mibBuilder.loadTexts: vlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanEntry.setDescription('A VLAN entry containing the VLAN id and name.')
vlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanId.setDescription('The VLAN identifier. A maximum of 16 VLANs is supported. The value must be from 0 to 4095.')
vlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanName.setDescription('The VLAN name associated with the VLAN Id.')
vlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vlanStatus.setDescription('The status of an entry in the VLAN Table. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available.')
vlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2), )
if mibBuilder.loadTexts: vlanPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortTable.setDescription('A list of ports and their associated VLAN.')
vlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "vlanPortPortId"), (0, "POWERCONNECT5012-MIB", "vlanPortVlanId"))
if mibBuilder.loadTexts: vlanPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortEntry.setDescription('Information pertaining to an individual port regarding to which VLAN it belongs.')
vlanPortPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortPortId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortPortId.setDescription('A port identifier that is in the range of 1 to ifNumber.')
vlanPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortVlanId.setDescription('The VLAN identifier.')
vlanPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6))).clone(namedValues=NamedValues(("active", 1), ("createAndGo", 4), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortStatus.setDescription("The status of this port's association within this VLAN. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available.")
vlanPortTaggedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("untagged", 1), ("tagged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vlanPortTaggedMode.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortTaggedMode.setDescription('The tagged mode of a VLAN port.')
portTrunkTable = MibTable((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14, 1), )
if mibBuilder.loadTexts: portTrunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTrunkTable.setDescription('A list of port trunks and their associated members.')
portTrunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14, 1, 1), ).setIndexNames((0, "POWERCONNECT5012-MIB", "portTrunkId"), (0, "POWERCONNECT5012-MIB", "portTrunkMember"))
if mibBuilder.loadTexts: portTrunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portTrunkEntry.setDescription('A port trunk entry containing the trunk id and trunk members.')
portTrunkId = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTrunkId.setStatus('mandatory')
if mibBuilder.loadTexts: portTrunkId.setDescription('The port trunk identifier. The current range is from 1 to 4.')
portTrunkMember = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTrunkMember.setStatus('mandatory')
if mibBuilder.loadTexts: portTrunkMember.setDescription('A port trunk has four members.')
portTrunkMemberValue = MibTableColumn((1, 3, 6, 1, 4, 1, 674, 10895, 2, 14, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrunkMemberValue.setStatus('mandatory')
if mibBuilder.loadTexts: portTrunkMemberValue.setDescription('A port trunk member value indicates which port is a member of the specified trunk. Valid values are in the range from 0 to ifNumber. A zero indicates that no port is contained in the specifed member.')
addressIntrusion = NotificationType((1, 3, 6, 1, 4, 1, 674) + (0,0)).setObjects(("POWERCONNECT5012-MIB", "ifIndex"))
if mibBuilder.loadTexts: addressIntrusion.setDescription('An addressIntrusion trap signifies that an unauthorized address has been seen on the network.')
mibBuilder.exportSymbols("POWERCONNECT5012-MIB", configUserAuthenticationMode=configUserAuthenticationMode, portTrunkMember=portTrunkMember, commIndex=commIndex, configGateway=configGateway, commName=commName, configPortGBIC=configPortGBIC, configPasswordUser=configPasswordUser, configWebOnOff=configWebOnOff, miscBaud=miscBaud, miscStatisticsReset=miscStatisticsReset, configIpAddress=configIpAddress, configHighPriorityOptimization=configHighPriorityOptimization, hostEntry=hostEntry, addressIntrusion=addressIntrusion, vlanName=vlanName, configPortAutoNegotiation=configPortAutoNegotiation, configRmonOnOff=configRmonOnOff, configMirrorSrc=configMirrorSrc, vlanPortVlanId=vlanPortVlanId, configNetMask=configNetMask, commStatus=commStatus, vlanPortPortId=vlanPortPortId, portTrunkMemberValue=portTrunkMemberValue, portTrunkId=portTrunkId, hostIP=hostIP, hostTable=hostTable, dellMiscGroup=dellMiscGroup, configPortFlowControlOper=configPortFlowControlOper, configPortDataRateOper=configPortDataRateOper, dell=dell, configMirroringOnOff=configMirroringOnOff, configSave=configSave, configPortComments=configPortComments, configRadiusSharedSecret=configRadiusSharedSecret, configVerSwPrimary=configVerSwPrimary, configIpAssignmentMode=configIpAssignmentMode, hostName=hostName, spanOnOff=spanOnOff, vlanTable=vlanTable, configPortDuplexOper=configPortDuplexOper, configIpFilterEntry=configIpFilterEntry, vlanStatus=vlanStatus, configIpFilterTable=configIpFilterTable, powerconnect5012=powerconnect5012, configTftpServerIpAddress=configTftpServerIpAddress, configPortEntry=configPortEntry, configIGMPOnOff=configIGMPOnOff, dellVlanGroup=dellVlanGroup, configVerHwChipSet=configVerHwChipSet, hostComm=hostComm, dellConfigGroup=dellConfigGroup, configDiffServPriority=configDiffServPriority, vlanId=vlanId, configDiffServEntry=configDiffServEntry, configBootFtpServerIp=configBootFtpServerIp, configBootImageFileName=configBootImageFileName, configIpFilterStatus=configIpFilterStatus, configPortFastLink=configPortFastLink, miscReset=miscReset, vlanPortTaggedMode=vlanPortTaggedMode, configPortRuntFilt=configPortRuntFilt, commTable=commTable, configTftpOperation=configTftpOperation, configForwardingMode=configForwardingMode, configPhysAddress=configPhysAddress, configVerifyPassword=configVerifyPassword, configDiffServDSCP=configDiffServDSCP, commTrap=commTrap, configPortSrcSecurity=configPortSrcSecurity, configRestoreDefaults=configRestoreDefaults, miscSwitchOperState=miscSwitchOperState, dellCommGroup=dellCommGroup, configPasswordAdmin=configPasswordAdmin, hostIndex=hostIndex, configPortHOLBlocking=configPortHOLBlocking, configDiffServTable=configDiffServTable, configPort=configPort, configBootMode=configBootMode, configIpFilter=configIpFilter, configVerBootRomImage=configVerBootRomImage, commSet=commSet, OwnerString=OwnerString, configPortPriority=configPortPriority, vlanPortTable=vlanPortTable, dellPortTrunkGroup=dellPortTrunkGroup, configPortDefaultVlanId=configPortDefaultVlanId, MacAddress=MacAddress, configDynamicAddressLearning=configDynamicAddressLearning, configTelnetConsole=configTelnetConsole, configPortFlowControl=configPortFlowControl, configIpFilterIpAddress=configIpFilterIpAddress, hostAuthorization=hostAuthorization, configPortDataRate=configPortDataRate, portTrunkEntry=portTrunkEntry, dellLan=dellLan, commEntry=commEntry, configPortStateOper=configPortStateOper, configPortDuplex=configPortDuplex, vlanPortStatus=vlanPortStatus, dellSpanGroup=dellSpanGroup, portTrunkTable=portTrunkTable, vlanEntry=vlanEntry, hostStatus=hostStatus, vlanPortEntry=vlanPortEntry, configRadiusServerIpAddress=configRadiusServerIpAddress, dellHostGroup=dellHostGroup, configTftpServerFileName=configTftpServerFileName, configMirrorMon=configMirrorMon, configPortTable=configPortTable, commGet=commGet)

#
# PySNMP MIB module IPSECV1-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPSECV1-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:35 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Unsigned32, Counter32, IpAddress, ObjectIdentity, TimeTicks, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, enterprises, iso, Gauge32, Integer32, ModuleIdentity, NotificationType, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Unsigned32", "Counter32", "IpAddress", "ObjectIdentity", "TimeTicks", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "enterprises", "iso", "Gauge32", "Integer32", "ModuleIdentity", "NotificationType", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class IPSIpAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )
ibmIROCroutingIpSec = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9))
ipSecLevels = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 1))
ipSecPhaseOne = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2))
ipSecPhaseTwo = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3))
ipSecHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4))
ipSecTrapCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5))
ipSecMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecMibLevel.setDescription('The level of the IBM IPSec MIB.')
ikeTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1), )
if mibBuilder.loadTexts: ikeTunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelTable.setDescription('The objects defined in this table are used to for the management of IKE (Phase-1) Tunnel. There is one entry in this table for each Phase-1 Tunnel.')
ikeTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1), ).setIndexNames((0, "IPSECV1-MIB", "ikeTunnelIndex"))
if mibBuilder.loadTexts: ikeTunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelEntry.setDescription('Each entry contains attributes associated with a Phase-1 IKE tunnel.')
ikeTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelIndex.setDescription('The index of the Phase-1 Tunnel table. The value of the index is a number which begins at one and is incremented with each tunnel that is created. The value of this object will wrap at 65535.')
ikeTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelId.setDescription('The internal ID of the Phase-1 Tunnel.')
ikeTunnelLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 3), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelLocalAddr.setDescription('The local IP Address the Phase-1 Tunnel.')
ikeTunnelLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelLocalName.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelLocalName.setDescription('The local name of the Phase-1 Tunnel.')
ikeTunnelRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelRemoteAddr.setDescription('The local IP Address the Phase-1 Tunnel.')
ikeTunnelRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelRemoteName.setDescription('The remote name of the Phase-1 Tunnel.')
ikeTunnelNegoMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("main", 1), ("aggressive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelNegoMode.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelNegoMode.setDescription('The negotiation mode of the Phase-1 Tunnel.')
ikeTunnelLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelLifetime.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelLifetime.setDescription('The lifetime of the Phase-1 Tunnel in seconds.')
ikeTunnelActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelActiveTime.setDescription('The length of time the tunnel has been active in hundredths of seconds.')
ikeTunnelSaRefreshThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelSaRefreshThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelSaRefreshThreshold.setDescription('The security association refresh threshold percentage of the Phase-1 Tunnel.')
ikeTunnelTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelTotalRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelTotalRefreshes.setDescription('The total number of security associations refreshes completed.')
ikeTunnelInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInOctets.setDescription('The total number of octets received by this Phase-1 Tunnel.')
ikeTunnelInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInPkts.setDescription('The total number of packets received by this Phase-1 Tunnel.')
ikeTunnelInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInDropPkts.setDescription('The total number of packets dropped by this Phase-1 Tunnel during receive processing.')
ikeTunnelInNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInNotifys.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInNotifys.setDescription('The total number of notifications received by this Phase-1 Tunnel.')
ikeTunnelInP2Proposals = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInP2Proposals.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInP2Proposals.setDescription('The total number of proposals received by this Phase-1 Tunnel.')
ikeTunnelInP2ProposalInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInP2ProposalInvalids.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInP2ProposalInvalids.setDescription('The total number of proposals received by this Phase-1 Tunnel which were invalid.')
ikeTunnelInP2ProposalRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInP2ProposalRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInP2ProposalRejects.setDescription('The total number of proposals received by this Phase-1 Tunnel which were rejected.')
ikeTunnelInSaDeleteRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelInSaDeleteRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelInSaDeleteRequests.setDescription('The total number of security association deleted requests received by this Phase-1 Tunnel.')
ikeTunnelOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutOctets.setDescription('The total number of octets sent by this Phase-1 Tunnel.')
ikeTunnelOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutPkts.setDescription('The total number of packets sent by this Phase-1 Tunnel.')
ikeTunnelOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutDropPkts.setDescription('The total number of packets dropped by this Phase-1 Tunnel during send processing.')
ikeTunnelOutNotifys = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutNotifys.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutNotifys.setDescription('The total number of notifications sent by this Phase-1 Tunnel.')
ikeTunnelOutP2Proposals = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutP2Proposals.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutP2Proposals.setDescription('The total number of Phase-2 Proposals sent by this Phase-1 Tunnel.')
ikeTunnelOutP2ProposalRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutP2ProposalRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutP2ProposalRejects.setDescription('The total number of Phase-2 Proposals sent by this Phase-1 Tunnel which were rejected.')
ikeTunnelOutSaDeleteRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ikeTunnelOutSaDeleteRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelOutSaDeleteRequests.setDescription('The total number of security association deleted requests sent by this Phase-1 Tunnel.')
ikeTunnelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("destroy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ikeTunnelStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ikeTunnelStatus.setDescription('The status of the MIB table row. This object can be used to bring the tunnel down by setting value of this object to destroy(2). This object cannot be used to create a MIB table row.')
ipSecGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1))
ipSecGlobalActiveTunnels = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalActiveTunnels.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalActiveTunnels.setDescription('The total number of currently active IPSec Phase-2 Tunnels.')
ipSecGlobalPreviousTunnels = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalPreviousTunnels.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalPreviousTunnels.setDescription('The total number of previously active IPSec Phase-2 Tunnels.')
ipSecGlobalInOctets = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInOctets.setDescription('The total number of octets received by all current and previous IPSec Phase-2 Tunnels. See also ipSecGlobalInOctWraps for the number of times this counter has wrapped.')
ipSecGlobalInPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInPkts.setDescription('The total number of packets received by all current and previous IPSec Phase-2 Tunnels.')
ipSecGlobalInDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInDrops.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInDrops.setDescription('The total number of packets dropped during receive processing by all current and previous IPSec Phase-2 Tunnels.')
ipSecGlobalInAuths = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInAuths.setDescription("The total number of inbound authentication's performed by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalInAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInAuthFails.setDescription("The total number of inbound authentication's which ended in failure by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalInDecrypts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInDecrypts.setDescription("The total number of inbound decryption's performed by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalInDecryptFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInDecryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInDecryptFails.setDescription("The total number of inbound decryption's which ended in failure by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalOutOctets = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutOctets.setDescription('The total number of octets sent by all current and previous IPSec Phase-2 Tunnels. See also ipSecGlobalOutOctWraps for the number of times this counter has wrapped.')
ipSecGlobalOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutPkts.setDescription('The total number of packets sent by all current and previous IPSec Phase-2 Tunnels.')
ipSecGlobalOutDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutDrops.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutDrops.setDescription('The total number of packets dropped during send processing by all current and previous IPSec Phase-2 Tunnels.')
ipSecGlobalOutAuths = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutAuths.setDescription("The total number of outbound authentication's performed by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalOutAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutAuthFails.setDescription("The total number of outbound authentication's which ended in failure by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalOutEncrypts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutEncrypts.setDescription("The total number of outbound encryption's performed by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalOutEncryptFails = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutEncryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutEncryptFails.setDescription("The total number of outbound encryption's which ended in failure by all current and previous IPSec Phase-2 Tunnels.")
ipSecGlobalInOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalInOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalInOctWraps.setDescription('The number of times the total number of octets received counter (ipSecGlobalInOctets) has wrapped.')
ipSecGlobalOutOctWraps = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecGlobalOutOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecGlobalOutOctWraps.setDescription('The number of times the total number of octets sent counter (ipSecGlobalOutOctets) has wrapped.')
ipSecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2), )
if mibBuilder.loadTexts: ipSecTunnelTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelTable.setDescription('The IPSec Phase-2 Tunnel table.')
ipSecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1), ).setIndexNames((0, "IPSECV1-MIB", "ipSecTunnelIndex"))
if mibBuilder.loadTexts: ipSecTunnelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelEntry.setDescription('An IPSec Phase-2 Tunnel entry.')
ipSecTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelIndex.setDescription('The index of the Phase-2 Tunnel table. The value of the index is a number which begins at one and is incremented with each tunnel that is created. The value of this object will wrap at 65535.')
ipSecTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelId.setDescription('The internal ID of the Phase-2 Tunnel.')
ipSecTunnelIkeTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelIkeTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelIkeTunnelIndex.setDescription('The index of the related IKE Phase-1 Tunnel. (ikeTunnelIndex)')
ipSecTunnelLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelLocalAddr.setDescription('The local IP address of the Phase-2 Tunnel.')
ipSecTunnelRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelRemoteAddr.setDescription('The remote IP address of the Phase-2 Tunnel.')
ipSecTunnelKeyType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ike", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelKeyType.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelKeyType.setDescription('The type of key used by the Phase-2 Tunnel.')
ipSecTunnelEncapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tunnel", 1), ("transport", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelEncapMode.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelEncapMode.setDescription('The encapsulation mode used by the Phase-2 Tunnel.')
ipSecTunnelLifetime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelLifetime.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelLifetime.setDescription('The defined lifetime of the tunnel in hundredths of seconds.')
ipSecTunnelActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelActiveTime.setDescription('The length of time the tunnel has been active in hundredths of seconds.')
ipSecTunnelSaRefreshThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelSaRefreshThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelSaRefreshThreshold.setDescription('The security association refresh threshold percentage of the tunnel.')
ipSecTunnelTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelTotalRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelTotalRefreshes.setDescription('The number of security association refreshes performed.')
ipSecTunnelExpiredSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelExpiredSaInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelExpiredSaInstances.setDescription('The number of security association which have expired.')
ipSecTunnelCurrentSaInstances = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelCurrentSaInstances.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelCurrentSaInstances.setDescription('The number of security associations which are currently active or expiring.')
ipSecTunnelInSaEncrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("espNone", 1), ("espDesIv64", 2), ("espDes", 3), ("esp3Des", 4), ("espRc5", 5), ("espIdea", 6), ("espCast", 7), ("espBlowfish", 8), ("esp3iDes", 9), ("espDesIv32", 10), ("espRc4", 11), ("espCdmf", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInSaEncrypt.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInSaEncrypt.setDescription('The encryption used by the inbound security association.')
ipSecTunnelInSaAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("hmacMd5", 2), ("hmacSha", 3), ("desMac", 4), ("kpdk", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInSaAuthAlgo.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInSaAuthAlgo.setDescription('The authentication algorithm used by the inbound security association.')
ipSecTunnelOutSaEncrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("espNone", 1), ("espDesIv64", 2), ("espDes", 3), ("esp3Des", 4), ("espRc5", 5), ("espIdea", 6), ("espCast", 7), ("espBlowfish", 8), ("esp3iDes", 9), ("espDesIv32", 10), ("espRc4", 11), ("espCdmf", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutSaEncrypt.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutSaEncrypt.setDescription('The encryption used by the outbound security association.')
ipSecTunnelOutSaAuthAlgo = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("hmacMd5", 2), ("hmacSha", 3), ("desMac", 4), ("kpdk", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutSaAuthAlgo.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutSaAuthAlgo.setDescription('The authentication algorithm used by the outbound security association.')
ipSecTunnelInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInOctets.setDescription('The number of octets received. This value is accumulated BEFORE determining whether or not the packet should be decompressed. See also ipSecTunnelInOctWraps for the number of times this counter has wrapped.')
ipSecTunnelInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInDecompOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInDecompOctets.setDescription('The number of decompressed octets received. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ipSecTunnelInOctets. See also ipSecTunnelInDecompOctWraps for the number of times this counter has wrapped.')
ipSecTunnelInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInPkts.setDescription('The number of packets received.')
ipSecTunnelInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInDropPkts.setDescription('The number of packets dropped during received processing.')
ipSecTunnelInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInAuths.setDescription("The total number of inbound authentication's performed.")
ipSecTunnelInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInAuthFails.setDescription("The number of inbound authentication's which failed.")
ipSecTunnelInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInDecrypts.setDescription("The total number of inbound decryption's performed.")
ipSecTunnelInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInDecryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInDecryptFails.setDescription("The number of inbound decryption's which failed.")
ipSecTunnelOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutOctets.setDescription('The number of octets sent. This value is accumulated AFTER determining whether or not the packet should be compressed. See also ipSecTunnelOutOctWraps for the number of times this counter has wrapped.')
ipSecTunnelOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutUncompOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutUncompOctets.setDescription('The number of uncompressed octets sent. This value is accumulated BEFORE the packet is compress. If compression is not being used, this value will match the value of ipSecTunnelOutOctets. See also ipSecTunnelOutUncompOctWraps for the number of times this counter has wrapped.')
ipSecTunnelOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutPkts.setDescription('The number of packets sent.')
ipSecTunnelOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutDropPkts.setDescription('The number of packets dropped during send processing.')
ipSecTunnelOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutAuths.setDescription("The total number of outbound authentication's performed.")
ipSecTunnelOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutAuthFails.setDescription("The number of outbound authentication's which failed.")
ipSecTunnelOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutEncrypts.setDescription("The total number of outbound encryption's performed.")
ipSecTunnelOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutEncryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutEncryptFails.setDescription("The number of outbound encryption's which failed.")
ipSecTunnelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("destroy", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTunnelStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelStatus.setDescription('The status of the MIB table row. This object can be used to: 1) allow user-data traffic flow through this tunnel by setting this the value of this object to active (1). 2 bring the tunnel down by setting the value of this object to destroy(2). 3) stop all user-data traffic flow through the tunnel by setting the value of this object to disable(3). This object cannot be used to create a MIB table row. Valid Status Changes New Status +---------+---------+---------+ Current Status | active | destroy | disable | +---------------+=========+=========+=========+ | active | Valid | Valid | Valid | +---------------+---------+---------+---------+ | destroy | Invalid | Invalid | Invalid | +---------------+---------+---------+---------+ | disable | Valid | Valid | Valid | +---------------+---------+---------+---------+ ')
ipSecTunnelInOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInOctWraps.setDescription('The number of times the octets received counter (ipSecTunnelInOctets) has wrapped.')
ipSecTunnelInDecompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelInDecompOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelInDecompOctWraps.setDescription('The number of times the decompressed octets received counter (ipSecTunnelInDecompOctets) has wrapped.')
ipSecTunnelOutOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutOctWraps.setDescription('The number of times the octets sent counter (ipSecTunnelOutOctets) has wrapped.')
ipSecTunnelOutUncompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelOutUncompOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelOutUncompOctWraps.setDescription('The number of times the uncompressed octets sent counter (ipSecTunnelOutUncompOctets) has wrapped.')
ipSecClientTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3), )
if mibBuilder.loadTexts: ipSecClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientTable.setDescription('The IPSec Phase-2 Tunnel Client table.')
ipSecClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1), ).setIndexNames((0, "IPSECV1-MIB", "ipSecTunnelIndex"), (0, "IPSECV1-MIB", "ipSecClientIndex"))
if mibBuilder.loadTexts: ipSecClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientEntry.setDescription('An IPSec Phase-2 Tunnel Client entry.')
ipSecClientIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientIndex.setDescription('The number of the Client associated with the Phase-2 Tunnel table. The value of this number begins at one and is incremented with each Client associated with a Phase-2 Tunnel. For example, each Phase-2 Tunnel may have Client Indices of 1 through 65,535. The value of this object will wrap at 65535.')
ipSecClientLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalName.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalName.setDescription('The local name of the Client.')
ipSecClientLocalType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipAddrRangeEntry", 1), ("ipSubnetMaskEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalType.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalType.setDescription('The local entry type. Possible values are: 1) The local IP Address Range is being used, or 2) The local IP Subnet Mask is being used.')
ipSecClientLocalProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalProtocol.setDescription('The local protocol number for this Client.')
ipSecClientLocalSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 5), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalSubnetMask.setDescription('The local subnet mask of the Client.')
ipSecClientLocalHiAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 6), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalHiAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalHiAddr.setDescription('The local high IP Address of the Client.')
ipSecClientLocalLoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 7), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalLoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalLoAddr.setDescription('The local low IP Address of the Client.')
ipSecClientLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientLocalPort.setDescription('The local port of the Client.')
ipSecClientRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteName.setDescription('The remote name of the Client.')
ipSecClientRemoteType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipAddrRangeEntry", 1), ("ipSubnetMaskEntry", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteType.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteType.setDescription('The remote entry type. Possible values are: 1) The remote IP Address Range is being used, or 2) The remote IP Subnet Mask is being used.')
ipSecClientRemoteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteProtocol.setDescription('The remote protocol number for this Client.')
ipSecClientRemoteSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 12), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteSubnetMask.setDescription('The remote subnet mask of the Client.')
ipSecClientRemoteHiAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 13), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteHiAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteHiAddr.setDescription('The remote high IP Address of the Client.')
ipSecClientRemoteLoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 14), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemoteLoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemoteLoAddr.setDescription('The remote low IP Address of the Client.')
ipSecClientRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecClientRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecClientRemotePort.setDescription('The remote port of the Client.')
ipSecSpiTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4), )
if mibBuilder.loadTexts: ipSecSpiTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiTable.setDescription('The IPSec Phase-2 Security Protection Index table.')
ipSecSpiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1), ).setIndexNames((0, "IPSECV1-MIB", "ipSecTunnelIndex"), (0, "IPSECV1-MIB", "ipSecSpiIndex"))
if mibBuilder.loadTexts: ipSecSpiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiEntry.setDescription('An IPSec Phase-2 Security Protection Index entry.')
ipSecSpiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecSpiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiIndex.setDescription('The number of the SPI associated with the Phase-2 Tunnel table. The value of this number begins at one and is incremented with each SPI associated with a Phase-2 Tunnel. For example, each Phase-2 Tunnel may have Client Indices of 1 through 65,535. The value of this object will wrap at 65535.')
ipSecSpiDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecSpiDirection.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiDirection.setDescription('The direction of the SPI.')
ipSecSpiValue = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecSpiValue.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiValue.setDescription('The value of the SPI.')
ipSecSpiProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ah", 1), ("esp", 2), ("ipcomp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecSpiProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiProtocol.setDescription('The protocol of the SPI.')
ipSecSpiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("expiring", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecSpiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecSpiStatus.setDescription('The status of the SPI.')
ipSecTunnelHistTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2), )
if mibBuilder.loadTexts: ipSecTunnelHistTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistTable.setDescription('The IPSec Phase-2 Tunnel History table.')
ipSecTunnelHistEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1), ).setIndexNames((0, "IPSECV1-MIB", "ipSecTunnelHistIndex"))
if mibBuilder.loadTexts: ipSecTunnelHistEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistEntry.setDescription('An IPSec Phase-2 Tunnel History entry.')
ipSecTunnelHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistIndex.setDescription('The index of the IPSec Phase-2 Tunnel History table. The value of the index is a number which begins at one and is incremented with each tunnel that ends. The value of this object will wrap at 65535.')
ipSecTunnelHistId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistId.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistId.setDescription('The internal ID of the Phase-2 Tunnel.')
ipSecTunnelHistLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 3), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistLocalAddr.setDescription('The local IP address of the Phase-2 Tunnel.')
ipSecTunnelHistRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 4), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistRemoteAddr.setDescription('The remote IP address of the Phase-2 Tunnel.')
ipSecTunnelHistActiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistActiveTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistActiveTime.setDescription('The length of time the tunnel was active in hundredths of seconds. ')
ipSecTunnelHistTotalRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistTotalRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistTotalRefreshes.setDescription('The number of security association refreshes performed.')
ipSecTunnelHistTotalSas = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistTotalSas.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistTotalSas.setDescription('The number of security associations which were active or or had expired during the life of the tunnel.')
ipSecTunnelHistInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInOctets.setDescription('The number of octets received. This value is accumulated BEFORE determining whether or not the packet should be decompressed. See also ipSecTunnelHistInOctWraps for the number of times this counter has wrapped.')
ipSecTunnelHistInDecompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInDecompOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInDecompOctets.setDescription('The number of decompressed octets received. This value is accumulated AFTER the packet is decompressed. If compression is not being used, this value will match the value of ipSecTunnelHistInOctets. See also ipSecTunnelHistInDecompOctWraps for the number of times this counter has wrapped.')
ipSecTunnelHistInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInPkts.setDescription('The number of packets received.')
ipSecTunnelHistInDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInDropPkts.setDescription('The number of packets dropped during received processing.')
ipSecTunnelHistInAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInAuths.setDescription("The total number of inbound authentication's performed.")
ipSecTunnelHistInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInAuthFails.setDescription("The number of inbound authentication's which failed.")
ipSecTunnelHistInDecrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInDecrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInDecrypts.setDescription("The total number of inbound decryption's performed.")
ipSecTunnelHistInDecryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInDecryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInDecryptFails.setDescription("The number of inbound decryption's which failed.")
ipSecTunnelHistOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutOctets.setDescription('The number of octets sent. This value is accumulated AFTER determining whether or not the packet should be compressed. See also ipSecTunnelHistOutOctWraps for the number of times this counter has wrapped.')
ipSecTunnelHistOutUncompOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutUncompOctets.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutUncompOctets.setDescription('The number of uncompressed octets sent. This value is accumulated BEFORE the packet is compress. If compression is not being used, this value will match the value of ipSecTunnelHistOutOctets. See also ipSecTunnelHistOutUncompOctWraps for the number of times this counter has wrapped.')
ipSecTunnelHistOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutPkts.setDescription('The number of packets sent.')
ipSecTunnelHistOutDropPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutDropPkts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutDropPkts.setDescription('The number of packets dropped during send processing.')
ipSecTunnelHistOutAuths = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutAuths.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutAuths.setDescription("The total number of outbound authentication's performed.")
ipSecTunnelHistOutAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutAuthFails.setDescription("The number of outbound authentication's which failed.")
ipSecTunnelHistOutEncrypts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutEncrypts.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutEncrypts.setDescription("The total number of outbound encryption's performed.")
ipSecTunnelHistOutEncryptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutEncryptFails.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutEncryptFails.setDescription("The number of outbound encryption's which failed.")
ipSecTunnelHistInOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInOctWraps.setDescription('The number of times the octets received counter (ipSecTunnelHistInOctets) has wrapped.')
ipSecTunnelHistInDecompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistInDecompOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistInDecompOctWraps.setDescription('The number of times the decompressed octets received counter (ipSecTunnelHistInDecompOctets) has wrapped.')
ipSecTunnelHistOutOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutOctWraps.setDescription('The number times the octets sent counter (ipSecTunnelHistOutOctets) has wrapped.')
ipSecTunnelHistOutUncompOctWraps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecTunnelHistOutUncompOctWraps.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTunnelHistOutUncompOctWraps.setDescription('The number times the uncompressed octets sent counter (ipSecTunnelHistOutUncompOctets) has wrapped.')
ipSecFailTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3), )
if mibBuilder.loadTexts: ipSecFailTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailTable.setDescription('The IPSec Phase-2 Failure table.')
ipSecFailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1), ).setIndexNames((0, "IPSECV1-MIB", "ipSecFailIndex"))
if mibBuilder.loadTexts: ipSecFailEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailEntry.setDescription('An IPSec Phase-2 Failure entry.')
ipSecFailIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailIndex.setDescription('The index of the IPSec Phase-2 Failure table. The value of the index is a number which begins at one and is incremented with each failure that occurs. The value of this object will wrap at 65535.')
ipSecFailReason = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 1), ("sendAuthentication", 2), ("recvAuthentication", 3), ("decryption", 4), ("encryption", 5), ("compression", 6), ("decompression", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailReason.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailReason.setDescription('The reason for the failure.')
ipSecFailTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailTime.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailTime.setDescription('The time of the failure in hundredths of seconds.')
ipSecFailTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailTunnelIndex.setDescription('The Phase-2 Tunnel index (ipSecTunnelIndex).')
ipSecFailTunnelId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailTunnelId.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailTunnelId.setDescription('The internal ID of the Phase-2 Tunnel.')
ipSecFailSaSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailSaSpi.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailSaSpi.setDescription('The security association SPI value.')
ipSecFailPktSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 7), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailPktSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailPktSrcAddr.setDescription("The packet's source IP address.")
ipSecFailPktDstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 4, 3, 1, 8), IPSIpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipSecFailPktDstAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecFailPktDstAddr.setDescription("The packet's destination IP address.")
ipSecTrapCntlIkeTunnelStart = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlIkeTunnelStart.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlIkeTunnelStart.setDescription('This object defines the administrative state of sending the IPSec IKE Phase-1 Tunnel Start TRAP ')
ipSecTrapCntlIkeTunnelStop = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlIkeTunnelStop.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlIkeTunnelStop.setDescription('This object defines the administrative state of sending the IPSec IKE Phase-1 Tunnel Stop TRAP ')
ipSecTrapCntlP2TunnelStart = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlP2TunnelStart.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlP2TunnelStart.setDescription('This object defines the administrative state of sending the IPSec Phase-2 Tunnel Start TRAP ')
ipSecTrapCntlP2TunnelStop = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlP2TunnelStop.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlP2TunnelStop.setDescription('This object defines the administrative state of sending the IPSec Phase-2 Tunnel Stop TRAP ')
ipSecTrapCntlAuthFail = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlAuthFail.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlAuthFail.setDescription('This object defines the administrative state of sending the IPSec Authentication Failure TRAP ')
ipSecTrapCntlDecryptFail = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipSecTrapCntlDecryptFail.setStatus('mandatory')
if mibBuilder.loadTexts: ipSecTrapCntlDecryptFail.setDescription('This object defines the administrative state of sending the IPSec Decryption Failure TRAP ')
ikeTunnelStart = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,1)).setObjects(("IPSECV1-MIB", "ikeTunnelIndex"), ("IPSECV1-MIB", "ikeTunnelId"))
if mibBuilder.loadTexts: ikeTunnelStart.setDescription('This TRAP is generated when an IPsec IKE Phase-1 Tunnel is created.')
ikeTunnelStop = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,2)).setObjects(("IPSECV1-MIB", "ikeTunnelIndex"), ("IPSECV1-MIB", "ikeTunnelId"), ("IPSECV1-MIB", "ikeTunnelActiveTime"))
if mibBuilder.loadTexts: ikeTunnelStop.setDescription('This TRAP is generated when an IPsec IKE Phase-1 Tunnel is stopped.')
ipSecTunnelStart = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,3)).setObjects(("IPSECV1-MIB", "ipSecTunnelIndex"), ("IPSECV1-MIB", "ipSecTunnelId"))
if mibBuilder.loadTexts: ipSecTunnelStart.setDescription('This TRAP is generated when an IPsec Phase-2 Tunnel is created.')
ipSecTunnelStop = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,4)).setObjects(("IPSECV1-MIB", "ipSecTunnelIndex"), ("IPSECV1-MIB", "ipSecTunnelId"), ("IPSECV1-MIB", "ipSecTunnelActiveTime"))
if mibBuilder.loadTexts: ipSecTunnelStop.setDescription('This TRAP is generated when an IPsec Phase-2 Tunnel is stopped.')
ipSecAuthFail = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,5)).setObjects(("IPSECV1-MIB", "ipSecTunnelIndex"), ("IPSECV1-MIB", "ipSecTunnelId"), ("IPSECV1-MIB", "ipSecFailTime"), ("IPSECV1-MIB", "ipSecFailPktSrcAddr"), ("IPSECV1-MIB", "ipSecFailPktDstAddr"))
if mibBuilder.loadTexts: ipSecAuthFail.setDescription('This TRAP is generated when a IPsec Phase-2 authenication failure is detected.')
ipSecDecryptFail = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 119, 4, 9) + (0,6)).setObjects(("IPSECV1-MIB", "ipSecTunnelIndex"), ("IPSECV1-MIB", "ipSecTunnelId"), ("IPSECV1-MIB", "ipSecFailTime"), ("IPSECV1-MIB", "ipSecFailPktSrcAddr"), ("IPSECV1-MIB", "ipSecFailPktDstAddr"))
if mibBuilder.loadTexts: ipSecDecryptFail.setDescription('This TRAP is generated when a IPsec Phase-2 decryption failure is detected.')
mibBuilder.exportSymbols("IPSECV1-MIB", ipSecTunnelInDecompOctWraps=ipSecTunnelInDecompOctWraps, ipSecTunnelHistInAuths=ipSecTunnelHistInAuths, ikeTunnelTable=ikeTunnelTable, ipSecTrapCntlIkeTunnelStart=ipSecTrapCntlIkeTunnelStart, ipSecGlobalInOctets=ipSecGlobalInOctets, ipSecGlobalOutAuthFails=ipSecGlobalOutAuthFails, ipSecTrapCntl=ipSecTrapCntl, ikeTunnelInP2ProposalInvalids=ikeTunnelInP2ProposalInvalids, ikeTunnelSaRefreshThreshold=ikeTunnelSaRefreshThreshold, ipSecClientLocalSubnetMask=ipSecClientLocalSubnetMask, ikeTunnelTotalRefreshes=ikeTunnelTotalRefreshes, ikeTunnelInNotifys=ikeTunnelInNotifys, ipSecGlobalOutDrops=ipSecGlobalOutDrops, ipSecTunnelRemoteAddr=ipSecTunnelRemoteAddr, ipSecMibLevel=ipSecMibLevel, ikeTunnelInPkts=ikeTunnelInPkts, ipSecFailSaSpi=ipSecFailSaSpi, ipSecTunnelLifetime=ipSecTunnelLifetime, ipSecFailPktDstAddr=ipSecFailPktDstAddr, ipSecGlobalOutAuths=ipSecGlobalOutAuths, ipSecTunnelHistOutOctets=ipSecTunnelHistOutOctets, ipSecTunnelOutSaAuthAlgo=ipSecTunnelOutSaAuthAlgo, ipSecTunnelHistLocalAddr=ipSecTunnelHistLocalAddr, ipSecTunnelId=ipSecTunnelId, ipSecTunnelHistOutEncrypts=ipSecTunnelHistOutEncrypts, ipSecTrapCntlP2TunnelStart=ipSecTrapCntlP2TunnelStart, ipSecSpiEntry=ipSecSpiEntry, ipSecTunnelHistInDropPkts=ipSecTunnelHistInDropPkts, ipSecFailTunnelIndex=ipSecFailTunnelIndex, ikeTunnelStart=ikeTunnelStart, ipSecTunnelStop=ipSecTunnelStop, ipSecClientLocalPort=ipSecClientLocalPort, ipSecSpiIndex=ipSecSpiIndex, ipSecGlobalOutOctets=ipSecGlobalOutOctets, ipSecClientRemoteLoAddr=ipSecClientRemoteLoAddr, ipSecTunnelLocalAddr=ipSecTunnelLocalAddr, ipSecClientRemotePort=ipSecClientRemotePort, ipSecTunnelHistInDecrypts=ipSecTunnelHistInDecrypts, ipSecTunnelHistInOctWraps=ipSecTunnelHistInOctWraps, ipSecTunnelHistActiveTime=ipSecTunnelHistActiveTime, ikeTunnelId=ikeTunnelId, ipSecGlobalActiveTunnels=ipSecGlobalActiveTunnels, ipSecTunnelInOctWraps=ipSecTunnelInOctWraps, ipSecClientTable=ipSecClientTable, ipSecTunnelEncapMode=ipSecTunnelEncapMode, ipSecTunnelHistOutAuths=ipSecTunnelHistOutAuths, ipSecTunnelTable=ipSecTunnelTable, ipSecAuthFail=ipSecAuthFail, ipSecGlobalOutEncrypts=ipSecGlobalOutEncrypts, ipSecGlobalInOctWraps=ipSecGlobalInOctWraps, ipSecTunnelHistInPkts=ipSecTunnelHistInPkts, ipSecTunnelInDecrypts=ipSecTunnelInDecrypts, ipSecTunnelHistOutPkts=ipSecTunnelHistOutPkts, ikeTunnelNegoMode=ikeTunnelNegoMode, ipSecTunnelHistOutEncryptFails=ipSecTunnelHistOutEncryptFails, ipSecGlobalInPkts=ipSecGlobalInPkts, ipSecTunnelHistInDecompOctets=ipSecTunnelHistInDecompOctets, ipSecClientLocalName=ipSecClientLocalName, ikeTunnelIndex=ikeTunnelIndex, ipSecTunnelHistTotalRefreshes=ipSecTunnelHistTotalRefreshes, ipSecTunnelOutOctWraps=ipSecTunnelOutOctWraps, ipSecSpiProtocol=ipSecSpiProtocol, ikeTunnelRemoteAddr=ikeTunnelRemoteAddr, ipSecTunnelOutEncrypts=ipSecTunnelOutEncrypts, ipSecTunnelHistInOctets=ipSecTunnelHistInOctets, ipSecTunnelInPkts=ipSecTunnelInPkts, ipSecTunnelInDecompOctets=ipSecTunnelInDecompOctets, ipSecTunnelInAuthFails=ipSecTunnelInAuthFails, ikeTunnelActiveTime=ikeTunnelActiveTime, ipSecClientIndex=ipSecClientIndex, ipSecTunnelHistRemoteAddr=ipSecTunnelHistRemoteAddr, ibmIROCroutingIpSec=ibmIROCroutingIpSec, ipSecFailTable=ipSecFailTable, ipSecSpiDirection=ipSecSpiDirection, ipSecTunnelHistInAuthFails=ipSecTunnelHistInAuthFails, ipSecFailEntry=ipSecFailEntry, ipSecFailReason=ipSecFailReason, ipSecTunnelInAuths=ipSecTunnelInAuths, ipSecLevels=ipSecLevels, ipSecTunnelStatus=ipSecTunnelStatus, ipSecTunnelEntry=ipSecTunnelEntry, ikeTunnelLocalAddr=ikeTunnelLocalAddr, ipSecTunnelOutUncompOctWraps=ipSecTunnelOutUncompOctWraps, ipSecTunnelInDropPkts=ipSecTunnelInDropPkts, ipSecTunnelKeyType=ipSecTunnelKeyType, ipSecTunnelHistOutUncompOctWraps=ipSecTunnelHistOutUncompOctWraps, ikeTunnelOutP2ProposalRejects=ikeTunnelOutP2ProposalRejects, ipSecGlobalOutEncryptFails=ipSecGlobalOutEncryptFails, ipSecClientEntry=ipSecClientEntry, ipSecTunnelActiveTime=ipSecTunnelActiveTime, ipSecTunnelSaRefreshThreshold=ipSecTunnelSaRefreshThreshold, ipSecTunnelOutEncryptFails=ipSecTunnelOutEncryptFails, ikeTunnelOutP2Proposals=ikeTunnelOutP2Proposals, ipSecTunnelOutAuths=ipSecTunnelOutAuths, ipSecSpiTable=ipSecSpiTable, ipSecFailIndex=ipSecFailIndex, ipSecTunnelHistTable=ipSecTunnelHistTable, ipSecGlobal=ipSecGlobal, ipSecFailPktSrcAddr=ipSecFailPktSrcAddr, ikeTunnelLifetime=ikeTunnelLifetime, ikeTunnelOutOctets=ikeTunnelOutOctets, ikeTunnelOutNotifys=ikeTunnelOutNotifys, ipSecTrapCntlP2TunnelStop=ipSecTrapCntlP2TunnelStop, ikeTunnelInP2Proposals=ikeTunnelInP2Proposals, ikeTunnelEntry=ikeTunnelEntry, ipSecTunnelIkeTunnelIndex=ipSecTunnelIkeTunnelIndex, ipSecTunnelOutUncompOctets=ipSecTunnelOutUncompOctets, ipSecClientRemoteSubnetMask=ipSecClientRemoteSubnetMask, ipSecTunnelStart=ipSecTunnelStart, ipSecTunnelOutPkts=ipSecTunnelOutPkts, ipSecClientLocalLoAddr=ipSecClientLocalLoAddr, ikeTunnelOutSaDeleteRequests=ikeTunnelOutSaDeleteRequests, ipSecPhaseTwo=ipSecPhaseTwo, ipSecGlobalInAuthFails=ipSecGlobalInAuthFails, ipSecTunnelInDecryptFails=ipSecTunnelInDecryptFails, ikeTunnelInDropPkts=ikeTunnelInDropPkts, ikeTunnelInSaDeleteRequests=ikeTunnelInSaDeleteRequests, ipSecTunnelHistEntry=ipSecTunnelHistEntry, ipSecTunnelHistOutAuthFails=ipSecTunnelHistOutAuthFails, ipSecTunnelInSaEncrypt=ipSecTunnelInSaEncrypt, ipSecTunnelHistId=ipSecTunnelHistId, ipSecGlobalInDecrypts=ipSecGlobalInDecrypts, ikeTunnelStop=ikeTunnelStop, ipSecGlobalOutPkts=ipSecGlobalOutPkts, ikeTunnelLocalName=ikeTunnelLocalName, ipSecTunnelHistInDecompOctWraps=ipSecTunnelHistInDecompOctWraps, ipSecSpiValue=ipSecSpiValue, ipSecTunnelInOctets=ipSecTunnelInOctets, ikeTunnelRemoteName=ikeTunnelRemoteName, ipSecTrapCntlAuthFail=ipSecTrapCntlAuthFail, ipSecGlobalInDrops=ipSecGlobalInDrops, ipSecTunnelOutSaEncrypt=ipSecTunnelOutSaEncrypt, ipSecTunnelCurrentSaInstances=ipSecTunnelCurrentSaInstances, ipSecFailTime=ipSecFailTime, ipSecGlobalOutOctWraps=ipSecGlobalOutOctWraps, ipSecHistory=ipSecHistory, ipSecTunnelOutDropPkts=ipSecTunnelOutDropPkts, ipSecTrapCntlDecryptFail=ipSecTrapCntlDecryptFail, ipSecTunnelHistIndex=ipSecTunnelHistIndex, ipSecClientLocalType=ipSecClientLocalType, ipSecSpiStatus=ipSecSpiStatus, ipSecGlobalInAuths=ipSecGlobalInAuths, ipSecTunnelHistOutDropPkts=ipSecTunnelHistOutDropPkts, ikeTunnelOutPkts=ikeTunnelOutPkts, ikeTunnelOutDropPkts=ikeTunnelOutDropPkts, ipSecGlobalInDecryptFails=ipSecGlobalInDecryptFails, ipSecTrapCntlIkeTunnelStop=ipSecTrapCntlIkeTunnelStop, IPSIpAddress=IPSIpAddress, ipSecClientRemoteName=ipSecClientRemoteName, ipSecTunnelIndex=ipSecTunnelIndex, ipSecClientRemoteType=ipSecClientRemoteType, ipSecTunnelExpiredSaInstances=ipSecTunnelExpiredSaInstances, ipSecClientRemoteHiAddr=ipSecClientRemoteHiAddr, ipSecTunnelHistTotalSas=ipSecTunnelHistTotalSas, ipSecTunnelHistOutUncompOctets=ipSecTunnelHistOutUncompOctets, ikeTunnelInOctets=ikeTunnelInOctets, ikeTunnelInP2ProposalRejects=ikeTunnelInP2ProposalRejects, ipSecDecryptFail=ipSecDecryptFail, ipSecPhaseOne=ipSecPhaseOne, ipSecGlobalPreviousTunnels=ipSecGlobalPreviousTunnels, ikeTunnelStatus=ikeTunnelStatus, ipSecTunnelOutOctets=ipSecTunnelOutOctets, ipSecClientLocalProtocol=ipSecClientLocalProtocol, ipSecTunnelTotalRefreshes=ipSecTunnelTotalRefreshes, ipSecClientRemoteProtocol=ipSecClientRemoteProtocol, ipSecFailTunnelId=ipSecFailTunnelId, ipSecTunnelInSaAuthAlgo=ipSecTunnelInSaAuthAlgo, ipSecTunnelHistOutOctWraps=ipSecTunnelHistOutOctWraps, ipSecClientLocalHiAddr=ipSecClientLocalHiAddr, ipSecTunnelHistInDecryptFails=ipSecTunnelHistInDecryptFails, ipSecTunnelOutAuthFails=ipSecTunnelOutAuthFails)

#
# PySNMP MIB module GSMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GSMP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:20:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
AtmVpIdentifier, AtmVcIdentifier = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier", "AtmVcIdentifier")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetPortNumber, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddress", "InetAddressType")
ZeroBasedCounter32, = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
TimeTicks, ModuleIdentity, NotificationType, Counter32, ObjectIdentity, Integer32, IpAddress, Unsigned32, mib_2, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ModuleIdentity", "NotificationType", "Counter32", "ObjectIdentity", "Integer32", "IpAddress", "Unsigned32", "mib-2", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "Bits", "Gauge32")
RowStatus, StorageType, DisplayString, TimeStamp, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue")
gsmpMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 98))
gsmpMIB.setRevisions(('2002-05-31 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: gsmpMIB.setRevisionsDescriptions(('Initial Version, published as RFC 3295',))
if mibBuilder.loadTexts: gsmpMIB.setLastUpdated('200205310000Z')
if mibBuilder.loadTexts: gsmpMIB.setOrganization('General Switch Management Protocol (gsmp) Working Group, IETF')
if mibBuilder.loadTexts: gsmpMIB.setContactInfo('WG Charter: http://www.ietf.org/html.charters/gsmp-charter.html WG-email: gsmp@ietf.org Subscribe: gsmp-request@ietf.org Email Archive: ftp://ftp.ietf.org/ietf-mail-archive/gsmp/ WG Chair: Avri Doria Email: avri@acm.org WG Chair: Kenneth Sundell Email: ksundell@nortelnetworks.com Editor: Hans Sjostrand Email: hans@ipunplugged.com Editor: Joachim Buerkle Email: joachim.buerkle@nortelnetworks.com Editor: Balaji Srinivasan Email: balaji@cplane.com')
if mibBuilder.loadTexts: gsmpMIB.setDescription('This MIB contains managed object definitions for the General Switch Management Protocol, GSMP, version 3')
gsmpNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 0))
gsmpObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 1))
gsmpNotificationsObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 2))
gsmpConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 3))
class GsmpNameType(TextualConvention, OctetString):
    description = 'The Name is a 48-bit quantity. A 48-bit IEEE 802 MAC address, if available, may be used.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class GsmpPartitionType(TextualConvention, Integer32):
    description = 'Defining if partitions are used and how the partition id is negotiated. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noPartition", 1), ("fixedPartitionRequest", 2), ("fixedPartitionAssigned", 3))

class GsmpPartitionIdType(TextualConvention, OctetString):
    description = 'A 8-bit quantity. The format of the Partition ID is not defined in GSMP. If desired, the Partition ID can be divided into multiple sub-identifiers within a single partition. For example: the Partition ID could be subdivided into a 6-bit partition number and a 2-bit sub-identifier which would allow a switch to support 64 partitions with 4 available IDs per partition.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 1)
    fixedLength = 1

class GsmpVersion(TextualConvention, Unsigned32):
    description = 'The version numbers defined for the GSMP protocol. The version numbers used are defined in the specifications of the respective protocol, 1 - GSMPv1.1 [RFC1987] 2 - GSMPv2.0 [RFC2397] 3 - GSMPv3 [RFC3292] Other numbers may be defined for other versions of the GSMP protocol.'
    status = 'current'

class GsmpLabelType(TextualConvention, OctetString):
    description = 'The label is structured as a TLV, a tuple, consisting of a Type, a Length, and a Value. The structure is defined in [RFC 3292]. The label TLV is encoded as a 2 octet type field, followed by a 2 octet Length field, followed by a variable length Value field. Additionally, a label field can be composed of many stacked labels that together constitute the label.'
    status = 'current'

gsmpControllerTable = MibTable((1, 3, 6, 1, 2, 1, 98, 1, 1), )
if mibBuilder.loadTexts: gsmpControllerTable.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerTable.setDescription('This table represents the Switch Controller Entities. An entry in this table needs to be configured (created) before a GSMP session might be started.')
gsmpControllerEntry = MibTableRow((1, 3, 6, 1, 2, 1, 98, 1, 1, 1), ).setIndexNames((0, "GSMP-MIB", "gsmpControllerEntityId"))
if mibBuilder.loadTexts: gsmpControllerEntry.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerEntry.setDescription('An entry in the table showing the data for a specific Switch Controller Entity. If partitions are used, one entity corresponds to one specific switch partition. Depending of the encapsulation used, a corresponding row in the gsmpAtmEncapTable or the gsmpTcpIpEncapTable may have been created.')
gsmpControllerEntityId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 1), GsmpNameType())
if mibBuilder.loadTexts: gsmpControllerEntityId.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerEntityId.setDescription('The Switch Controller Entity Id is unique within the operational context of the device.')
gsmpControllerMaxVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 2), GsmpVersion().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerMaxVersion.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerMaxVersion.setDescription('The max version number of the GSMP protocol being used in this session. The version is negotiated by the adjacency protocol.')
gsmpControllerTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setUnits('100ms').setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerTimer.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerTimer.setDescription('The timer specifies the nominal time between periodic adjacency protocol messages. It is a constant for the duration of a GSMP session. The timer is specified in units of 100ms.')
gsmpControllerPort = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerPort.setReference('General Switch Management Protocol V3: Section 3.1.2')
if mibBuilder.loadTexts: gsmpControllerPort.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerPort.setDescription('The local port number for the Switch Controller Entity.')
gsmpControllerInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpControllerInstance.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerInstance.setDescription('The instance number for the Switch Controller Entity. The Instance number is a 24-bit number that should be guaranteed to be unique within the recent past and to change when the link or node comes back up after going down. Zero is not a valid instance number. ')
gsmpControllerPartitionType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 6), GsmpPartitionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerPartitionType.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerPartitionType.setDescription('A controller can request the specific partition identifier to the session by setting the Partition Type to fixedPartitionRequest(2). A controller can let the switch decide whether it wants to assign a fixed partition ID or not, by setting the Partition Type to noPartition(1).')
gsmpControllerPartitionId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 7), GsmpPartitionIdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerPartitionId.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerPartitionId.setDescription('The Id for the specific switch partition that this Switch Controller is concerned with. If partitions are not used or if the controller lets the switch assigns Partition ID, i.e Partition Type = noPartition(1), then this object is undefined.')
gsmpControllerDoResync = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerDoResync.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerDoResync.setDescription('This object specifies whether the controller should resynchronise or reset in case of loss of synchronisation. If this object is set to true then the Controller should resync with PFLAG=2 (recovered adjacency).')
gsmpControllerNotificationMap = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 9), Bits().clone(namedValues=NamedValues(("sessionDown", 0), ("sessionUp", 1), ("sendFailureIndication", 2), ("receivedFailureIndication", 3), ("portUpEvent", 4), ("portDownEvent", 5), ("invalidLabelEvent", 6), ("newPortEvent", 7), ("deadPortEvent", 8), ("adjacencyUpdateEvent", 9))).clone(namedValues=NamedValues(("sessionDown", 0), ("sessionUp", 1), ("sendFailureIndication", 2), ("receivedFailureIndication", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerNotificationMap.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerNotificationMap.setDescription('This bitmap defines whether a corresponding SNMP notification should be sent if a GSMP event is received by the Switch Controller. If the bit is set to 1 a notification should be sent. The handling and filtering of the SNMP notifications are then further specified in the SNMP notification originator application. ')
gsmpControllerSessionState = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("null", 1), ("synsent", 2), ("synrcvd", 3), ("estab", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpControllerSessionState.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerSessionState.setDescription('The state for the existing or potential session that this entity is concerned with. The NULL state is returned if the proper encapsulation data is not yet configured, if the row is not in active status or if the session is in NULL state as defined in the GSMP specification.')
gsmpControllerStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerStorageType.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerStorageType.setDescription("The storage type for this controller entity. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
gsmpControllerRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpControllerRowStatus.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. While the row is in active state it's not possible to modify the value of any object for that row except the gsmpControllerNotificationMap and the gsmpControllerRowStatus objects.")
gsmpSwitchTable = MibTable((1, 3, 6, 1, 2, 1, 98, 1, 2), )
if mibBuilder.loadTexts: gsmpSwitchTable.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchTable.setDescription('This table represents the Switch Entities. An entry in this table needs to be configured (created) before a GSMP session might be started.')
gsmpSwitchEntry = MibTableRow((1, 3, 6, 1, 2, 1, 98, 1, 2, 1), ).setIndexNames((0, "GSMP-MIB", "gsmpSwitchEntityId"))
if mibBuilder.loadTexts: gsmpSwitchEntry.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchEntry.setDescription('An entry in the table showing the data for a specific Switch Entity. If partitions are used, one entity corresponds to one specific switch partition. Depending of the encapsulation used, a corresponding row in the gsmpAtmEncapTable or the gsmpTcpIpEncapTable may have been created.')
gsmpSwitchEntityId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 1), GsmpNameType())
if mibBuilder.loadTexts: gsmpSwitchEntityId.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchEntityId.setDescription('The Switch Entity Id is unique within the operational context of the device. ')
gsmpSwitchMaxVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 2), GsmpVersion().clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchMaxVersion.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchMaxVersion.setDescription('The max version number of the GSMP protocol being supported by this Switch. The version is negotiated by the adjacency protocol.')
gsmpSwitchTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setUnits('100ms').setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchTimer.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchTimer.setDescription('The timer specifies the nominal time between periodic adjacency protocol messages. It is a constant for the duration of a GSMP session. The timer is specified in units of 100ms.')
gsmpSwitchName = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 4), GsmpNameType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchName.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchName.setDescription('The name of the Switch. The first three octets must be an Organisationally Unique Identifier (OUI) that identifies the manufacturer of the Switch. This is by default set to the same value as the gsmpSwitchId object if not separately specified. ')
gsmpSwitchPort = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchPort.setReference('General Switch Management Protocol V3: Section 3.1.2')
if mibBuilder.loadTexts: gsmpSwitchPort.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchPort.setDescription('The local port number for this Switch Entity.')
gsmpSwitchInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSwitchInstance.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchInstance.setDescription('The instance number for the Switch Entity. The Instance number is a 24-bit number that should be guaranteed to be unique within the recent past and to change when the link or node comes back up after going down. Zero is not a valid instance number.')
gsmpSwitchPartitionType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 7), GsmpPartitionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchPartitionType.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchPartitionType.setDescription('A switch can assign the specific partition identifier to the session by setting the Partition Type to fixedPartitionAssigned(3). A switch can specify that no partitions are handled in the session by setting the Partition Type to noPartition(1).')
gsmpSwitchPartitionId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 8), GsmpPartitionIdType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchPartitionId.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchPartitionId.setDescription('The Id for this specific switch partition that the switch entity represents. If partitions are not used, i.e. Partition Type = noPartition(1), then this object is undefined.')
gsmpSwitchNotificationMap = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 9), Bits().clone(namedValues=NamedValues(("sessionDown", 0), ("sessionUp", 1), ("sendFailureIndication", 2), ("receivedFailureIndication", 3), ("portUpEvent", 4), ("portDownEvent", 5), ("invalidLabelEvent", 6), ("newPortEvent", 7), ("deadPortEvent", 8), ("adjacencyUpdateEvent", 9))).clone(namedValues=NamedValues(("sessionDown", 0), ("sessionUp", 1), ("sendFailureIndication", 2), ("receivedFailureIndication", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchNotificationMap.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchNotificationMap.setDescription('This bitmap defines whether a corresponding SNMP notification should be sent if an GSMP event is sent by the Switch Entity. If the bit is set to 1 a notification should be sent. The handling and filtering of the SNMP notifications are then further specified in the SNMP notification originator application. ')
gsmpSwitchSwitchType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchSwitchType.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchSwitchType.setDescription('A 16-bit field allocated by the manufacturer of the switch. The Switch Type identifies the product. When the Switch Type is combined with the OUI from the Switch Name the product is uniquely identified. ')
gsmpSwitchWindowSize = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchWindowSize.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchWindowSize.setDescription('The maximum number of unacknowledged request messages that may be transmitted by the controller without the possibility of loss. This field is used to prevent request messages from being lost in the switch because of overflow in the receive buffer. The field is a hint to the controller.')
gsmpSwitchSessionState = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("null", 1), ("synsent", 2), ("synrcvd", 3), ("estab", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSwitchSessionState.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchSessionState.setDescription('The state for the existing or potential session that this entity is concerned with. The NULL state is returned if the proper encapsulation data is not yet configured, if the row is not in active status or if the session is in NULL state as defined in the GSMP specification.')
gsmpSwitchStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 13), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchStorageType.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchStorageType.setDescription("The storage type for this switch entity. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
gsmpSwitchRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 2, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpSwitchRowStatus.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. While the row is in active state it's not possible to modify the value of any object for that row except the gsmpSwitchNotificationMap and the gsmpSwitchRowStatus objects.")
gsmpAtmEncapTable = MibTable((1, 3, 6, 1, 2, 1, 98, 1, 3), )
if mibBuilder.loadTexts: gsmpAtmEncapTable.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapTable.setDescription('This table contains the atm encapsulation data for the Controller or Switch that uses atm aal5 as encapsulation. ')
gsmpAtmEncapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 98, 1, 3, 1), ).setIndexNames((0, "GSMP-MIB", "gsmpAtmEncapEntityId"))
if mibBuilder.loadTexts: gsmpAtmEncapEntry.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapEntry.setDescription('An entry in the table showing the encapsulation data for a specific Switch Controller entity or Switch entity.')
gsmpAtmEncapEntityId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 1), GsmpNameType())
if mibBuilder.loadTexts: gsmpAtmEncapEntityId.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapEntityId.setDescription('The Controller Id or Switch Id that is unique within the operational context of the device. ')
gsmpAtmEncapIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 2), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpAtmEncapIfIndex.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapIfIndex.setDescription('The interface index for the virtual channel over which the GSMP session is established, i.e., the GSMP control channel for LLC/SNAP encapsulated GSMP messages on an ATM data link layer.')
gsmpAtmEncapVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpAtmEncapVpi.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapVpi.setDescription(' The VPI value for the virtual channel over which the GSMP session is established, i.e., the GSMP control channel for LLC/SNAP encapsulated GSMP messages on an ATM data link layer.')
gsmpAtmEncapVci = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 4), AtmVcIdentifier().clone(15)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpAtmEncapVci.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapVci.setDescription(' The VCI value for the virtual channel over which the GSMP session is established, i.e., the GSMP control channel for LLC/SNAP encapsulated GSMP messages on an ATM data link layer.')
gsmpAtmEncapStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpAtmEncapStorageType.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapStorageType.setDescription('The storage type for this entry. It should have the same value as the StorageType in the referring Switch Controller entity or Switch entity.')
gsmpAtmEncapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpAtmEncapRowStatus.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. While the row is in active state it's not possible to modify the value of any object for that row except the gsmpAtmEncapRowStatus object.")
gsmpTcpIpEncapTable = MibTable((1, 3, 6, 1, 2, 1, 98, 1, 4), )
if mibBuilder.loadTexts: gsmpTcpIpEncapTable.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapTable.setDescription('This table contains the encapsulation data for the Controller or Switch that uses TCP/IP as encapsulation.')
gsmpTcpIpEncapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 98, 1, 4, 1), ).setIndexNames((0, "GSMP-MIB", "gsmpTcpIpEncapEntityId"))
if mibBuilder.loadTexts: gsmpTcpIpEncapEntry.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapEntry.setDescription('An entry in the table showing the encapsulation data for a specific Switch Controller entity or Switch entity.')
gsmpTcpIpEncapEntityId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 1), GsmpNameType())
if mibBuilder.loadTexts: gsmpTcpIpEncapEntityId.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapEntityId.setDescription('The Controller or Switch Id is unique within the operational context of the device. ')
gsmpTcpIpEncapAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpTcpIpEncapAddressType.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapAddressType.setDescription('The type of address in gsmpTcpIpEncapAddress.')
gsmpTcpIpEncapAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpTcpIpEncapAddress.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapAddress.setDescription('The IPv4 or IPv6 address used for the GSMP session peer.')
gsmpTcpIpEncapPortNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 4), InetPortNumber().clone(6068)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpTcpIpEncapPortNumber.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapPortNumber.setDescription('The TCP port number used for the TCP session establishment to the GSMP peer.')
gsmpTcpIpEncapStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpTcpIpEncapStorageType.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapStorageType.setDescription('The storage type for this entry. It should have the same value as the StorageType in the referring Switch Controller entity or Switch entity.')
gsmpTcpIpEncapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: gsmpTcpIpEncapRowStatus.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapRowStatus.setDescription("An object that allows entries in this table to be created and deleted using the RowStatus convention. While the row is in active state it's not possible to modify the value of any object for that row except the gsmpTcpIpEncapRowStatus object.")
gsmpSessionTable = MibTable((1, 3, 6, 1, 2, 1, 98, 1, 5), )
if mibBuilder.loadTexts: gsmpSessionTable.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionTable.setDescription('This table represents the sessions between Controller and Switch pairs. ')
gsmpSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 98, 1, 5, 1), ).setIndexNames((0, "GSMP-MIB", "gsmpSessionThisSideId"), (0, "GSMP-MIB", "gsmpSessionFarSideId"))
if mibBuilder.loadTexts: gsmpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionEntry.setDescription('An entry in the table showing the session data for a specific Controller and Switch pair. Also, statistics for this specific session is shown.')
gsmpSessionThisSideId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 1), GsmpNameType())
if mibBuilder.loadTexts: gsmpSessionThisSideId.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionThisSideId.setDescription('This side ID uniquely identifies the entity that this session relates to within the operational context of the device. ')
gsmpSessionFarSideId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 2), GsmpNameType())
if mibBuilder.loadTexts: gsmpSessionFarSideId.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionFarSideId.setDescription('The Far side ID uniquely identifies the entity that this session is established against. ')
gsmpSessionVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 3), GsmpVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionVersion.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionVersion.setDescription('The version number of the GSMP protocol being used in this session. The version is the result of the negotiation by the adjacency protocol.')
gsmpSessionTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 4), Integer32()).setUnits('100ms').setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionTimer.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionTimer.setDescription('The timer specifies the time remaining until the adjacency timer expires. The object could take negative values since if no valid GSMP messages are received in any period of time in excess of three times the value of the Timer negotiated by the adjacency protocol loss of synchronisation may be declared. The timer is specified in units of 100ms.')
gsmpSessionPartitionId = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 5), GsmpPartitionIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionPartitionId.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionPartitionId.setDescription('The Partition Id for the specific switch partition that this session is concerned with.')
gsmpSessionAdjacencyCount = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionAdjacencyCount.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionAdjacencyCount.setDescription('This object specifies the current number of adjacencies that are established with controllers and the switch partition that is used for this session. The value includes this session.')
gsmpSessionFarSideName = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 7), GsmpNameType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionFarSideName.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionFarSideName.setDescription('The name of the far side as advertised in the adjacency message.')
gsmpSessionFarSidePort = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionFarSidePort.setReference('General Switch Management Protocol V3: Section 3.1.2')
if mibBuilder.loadTexts: gsmpSessionFarSidePort.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionFarSidePort.setDescription('The local port number of the link across which the message is being sent.')
gsmpSessionFarSideInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionFarSideInstance.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionFarSideInstance.setDescription('The instance number used for the link during this session. The Instance number is a 24-bit number that should be guaranteed to be unique within the recent past and to change when the link or node comes back up after going down. Zero is not a valid instance number.')
gsmpSessionLastFailureCode = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionLastFailureCode.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionLastFailureCode.setDescription('This is the last failure code that was received over this session. If no failure code have been received, the value is zero.')
gsmpSessionDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which one or more of this session's counters suffered a discontinuity. If no such discontinuities have occurred since then, this object contains the same timestamp as gsmpSessionStartUptime .")
gsmpSessionStartUptime = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStartUptime.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStartUptime.setDescription(' The value of sysUpTime when the session came to established state.')
gsmpSessionStatSentMessages = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 13), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatSentMessages.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatSentMessages.setDescription('The number of messages that have been sent in this session. All GSMP messages pertaining to this session after the session came to established state SHALL be counted, also including adjacency protocol messages and failure response messages. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatFailureInds = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 14), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatFailureInds.setReference('General Switch Management Protocol V3: Section 12.1')
if mibBuilder.loadTexts: gsmpSessionStatFailureInds.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatFailureInds.setDescription('The number of messages that have been sent with a failure indication in this session. Warning messages SHALL NOT be counted. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatReceivedMessages = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 15), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatReceivedMessages.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatReceivedMessages.setDescription('The number of messages that have been received in this session. All legal GSMP messages pertaining to this session after the session came to established state SHALL be counted, also including adjacency protocol messages and failure response messages. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatReceivedFailures = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 16), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatReceivedFailures.setReference('General Switch Management Protocol V3: Section 12.1')
if mibBuilder.loadTexts: gsmpSessionStatReceivedFailures.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatReceivedFailures.setDescription('The number of messages that have been received in this session with a failure indication. Warning messages SHALL NOT be counted. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatPortUpEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 17), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatPortUpEvents.setReference('General Switch Management Protocol V3: Section 9.1')
if mibBuilder.loadTexts: gsmpSessionStatPortUpEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatPortUpEvents.setDescription('The number of Port Up events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatPortDownEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 18), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatPortDownEvents.setReference('General Switch Management Protocol V3: Section 9.2')
if mibBuilder.loadTexts: gsmpSessionStatPortDownEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatPortDownEvents.setDescription('The number of Port Down events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatInvLabelEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 19), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatInvLabelEvents.setReference('General Switch Management Protocol V3: Section 9.3')
if mibBuilder.loadTexts: gsmpSessionStatInvLabelEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatInvLabelEvents.setDescription('The number of Invalid label events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatNewPortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 20), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatNewPortEvents.setReference('General Switch Management Protocol V3: Section 9.4')
if mibBuilder.loadTexts: gsmpSessionStatNewPortEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatNewPortEvents.setDescription('The number of New Port events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatDeadPortEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 21), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatDeadPortEvents.setReference('General Switch Management Protocol V3: Section 9.5')
if mibBuilder.loadTexts: gsmpSessionStatDeadPortEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatDeadPortEvents.setDescription('The number of Dead Port events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpSessionStatAdjUpdateEvents = MibTableColumn((1, 3, 6, 1, 2, 1, 98, 1, 5, 1, 22), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: gsmpSessionStatAdjUpdateEvents.setReference('General Switch Management Protocol V3: Section 9.6')
if mibBuilder.loadTexts: gsmpSessionStatAdjUpdateEvents.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionStatAdjUpdateEvents.setDescription('The number of Adjacency Update events that have been sent or received on this session. When the counter suffers any discontinuity, then the gsmpSessionDiscontinuityTime object indicates when it happened.')
gsmpEventPort = MibScalar((1, 3, 6, 1, 2, 1, 98, 2, 1), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: gsmpEventPort.setStatus('current')
if mibBuilder.loadTexts: gsmpEventPort.setDescription('This object specifies the Port Number that is carried in this event.')
gsmpEventPortSessionNumber = MibScalar((1, 3, 6, 1, 2, 1, 98, 2, 2), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: gsmpEventPortSessionNumber.setStatus('current')
if mibBuilder.loadTexts: gsmpEventPortSessionNumber.setDescription('This object specifies the Port Session Number that is carried in this event.')
gsmpEventSequenceNumber = MibScalar((1, 3, 6, 1, 2, 1, 98, 2, 3), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: gsmpEventSequenceNumber.setStatus('current')
if mibBuilder.loadTexts: gsmpEventSequenceNumber.setDescription('This object specifies the Event Sequence Number that is carried in this event.')
gsmpEventLabel = MibScalar((1, 3, 6, 1, 2, 1, 98, 2, 4), GsmpLabelType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: gsmpEventLabel.setStatus('current')
if mibBuilder.loadTexts: gsmpEventLabel.setDescription('This object specifies the Label that is carried in this event.')
gsmpSessionDown = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 1)).setObjects(("GSMP-MIB", "gsmpSessionStartUptime"), ("GSMP-MIB", "gsmpSessionStatSentMessages"), ("GSMP-MIB", "gsmpSessionStatFailureInds"), ("GSMP-MIB", "gsmpSessionStatReceivedMessages"), ("GSMP-MIB", "gsmpSessionStatReceivedFailures"), ("GSMP-MIB", "gsmpSessionStatPortUpEvents"), ("GSMP-MIB", "gsmpSessionStatPortDownEvents"), ("GSMP-MIB", "gsmpSessionStatInvLabelEvents"), ("GSMP-MIB", "gsmpSessionStatNewPortEvents"), ("GSMP-MIB", "gsmpSessionStatDeadPortEvents"), ("GSMP-MIB", "gsmpSessionStatAdjUpdateEvents"))
if mibBuilder.loadTexts: gsmpSessionDown.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionDown.setDescription('When it has been enabled, this notification is generated whenever a session is taken down, regardless of whether the session went down normally or not. Its purpose is to allow a management application (primarily an accounting application) that is monitoring the session statistics to receive the final values of these counters, so that the application can properly account for the amounts the counters were incremented since the last time the application polled them. The gsmpSessionStartUptime object provides the total amount of time that the session was active. This notification is not a substitute for polling the session statistic counts. In particular, the count values reported in this notification cannot be assumed to be the complete totals for the life of the session, since they may have wrapped while the session was up. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifiers of the objects contained in the notification. An instance of this notification will contain exactly one instance of each of its objects, and these objects will all belong to the same conceptual row of the gsmpSessionTable.')
gsmpSessionUp = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 2)).setObjects(("GSMP-MIB", "gsmpSessionFarSideInstance"))
if mibBuilder.loadTexts: gsmpSessionUp.setStatus('current')
if mibBuilder.loadTexts: gsmpSessionUp.setDescription('When it has been enabled, this notification is generated when new session is established. The new session is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionFarSideInstance object contained in the notification.')
gsmpSentFailureInd = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 3)).setObjects(("GSMP-MIB", "gsmpSessionLastFailureCode"), ("GSMP-MIB", "gsmpSessionStatFailureInds"))
if mibBuilder.loadTexts: gsmpSentFailureInd.setStatus('current')
if mibBuilder.loadTexts: gsmpSentFailureInd.setDescription('When it has been enabled, this notification is generated when a message with a failure indication was sent. The notification indicates a change in the value of gsmpSessionStatFailureInds. The gsmpSessionLastFailureCode contains the failure reason. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifiers of the objects contained in the notification.')
gsmpReceivedFailureInd = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 4)).setObjects(("GSMP-MIB", "gsmpSessionLastFailureCode"), ("GSMP-MIB", "gsmpSessionStatReceivedFailures"))
if mibBuilder.loadTexts: gsmpReceivedFailureInd.setStatus('current')
if mibBuilder.loadTexts: gsmpReceivedFailureInd.setDescription('When it has been enabled, this notification is generate when a message with a failure indication is received. The notification indicates a change in the value of gsmpSessionStatReceivedFailures. The gsmpSessionLastFailureCode contains the failure reason. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifiers of the objects contained in the notification.')
gsmpPortUpEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 5)).setObjects(("GSMP-MIB", "gsmpSessionStatPortUpEvents"), ("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventPortSessionNumber"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpPortUpEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpPortUpEvent.setDescription('When it has been enabled, this notification is generated when a Port Up Event occurs. The notification indicates a change in the value of gsmpSessionStatPortUpEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionStatPortUpEvents object contained in the notification.')
gsmpPortDownEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 6)).setObjects(("GSMP-MIB", "gsmpSessionStatPortDownEvents"), ("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventPortSessionNumber"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpPortDownEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpPortDownEvent.setDescription('When it has been enabled, this notification is generated when a Port Down Event occurs. The notification indicates a change in the value of gsmpSessionStatPortDownEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionStatPortDownEvents object contained in the notification.')
gsmpInvalidLabelEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 7)).setObjects(("GSMP-MIB", "gsmpSessionStatInvLabelEvents"), ("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventLabel"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpInvalidLabelEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpInvalidLabelEvent.setDescription('When it has been enabled, this notification is generated when an Invalid Label Event occurs. The notification indicates a change in the value of gsmpSessionStatInvLabelEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionStatInvLabelEvents object contained in the notification.')
gsmpNewPortEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 8)).setObjects(("GSMP-MIB", "gsmpSessionStatNewPortEvents"), ("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventPortSessionNumber"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpNewPortEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpNewPortEvent.setDescription('When it has been enabled, this notification is generated when a New Port Event occurs. The notification indicates a change in the value of gsmpSessionStatNewPortEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionStatNewPortEvents object contained in the notification.')
gsmpDeadPortEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 9)).setObjects(("GSMP-MIB", "gsmpSessionStatDeadPortEvents"), ("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventPortSessionNumber"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpDeadPortEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpDeadPortEvent.setDescription('When it has been enabled, this notification is generated when a Dead Port Event occurs. The notification indicates a change in the value of gsmpSessionStatDeadPortEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionStatDeadPortEvents object contained in the notification.')
gsmpAdjacencyUpdateEvent = NotificationType((1, 3, 6, 1, 2, 1, 98, 0, 10)).setObjects(("GSMP-MIB", "gsmpSessionAdjacencyCount"), ("GSMP-MIB", "gsmpSessionStatAdjUpdateEvents"), ("GSMP-MIB", "gsmpEventSequenceNumber"))
if mibBuilder.loadTexts: gsmpAdjacencyUpdateEvent.setStatus('current')
if mibBuilder.loadTexts: gsmpAdjacencyUpdateEvent.setDescription('When it has been enabled, this notification is generated when an Adjacency Update Event occurs. The gsmpSessionAdjacencyCount contains the new value of the number of adjacencies that are established with controllers and the switch partition that is used for this session. The notification indicates a change in the value of gsmpSessionStatAdjUpdateEvents. The session to which this notification applies is identified by the gsmpSessionThisSideId and gsmpSessionFarSideId which could be inferred from the Object Identifier of the gsmpSessionAdjacencyCount or the gsmpSessionStatAdjUpdateEvents object contained in the notification.')
gsmpGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 3, 1))
gsmpCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 98, 3, 2))
gsmpModuleCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 98, 3, 2, 1)).setObjects(("GSMP-MIB", "gsmpGeneralGroup"), ("GSMP-MIB", "gsmpControllerGroup"), ("GSMP-MIB", "gsmpSwitchGroup"), ("GSMP-MIB", "gsmpAtmEncapGroup"), ("GSMP-MIB", "gsmpTcpIpEncapGroup"), ("GSMP-MIB", "gsmpNotificationObjectsGroup"), ("GSMP-MIB", "gsmpNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpModuleCompliance = gsmpModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: gsmpModuleCompliance.setDescription('The compliance statement for agents that support the GSMP MIB.')
gsmpGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 1)).setObjects(("GSMP-MIB", "gsmpSessionVersion"), ("GSMP-MIB", "gsmpSessionTimer"), ("GSMP-MIB", "gsmpSessionPartitionId"), ("GSMP-MIB", "gsmpSessionAdjacencyCount"), ("GSMP-MIB", "gsmpSessionFarSideName"), ("GSMP-MIB", "gsmpSessionFarSidePort"), ("GSMP-MIB", "gsmpSessionFarSideInstance"), ("GSMP-MIB", "gsmpSessionLastFailureCode"), ("GSMP-MIB", "gsmpSessionDiscontinuityTime"), ("GSMP-MIB", "gsmpSessionStartUptime"), ("GSMP-MIB", "gsmpSessionStatSentMessages"), ("GSMP-MIB", "gsmpSessionStatFailureInds"), ("GSMP-MIB", "gsmpSessionStatReceivedMessages"), ("GSMP-MIB", "gsmpSessionStatReceivedFailures"), ("GSMP-MIB", "gsmpSessionStatPortUpEvents"), ("GSMP-MIB", "gsmpSessionStatPortDownEvents"), ("GSMP-MIB", "gsmpSessionStatInvLabelEvents"), ("GSMP-MIB", "gsmpSessionStatNewPortEvents"), ("GSMP-MIB", "gsmpSessionStatDeadPortEvents"), ("GSMP-MIB", "gsmpSessionStatAdjUpdateEvents"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpGeneralGroup = gsmpGeneralGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpGeneralGroup.setDescription('Objects that apply to all GSMP implementations.')
gsmpControllerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 2)).setObjects(("GSMP-MIB", "gsmpControllerMaxVersion"), ("GSMP-MIB", "gsmpControllerTimer"), ("GSMP-MIB", "gsmpControllerPort"), ("GSMP-MIB", "gsmpControllerInstance"), ("GSMP-MIB", "gsmpControllerPartitionType"), ("GSMP-MIB", "gsmpControllerPartitionId"), ("GSMP-MIB", "gsmpControllerDoResync"), ("GSMP-MIB", "gsmpControllerNotificationMap"), ("GSMP-MIB", "gsmpControllerSessionState"), ("GSMP-MIB", "gsmpControllerStorageType"), ("GSMP-MIB", "gsmpControllerRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpControllerGroup = gsmpControllerGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpControllerGroup.setDescription('Objects that apply GSMP implementations of Switch Controllers.')
gsmpSwitchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 3)).setObjects(("GSMP-MIB", "gsmpSwitchMaxVersion"), ("GSMP-MIB", "gsmpSwitchTimer"), ("GSMP-MIB", "gsmpSwitchName"), ("GSMP-MIB", "gsmpSwitchPort"), ("GSMP-MIB", "gsmpSwitchInstance"), ("GSMP-MIB", "gsmpSwitchPartitionType"), ("GSMP-MIB", "gsmpSwitchPartitionId"), ("GSMP-MIB", "gsmpSwitchNotificationMap"), ("GSMP-MIB", "gsmpSwitchSwitchType"), ("GSMP-MIB", "gsmpSwitchWindowSize"), ("GSMP-MIB", "gsmpSwitchSessionState"), ("GSMP-MIB", "gsmpSwitchStorageType"), ("GSMP-MIB", "gsmpSwitchRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpSwitchGroup = gsmpSwitchGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpSwitchGroup.setDescription('Objects that apply GSMP implementations of Switches.')
gsmpAtmEncapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 4)).setObjects(("GSMP-MIB", "gsmpAtmEncapIfIndex"), ("GSMP-MIB", "gsmpAtmEncapVpi"), ("GSMP-MIB", "gsmpAtmEncapVci"), ("GSMP-MIB", "gsmpAtmEncapStorageType"), ("GSMP-MIB", "gsmpAtmEncapRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpAtmEncapGroup = gsmpAtmEncapGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpAtmEncapGroup.setDescription('Objects that apply to GSMP implementations that supports ATM for GSMP encapsulation.')
gsmpTcpIpEncapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 5)).setObjects(("GSMP-MIB", "gsmpTcpIpEncapAddressType"), ("GSMP-MIB", "gsmpTcpIpEncapAddress"), ("GSMP-MIB", "gsmpTcpIpEncapPortNumber"), ("GSMP-MIB", "gsmpTcpIpEncapStorageType"), ("GSMP-MIB", "gsmpTcpIpEncapRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpTcpIpEncapGroup = gsmpTcpIpEncapGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpTcpIpEncapGroup.setDescription('Objects that apply to GSMP implementations that supports TCP/IP for GSMP encapsulation.')
gsmpNotificationObjectsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 6)).setObjects(("GSMP-MIB", "gsmpEventPort"), ("GSMP-MIB", "gsmpEventPortSessionNumber"), ("GSMP-MIB", "gsmpEventSequenceNumber"), ("GSMP-MIB", "gsmpEventLabel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpNotificationObjectsGroup = gsmpNotificationObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpNotificationObjectsGroup.setDescription('Objects that are contained in the notifications.')
gsmpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 98, 3, 1, 7)).setObjects(("GSMP-MIB", "gsmpSessionDown"), ("GSMP-MIB", "gsmpSessionUp"), ("GSMP-MIB", "gsmpSentFailureInd"), ("GSMP-MIB", "gsmpReceivedFailureInd"), ("GSMP-MIB", "gsmpPortUpEvent"), ("GSMP-MIB", "gsmpPortDownEvent"), ("GSMP-MIB", "gsmpInvalidLabelEvent"), ("GSMP-MIB", "gsmpNewPortEvent"), ("GSMP-MIB", "gsmpDeadPortEvent"), ("GSMP-MIB", "gsmpAdjacencyUpdateEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    gsmpNotificationsGroup = gsmpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: gsmpNotificationsGroup.setDescription('The notifications which indicate specific changes in the value of objects gsmpSessionTable')
mibBuilder.exportSymbols("GSMP-MIB", gsmpSessionDown=gsmpSessionDown, gsmpControllerPartitionId=gsmpControllerPartitionId, gsmpSwitchPartitionId=gsmpSwitchPartitionId, gsmpAtmEncapIfIndex=gsmpAtmEncapIfIndex, GsmpNameType=GsmpNameType, gsmpSwitchTable=gsmpSwitchTable, gsmpSwitchRowStatus=gsmpSwitchRowStatus, gsmpTcpIpEncapStorageType=gsmpTcpIpEncapStorageType, gsmpAtmEncapEntityId=gsmpAtmEncapEntityId, gsmpSessionThisSideId=gsmpSessionThisSideId, gsmpTcpIpEncapGroup=gsmpTcpIpEncapGroup, gsmpTcpIpEncapEntry=gsmpTcpIpEncapEntry, gsmpSwitchSessionState=gsmpSwitchSessionState, gsmpControllerNotificationMap=gsmpControllerNotificationMap, gsmpSwitchPort=gsmpSwitchPort, gsmpTcpIpEncapAddressType=gsmpTcpIpEncapAddressType, gsmpSwitchPartitionType=gsmpSwitchPartitionType, gsmpSwitchNotificationMap=gsmpSwitchNotificationMap, gsmpSwitchInstance=gsmpSwitchInstance, gsmpControllerGroup=gsmpControllerGroup, gsmpNewPortEvent=gsmpNewPortEvent, gsmpTcpIpEncapEntityId=gsmpTcpIpEncapEntityId, gsmpSessionStatInvLabelEvents=gsmpSessionStatInvLabelEvents, gsmpDeadPortEvent=gsmpDeadPortEvent, GsmpPartitionType=GsmpPartitionType, gsmpInvalidLabelEvent=gsmpInvalidLabelEvent, gsmpNotificationsObjects=gsmpNotificationsObjects, gsmpAdjacencyUpdateEvent=gsmpAdjacencyUpdateEvent, gsmpSwitchStorageType=gsmpSwitchStorageType, gsmpSessionEntry=gsmpSessionEntry, gsmpGroups=gsmpGroups, gsmpSessionStartUptime=gsmpSessionStartUptime, gsmpControllerPort=gsmpControllerPort, gsmpAtmEncapGroup=gsmpAtmEncapGroup, gsmpSwitchEntry=gsmpSwitchEntry, gsmpGeneralGroup=gsmpGeneralGroup, gsmpControllerTable=gsmpControllerTable, gsmpNotificationObjectsGroup=gsmpNotificationObjectsGroup, gsmpAtmEncapRowStatus=gsmpAtmEncapRowStatus, gsmpSwitchMaxVersion=gsmpSwitchMaxVersion, gsmpSessionFarSideName=gsmpSessionFarSideName, gsmpSessionStatFailureInds=gsmpSessionStatFailureInds, gsmpSessionVersion=gsmpSessionVersion, gsmpNotificationsGroup=gsmpNotificationsGroup, gsmpSwitchSwitchType=gsmpSwitchSwitchType, gsmpEventSequenceNumber=gsmpEventSequenceNumber, gsmpReceivedFailureInd=gsmpReceivedFailureInd, gsmpSessionStatDeadPortEvents=gsmpSessionStatDeadPortEvents, gsmpSwitchWindowSize=gsmpSwitchWindowSize, gsmpAtmEncapStorageType=gsmpAtmEncapStorageType, gsmpSessionTimer=gsmpSessionTimer, gsmpSessionAdjacencyCount=gsmpSessionAdjacencyCount, gsmpSessionTable=gsmpSessionTable, gsmpEventPort=gsmpEventPort, gsmpSessionLastFailureCode=gsmpSessionLastFailureCode, GsmpLabelType=GsmpLabelType, gsmpSessionDiscontinuityTime=gsmpSessionDiscontinuityTime, gsmpPortDownEvent=gsmpPortDownEvent, GsmpPartitionIdType=GsmpPartitionIdType, gsmpEventPortSessionNumber=gsmpEventPortSessionNumber, gsmpEventLabel=gsmpEventLabel, gsmpTcpIpEncapAddress=gsmpTcpIpEncapAddress, gsmpSessionStatNewPortEvents=gsmpSessionStatNewPortEvents, gsmpSwitchGroup=gsmpSwitchGroup, gsmpControllerEntry=gsmpControllerEntry, gsmpObjects=gsmpObjects, gsmpAtmEncapVpi=gsmpAtmEncapVpi, gsmpSessionStatReceivedMessages=gsmpSessionStatReceivedMessages, gsmpTcpIpEncapPortNumber=gsmpTcpIpEncapPortNumber, gsmpSessionUp=gsmpSessionUp, GsmpVersion=GsmpVersion, gsmpControllerEntityId=gsmpControllerEntityId, gsmpTcpIpEncapRowStatus=gsmpTcpIpEncapRowStatus, gsmpControllerTimer=gsmpControllerTimer, gsmpSessionStatAdjUpdateEvents=gsmpSessionStatAdjUpdateEvents, gsmpSessionStatPortUpEvents=gsmpSessionStatPortUpEvents, gsmpNotifications=gsmpNotifications, gsmpSessionFarSideInstance=gsmpSessionFarSideInstance, gsmpSessionFarSideId=gsmpSessionFarSideId, gsmpControllerRowStatus=gsmpControllerRowStatus, gsmpTcpIpEncapTable=gsmpTcpIpEncapTable, gsmpSessionStatPortDownEvents=gsmpSessionStatPortDownEvents, gsmpSessionFarSidePort=gsmpSessionFarSidePort, gsmpControllerDoResync=gsmpControllerDoResync, gsmpSwitchTimer=gsmpSwitchTimer, gsmpAtmEncapTable=gsmpAtmEncapTable, gsmpControllerInstance=gsmpControllerInstance, gsmpMIB=gsmpMIB, gsmpSwitchName=gsmpSwitchName, gsmpControllerPartitionType=gsmpControllerPartitionType, gsmpControllerMaxVersion=gsmpControllerMaxVersion, gsmpSessionPartitionId=gsmpSessionPartitionId, gsmpAtmEncapVci=gsmpAtmEncapVci, gsmpSwitchEntityId=gsmpSwitchEntityId, gsmpCompliances=gsmpCompliances, gsmpControllerSessionState=gsmpControllerSessionState, gsmpAtmEncapEntry=gsmpAtmEncapEntry, gsmpSessionStatSentMessages=gsmpSessionStatSentMessages, gsmpSessionStatReceivedFailures=gsmpSessionStatReceivedFailures, gsmpSentFailureInd=gsmpSentFailureInd, PYSNMP_MODULE_ID=gsmpMIB, gsmpConformance=gsmpConformance, gsmpPortUpEvent=gsmpPortUpEvent, gsmpControllerStorageType=gsmpControllerStorageType, gsmpModuleCompliance=gsmpModuleCompliance)

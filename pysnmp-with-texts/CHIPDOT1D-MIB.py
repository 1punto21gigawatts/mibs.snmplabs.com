#
# PySNMP MIB module CHIPDOT1D-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CHIPDOT1D-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:48:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
DisplayString, = mibBuilder.importSymbols("RFC1155-SMI", "DisplayString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter32, TimeTicks, Counter64, ObjectIdentity, Unsigned32, ModuleIdentity, IpAddress, Gauge32, enterprises, iso = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter32", "TimeTicks", "Counter64", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "IpAddress", "Gauge32", "enterprises", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class BridgeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class Timeout(Integer32):
    pass

chipcom = MibIdentifier((1, 3, 6, 1, 4, 1, 49))
chipmib02 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2))
chipGen = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 1))
chipEcho = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 2))
chipProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3))
chipExperiment = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4))
chipTTY = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 5))
chipTFTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 6))
chipDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 7))
online = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1))
oebm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 2))
midnight = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 3))
workGroupHub = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4))
emm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 5))
chipBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 6))
trmm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 7))
fmm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 8))
focus1 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 9))
oeim = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 10))
chipExpTokenRing = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 1))
dot1dBridge = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14))
dot5 = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 1, 1))
olAgents = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 1))
olConc = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 2))
olEnv = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 3))
olModules = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4))
olNets = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5))
olGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 6))
olAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7))
olSpecMods = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4))
ol50nnMCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 3))
ol51nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 4))
ol51nnMFIB = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 5))
ol51nnMUTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 6))
ol51nnMTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 7))
ol51nnMBNC = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 8))
ol51nnBEE = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 9))
ol51nnRES = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 10))
ol51nnREE = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 11))
ol51nnMAUIF = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 12))
ol51nnMAUIM = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 13))
ol5208MTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 14))
ol51nnMFP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 15))
ol51nnMFBP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 16))
ol51nnMTPL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 17))
ol51nnMTPPL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 18))
ol52nnMTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 19))
ol52nnMFR = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 20))
ol51nnMTS = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 21))
ol51nnMFL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 22))
ol50nnMRCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 23))
ol51nnMFB = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 24))
ol53nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 25))
ol53nnMFBMIC = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 26))
ol53nnMFIBST = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 27))
ol53nnMSTP = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 28))
ol51nnMTPCL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 29))
ol52nnBTT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 30))
ol51nnIx = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 31))
ol52nnMMGT = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 32))
ol50nnMHCTL = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 4, 4, 33))
olNet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 1))
olEnet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 2))
olTRnet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 3))
olFDDInet = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 5, 4))
hubSysGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 1))
hardwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 2))
softwareGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 3))
hubGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 4))
boardGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 5))
portGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 6))
alarmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 4, 7))
olThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1))
olThreshControl = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 3, 1, 7, 1, 1))
chipBridgeSideSwitchMode = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chipBridgeSideSwitchMode.setStatus('mandatory')
if mibBuilder.loadTexts: chipBridgeSideSwitchMode.setDescription('The state of the side switch feature.')
dot1dBase = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1))
dot1dStp = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2))
dot1dTp = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4))
dot1dStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 5))
dot1dBaseBridgeAddress = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setReference('P802.1d/D9, July 14, 1989: Sections 6.4.1.1.3 and 3.12.5')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseBridgeAddress.setDescription('The MAC address used by this bridge when it must be referred to in a unique fashion. It is recommended that this be the numerically smallest MAC address of all ports that belong to this bridge. However it is only required to be unique. When concatenated with dot1dStpPriority a unique BridgeIdentifier is formed which is used in the Spanning Tree Protocol.')
dot1dBaseNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseNumPorts.setReference('P802.1d/D9, July 14, 1989: Section 6.4.1.1.3')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseNumPorts.setDescription('The number of ports controlled by this bridging entity.')
dot1dBaseType = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparent-only", 2), ("sourceroute-only", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBaseType.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBaseType.setDescription('Indicates what type of bridging this bridge can perform. If a bridge is actually performing a certain type of bridging this will be indicated by entries in the port table for the given type.')
dot1dBasePortTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4), )
if mibBuilder.loadTexts: dot1dBasePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortTable.setDescription('A table that contains generic information about every port that is associated with this bridge. Transparent, source-route, and srt ports are included.')
dot1dBasePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1), ).setIndexNames((0, "CHIPDOT1D-MIB", "dot1dBasePort"))
if mibBuilder.loadTexts: dot1dBasePortEntry.setReference('P802.1d/D9, July 14, 1989: Section 6.4.2, 6.6.1')
if mibBuilder.loadTexts: dot1dBasePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortEntry.setDescription('A list of information for each port of the bridge.')
dot1dBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePort.setDescription('The port number of the port for which this entry contains bridge management information.')
dot1dBasePortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortIfIndex.setDescription('The value of the instance of the ifIndex object, defined in [4,6], for the interface corresponding to this port.')
dot1dBasePortCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortCircuit.setDescription('For a port which (potentially) has the same value of dot1dBasePortIfIndex as another port on the same bridge, this object contains the name of an object instance unique to this port. For example, in the case where multiple ports correspond one- to-one with multiple X.25 virtual circuits, this value might identify an (e.g., the first) object instance associated with the X.25 virtual circuit corresponding to this port. For a port which has a unique value of dot1dBasePortIfIndex, this object can have the value { 0 0 }.')
dot1dBasePortDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortDelayExceededDiscards.setDescription('The number of frames discarded by this port due to excessive transit delay through the bridge. It is incremented by both transparent and source route bridges.')
dot1dBasePortMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 1, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dBasePortMtuExceededDiscards.setDescription('The number of frames discarded by this port due to an excessive size. It is incremented by both transparent and source route bridges.')
dot1dStpProtocolSpecification = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("decLb100", 2), ("ieee8021d", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpProtocolSpecification.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpProtocolSpecification.setDescription("An indication of what version of the Spanning Tree Protocol is being run. The value 'decLb100(2)' indicates the DEC LANbridge 100 Spanning Tree protocol. IEEE 802.1d implementations will return 'ieee8021d(3)'. If future versions of the IEEE Spanning Tree Protocol are released that are incompatible with the current version a new value will be defined.")
dot1dStpPriority = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.7')
if mibBuilder.loadTexts: dot1dStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPriority.setDescription('The value of the write-able portion of the Bridge ID, i.e., the first two octets of the (8 octet long) Bridge ID. The other (last) 6 octets of the Bridge ID are given by the value of dot1dBaseBridgeAddress.')
dot1dStpTimeSinceTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpTimeSinceTopologyChange.setDescription('The time (in hundredths of a second) since the last time a topology change was detected by the bridge entity.')
dot1dStpTopChanges = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpTopChanges.setReference('P802.1d/D9, July 14, 1989: Section 6.8.1.1.3')
if mibBuilder.loadTexts: dot1dStpTopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpTopChanges.setDescription('The total number of topology changes detected by this bridge since the management entity was last reset or initialized.')
dot1dStpDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 5), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.1')
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpDesignatedRoot.setDescription('The bridge identifier of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by this node. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node.')
dot1dStpRootCost = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpRootCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.2')
if mibBuilder.loadTexts: dot1dStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpRootCost.setDescription('The cost of the path to the root as seen from this bridge.')
dot1dStpRootPort = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpRootPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.3')
if mibBuilder.loadTexts: dot1dStpRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpRootPort.setDescription('The port number of the port which offers the lowest cost path from this bridge to the root bridge.')
dot1dStpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 8), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.4')
if mibBuilder.loadTexts: dot1dStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpMaxAge.setDescription('The maximum age of Spanning Tree Protocol information learned from the network on any port before it is discarded, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
dot1dStpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 9), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.5')
if mibBuilder.loadTexts: dot1dStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpHelloTime.setDescription('The amount of time between the transmission of Configuration bridge PDUs by this node on any port when it is the root of the spanning tree or trying to become so, in units of hundredths of a second. This is the actual value that this bridge is currently using.')
dot1dStpHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpHoldTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.14')
if mibBuilder.loadTexts: dot1dStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpHoldTime.setDescription('This time value determines the interval length during which no more than two Configuration bridge PDUs shall be transmitted by this node, in units of hundredths of a second.')
dot1dStpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 11), Timeout()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.6')
if mibBuilder.loadTexts: dot1dStpForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpForwardDelay.setDescription('This time value, measured in units of hundredths of a second, controls how fast a port changes its spanning state when moving towards the Forwarding state. The value determines how long the port stays in a particular state before moving to the next state. For example, how long a port stays in the Listening state when moving from Blocking to Learning. This value is also used, when a topology change has been detected and is underway, to age all dynamic entries in the Forwarding Database. [Note that this value is the one that this bridge is currently using, in contrast to dot1dStpBridgeForwardDelay which is the value that this bridge and all others would start using if/when this bridge were to become the root.]')
dot1dStpBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 12), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.8')
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpBridgeMaxAge.setDescription('The value that all bridges use for MaxAge when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of dot1dStpBridgeHelloTime. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 13), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.9')
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpBridgeHelloTime.setDescription('The value that all bridges use for HelloTime when this bridge is acting as the root. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 14), Timeout()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.10')
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpBridgeForwardDelay.setDescription('The value that all bridges use for ForwardDelay when this bridge is acting as the root. Note that 802.1d/D9 specifies that the range for this parameter is related to the value of dot1dStpBridgeMaxAge. The granularity of this timer is specified by 802.1d/D9 to be 1 second. An agent may return a badValue error if a set is attempted to a value which is not a whole number of seconds.')
dot1dStpPortTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15), )
if mibBuilder.loadTexts: dot1dStpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortTable.setDescription('A table that contains port-specific information for the Spanning Tree Protocol.')
dot1dStpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1), ).setIndexNames((0, "CHIPDOT1D-MIB", "dot1dStpPort"))
if mibBuilder.loadTexts: dot1dStpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortEntry.setDescription('A list of information maintained by every port about the Spanning Tree Protocol state for that port.')
dot1dStpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPort.setReference('P802.1d/D9, July 14, 1989: Section 6.8.2.1.2')
if mibBuilder.loadTexts: dot1dStpPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPort.setDescription('The port number of the port for which this entry contains Spanning Tree Protocol management information.')
dot1dStpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.1')
if mibBuilder.loadTexts: dot1dStpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortPriority.setDescription('The value of the priority field which is contained in the first (in network byte order) octet of the (2 octet long) Port ID. The other octet of the Port ID is given by the value of dot1dStpPort.')
dot1dStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortState.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: dot1dStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortState.setDescription("The port's current state as defined by application of the Spanning Tree Protocol. This state controls what action a port takes on reception of a frame. If the bridge has detected a port that is malfunctioning it will place that port into the broken(6) state. For ports which are disabled (see dot1dStpPortEnable), this object will have a value of disabled(1).")
dot1dStpPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortEnable.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.2')
if mibBuilder.loadTexts: dot1dStpPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortEnable.setDescription('The enabled/disabled status of the port.')
dot1dStpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dStpPortPathCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.3')
if mibBuilder.loadTexts: dot1dStpPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortPathCost.setDescription('The contribution of this port to the path cost of paths towards the spanning tree root which include this port.')
dot1dStpPortDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 6), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.4')
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortDesignatedRoot.setDescription('The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which the port is attached.')
dot1dStpPortDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.5')
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortDesignatedCost.setDescription('The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs.')
dot1dStpPortDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 8), BridgeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.6')
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortDesignatedBridge.setDescription("The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment.")
dot1dStpPortDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.5.7')
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortDesignatedPort.setDescription("The Port Identifier of the port on the Designated Bridge for this port's segment.")
dot1dStpPortForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 2, 15, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dStpPortForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dStpPortForwardTransitions.setDescription('The number of times this port has transitioned from the Learning state to the Forwarding state.')
dot1dTpLearnedEntryDiscards = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpLearnedEntryDiscards.setDescription('The total number of Forwarding Database entries, which have been or would have been learnt, but have been discarded due to a lack of space to store them in the Forwarding Database. If this counter is increasing, it indicates that the Forwarding Database is regularly becoming full (a condition which has unpleasant performance effects on the subnetwork). If this counter has a significant value but is not presently increasing, it indicates that the problem has been occurring but is not persistent.')
dot1dTpAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1dTpAgingTime.setReference('P802.1d/D9, July 14, 1989: Section 6.7.1.1.3')
if mibBuilder.loadTexts: dot1dTpAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpAgingTime.setDescription('The timeout period in seconds for aging out dynamically learned forwarding information.')
dot1dTpPortTable = MibTable((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4), )
if mibBuilder.loadTexts: dot1dTpPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortTable.setDescription('A table that contains information about every port that is associated with this transparent bridge.')
dot1dTpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1), ).setIndexNames((0, "CHIPDOT1D-MIB", "dot1dTpPort"))
if mibBuilder.loadTexts: dot1dTpPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortEntry.setDescription('A list of information for each port of a transparent bridge.')
dot1dTpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPort.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPort.setDescription('The port number of the port for which this entry contains Transparent bridging management information.')
dot1dTpPortMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
dot1dTpPortInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortInFrames.setDescription('The number of frames that have been received by this port from its segment. Note that a frame received on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
dot1dTpPortOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortOutFrames.setDescription('The number of frames that have been transmitted by this port to its segment. Note that a frame transmitted on the interface corresponding to this port is only counted by this object if and only if it is for a protocol being processed by the local bridging function.')
dot1dTpPortInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 49, 2, 4, 14, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setReference('P802.1d/D9, July 14, 1989: Section 6.6.1.1.3')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: dot1dTpPortInDiscards.setDescription('Count of valid frames received which were discarded (i.e., filtered) by the Forwarding Process.')
newRoot = NotificationType((1, 3, 6, 1, 4, 1, 49, 2, 4, 14) + (0,1))
if mibBuilder.loadTexts: newRoot.setDescription('The newRoot trap indicates that the sending agent has become the new root of the Spanning Tree; the trap is sent by a bridge soon after its election as the new root, e.g., upon expiration of the Topology Change Timer immediately subsequent to its election.')
topologyChange = NotificationType((1, 3, 6, 1, 4, 1, 49, 2, 4, 14) + (0,2))
if mibBuilder.loadTexts: topologyChange.setDescription('A topologyChange trap is sent by a bridge when any of its configured ports transitions from the Learning state to the Forwarding state, or from the Forwarding state to the Blocking state. The trap is not sent if a newRoot trap is sent for the same transition.')
mibBuilder.exportSymbols("CHIPDOT1D-MIB", dot1dBasePortDelayExceededDiscards=dot1dBasePortDelayExceededDiscards, ol52nnBTT=ol52nnBTT, softwareGroup=softwareGroup, chipBridge=chipBridge, dot1dStpRootCost=dot1dStpRootCost, ol51nnRES=ol51nnRES, ol53nnMSTP=ol53nnMSTP, chipExperiment=chipExperiment, chipGen=chipGen, dot1dBaseNumPorts=dot1dBaseNumPorts, dot1dBaseBridgeAddress=dot1dBaseBridgeAddress, dot1dStpBridgeMaxAge=dot1dStpBridgeMaxAge, Timeout=Timeout, ol51nnBEE=ol51nnBEE, ol53nnMFIBST=ol53nnMFIBST, midnight=midnight, chipProducts=chipProducts, ol51nnMMGT=ol51nnMMGT, fmm=fmm, dot1dStpBridgeForwardDelay=dot1dStpBridgeForwardDelay, dot1dStpPortPathCost=dot1dStpPortPathCost, ol5208MTP=ol5208MTP, dot1dStpPortDesignatedPort=dot1dStpPortDesignatedPort, newRoot=newRoot, olThreshControl=olThreshControl, ol51nnMTP=ol51nnMTP, dot1dTpPortInFrames=dot1dTpPortInFrames, dot1dStpHelloTime=dot1dStpHelloTime, olGroups=olGroups, dot1dStpPriority=dot1dStpPriority, dot1dBase=dot1dBase, alarmGroup=alarmGroup, ol51nnMFB=ol51nnMFB, chipDownload=chipDownload, dot1dStpPortForwardTransitions=dot1dStpPortForwardTransitions, chipTTY=chipTTY, dot1dBasePortCircuit=dot1dBasePortCircuit, chipmib02=chipmib02, olEnet=olEnet, dot1dBasePortIfIndex=dot1dBasePortIfIndex, ol50nnMCTL=ol50nnMCTL, dot1dTpPortEntry=dot1dTpPortEntry, dot1dStpDesignatedRoot=dot1dStpDesignatedRoot, focus1=focus1, dot1dTpAgingTime=dot1dTpAgingTime, oeim=oeim, dot1dBasePortMtuExceededDiscards=dot1dBasePortMtuExceededDiscards, dot1dTpPortMaxInfo=dot1dTpPortMaxInfo, dot1dTpPort=dot1dTpPort, olModules=olModules, ol50nnMHCTL=ol50nnMHCTL, dot1dStpPort=dot1dStpPort, dot1dBridge=dot1dBridge, dot1dTp=dot1dTp, ol51nnMTPL=ol51nnMTPL, chipBridgeSideSwitchMode=chipBridgeSideSwitchMode, dot1dBasePort=dot1dBasePort, olEnv=olEnv, dot1dTpPortTable=dot1dTpPortTable, ol52nnMFR=ol52nnMFR, dot1dStpRootPort=dot1dStpRootPort, dot1dStatic=dot1dStatic, ol52nnMTP=ol52nnMTP, ol50nnMRCTL=ol50nnMRCTL, ol51nnMAUIM=ol51nnMAUIM, chipTFTP=chipTFTP, chipcom=chipcom, ol51nnMAUIF=ol51nnMAUIF, hubGroup=hubGroup, dot1dStpPortDesignatedRoot=dot1dStpPortDesignatedRoot, ol51nnMFL=ol51nnMFL, dot1dBasePortEntry=dot1dBasePortEntry, dot5=dot5, boardGroup=boardGroup, ol53nnMMGT=ol53nnMMGT, dot1dStpPortPriority=dot1dStpPortPriority, ol51nnIx=ol51nnIx, dot1dBaseType=dot1dBaseType, ol51nnMFBP=ol51nnMFBP, olTRnet=olTRnet, trmm=trmm, olSpecMods=olSpecMods, ol51nnMFIB=ol51nnMFIB, ol51nnMFP=ol51nnMFP, chipExpTokenRing=chipExpTokenRing, dot1dStpHoldTime=dot1dStpHoldTime, dot1dStpPortEntry=dot1dStpPortEntry, ol51nnREE=ol51nnREE, ol52nnMMGT=ol52nnMMGT, dot1dTpPortOutFrames=dot1dTpPortOutFrames, olAgents=olAgents, dot1dStpPortEnable=dot1dStpPortEnable, dot1dStpPortDesignatedCost=dot1dStpPortDesignatedCost, ol53nnMFBMIC=ol53nnMFBMIC, ol51nnMUTP=ol51nnMUTP, olThresh=olThresh, dot1dStpBridgeHelloTime=dot1dStpBridgeHelloTime, olNets=olNets, ol51nnMBNC=ol51nnMBNC, ol51nnMTPPL=ol51nnMTPPL, online=online, dot1dStpPortState=dot1dStpPortState, dot1dBasePortTable=dot1dBasePortTable, dot1dStpPortDesignatedBridge=dot1dStpPortDesignatedBridge, olNet=olNet, dot1dStpPortTable=dot1dStpPortTable, ol51nnMTPCL=ol51nnMTPCL, olAlarm=olAlarm, olConc=olConc, topologyChange=topologyChange, workGroupHub=workGroupHub, chipEcho=chipEcho, dot1dTpLearnedEntryDiscards=dot1dTpLearnedEntryDiscards, dot1dStp=dot1dStp, hubSysGroup=hubSysGroup, emm=emm, olFDDInet=olFDDInet, dot1dStpTopChanges=dot1dStpTopChanges, oebm=oebm, dot1dStpForwardDelay=dot1dStpForwardDelay, dot1dStpMaxAge=dot1dStpMaxAge, dot1dStpProtocolSpecification=dot1dStpProtocolSpecification, BridgeId=BridgeId, portGroup=portGroup, dot1dStpTimeSinceTopologyChange=dot1dStpTimeSinceTopologyChange, ol51nnMTS=ol51nnMTS, MacAddress=MacAddress, hardwareGroup=hardwareGroup, dot1dTpPortInDiscards=dot1dTpPortInDiscards)

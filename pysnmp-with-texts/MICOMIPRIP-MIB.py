#
# PySNMP MIB module MICOMIPRIP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MICOMIPRIP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:12:38 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint")
micom_oscar, = mibBuilder.importSymbols("MICOM-OSCAR-MIB", "micom-oscar")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ObjectIdentity, Counter64, NotificationType, Bits, IpAddress, TimeTicks, Counter32, Unsigned32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ObjectIdentity", "Counter64", "NotificationType", "Bits", "IpAddress", "TimeTicks", "Counter32", "Unsigned32", "iso")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
mcmIp = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5))
ip_control = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 16)).setLabel("ip-control")
mcmIpRipEnable = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIpRipEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpRipEnable.setDescription('NAME = ; DESC = This Parameter determines if RIP is \\ turned ON or OFF on the access device.; HELP = When RIP is enabled, The access device \\ propogates routing information to other \\ access devices, gateways, and Hosts.; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpRipDfltRtEnable = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIpRipDfltRtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpRipDfltRtEnable.setDescription('NAME = ; DESC = This value determines if this unit should \\ act as default Router.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpRipCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rip1", 1), ("rip1Compatible", 2), ("rip2", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIpRipCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpRipCompatibility.setDescription('NAME = ; DESC = This value indicates the Routing \\ Internet Protocol (RIP) version.\\ rip1 indicates only RIP version 1 \\ packets are broadcasted. \\ rip1Compatible indicates RIP \\ version 2 packets are broadcasted. \\ rip2 indicates RIP version 2 packets \\ are multicasted.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3), )
if mibBuilder.loadTexts: mcmIpAddrTable.setStatus('deprecated')
if mibBuilder.loadTexts: mcmIpAddrTable.setDescription('NAME = ; DESC = ** Note this table has been deprecated and replaced by mcmIpAddressTable below ** \\ Information about the IP Protocol parameters \\ on a per interface basis.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "mcmipIfIndex"))
if mibBuilder.loadTexts: mcmIpAddrEntry.setStatus('deprecated')
if mibBuilder.loadTexts: mcmIpAddrEntry.setDescription('NAME = ; DESC = IP Parameters on a per interface basic.; HELP = ; CAPABILITIES = ;')
mcmipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipIfIndex.setDescription('NAME = ; DESC = ** DEPRECATED **\\ The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = The interface identified by a particular \\ value of this index is the same interface as \\ identified by the same value of ifIndex.; CAPABILITIES = ;')
mcmipAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddr.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipAddr.setDescription("NAME = ; DESC = ** DEPRECATED **\\ The IP address to which this entry's \\ addressing information pertains.; HELP = ; CAPABILITIES = ;")
mcmipMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipMtu.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipMtu.setDescription('NAME = ; DESC = ** DEPRECATED **\\ The size of the largest datagram which \\ can be sent/received on the interface, \\ specified in octets.; HELP = For interfaces that are used for transmitting \\ datagrams, this is the size of the largest \\ network datagram that can be sent on the interface.; CAPABILITIES = ;')
mcmipDlType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("csmacd", 1), ("tpb", 2), ("tpr", 3), ("metro", 4), ("ether", 5), ("hdlc", 6), ("char", 7), ("ctca", 8), ("fddi", 9), ("frameRelay", 10), ("frIpOpt", 11), ("other", 12), ("invalid", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipDlType.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipDlType.setDescription("NAME = ; DESC = ** DEPRECATED **\\ The type of interface, distinguished \\ according to the physical/link protocol(s) \\ immediately `below' the network layer \\ in the protocol stack. Note - these \\ HELP = ; CAPABILITIES = ;")
mcmipKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipKeepAlive.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipKeepAlive.setDescription('NAME = ; DESC = ** DEPRECATED **\\ This value determines if keepalives \\ are sent over this interface.; HELP = ; CAPABILITIES = ;')
mcmipForwardBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipForwardBcast.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipForwardBcast.setDescription('NAME = ; DESC = ** DEPRECATED **\\ This value determines if forward Broadcast \\ is turned ON or OFF.; HELP = This value determines if broadcasts \\ are forwarded.; CAPABILITIES = ;')
mcmipUnumIf = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unnumbered", 1), ("numbered", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipUnumIf.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipUnumIf.setDescription('NAME = ; DESC = ** DEPRECATED **\\ This value determines if Unumbered IP \\ is supported on this interface.; HELP = ; CAPABILITIES = ;')
mcmipRoutProtType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 2), ("passiveRip", 3), ("disable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipRoutProtType.setStatus('deprecated')
if mibBuilder.loadTexts: mcmipRoutProtType.setDescription('NAME = ; DESC = ** DEPRECATED **\\ This value determines the IP routing \\ protocol on this interface.; HELP =; CAPABILITIES = ;')
mcmIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12), )
if mibBuilder.loadTexts: mcmIpAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpAddressTable.setDescription('NAME = ; DESC = Information about the IP Protocol parameters \\ on a per interface basis.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "mcmipAddressIfIndex"), (0, "MICOMIPRIP-MIB", "mcmipAddress"))
if mibBuilder.loadTexts: mcmIpAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpAddressEntry.setDescription('NAME = ; DESC = IP Parameters on a per interface basic.; HELP = ; CAPABILITIES = ;')
mcmipAddressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressIfIndex.setDescription('NAME = ; DESC = The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = The interface identified by a particular \\ value of this index is the same interface as \\ identified by the same value of ifIndex.; CAPABILITIES = ;')
mcmipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddress.setDescription("NAME = ; DESC = The IP address to which this entry's \\ addressing information pertains. This \\ object is also used as the second index \\ for this table.; HELP = ; CAPABILITIES = ;")
mcmipAddressMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressMtu.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressMtu.setDescription('NAME = ; DESC = The size of the largest datagram which \\ can be sent/received on the interface, \\ specified in octets.; HELP = For interfaces that are used for transmitting \\ datagrams, this is the size of the largest \\ network datagram that can be sent on the interface.; CAPABILITIES = ;')
mcmipAddressDlType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 13))).clone(namedValues=NamedValues(("ether", 5), ("frameRelay", 10), ("invalid", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressDlType.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressDlType.setDescription("NAME = ; DESC = The type of interface, distinguished \\ according to the physical/link protocol(s) \\ immediately `below' the network layer \\ in the protocol stack. Invalid is used on releases \\ previous to 3.0; HELP = ; CAPABILITIES = ;")
mcmipAddressKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressKeepAlive.setDescription('NAME = ; DESC = This value determines if keepalives \\ are sent over this interface.; HELP = ; CAPABILITIES = ;')
mcmipAddressForwardBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressForwardBcast.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressForwardBcast.setDescription('NAME = ; DESC = This value determines if forward Broadcast \\ is turned ON or OFF.; HELP = This value determines if broadcasts \\ are forwarded.; CAPABILITIES = ;')
mcmipAddressUnumIf = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unnumbered", 1), ("numbered", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressUnumIf.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressUnumIf.setDescription('NAME = ; DESC = This value determines if Unumbered IP \\ is supported on this interface.; HELP = ; CAPABILITIES = ;')
mcmipAddressRoutProtType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 2), ("passiveRip", 3), ("disable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmipAddressRoutProtType.setStatus('mandatory')
if mibBuilder.loadTexts: mcmipAddressRoutProtType.setDescription('NAME = ; DESC = This value determines the IP routing \\ protocol on this interface.; HELP =; CAPABILITIES = ;')
mcmIPBootpRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 14))
mcmIPBootpRelay = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIPBootpRelay.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIPBootpRelay.setDescription('NAME = ; DESC = The value of this object determines \\ if the access device will relay Bootp \\ packets. \\ (Operational); HELP = When the Bootp Relay is on, the access \\ device can forward Bootp requests to \\ servers on another network.; CAPABILITIES = ;')
mcmIPBootpRelayServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 14, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIPBootpRelayServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIPBootpRelayServerAddr.setDescription('NAME = ; DESC = The value of this object indicates the IP \\ address to which Bootp relay agent will \\ relay Bootp requests to. \\ (Operational); HELP = ; CAPABILITIES = ;')
mcmIPBootpRelayHops = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIPBootpRelayHops.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIPBootpRelayHops.setDescription('NAME = ; DESC = The value of this object indicates the \\ number of hops a Bootp packet is allowed \\ to make. \\ (Operational); HELP = ; CAPABILITIES = ;')
nvmIpRipEnable = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIpRipEnable.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIpRipEnable.setDescription("NAME = ; DESC = This Parameter determines if RIP is \\ turned ON or OFF on the access device.; HELP = When RIP is enabled, The access \\ device propogates routing information \\ to other access device's, gateways, \\ and Hosts.; CAPABILITIES = NET_CFG, VPN_CFG;")
nvmIpRipDfltRtEnable = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIpRipDfltRtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIpRipDfltRtEnable.setDescription('NAME = ; DESC = This value determines if this unit should \\ act as default Router.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmIpAddressRipCompatibility = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rip1", 1), ("rip1Compatible", 2), ("rip2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIpAddressRipCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIpAddressRipCompatibility.setDescription('NAME = ; DESC = This value indicates the the Routing \\ Information Protocol (RIP) version. \\ rip1 indicates only RIP version 1 \\ packets are broadcasted. \\ rip1Compatible indicates RIP \\ version 2 packets are broadcasted. \\ rip2 indicates RIP version 2 packets \\ are multicasted.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmIpAddrTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6), )
if mibBuilder.loadTexts: nvmIpAddrTable.setStatus('deprecated')
if mibBuilder.loadTexts: nvmIpAddrTable.setDescription("NAME = ; DESC = ** Note that this table has been deprecated \\ and it's functionality has been replaced by \\ nvmIpAddressTable. \\ Information about the IP Protocol parameters \\ on a per interface basis.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;")
nvmIpAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "nvmipIfIndex"))
if mibBuilder.loadTexts: nvmIpAddrEntry.setStatus('deprecated')
if mibBuilder.loadTexts: nvmIpAddrEntry.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ IP Parameters on a per interface basis.; HELP = ; CAPABILITIES = ;')
nvmipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipIfIndex.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = The interface identified by a particular \\ value of this index is the same interface as \\ identified by the same value of ifIndex.; CAPABILITIES = ;')
nvmipAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddr.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipAddr.setDescription("NAME = ; DESC = ** DEPRECATED ** \\ The IP address to which this entry's \\ addressing information pertains.; HELP = ; CAPABILITIES = ;")
nvmipMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipMtu.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipMtu.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ The size of the largest datagram which \\ can be sent/received on the interface, \\ specified in octets.; HELP = For interfaces that are used for transmitting \\ datagrams, this is the size of the largest \\ network datagram that can be sent on the interface.; CAPABILITIES = ;')
nvmipDlType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("csmacd", 1), ("tpb", 2), ("tpr", 3), ("metro", 4), ("ether", 5), ("hdlc", 6), ("char", 7), ("ctca", 8), ("fddi", 9), ("frameRelay", 10), ("frIpOpt", 11), ("other", 12), ("invalid", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipDlType.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipDlType.setDescription("NAME = ; DESC = ** DEPRECATED ** \\ The type of interface, distinguished \\ according to the physical/link protocol(s) \\ immediately `below' the network layer \\ in the protocol stack.; HELP = ; CAPABILITIES = ;")
nvmipKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipKeepAlive.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipKeepAlive.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ This value determines if keepalives \\ are sent over this interface.; HELP = ; CAPABILITIES = ;')
nvmipForwardBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipForwardBcast.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipForwardBcast.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ This value determines if forward Broadcast \\ is turned ON or OFF.; HELP = This value determines if broadcasts \\ are forwarded.; CAPABILITIES = ;')
nvmipUnumIf = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unnumbered", 1), ("numbered", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipUnumIf.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipUnumIf.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ This value determines if Unumbered IP \\ is supported on this interface.; HELP = ; CAPABILITIES = ;')
nvmipRoutProtType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 2), ("passiveRip", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipRoutProtType.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipRoutProtType.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ This value determines the IP routing \\ protocol on this interface.; HELP = ; CAPABILITIES = ;')
nvmipNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipNetMask.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipNetMask.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ The subnet mask associated with the \\ Ip address of this entry.; HELP = The value of the mask is an IP address with \\ all the network bits set to 1 and all the \\ hosts bits set to 0.; CAPABILITIES = ;')
nvmipBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 6, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipBcastAddr.setStatus('deprecated')
if mibBuilder.loadTexts: nvmipBcastAddr.setDescription('NAME = ; DESC = ** DEPRECATED ** \\ The value of the least-significant bit in the IP\\ broadcast address used for sending datagrams on the \\ (logical) interface associated w/ IP addr of this entry.; HELP = when the Internet standard all-ones broadcast \\ address is used, the value will be \\ 1. This value applies to both the subnet & network \\ broadcasts addresses used by the entity on this interface.; CAPABILITIES = ;')
nvmIpAddressTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13), )
if mibBuilder.loadTexts: nvmIpAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIpAddressTable.setDescription('NAME = ; DESC = Information about the IP Protocol parameters \\ on a per interface basis.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmIpAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "nvmipAddressIfIndex"), (0, "MICOMIPRIP-MIB", "nvmipAddress"))
if mibBuilder.loadTexts: nvmIpAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIpAddressEntry.setDescription('NAME = ; DESC = IP Parameters on a per interface basis.; HELP = ; CAPABILITIES = ;')
nvmipAddressIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressIfIndex.setDescription('NAME = ; DESC = The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = The interface identified by a particular \\ value of this index is the same interface as \\ identified by the same value of ifIndex.; CAPABILITIES = ;')
nvmipAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddress.setDescription("NAME = ; DESC = The IP address to which this entry's \\ addressing information pertains. \\ This object is also used as the second \\ index for this table.; HELP = ; CAPABILITIES = ;")
nvmipAddressMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 1518))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressMtu.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressMtu.setDescription('NAME = ; DESC = The size of the largest datagram which \\ can be sent/received on the interface, \\ specified in octets.; HELP = For interfaces that are used for transmitting \\ datagrams, this is the size of the largest \\ network datagram that can be sent on the interface.; CAPABILITIES = ;')
nvmipAddressDlType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 13))).clone(namedValues=NamedValues(("ether", 5), ("frameRelay", 10), ("invalid", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressDlType.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressDlType.setDescription("NAME = ; DESC = The type of interface, distinguished \\ according to the physical/link protocol(s) \\ immediately `below' the network layer \\ in the protocol stack.; HELP = ; CAPABILITIES = ;")
nvmipAddressKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressKeepAlive.setDescription('NAME = ; DESC = This value determines if keepalives \\ are sent over this interface.; HELP = ; CAPABILITIES = ;')
nvmipAddressForwardBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressForwardBcast.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressForwardBcast.setDescription('NAME = ; DESC = This value determines if forward Broadcast \\ is turned ON or OFF.; HELP = This value determines if broadcasts \\ are forwarded.; CAPABILITIES = ;')
nvmipAddressUnumIf = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unnumbered", 1), ("numbered", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressUnumIf.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressUnumIf.setDescription('NAME = ; DESC = This value determines if Unumbered IP \\ is supported on this interface.; HELP = ; CAPABILITIES = ;')
nvmipAddressRoutProtType = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 2), ("passiveRip", 3), ("disable", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressRoutProtType.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressRoutProtType.setDescription("NAME = ; DESC = This value determines the IP routing \\ protocol on this interface. \\ This object only supported enumerations of \\ 'rip', 'passiveRip' and 'disable'; HELP = ; CAPABILITIES = ;")
nvmipAddressNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 9), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressNetMask.setDescription('NAME = ; DESC = The subnet mask associated with the \\ Ip address of this entry.; HELP = The value of the mask is an IP address with \\ all the network bits set to 1 and all the \\ hosts bits set to 0.; CAPABILITIES = ;')
nvmipAddressBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressBcastAddr.setDescription('NAME = ; DESC = The value of the least-significant bit in the IP\\ broadcast address used for sending datagrams on the \\ (logical) interface associated w/ IP addr of this entry.; HELP = when the Internet standard all-ones broadcast \\ address is used, the value will be \\ 1. This value applies to both the subnet & network \\ broadcasts addresses used by the entity on this interface.; CAPABILITIES = ;')
nvmipAddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 13, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("destroy", 2), ("active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmipAddressRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nvmipAddressRowStatus.setDescription('NAME = ; DESC = This value determines the state on \\ which this interface is.; HELP = ; CAPABILITIES = ;')
nvmIPBootpRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 15))
nvmIPBootpRelay = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIPBootpRelay.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIPBootpRelay.setDescription('NAME = ; DESC = The value of this object determines \\ if the access device will relay Bootp \\ packets. \\ (Configuration); HELP = When the Bootp Relay is on, the access \\ device can forward Bootp requests to \\ servers on another network.; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmIPBootpRelayServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 15, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIPBootpRelayServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIPBootpRelayServerAddr.setDescription('NAME = ; DESC = The value of this object indicates the IP \\ address to which Bootp relay agent will \\ relay Bootp requests to. \\ (Configuration); HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmIPBootpRelayHops = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 15, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmIPBootpRelayHops.setStatus('mandatory')
if mibBuilder.loadTexts: nvmIPBootpRelayHops.setDescription('NAME = ; DESC = The value of this object indicates the \\ number of hops a Bootp packet is allowed \\ to make. \\ (Configuration); HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpPingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 16, 1))
mcmIpPingAction = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ping", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmIpPingAction.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpPingAction.setDescription('NAME = ; DESC = This object invokes \\ the ping commmand. ; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpPingAddress = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 16, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mcmIpPingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpPingAddress.setDescription('NAME = ; DESC = The value of this object specifies \\ the address to be pinged. ; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpPingStatus = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("alive", 1), ("destinationUnreachable", 2), ("timeExceeded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmIpPingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcmIpPingStatus.setDescription('NAME = ; DESC = The value of this object indicates \\ the ping status. ; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpCntr = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7))
mcmIpIfCntrZeroTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 1), )
if mibBuilder.loadTexts: mcmIpIfCntrZeroTable.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIpIfCntrZeroTable.setDescription('NAME = ; DESC = ** NOTE:THIS TABLE IS OBSOLETE AND NO \\ LONGER SUPPORTED IN RELEASE 3.0 AND \\ BEYOND. \\ A table that contains port-specific \\ information for the MICOM Port Counter \\ Zeroing.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpIfCntrZeroEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 1, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "mcmIpIfCntrZeroIndex"))
if mibBuilder.loadTexts: mcmIpIfCntrZeroEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIpIfCntrZeroEntry.setDescription('NAME = ; DESC = A list of information maintained by \\ every port about the MICOM E-type Filter \\ parameters for that port.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIpIfCntrZeroIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 1, 1, 1), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmIpIfCntrZeroIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIpIfCntrZeroIndex.setDescription('NAME = ; DESC = The Index to which this entry pertains.; HELP = ; CAPABILITIES = ;')
mcmIpIfGrpCounterZero = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmIpIfGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIpIfGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the Interfaces Group \\ Counters should be zeroed out.; HELP = ; CAPABILITIES = ;')
mcmIpCntrGrp = MibIdentifier((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2))
mcmIpGrpCounterZero = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmIpGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIpGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the IP Counters should \\ be zeroed out.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmIcmpGrpCounterZero = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmIcmpGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmIcmpGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the ICMP Counters \\ should be zeroed out.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmTcpGrpCounterZero = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmTcpGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmTcpGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the TCP Counters \\ should be zeroed out.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmUdpGrpCounterZero = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmUdpGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmUdpGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the UDP Counters \\ should be zeroed out.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmSnmpGrpCounterZero = MibScalar((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 7, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("other", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mcmSnmpGrpCounterZero.setStatus('obsolete')
if mibBuilder.loadTexts: mcmSnmpGrpCounterZero.setDescription('NAME = ; DESC = When set to reset, the SNMP Counters \\ should be zeroed out.; HELP = ; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmInverseArpTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 8), )
if mibBuilder.loadTexts: mcmInverseArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mcmInverseArpTable.setDescription('NAME = ; DESC = This table gives information \\ on the status (enable/disable) of Inverse \\ ARP for a protocol for a specific DLCI.; HELP = Inverse ARP is used to get the IP Address \\ of the Core Router from the branch \\ OSCAR using the Frame Relay DLCI NNumber \\ that is used to connect to the Core Router.; CAPABILITIES = NET_CFG, VPN_CFG;')
mcmInverseArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 8, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "mcmInverseArpIfIndex"), (0, "MICOMIPRIP-MIB", "mcmInverseArpProtocol"))
if mibBuilder.loadTexts: mcmInverseArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mcmInverseArpEntry.setDescription('NAME = ; DESC = Inverse ARP for a DLCI for a protocol.; HELP = ; CAPABILITIES = ;')
mcmInverseArpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmInverseArpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mcmInverseArpIfIndex.setDescription('NAME = ; DESC = The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = ; CAPABILITIES = ;')
mcmInverseArpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ip", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmInverseArpProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mcmInverseArpProtocol.setDescription('NAME = ; DESC = The protocol that is used for Auto-discovery of \\ IP address.; HELP = ; CAPABILITIES = ;')
mcmInverseArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mcmInverseArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mcmInverseArpStatus.setDescription('NAME = ; DESC = This tells weather InversArp is enabled or not.; HELP = ; CAPABILITIES = ;')
nvmInverseArpTable = MibTable((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 9), )
if mibBuilder.loadTexts: nvmInverseArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: nvmInverseArpTable.setDescription('NAME = ; DESC = This table gives information \\ on the status (enable/disable) of Inverse \\ ARP for a protocol for a specific DLCI.; HELP = Inverse ARP is used to get the IP Address \\ of the Core Router from the branch \\ OSCAR using the Frame Relay DLCI NNumber \\ that is used to connect to the Core Router.; CAPABILITIES = NET_CFG, VPN_CFG;')
nvmInverseArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 9, 1), ).setIndexNames((0, "MICOMIPRIP-MIB", "nvmInverseArpIfIndex"), (0, "MICOMIPRIP-MIB", "nvmInverseArpProtocol"))
if mibBuilder.loadTexts: nvmInverseArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nvmInverseArpEntry.setDescription('NAME = ; DESC = Inverse ARP for a DLCI for a protocol.; HELP = ; CAPABILITIES = ;')
nvmInverseArpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nvmInverseArpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nvmInverseArpIfIndex.setDescription('NAME = ; DESC = The index value which uniquely identifies \\ the interface to which this entry is applicable.; HELP = ; CAPABILITIES = ;')
nvmInverseArpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ip", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nvmInverseArpProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: nvmInverseArpProtocol.setDescription('NAME = ; DESC = The protocol that is used for Auto-discovery of \\ IP address.; HELP = ; CAPABILITIES = ;')
nvmInverseArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 335, 1, 4, 5, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nvmInverseArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nvmInverseArpStatus.setDescription('NAME = ; DESC = This tells weather InversArp is enabled or not.; HELP = ; CAPABILITIES = ;')
mibBuilder.exportSymbols("MICOMIPRIP-MIB", nvmIpAddressRipCompatibility=nvmIpAddressRipCompatibility, mcmIpPingAction=mcmIpPingAction, nvmInverseArpIfIndex=nvmInverseArpIfIndex, mcmIpIfCntrZeroTable=mcmIpIfCntrZeroTable, nvmIPBootpRelayHops=nvmIPBootpRelayHops, mcmipAddressForwardBcast=mcmipAddressForwardBcast, mcmIpPingAddress=mcmIpPingAddress, nvmipAddressRowStatus=nvmipAddressRowStatus, mcmIpAddressTable=mcmIpAddressTable, nvmIpAddressEntry=nvmIpAddressEntry, nvmInverseArpStatus=nvmInverseArpStatus, mcmipUnumIf=mcmipUnumIf, mcmSnmpGrpCounterZero=mcmSnmpGrpCounterZero, nvmipAddressIfIndex=nvmipAddressIfIndex, nvmIpAddrTable=nvmIpAddrTable, mcmIpRipDfltRtEnable=mcmIpRipDfltRtEnable, mcmIpRipEnable=mcmIpRipEnable, mcmIcmpGrpCounterZero=mcmIcmpGrpCounterZero, nvmIpAddrEntry=nvmIpAddrEntry, nvmipMtu=nvmipMtu, nvmipNetMask=nvmipNetMask, nvmipDlType=nvmipDlType, nvmipAddressKeepAlive=nvmipAddressKeepAlive, nvmipBcastAddr=nvmipBcastAddr, mcmIpIfCntrZeroIndex=mcmIpIfCntrZeroIndex, nvmipAddress=nvmipAddress, nvmInverseArpTable=nvmInverseArpTable, mcmipAddr=mcmipAddr, mcmipIfIndex=mcmipIfIndex, nvmipAddressRoutProtType=nvmipAddressRoutProtType, nvmipAddr=nvmipAddr, mcmIpCntr=mcmIpCntr, mcmIpCntrGrp=mcmIpCntrGrp, nvmipAddressMtu=nvmipAddressMtu, mcmIPBootpRelay=mcmIPBootpRelay, mcmInverseArpProtocol=mcmInverseArpProtocol, mcmIpIfCntrZeroEntry=mcmIpIfCntrZeroEntry, nvmIPBootpRelayServerAddr=nvmIPBootpRelayServerAddr, mcmipAddressMtu=mcmipAddressMtu, mcmIpPingGroup=mcmIpPingGroup, nvmIpRipEnable=nvmIpRipEnable, mcmIpAddrTable=mcmIpAddrTable, mcmInverseArpIfIndex=mcmInverseArpIfIndex, nvmipKeepAlive=nvmipKeepAlive, mcmipAddressIfIndex=mcmipAddressIfIndex, mcmIPBootpRelayGroup=mcmIPBootpRelayGroup, mcmInverseArpStatus=mcmInverseArpStatus, nvmInverseArpEntry=nvmInverseArpEntry, mcmipAddressUnumIf=mcmipAddressUnumIf, mcmipAddressRoutProtType=mcmipAddressRoutProtType, mcmIPBootpRelayHops=mcmIPBootpRelayHops, mcmipRoutProtType=mcmipRoutProtType, mcmTcpGrpCounterZero=mcmTcpGrpCounterZero, mcmIpAddressEntry=mcmIpAddressEntry, nvmipAddressDlType=nvmipAddressDlType, mcmipAddressDlType=mcmipAddressDlType, mcmIp=mcmIp, nvmIPBootpRelayGroup=nvmIPBootpRelayGroup, nvmIpAddressTable=nvmIpAddressTable, mcmIpRipCompatibility=mcmIpRipCompatibility, nvmipRoutProtType=nvmipRoutProtType, nvmipAddressUnumIf=nvmipAddressUnumIf, nvmipAddressNetMask=nvmipAddressNetMask, nvmipIfIndex=nvmipIfIndex, nvmipForwardBcast=nvmipForwardBcast, mcmInverseArpEntry=mcmInverseArpEntry, mcmIPBootpRelayServerAddr=mcmIPBootpRelayServerAddr, mcmInverseArpTable=mcmInverseArpTable, mcmipKeepAlive=mcmipKeepAlive, nvmIPBootpRelay=nvmIPBootpRelay, mcmipDlType=mcmipDlType, mcmIpAddrEntry=mcmIpAddrEntry, mcmIpGrpCounterZero=mcmIpGrpCounterZero, nvmIpRipDfltRtEnable=nvmIpRipDfltRtEnable, mcmipForwardBcast=mcmipForwardBcast, mcmipAddress=mcmipAddress, ip_control=ip_control, nvmipUnumIf=nvmipUnumIf, mcmUdpGrpCounterZero=mcmUdpGrpCounterZero, mcmIpPingStatus=mcmIpPingStatus, nvmInverseArpProtocol=nvmInverseArpProtocol, mcmipAddressKeepAlive=mcmipAddressKeepAlive, nvmipAddressForwardBcast=nvmipAddressForwardBcast, mcmIpIfGrpCounterZero=mcmIpIfGrpCounterZero, nvmipAddressBcastAddr=nvmipAddressBcastAddr, mcmipMtu=mcmipMtu)

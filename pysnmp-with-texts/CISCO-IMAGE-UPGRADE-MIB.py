#
# PySNMP MIB module CISCO-IMAGE-UPGRADE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-IMAGE-UPGRADE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:01:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
EntPhysicalIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "EntPhysicalIndexOrZero")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, Integer32, iso, Counter64, ModuleIdentity, ObjectIdentity, Gauge32, IpAddress, MibIdentifier, Counter32, Bits, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "Integer32", "iso", "Counter64", "ModuleIdentity", "ObjectIdentity", "Gauge32", "IpAddress", "MibIdentifier", "Counter32", "Bits", "NotificationType")
RowStatus, DisplayString, TimeStamp, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TimeStamp", "TextualConvention", "TruthValue")
ciscoImageUpgradeMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 360))
ciscoImageUpgradeMIB.setRevisions(('2011-03-28 00:00', '2008-03-18 00:00', '2007-07-18 00:00', '2006-12-21 00:00', '2004-01-20 00:00', '2003-11-04 00:00', '2003-10-28 00:00', '2003-07-11 00:00', '2003-07-08 00:00', '2003-06-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoImageUpgradeMIB.setRevisionsDescriptions(("Added new group ciuUpgradeOpNewGroup. Added new enum 'systemPreupgradeBegin' to ciuUpgradeOpStatusOperation. Added ciuUpgradeOpLastCommand and ciuUpgradeOpLastStatus to the varbind list of ciuUpgradeOpCompletionNotify. Added new compliance ciuImageUpgradeComplianceRev4 and deprecated ciuImageUpgradeComplianceRev3. Added ciuUpgradeJobStatusNotifyOnCompletion.", "Added new enum 'compactFlashTcamSanity' to ciuUpgradeOpStatusOperation.", 'Added new enums to ciuUpgradeOpStatusOperation.', 'Added new enums to ciuUpgradeOpStatus and ciuUpgradeOpStatusOperation. Added new trap ciuUpgradeJobStatusNotify. Changed type for ciuUpgradeOpStatusModule to EntPhysicalIndexOrZero. Added ciuUpgradeNotificationGroupSup group, deprecated ciuImageUpgradeComplianceRev2 and added ciuImageUpgradeComplianceRev3 ', "Added new enums to ciuUpgradeOpStatus and ciuUpgradeOpStatusOperation. Corrected description for 'configSync' enum defined in ciuUpgradeOpStatusOperation object. ", 'Updated compliance statement. Removed ciuImageLocInputGroup from conditionally mandatory.', 'Added ciuUpgradeMiscInfoTable. Added more enums to ciuUpgradeOpStatusOperation. Added ciuUpgradeMiscInfoGroup, deprecated ciuImageUpgradeComplianceRev1 and added ciuImageUpgradeComplianceRev2.', 'Changed: ciuImageLocInputURI identifier from 2 to 1, ciuImageLocInputEntryStatus identifier from 3 to 2 and ciuImageVariableName from 2 to 1. Added recommendedAction to ciuUpgradeOpStatusOperation.', 'Added ciscoImageUpgradeMisc, added ciuUpgradeMiscAutoCopy under the group ciscoImageUpgradeMisc. Added ciuUpgradeMiscGroup, deprecated ciuImageUpgradeCompliance and added ciuImageUpgradeComplianceReve1.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoImageUpgradeMIB.setLastUpdated('201103280000Z')
if mibBuilder.loadTexts: ciscoImageUpgradeMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoImageUpgradeMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553 -NETS E-mail: cs-san@cisco.com')
if mibBuilder.loadTexts: ciscoImageUpgradeMIB.setDescription("This mib provides, objects to upgrade images on modules in the system, objects showing the status of the upgrade operation, and objects showing the type of images that could be run in the system. For example the modules could be Controller card, Line card .. etc. The system fills up the ciuImageVariableTable with the type of images the system can support. For performing an upgrade operation a management application must first read this table and use this info in other tables, as explained below. The ciuImageURITable table is also filled by the system and provides the image name presently running for each type of image in the system. The user is allowed to configure a new image name for each image type as listed in ciuImageVariableTable. The system would use this image on the particular module on the next reboot. The management application on deciding to do an upgrade operation must first check if an upgrade operation is already in progress in the system. This is done by reading the ciuUpgradeOpCommand and if it contains 'none', signifies that no other upgrade operation is in progress. Any other value, signifies that upgrade is in progress and a new upgrade operation is not allowed. To start an 'install' operation, first the user must perform a 'check' operation to do the version compatibility for the given set of image files (provided using the ciuImageLocInputTable) against the current system configuration. Only if the result of this operation is 'success' can the user proceed to do an install operation. The tables, ciuVersionCompChkTable, ciuUpgradeImageVersionTable, ciuUpgradeOpStatusTable, provide the result of the 'check' or 'install' operation performed using ciuUpgradeOpCommand. These tables are in addition to objects ciuUpgradeOpStatus, ciuUpgradeOpTimeStarted, ciuUpgradeOpTimeCompleted, ciuUpgradeOpStatusReason. The ciuUpgradeOpStatus object provides the status of the selected upgrade operation. An option is available for user to upgrade only some modules, provided using ciuUpgradeTargetTable. If this table is empty than an upgrade operation would be performed on all the modules in the system.")
ciscoImageUpgradeMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 0))
ciscoImageUpgradeMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 1))
ciscoImageUpgradeMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 2))
ciscoImageUpgradeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1))
ciscoImageUpgradeOp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4))
ciscoImageUpgradeMisc = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 10))
class CiuImageVariableTypeName(TextualConvention, OctetString):
    description = "The type of image that the system can run. e.g. Let us say that the device has 3 image variables names - 'system', 'kickstart' and 'ilce'. This TC would, then be as follows: system kickstart ilce. "
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 32)

ciuTotalImageVariables = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuTotalImageVariables.setStatus('current')
if mibBuilder.loadTexts: ciuTotalImageVariables.setDescription('Total number of image variables supported in the device at this time.')
ciuImageVariableTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 2), )
if mibBuilder.loadTexts: ciuImageVariableTable.setStatus('current')
if mibBuilder.loadTexts: ciuImageVariableTable.setDescription('A table listing the image variable types that exist in the device. ')
ciuImageVariableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableName"))
if mibBuilder.loadTexts: ciuImageVariableEntry.setStatus('current')
if mibBuilder.loadTexts: ciuImageVariableEntry.setDescription('A ciuImageVariableEntry entry. Each entry provides the image variable type existing in the device. ')
ciuImageVariableName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 2, 1, 1), CiuImageVariableTypeName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuImageVariableName.setStatus('current')
if mibBuilder.loadTexts: ciuImageVariableName.setDescription("The type of image that the system can run. The value of this object depends on the underlying agent. e.g. Let us say that the device has 3 image variables names - 'system', 'kickstart' and 'ilce'. This table , then will list these 3 strings as entries such as follows: ciuImageVariableName system kickstart ilce The user can assign images (using ciuImageURITable) to these variables and the system will use the assigned values to boot. ")
ciuImageURITable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 3), )
if mibBuilder.loadTexts: ciuImageURITable.setStatus('current')
if mibBuilder.loadTexts: ciuImageURITable.setDescription("A table listing the Universal Resource Identifier(URI) of images that are assigned to variables of the ciuImageVariableTable. In the example for ciuImageVariableTable, there are 3 image types. This table will list the names for those image types as follows - entPhysicalIndex ciuImageVariableName ciuImageURI 25 'system' m9200-ek9-mgz.1.0.bin 25 'kickstart' boot-1.0.bin 26 'ilce' linecard-1.0.bin In this example, the 'system' image name is 'm9200-ek9-mgz.1.0.bin', the 'ilce' image name is 'linecard-1.0.bin' and the 'kickstart' image name is 'boot-1.0.bin'. ")
ciuImageURIEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 3, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableName"))
if mibBuilder.loadTexts: ciuImageURIEntry.setStatus('current')
if mibBuilder.loadTexts: ciuImageURIEntry.setDescription('A ciuImageURITable entry. Each entry provides the Image URI corresponding to this image variable name, identified by ciuImageVariableName, on this module identified by entPhysicalIndex. Each such module of the type PhysicalClass module(9), has an entry in entPhysicalTable in ENTITY-MIB, where that entry is identified by entPhysicalIndex. Only modules capable of running images, identified by ciuImageVariableName would have an entry in this table. ')
ciuImageURI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 3, 1, 1), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuImageURI.setStatus('current')
if mibBuilder.loadTexts: ciuImageURI.setDescription('This object contains the string value of the image corresponding to ciuImageVariableName on this entity.')
ciuUpgradeOpCommand = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("done", 2), ("install", 3), ("check", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuUpgradeOpCommand.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpCommand.setDescription("The command to be executed. Note that it is possible for a system to support only a subset of these commands. If a command is unsupported, it will complete immediatly with the 'invalidOperation' error being reported in the ciuUpgradeOpStatus object. The 'check' must be performed first before 'install' command can be executed. If 'install' is performed first the operation would fail. So 'install' will be allowed only if a read of this object returns 'check' and the value of object ciuUpgradeOpStatus is 'success'. Also 'check' will be allowed only if a read of this object returns 'none'. Command Remarks none if this object is read without performing any operation listed above, 'none' would be returned. Also 'none' would be returned for a read operation if a cleanup of the previous upgrade operation is completed either through the issue of 'done' command or the maximum timeout of 5 minutes is elapsed. Setting this object to 'none', agent would return a success without any upgrade operation being performed. done if this object returns any value other than 'none', then setting this to 'done' would do the required cleanup of previous upgrade operation and make the system ready for any new upgrade operation. This is needed because the system maintains the status of the previous upgrade operation for a maximum time of 5 minutes before it does the cleanup. During this period no new upgrade operation is allowed. install for all the physical entities listed in the ciuUpgradeTargetTable perform the required upgrade operation listed in that table. However the upgrade operation for a module would not be done if the current running image and the image to be upgraded given as an input through the ciuImageLocInputTable are the same. check check the version compatibility for the given set of image files against the current system configuration. ")
ciuUpgradeOpStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("none", 1), ("invalidOperation", 2), ("failure", 3), ("inProgress", 4), ("success", 5), ("abortInProgress", 6), ("abortSuccess", 7), ("abortFailed", 8), ("successReset", 9), ("fsUpgReset", 10))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatus.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatus.setDescription('The status of the specified operation. none(1) - no operation was performed. invalidOperation(2) - the selected operation is not supported. failure(3) - the selected operation has failed. inProgress(4) - specified operation is active. success(5) - specified operation has completed successfully. abortInProgress(6) - abort in progress. abortSuccess(7) - abort operation successful. abortFailed(8) - abort failed. successReset(9) - specified operation has completed successfully and the system will reset. fsUpgReset(10) - fabric switch upgrade reset.')
ciuUpgradeOpNotifyOnCompletion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuUpgradeOpNotifyOnCompletion.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpNotifyOnCompletion.setDescription("Specifies whether or not a notification should be generated on the completion of an operation. If 'true', ciuUpgradeOpCompletionNotify will be generated, else if 'false' it would not be. It is the responsibility of the management entity to ensure that the SNMP administrative model is configured in such a way as to allow the notification to be delivered. This object can only be modified alongwith ciuUpgradeOpCommand object.This object returns default value when ciuUpgradeOpCommand object contains 'none'. To SET this object a multivarbind set containing this object and ciuUpgradeOpCommand must be done in the same PDU for the operation to succeed.")
ciuUpgradeOpTimeStarted = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpTimeStarted.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpTimeStarted.setDescription("Specifies the time the upgrade operation was started. This object would return 0 if ciuUpgradeOpCommand contains 'none'.")
ciuUpgradeOpTimeCompleted = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpTimeCompleted.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpTimeCompleted.setDescription("Specifies the time the upgrade operation completed. This object would return 0 if ciuUpgradeOpCommand contains 'none'. ")
ciuUpgradeOpAbort = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuUpgradeOpAbort.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpAbort.setDescription("Provides the means to abort an operation. If this object is set to 'true' when an upgrade operation is in progress and the corresponding instance of ciuUpgradeOpCommand has the value 'install' or 'check', then the operation will be aborted. Setting this object to 'true' when ciuUpgradeOpCommand has a different value other than 'install' or 'check' will fail. If retrieved, this object always has the value 'false'. ")
ciuUpgradeOpStatusReason = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusReason.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusReason.setDescription("Specifies the description of the cause of 'failed' state of the object 'ciuUpgradeOpStatus'. This object would be a null string if value of 'ciuUpgradeOpStatus' is anything other than 'failure'.")
ciuUpgradeOpLastCommand = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("done", 2), ("install", 3), ("check", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpLastCommand.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpLastCommand.setDescription("This object indicates previous OpCommand value. It will be updated after new OpCommand is set and delivered to upgrade process. 'none' if this object is read without performing any operation listed above, 'none' would be returned. Also 'none' would be returned for a read operation if a cleanup of the previous upgrade operation is completed either through the issue of 'done' command or the maximum timeout of 5 minutes is elapsed. Setting this object to 'none', agent would return a success without any upgrade operation being performed. 'done' if this object returns any value other than 'none', then setting this to 'done' would do the required cleanup of previous upgrade operation and make the system ready for any new upgrade operation. This is needed because the system maintains the status of the previous upgrade operation for a maximum time of 5 minutes before it does the cleanup. During this period no new upgrade operation is allowed. 'install' perform the required upgrade operation listed in ciuUpgradeTargetTable table. However the upgrade operation for a module would not be done if the current running image and the image to be upgraded given as an input through the ciuImageLocInputTable are the same. 'check' check the version compatibility for the given set of image files against the current system configuration.")
ciuUpgradeOpLastStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("none", 1), ("invalidOperation", 2), ("failure", 3), ("inProgress", 4), ("success", 5), ("abortInProgress", 6), ("abortSuccess", 7), ("abortFailed", 8), ("successReset", 9), ("fsUpgReset", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpLastStatus.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpLastStatus.setDescription("This object indicates previous OpStatus value. It will be updated after new OpCommand is set and delivered to upgrade process. 'none' - no operation was performed. 'invalidOperation' - the selected operation is not supported. 'failure' - the selected operation has failed. 'inProgress' - specified operation is active. 'success' - specified operation has completed successfully. 'abortInProgress' - abort in progress. 'abortSuccess' - abort operation successful. 'abortFailed' - abort failed. 'successReset' - specified operation has completed successfully and the system will reset. 'fsUpgReset' - fabric switch upgrade reset.")
ciuUpgradeOpLastStatusReason = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 10), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpLastStatusReason.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpLastStatusReason.setDescription('This object indicates the previous OpStatusReason value. It will be updated after new OpCommand is set and delivered to upgrade process.')
ciuUpgradeJobStatusNotifyOnCompletion = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 4, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuUpgradeJobStatusNotifyOnCompletion.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeJobStatusNotifyOnCompletion.setDescription("This object specifies whether or not ciuUpgradeJobStatusCompletionNotify notification should be generated on the completion of an operation. If 'true', ciuUpgradeJobStatusCompletionNotify will be generated, else if 'false' it would not be.")
ciuUpgradeTargetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 5), )
if mibBuilder.loadTexts: ciuUpgradeTargetTable.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeTargetTable.setDescription('A table listing the modules and the type of upgrade operation to be performed on these modules. ')
ciuUpgradeTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 5, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: ciuUpgradeTargetEntry.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeTargetEntry.setDescription("Each entry provides the module that needs to be upgraded and the type of operation that needs to be performed on this module. The upgrade operation, selected using the object 'ciuUpgradeOpCommand', would be performed on each and every module represented by an entry in this table. Each such module of the type PhysicalClass module(9), has an entry in entPhysicalTable in ENTITY-MIB, where that entry is identified by entPhysicalIndex. Only modules capable of running images, identified by ciuImageVariableName would have an entry in this table. This table cannot be modified when ciuUpgradeOpCommand object contains value other than 'none'. ")
ciuUpgradeTargetAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("image", 1), ("bios", 2), ("loader", 3), ("bootrom", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciuUpgradeTargetAction.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeTargetAction.setDescription("The type of operation to be performed on this module. image - upgrade image. bios - upgrade bios. loader - upgrade loader.loader is the program that loads and starts the operating system bootrom - upgrade boot rom This object cannot be modified while the corresponding value of ciuUpgradeTargetEntryStatus is equal to 'active'. It is okay to support only a subset of the enums defined above. ")
ciuUpgradeTargetEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 5, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciuUpgradeTargetEntryStatus.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeTargetEntryStatus.setDescription('The status of this table entry. A multivarbind set containing this object and ciuUpgradeTargetAction must be done in the same PDU for the operation to succeed. ')
ciuImageLocInputTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 6), )
if mibBuilder.loadTexts: ciuImageLocInputTable.setStatus('current')
if mibBuilder.loadTexts: ciuImageLocInputTable.setDescription('A table listing the URI of the images that need to be upgraded. ')
ciuImageLocInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 6, 1), ).setIndexNames((0, "CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableName"))
if mibBuilder.loadTexts: ciuImageLocInputEntry.setStatus('current')
if mibBuilder.loadTexts: ciuImageLocInputEntry.setDescription("Each entry provides the image location URI that need to be upgraded. This table cannot be modified if ciuUpgradeOpCommand object contains any value other than 'none' ")
ciuImageLocInputURI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 6, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciuImageLocInputURI.setStatus('current')
if mibBuilder.loadTexts: ciuImageLocInputURI.setDescription("An ASCII string specifying the system image location. For example the string could be 'bootflash:file1'. This object cannot be modified while the corresponding value of ciuImageLocInputEntryStatus is equal to 'active'. ")
ciuImageLocInputEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ciuImageLocInputEntryStatus.setStatus('current')
if mibBuilder.loadTexts: ciuImageLocInputEntryStatus.setDescription('The status of this table entry. ')
ciuVersionCompChkTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7), )
if mibBuilder.loadTexts: ciuVersionCompChkTable.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompChkTable.setDescription("A table showing the result of the version compatibility check operation performed in response to the option 'check' selected for ciuUpgradeOpCommand. The table would be emptied out once the value of ciuUpgradeOpCommand object is 'none'. ")
ciuVersionCompChkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: ciuVersionCompChkEntry.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompChkEntry.setDescription('An entry containing the results of the version compatibility check operation performed on each module, identified by entPhysicalIndex. Each such module of the type PhysicalClass module(9), has an entry in entPhysicalTable in ENTITY-MIB, where that entry is identified by entPhysicalIndex. Only modules capable of running images, identified by ciuImageVariableName would have an entry in this table. ')
ciuVersionCompImageSame = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompImageSame.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompImageSame.setDescription(' Specifies whether for this module the image provided by the user for upgrade is same as the current running image. ')
ciuVersionCompUpgradable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradable.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradable.setDescription(" Specifies whether the set of images provided in ciuImageLocInputTable are compatible with each other as far as this module is concerned. If 'true' the set of images provided are compatible and can be run on this module else they are not compatible. This module would not come up if it is booted with a uncompatible set of image. ")
ciuVersionCompUpgradeAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("other", 2), ("rollingUpgrade", 3), ("switchOverReset", 4), ("reset", 5), ("copy", 6), ("notApplicable", 7), ("plugin", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeAction.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeAction.setDescription(" Specifies the type of upgrade action that would be performed on this module if ciuUpgradeOpCommand were set to 'install' or to 'check'. none(1) : is no upgrade action. other(2) : actions other than defined here rollingUpgrade(3) : modules would be upgraded one at a time. switchOverReset(4): all the modules would be reset after a switchover happens at the same time. reset(5) : all the modules would be reset without or before a switchover. copy(6) : then image upgrade would not be done, but only bios/loader/bootrom would be updated and will take effect on next reload. notApplicable(7) : upgrade action is not possible because image is not upgradable. plugin(8) : upgrading plugin only instead of full image.")
ciuVersionCompUpgradeBios = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeBios.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeBios.setDescription(" Specifies whether the BIOS will be upgraded. If 'true' the bios would be upgraded else it would not.")
ciuVersionCompUpgradeBootrom = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeBootrom.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeBootrom.setDescription(" Specifies whether the bootrom will be upgraded. If 'true' the bootrom would be upgraded else it would not.")
ciuVersionCompUpgradeLoader = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeLoader.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeLoader.setDescription(" Specifies whether the loader will be upgraded. If 'true' the loader would be upgraded else it would not.")
ciuVersionCompUpgradeImpact = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("nonDisruptive", 2), ("disruptive", 3), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeImpact.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeImpact.setDescription(' Specifies the impact of the upgrade operation that would have on this module. other(1) : reasons other than defined here nonDisruptive(2): this module would be upgraded without disruption of traffic. disruptive(3) : this module would be upgraded with disruption of traffic. notApplicable(4): upgrade is not possible because image is not upgradable. ')
ciuVersionCompUpgradeReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 7, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuVersionCompUpgradeReason.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompUpgradeReason.setDescription("This object would give the reason for the following cases: 1)value of object ciuVersionCompUpgradable is 'false' then it would give the reason why the module is not upgradable. 2)the value of object ciuversionCompUpgradeAction is either 'switchOverReset' or 'reset' and value of object ciuVersionCompUpgradable is 'true'. 3)the value of object ciuVersionCompUpgradeImpact is 'disruptive' and value of objects, ciuVersionCompUpgradable is 'true' and ciuversionCompUpgradeAction is neither 'switchOverReset' nor 'reset. This object would have the reason in the above listed order. It would be a null string for all the other values of the above mentioned objects. ")
ciuUpgradeImageVersionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8), )
if mibBuilder.loadTexts: ciuUpgradeImageVersionTable.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionTable.setDescription("A table showing the current version of images running on the modules and the images they would be upgraded with. The table would be emptied out once the value of ciuUpgradeOpCommand object is 'none'. This table becomes valid when value of ciuUpgradeOpStatus is 'success' in response to 'check' operation selected using ciuUpgradeOpCommand. ")
ciuUpgradeImageVersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionIndex"))
if mibBuilder.loadTexts: ciuUpgradeImageVersionEntry.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionEntry.setDescription('An entry containing the current version of image running on a particular module and the images they would be upgraded with. An ciuUpgradeImageVersionVarName identifies the type of software running on this module, identified by entPhysicalIndex. It is possible that the same module, identified by entPhysicalIndex, can run multiple instances of the software type identified by ciuUpgradeImageVersionVarName. Each such module of the type PhysicalClass module(9), has an entry in entPhysicalTable in ENTITY-MIB, where that entry is identified by entPhysicalIndex. Only modules capable of running images, identified by ciuImageVariableName would have an entry in this table. ')
ciuUpgradeImageVersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ciuUpgradeImageVersionIndex.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionIndex.setDescription('This is an arbitrary integer which uniquely identifies different rows which have the same value of entPhysicalIndex.')
ciuUpgradeImageVersionVarName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1, 2), CiuImageVariableTypeName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeImageVersionVarName.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionVarName.setDescription('The type of image on this module. ')
ciuUpgradeImageVersionRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeImageVersionRunning.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionRunning.setDescription('An ASCII string specifying the running image version. ')
ciuUpgradeImageVersionNew = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeImageVersionNew.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionNew.setDescription('An ASCII string specifying what the new image version would be after an upgrade. ')
ciuUpgradeImageVersionUpgReqd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 8, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeImageVersionUpgReqd.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionUpgReqd.setDescription(" Specifies whether an upgrade is required for this software component, identified by entPhysicalIndex and ciuUpgradeImageVersionVarName. If the value of objects ciuUpgradeImageVersionRunning and ciuUpgradeImageVersionNew are same then the value of this object would be 'false' else it would be 'true'. If 'true' then this software component, identified by ciuUpgradeImageVersionVarName needs to be upgraded else it would not.")
ciuUpgradeOpStatusTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9), )
if mibBuilder.loadTexts: ciuUpgradeOpStatusTable.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusTable.setDescription("A table showing the result of the upgrade operation selected from ciuUpgradeOpCommand in ciuUpgradeOpTable. The table would be emptied out once the value of ciuUpgradeOpCommand object is 'none'. ")
ciuUpgradeOpStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1), ).setIndexNames((0, "CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusOperIndex"))
if mibBuilder.loadTexts: ciuUpgradeOpStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusEntry.setDescription('An entry containing the status of the upgrade operation. ')
ciuUpgradeOpStatusOperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ciuUpgradeOpStatusOperIndex.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusOperIndex.setDescription('This is an arbitrary integer which identifies uniquely an entry in this table. ')
ciuUpgradeOpStatusOperation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("copy", 3), ("verify", 4), ("versionExtraction", 5), ("imageSync", 6), ("configSync", 7), ("preUpgrade", 8), ("forceDownload", 9), ("moduleOnline", 10), ("hitlessLCUpgrade", 11), ("hitfulLCUpgrade", 12), ("unusedBootvar", 13), ("convertStartUp", 14), ("looseIncompatibility", 15), ("haSeqNumMismatch", 16), ("unknownModuleOnline", 17), ("recommendedAction", 18), ("recoveryAction", 19), ("remainingAction", 20), ("additionalInfo", 21), ("settingBootvars", 22), ("informLcmFsUpg", 23), ("sysmgrSaveRuntimeStateAndSuccessReset", 24), ("kexecLoadUpgImages", 25), ("fsUpgCleanup", 26), ("saveMtsState", 27), ("fsUpgBegin", 28), ("lcWarmBootStatus", 29), ("waitStateVerificationStatus", 30), ("informLcmFsUpgExternalLc", 31), ("externalLcWarmBootStatus", 32), ("total", 33), ("compactFlashTcamSanity", 34), ("systemPreupgradeBegin", 35)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusOperation.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusOperation.setDescription("Specifies the operation that is currently in progress or completed in response to the ciuUpgradeOpCommand. 'unknown' - operation status unknown. 'other' - operation status other than defined here. 'copy' - the image is being copied from ciuUpgradeOpStatusSrcImageLoc to ciuUpgradeOpStatusDestImageLoc. 'verify' - copied images are being verified for checksum and input consistency. 'versionExtraction' - extracting the version info from image. 'imageSync' - Syncing image to the standby supervisor, if standby supervisor exists. 'configSync' - saving running configuration to startup configuration and syncing it to standby supervisor, if it exists. 'preUpgrade' - Upgrading Bios/loader/bootrom 'forceDownload' - This module is being force downloaded. 'moduleOnline' - waiting for this module to come online 'hitlessLCUpgrade' - Upgrading hitless 'hitfulLCUpgrade' - Upgrading hitful 'unusedBootvar' - The image variable name type supplied as input for upgrade operation is unused. 'convertStartUp' - converting the startup config. 'looseIncompatibility' - incomplete support for current running config in the new image. 'haSeqNumMismatch' - High availability sequence number mismatch, so the module will be power cycled. 'unknownModuleOnline' - this module was powered down before switchover and has now come online. 'recommendedAction' - Specifies the recommended action if upgrading operation fails. If this object value is 'recommendedAction' then the object 'ciuUpgradeOpStatusSrcImageLoc' would contain the string specifying the recommended action. 'recoveryAction' - Specifies that installer is doing a recovery because of install failure. If this object value is 'recoveryAction' then the object 'ciuUpgradeOpStatusSrcImageLoc' would contain the string specifying the recovery action. 'remainingAction' - Specifies the remaining actions that have not been performed due to install failure. If this object value is 'remainingAction' then the object 'ciuUpgradeOpStatusSrcImageLoc' would contain the information about the remaining actions. 'additionalInfo' - Specifies the additional info the installer conveys to the user. If this object value is 'additionalInfo' then the object 'ciuUpgradeOpStatusSrcImageLoc' would contain the information. 'settingBootvars' - setting the boot variables. 'informLcmFsUpg' - save linecard runtime state. 'sysmgrSaveRuntimeStateAndSuccessReset' - save supervisor runtime state and terminate all services. 'kexecLoadUpgImages' - load upgrade images into memory. 'fsUpgCleanup' - cleanup file system for upgrade. 'saveMtsState' - saving persistent transaction messages. 'fsUpgBegin' - notify services that upgrade is about to begin. 'lcWarmBootStatus' - linecard upgrade status. 'waitStateVerificationStatus' - supervisor state verification with the new image. 'informLcmFsUpgExternalLc' - save external linecard runtime state. 'externalLcWarmBootStatus' - external linecard upgrade status. 'total' - total. 'compactFlashTcamSanity' - compact flash and TCAM sanity test. 'systemPreupgradeBegin' - notify services of beginning of upgrade. ")
ciuUpgradeOpStatusModule = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 3), EntPhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusModule.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusModule.setDescription('The physical entity of the module for which this status is being shown. For example such an entity is one of the type PhysicalClass module(9). This object must contain the same value as the entPhysicalIndex of the physical entity from entPhysicalTable in ENTITY-MIB. ')
ciuUpgradeOpStatusSrcImageLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusSrcImageLoc.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusSrcImageLoc.setDescription("An ASCII string specifying the source image location. For example the string could be 'bootflash:file1'. This object is only valid if the value of ciuUpgradeOpStatusOperation is 'copy'.")
ciuUpgradeOpStatusDestImageLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusDestImageLoc.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusDestImageLoc.setDescription("An ASCII string specifying the destination image location. For example the string could be 'bootflash:file1'.")
ciuUpgradeOpStatusJobStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("other", 2), ("failed", 3), ("inProgress", 4), ("success", 5), ("planned", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusJobStatus.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusJobStatus.setDescription("The status of this operation. 'unknown' - operation status unknown. 'other' - operation status other than defined here. 'failed' - this operation has failed 'inProgress' - this operation is active 'success' - this operation has completed successfully. 'planned' - this operation would be executed at later point of time.")
ciuUpgradeOpStatusPercentCompl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusPercentCompl.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusPercentCompl.setDescription('The percentage completion of the upgrade operation selected from ciuUpgradeOpTable. If this object is invalid for a particular operation, identified by ciuUpgradeOpStatusOperation, then the value of this object would be -1. ')
ciuUpgradeOpStatusJobStatusReas = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 9, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeOpStatusJobStatusReas.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusJobStatusReas.setDescription("Specifies the description of the cause of 'failed' state of the object 'ciuUpgradeOpStatusJobStatus'. This object would be a null string if value of 'ciuUpgradeOpStatusJobStatus' is anything other than 'failed'.")
ciuUpgradeMiscAutoCopy = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 10, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ciuUpgradeMiscAutoCopy.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscAutoCopy.setDescription("Specifies whether or not the images on the active supervisor will be copied to the standby supervisor, if the standby supervisor exists. If the standby supervisor does not exist, the setting of this object to 'true' will not have any effect and no image copy will be done. ciuImageURITable lists all the images for the supervisor cards as well as the line cards. If this object is set to 'true', all the images pointed to by the instances of ciuImageURI will be automatically copied to the standby supervisor. For example, assume that the ciuImageURITable looks like below - entPhysicalIndex ciuImageVariableName ciuImageURI 25 'system' bootflash://image.bin 25 'kickstart' slot0://boot.bin 26 'ilce' bootflash://linecard.bin So, if the ciuUpgradeMiscAutoCopy is 'true', then bootflash://image.bin from the active supervisor will be copied to the bootflash://image.bin on the standby supervisor; slot0://boot.bin will be copied to the slot0://boot.bin on the standby supervisor etc. If this object is set to 'false' then this copying of the images will not be done.")
ciuUpgradeMiscInfoTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 11), )
if mibBuilder.loadTexts: ciuUpgradeMiscInfoTable.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoTable.setDescription("A table showing additional information such as warnings during upgrade. The table would be emptied out once the value of ciuUpgradeOpCommand object is 'none'. ")
ciuUpgradeMiscInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 11, 1), ).setIndexNames((0, "CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoIndex"))
if mibBuilder.loadTexts: ciuUpgradeMiscInfoEntry.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoEntry.setDescription('An entry containing additional information of upgrade operation being performed on modules. Each entry is uniquely identified by ciuUpgradeMiscInfoIndex. If the info given in object ciuUpgradeMiscInfoDescr is not for any module then the value of ciuUpgradeMiscInfoModule would be 0.')
ciuUpgradeMiscInfoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 11, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ciuUpgradeMiscInfoIndex.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoIndex.setDescription('This is an arbitrary integer which identifies uniquely an entry in this table. ')
ciuUpgradeMiscInfoModule = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 11, 1, 2), EntPhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeMiscInfoModule.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoModule.setDescription('The entPhysicalIndex of the module. The value of this object would be 0 if the information shown in ciuUpgradeMiscInfoDescr is not for any module.')
ciuUpgradeMiscInfoDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 360, 1, 1, 11, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ciuUpgradeMiscInfoDescr.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoDescr.setDescription('Specifies the miscelleneous information of the upgrade operation.')
ciuUpgradeOpCompletionNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 360, 0, 1)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpCommand"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpTimeCompleted"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpLastCommand"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpLastStatus"))
if mibBuilder.loadTexts: ciuUpgradeOpCompletionNotify.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpCompletionNotify.setDescription('A ciuUpgradeOpCompletionNotify is sent at the completion of upgrade operation denoted by ciuUpgradeOpCommand object if such a notification was requested when the operation was initiated. ciuUpgradeOpCommand indicates the type of operation. ciuUpgradeOpStatus indicates the result of the operation. ciuUpgradeOpTimeCompleted indicates the time when the operation is completed. ciuUpgradeopLastCommand indicates the previous operation that was executed. ciuUpgradeOpLastStatus indicates the result of previous operation.')
ciuUpgradeJobStatusNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 360, 0, 2)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusOperation"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusModule"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusSrcImageLoc"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusDestImageLoc"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusJobStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusPercentCompl"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusJobStatusReas"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusReason"))
if mibBuilder.loadTexts: ciuUpgradeJobStatusNotify.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeJobStatusNotify.setDescription('A ciuUpgradeJobStatusNotify is sent when there is status change in the upgrade process. ciuUpgradeOpStatusOperation indicates the operation to change the upgrade status. ciuUpgradeOpStatusModule indicates which module is affected. ciuUpgradeOpStatusSrcImageLoc indicates location of source image if applicable. ciuUpgradeOpStatusDestImageLoc indicates location of destination image if applicable. ciuUpgradeOpStatusJobStatus indicates the result of this operation to change the status. ciuUpgradeOpStatusPercentCompl indicates percentage of the operation that has been completed. ciuUpgradeOpStatusJobStatusReas gives explanation of the faiure if there is a failure. ciuUpgradeOpStatus indicates the result of the operation at higher level. ciuUpgradeOpStatusReason gives detailed explanation if ciuUpgradeOpStatus is not successful.')
ciuImageUpgradeCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1))
ciuImageUpgradeGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2))
ciuImageUpgradeCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1, 1)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageUpgradeGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURIGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompChkGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeCompliance = ciuImageUpgradeCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciuImageUpgradeCompliance.setDescription("Compliance statement for Image Upgrade MIB. For the (mandatory) ciuImageLocInputGroup, it is compliant to allow only a limited number of entries to be created and concurrently 'active' in the ciuImageLocInputTable table. ")
ciuImageUpgradeComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1, 2)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageUpgradeGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURIGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompChkGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeComplianceRev1 = ciuImageUpgradeComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciuImageUpgradeComplianceRev1.setDescription("Compliance statement for Image Upgrade MIB. For the (mandatory) ciuImageLocInputGroup, it is compliant to allow only a limited number of entries to be created and concurrently 'active' in the ciuImageLocInputTable table. ")
ciuImageUpgradeComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1, 3)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageUpgradeGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURIGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompChkGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeComplianceRev2 = ciuImageUpgradeComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciuImageUpgradeComplianceRev2.setDescription("Compliance statement for Image Upgrade MIB. For the (mandatory) ciuImageLocInputGroup, it is compliant to allow only a limited number of entries to be created and concurrently 'active' in the ciuImageLocInputTable table.")
ciuImageUpgradeComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1, 4)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageUpgradeGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURIGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompChkGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroupSup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeComplianceRev3 = ciuImageUpgradeComplianceRev3.setStatus('deprecated')
if mibBuilder.loadTexts: ciuImageUpgradeComplianceRev3.setDescription("Compliance statement for Image Upgrade MIB. For the (mandatory) ciuImageLocInputGroup, it is compliant to allow only a limited number of entries to be created and concurrently 'active' in the ciuImageLocInputTable table.")
ciuImageUpgradeComplianceRev4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 1, 5)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageUpgradeGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURIGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompChkGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeNotificationGroupSup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoGroup"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpNewGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeComplianceRev4 = ciuImageUpgradeComplianceRev4.setStatus('current')
if mibBuilder.loadTexts: ciuImageUpgradeComplianceRev4.setDescription("Compliance statement for Image Upgrade MIB. For the (mandatory) ciuImageLocInputGroup, it is compliant to allow only a limited number of entries to be created and concurrently 'active' in the ciuImageLocInputTable table.")
ciuImageUpgradeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 1)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuTotalImageVariables"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageUpgradeGroup = ciuImageUpgradeGroup.setStatus('current')
if mibBuilder.loadTexts: ciuImageUpgradeGroup.setDescription('A collection of objects providing information about Image upgrade. ')
ciuImageVariableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 2)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageVariableName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageVariableGroup = ciuImageVariableGroup.setStatus('current')
if mibBuilder.loadTexts: ciuImageVariableGroup.setDescription('A group containing an object providing information about the type of the system images.')
ciuImageURIGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 3)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageURI"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageURIGroup = ciuImageURIGroup.setStatus('current')
if mibBuilder.loadTexts: ciuImageURIGroup.setDescription('A group containing an object providing information about the name of system variable or parameter.')
ciuUpgradeOpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 4)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpCommand"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpNotifyOnCompletion"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpTimeStarted"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpTimeCompleted"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpAbort"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeOpGroup = ciuUpgradeOpGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpGroup.setDescription('A collection of objects for Upgrade operation.')
ciuUpgradeTargetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 5)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeTargetAction"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeTargetEntryStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeTargetGroup = ciuUpgradeTargetGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeTargetGroup.setDescription('A collection of objects giving the modules and the type of image to be upgraded.')
ciuImageLocInputGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 6)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputURI"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuImageLocInputEntryStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuImageLocInputGroup = ciuImageLocInputGroup.setStatus('current')
if mibBuilder.loadTexts: ciuImageLocInputGroup.setDescription('A collection of objects giving the location of the images to be upgraded.')
ciuVersionCompChkGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 7)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompImageSame"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradable"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeAction"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeBios"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeBootrom"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeLoader"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeImpact"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuVersionCompUpgradeReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuVersionCompChkGroup = ciuVersionCompChkGroup.setStatus('current')
if mibBuilder.loadTexts: ciuVersionCompChkGroup.setDescription('A collection of objects showing the results of the version compatibility check done.')
ciuUpgradeImageVersionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 8)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionVarName"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionRunning"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionNew"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeImageVersionUpgReqd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeImageVersionGroup = ciuUpgradeImageVersionGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeImageVersionGroup.setDescription('A collection of objects showing the current running images and the images to be upgraded with.')
ciuUpgradeOpStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 9)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusOperation"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusModule"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusSrcImageLoc"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusDestImageLoc"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusJobStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusPercentCompl"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpStatusJobStatusReas"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeOpStatusGroup = ciuUpgradeOpStatusGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpStatusGroup.setDescription('A collection of objects showing the status of the upgrade operation.')
ciuUpgradeNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 10)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpCompletionNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeNotificationGroup = ciuUpgradeNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeNotificationGroup.setDescription('A collection of notifications for upgrade operations. ')
ciuUpgradeMiscGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 11)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscAutoCopy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeMiscGroup = ciuUpgradeMiscGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscGroup.setDescription('A collection of objects for Miscelleneous operation.')
ciuUpgradeMiscInfoGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 12)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoModule"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeMiscInfoDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeMiscInfoGroup = ciuUpgradeMiscInfoGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeMiscInfoGroup.setDescription('A collection of objects for Miscelleneous info for upgrade operation.')
ciuUpgradeNotificationGroupSup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 13)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeJobStatusNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeNotificationGroupSup = ciuUpgradeNotificationGroupSup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeNotificationGroupSup.setDescription('A collection of notifications for upgrade operations. ')
ciuUpgradeOpNewGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 360, 2, 2, 14)).setObjects(("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeJobStatusNotifyOnCompletion"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpLastCommand"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpLastStatus"), ("CISCO-IMAGE-UPGRADE-MIB", "ciuUpgradeOpLastStatusReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciuUpgradeOpNewGroup = ciuUpgradeOpNewGroup.setStatus('current')
if mibBuilder.loadTexts: ciuUpgradeOpNewGroup.setDescription('A collection of objects for Upgrade operation.')
mibBuilder.exportSymbols("CISCO-IMAGE-UPGRADE-MIB", ciuUpgradeImageVersionUpgReqd=ciuUpgradeImageVersionUpgReqd, ciuUpgradeOpAbort=ciuUpgradeOpAbort, ciuImageLocInputURI=ciuImageLocInputURI, ciuUpgradeOpGroup=ciuUpgradeOpGroup, ciuUpgradeOpStatusReason=ciuUpgradeOpStatusReason, ciuVersionCompUpgradeReason=ciuVersionCompUpgradeReason, ciuTotalImageVariables=ciuTotalImageVariables, ciuUpgradeJobStatusNotify=ciuUpgradeJobStatusNotify, ciuUpgradeImageVersionTable=ciuUpgradeImageVersionTable, ciuUpgradeTargetAction=ciuUpgradeTargetAction, ciuUpgradeOpStatusOperation=ciuUpgradeOpStatusOperation, ciuImageVariableName=ciuImageVariableName, ciuUpgradeImageVersionIndex=ciuUpgradeImageVersionIndex, ciuUpgradeOpStatusModule=ciuUpgradeOpStatusModule, ciuVersionCompChkGroup=ciuVersionCompChkGroup, ciuVersionCompUpgradeImpact=ciuVersionCompUpgradeImpact, ciuUpgradeMiscGroup=ciuUpgradeMiscGroup, ciuUpgradeOpStatusOperIndex=ciuUpgradeOpStatusOperIndex, ciuImageUpgradeGroup=ciuImageUpgradeGroup, ciuImageLocInputEntryStatus=ciuImageLocInputEntryStatus, ciuUpgradeOpStatus=ciuUpgradeOpStatus, ciuImageURIGroup=ciuImageURIGroup, ciuUpgradeMiscInfoTable=ciuUpgradeMiscInfoTable, ciuUpgradeTargetEntry=ciuUpgradeTargetEntry, ciscoImageUpgradeMIB=ciscoImageUpgradeMIB, ciuImageVariableTable=ciuImageVariableTable, ciuUpgradeOpStatusJobStatusReas=ciuUpgradeOpStatusJobStatusReas, ciuUpgradeOpLastCommand=ciuUpgradeOpLastCommand, ciuVersionCompUpgradeBios=ciuVersionCompUpgradeBios, ciuImageUpgradeComplianceRev3=ciuImageUpgradeComplianceRev3, ciuVersionCompUpgradeLoader=ciuVersionCompUpgradeLoader, ciuUpgradeTargetTable=ciuUpgradeTargetTable, ciuUpgradeOpCompletionNotify=ciuUpgradeOpCompletionNotify, ciscoImageUpgradeMIBObjects=ciscoImageUpgradeMIBObjects, ciuVersionCompChkTable=ciuVersionCompChkTable, ciuUpgradeOpStatusTable=ciuUpgradeOpStatusTable, ciuImageURI=ciuImageURI, ciuUpgradeOpStatusSrcImageLoc=ciuUpgradeOpStatusSrcImageLoc, ciuImageLocInputEntry=ciuImageLocInputEntry, ciuUpgradeImageVersionGroup=ciuUpgradeImageVersionGroup, ciuVersionCompImageSame=ciuVersionCompImageSame, ciuUpgradeMiscInfoGroup=ciuUpgradeMiscInfoGroup, ciuUpgradeOpLastStatusReason=ciuUpgradeOpLastStatusReason, ciuUpgradeMiscInfoIndex=ciuUpgradeMiscInfoIndex, ciuUpgradeMiscInfoEntry=ciuUpgradeMiscInfoEntry, ciuUpgradeImageVersionRunning=ciuUpgradeImageVersionRunning, ciuImageVariableEntry=ciuImageVariableEntry, CiuImageVariableTypeName=CiuImageVariableTypeName, ciscoImageUpgradeMisc=ciscoImageUpgradeMisc, ciscoImageUpgradeConfig=ciscoImageUpgradeConfig, ciuImageUpgradeCompliances=ciuImageUpgradeCompliances, ciuUpgradeOpStatusDestImageLoc=ciuUpgradeOpStatusDestImageLoc, ciuImageLocInputGroup=ciuImageLocInputGroup, ciuUpgradeOpTimeCompleted=ciuUpgradeOpTimeCompleted, ciuUpgradeMiscInfoModule=ciuUpgradeMiscInfoModule, ciuUpgradeTargetGroup=ciuUpgradeTargetGroup, ciuImageVariableGroup=ciuImageVariableGroup, ciuImageURITable=ciuImageURITable, ciscoImageUpgradeMIBNotifs=ciscoImageUpgradeMIBNotifs, ciuVersionCompUpgradeAction=ciuVersionCompUpgradeAction, ciuUpgradeMiscAutoCopy=ciuUpgradeMiscAutoCopy, ciuUpgradeOpNotifyOnCompletion=ciuUpgradeOpNotifyOnCompletion, ciuUpgradeImageVersionNew=ciuUpgradeImageVersionNew, ciuUpgradeOpCommand=ciuUpgradeOpCommand, ciuImageUpgradeGroups=ciuImageUpgradeGroups, ciuVersionCompUpgradeBootrom=ciuVersionCompUpgradeBootrom, ciuUpgradeOpStatusPercentCompl=ciuUpgradeOpStatusPercentCompl, ciuUpgradeNotificationGroupSup=ciuUpgradeNotificationGroupSup, ciuUpgradeOpStatusJobStatus=ciuUpgradeOpStatusJobStatus, ciuUpgradeJobStatusNotifyOnCompletion=ciuUpgradeJobStatusNotifyOnCompletion, ciuUpgradeOpNewGroup=ciuUpgradeOpNewGroup, ciuUpgradeImageVersionEntry=ciuUpgradeImageVersionEntry, ciuUpgradeOpTimeStarted=ciuUpgradeOpTimeStarted, ciuUpgradeTargetEntryStatus=ciuUpgradeTargetEntryStatus, ciuImageUpgradeComplianceRev4=ciuImageUpgradeComplianceRev4, ciuUpgradeOpStatusGroup=ciuUpgradeOpStatusGroup, ciuImageURIEntry=ciuImageURIEntry, ciuUpgradeOpLastStatus=ciuUpgradeOpLastStatus, ciuVersionCompUpgradable=ciuVersionCompUpgradable, ciuVersionCompChkEntry=ciuVersionCompChkEntry, ciuUpgradeMiscInfoDescr=ciuUpgradeMiscInfoDescr, ciuImageLocInputTable=ciuImageLocInputTable, ciuUpgradeImageVersionVarName=ciuUpgradeImageVersionVarName, ciuImageUpgradeCompliance=ciuImageUpgradeCompliance, ciuUpgradeNotificationGroup=ciuUpgradeNotificationGroup, ciscoImageUpgradeMIBConform=ciscoImageUpgradeMIBConform, ciuImageUpgradeComplianceRev2=ciuImageUpgradeComplianceRev2, ciuUpgradeOpStatusEntry=ciuUpgradeOpStatusEntry, PYSNMP_MODULE_ID=ciscoImageUpgradeMIB, ciuImageUpgradeComplianceRev1=ciuImageUpgradeComplianceRev1, ciscoImageUpgradeOp=ciscoImageUpgradeOp)

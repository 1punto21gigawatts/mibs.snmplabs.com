#
# PySNMP MIB module ALCATEL-IND1-TIMETRA-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ALCATEL-IND1-TIMETRA-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:19:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
timetraSRMIBModules, tmnxSRNotifyPrefix, tmnxSRConfs, tmnxSRObjs = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-GLOBAL-MIB", "timetraSRMIBModules", "tmnxSRNotifyPrefix", "tmnxSRConfs", "tmnxSRObjs")
TNamedItem, TItemDescription, TNamedItemOrEmpty, TmnxActionType, TmnxPortID, TmnxOperState, TmnxAdminState = mibBuilder.importSymbols("ALCATEL-IND1-TIMETRA-TC-MIB", "TNamedItem", "TItemDescription", "TNamedItemOrEmpty", "TmnxActionType", "TmnxPortID", "TmnxOperState", "TmnxAdminState")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
NotificationType, Counter32, ObjectIdentity, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, iso, IpAddress, Counter64, Gauge32, Bits, Integer32, Unsigned32, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "ObjectIdentity", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "iso", "IpAddress", "Counter64", "Gauge32", "Bits", "Integer32", "Unsigned32", "TimeTicks")
DisplayString, TextualConvention, MacAddress, DateAndTime, RowStatus, RowPointer, TimeInterval, TimeStamp, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "MacAddress", "DateAndTime", "RowStatus", "RowPointer", "TimeInterval", "TimeStamp", "TruthValue")
tmnxChassisMIBModule = ModuleIdentity((1, 3, 6, 1, 4, 1, 6527, 1, 1, 3, 2))
tmnxChassisMIBModule.setRevisions(('1908-01-01 00:00', '1907-01-01 00:00', '1906-03-16 00:00', '1905-08-31 00:00', '1905-01-24 00:00', '1904-01-15 00:00', '1903-08-15 00:00', '1903-01-20 00:00', '1900-08-14 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: tmnxChassisMIBModule.setRevisionsDescriptions(('Rev 6.0 01 Jan 2008 00:00 6.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 5.0 01 Jan 2007 00:00 5.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 4.0 16 Mar 2006 00:00 4.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 3.0 31 Aug 2005 00:00 3.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 2.1 24 Jan 2005 00:00 2.1 release of the TIMETRA-CHASSIS-MIB.', 'Rev 2.0 15 Jan 2004 00:00 2.0 release of the TIMETRA-CHASSIS-MIB.', 'Rev 1.2 15 Aug 2003 00:00 1.2 release of the TIMETRA-CHASSIS-MIB.', 'Rev 1.0 20 Jan 2003 00:00 Release 1.0 of the TIMETRA-HW-MIB.', 'Rev 0.1 14 Aug 2000 00:00 Initial version of the TIMETRA-HW-MIB.',))
if mibBuilder.loadTexts: tmnxChassisMIBModule.setLastUpdated('0801010000Z')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setOrganization('Alcatel')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setContactInfo('Alcatel 7x50 Support Web: http://www.alcatel.com/comps/pages/carrier_support.jhtml')
if mibBuilder.loadTexts: tmnxChassisMIBModule.setDescription("This document is the SNMP MIB module to manage and provision the hardware components of the Alcatel 7x50 device. Copyright 2003-2008 Alcatel-Lucent. All rights reserved. Reproduction of this document is authorized on the condition that the foregoing copyright notice is included. This SNMP MIB module (Specification) embodies Alcatel's proprietary intellectual property. Alcatel retains all title and ownership in the Specification, including any revisions. Alcatel grants all interested parties a non-exclusive license to use and distribute an unmodified copy of this Specification in connection with management of Alcatel products, and without fee, provided this copyright notice and license appear on all copies. This Specification is supplied 'as is', and Alcatel makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
tmnxHwObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2))
tmnxChassisObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1))
tmnxSlotObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 2))
tmnxCardObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3))
tmnxChassisNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6))
tmnxChassisAdminObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8))
tmnxHwNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2))
tmnxChassisNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1))
tmnxChassisNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0))
tmnxHwConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2))
tmnxChassisConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1))
class TmnxAlarmState(TextualConvention, Integer32):
    description = 'The TmnxAlarmState is an enumerated integer whose value indicates the current alarm state of a physical or logical component in the Alcatel 7x50 SR series system.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("alarmActive", 1), ("alarmCleared", 2))

class TmnxChassisIndex(TextualConvention, Integer32):
    description = 'The TmnxChassisIndex is a unique index that identifies a chassis within an Alcatel 7x50 system. Note that initial releases will support only one chassis in a system.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 32)

class TmnxHwIndex(TextualConvention, Integer32):
    description = 'The TmnxHwIndex is a unique integer index that identifies an Alcatel 7x50 SR series manufactured hardware component, such as an IOM, CPM, Fabric or MDA card.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class TmnxHwIndexOrZero(TextualConvention, Integer32):
    description = 'The TmnxHwIndexOrZero is a unique integer index that identifies an Alcatel 7x50 SR series manufactured hardware component, such as an IOM, CPM, Fabric or MDA card. Also TmnxHwIndexOrZero can be zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class TmnxHwClass(TextualConvention, Integer32):
    description = 'TmnxHwClass is an enumerated integer that identifies the general hardware type of a component in the tmnxHwTable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("chassis", 3), ("container", 4), ("powerSupply", 5), ("fan", 6), ("sensor", 7), ("ioModule", 8), ("cpmModule", 9), ("fabricModule", 10), ("mdaModule", 11), ("flashDiskModule", 12), ("port", 13), ("mcm", 14), ("ccm", 15))

class TmnxCardType(TextualConvention, Unsigned32):
    description = 'The TmnxCardType data type is a bit-mask field that describes the various Alcatel 7x50 SR series card types. A TmnxCardType bit value specifies the index value for the entry in the tmnxCardTypeTable used to identify a specific type of card manufactured by Alcatel. When multiple bits are set, it can be used to identify a set or list of card types used in the tmnxCardTable and tmnxCpmCardTable to indicate supported or allowed cards within a specific chassis slot. Some example card types might be: sfm-400g -- 400g CPM/SF module sfm-200g -- 200g CPM/SF module sfm-100g -- 100g CPM/SF module iom-20g -- 2 x 10-Gig MDA IOM Card '
    status = 'current'

class TmnxChassisType(TextualConvention, Unsigned32):
    description = 'The TmnxChassisType data type is an integer that specifies the index value for the entry in the tmnxChassisTypeTable used to identify a specific type of chassis backplane manufactured by Alcatel.'
    status = 'current'

class TmnxDeviceState(TextualConvention, Integer32):
    description = 'The TmnxDeviceState data type is an enumerated integer that describes the values used to identify states of chassis components such as fans and power supplies.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("deviceStateUnknown", 1), ("deviceNotEquipped", 2), ("deviceStateOk", 3), ("deviceStateFailed", 4), ("deviceStateOutOfService", 5))

class TmnxLEDState(TextualConvention, Integer32):
    description = 'The TmnxLEDState data type is an enumerated integer that describes the values used to identify state LEDs on Alcatel 7x50 SR series cards.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("ledOff", 1), ("ledRed", 2), ("ledAmber", 3), ("ledYellow", 4), ("ledGreen", 5), ("ledAmberBlink", 6), ("ledYellowBlink", 7), ("ledGreenBlink", 8))

class TmnxMdaType(TextualConvention, Unsigned32):
    description = 'The TmnxMdaType data type is an integer that used to identify the kind of Media Dependent Adapter (MDA) installed on a card. The value of TmnxMdaType corresponds to the bit number indicated by TmnxMDASuppType. A TmnxMdaType value specifies the index value for the entry in the tmnxMdaTypeTable used to identify a specific type of MDA manufactured by Alcatel.'
    status = 'current'

class TmnxMDASuppType(TextualConvention, Bits):
    description = 'The TmnxMDASuppType data type is a SNMP BIT that is used to identify the kind of Media Dependent Adapter (MDA) supported on a card. When multiple bits are set, it can be used to identify a set or list of supported MDAs within a specific card slot. The MDA types are defined in the tmnxMdaTypeTable.'
    status = 'current'
    namedValues = NamedValues(("invalid-MDA-type", 0), ("unassigned", 1), ("supp-MDA-type-2", 2), ("supp-MDA-type-3", 3), ("supp-MDA-type-4", 4), ("supp-MDA-type-5", 5), ("supp-MDA-type-6", 6), ("supp-MDA-type-7", 7), ("supp-MDA-type-8", 8), ("supp-MDA-type-9", 9), ("supp-MDA-type-10", 10), ("supp-MDA-type-11", 11), ("supp-MDA-type-12", 12), ("supp-MDA-type-13", 13), ("supp-MDA-type-14", 14), ("supp-MDA-type-15", 15), ("supp-MDA-type-16", 16), ("supp-MDA-type-17", 17), ("supp-MDA-type-18", 18), ("supp-MDA-type-19", 19), ("supp-MDA-type-20", 20), ("supp-MDA-type-21", 21), ("supp-MDA-type-22", 22), ("supp-MDA-type-23", 23), ("supp-MDA-type-24", 24), ("supp-MDA-type-25", 25), ("supp-MDA-type-26", 26), ("supp-MDA-type-27", 27), ("supp-MDA-type-28", 28), ("supp-MDA-type-29", 29), ("supp-MDA-type-30", 30), ("supp-MDA-type-31", 31), ("supp-MDA-type-32", 32), ("supp-MDA-type-33", 33), ("supp-MDA-type-34", 34), ("supp-MDA-type-35", 35), ("supp-MDA-type-36", 36), ("supp-MDA-type-37", 37), ("supp-MDA-type-38", 38), ("supp-MDA-type-39", 39), ("supp-MDA-type-40", 40), ("supp-MDA-type-41", 41), ("supp-MDA-type-42", 42), ("supp-MDA-type-43", 43), ("supp-MDA-type-44", 44), ("supp-MDA-type-45", 45), ("supp-MDA-type-46", 46), ("supp-MDA-type-47", 47))

class TmnxMDAChanType(TextualConvention, Integer32):
    description = 'The TmnxMDAChanType data type indicates the type of channel that can be created on an MDA.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))
    namedValues = NamedValues(("unknown", 0), ("sonetSts768", 1), ("sonetSts192", 2), ("sonetSts48", 3), ("sonetSts12", 4), ("sonetSts3", 5), ("sonetSts1", 6), ("sdhTug3", 7), ("sonetVtg", 8), ("sonetVt15", 9), ("sonetVt2", 10), ("sonetVt3", 11), ("sonetVt6", 12), ("pdhTu3", 13), ("pdhDs3", 14), ("pdhE3", 15), ("pdhDs1", 16), ("pdhE1", 17), ("pdhDs0Grp", 18))

class TmnxCcmType(TextualConvention, Unsigned32):
    description = 'The TmnxCcmType data type is bit-mask field that describes the values used to identify the kind of Chassis Control module (CCM) installed on the chassis. A TmnxCcmType bit value specifies the index value for the entry in the tmnxCcmTypeTable used to identify a specific type of CCM manufactured by Alcatel. When multiple bits are set, it can be used to identify a set or list of CCM types used in the tmnxCcmTable to indicate supported CCMs within a specific chassis slot. Some example CCM types are: unknown -- unknown/uninstalled ccm-v1 -- Chassis Control Module version 1 '
    status = 'current'

class TmnxMcmType(TextualConvention, Unsigned32):
    description = 'The TmnxMcmType data type is bit-mask field that describes the values used to identify the kind of MDA Carrier module (MCM) installed on the chassis. A TmnxMcmType bit value specifies the index value for the entry in the tmnxMcmTypeTable used to identify a specific type of MCM manufactured by Alcatel. When multiple bits are set, it can be used to identify a set or list of MCM types used in the tmnxMcmTable to indicate supported MCMs within a specific card slot. Some example MCM types are: unknown -- unknown/uninstalled mcm-v1 -- MDA Carrier Module version 1 '
    status = 'current'

class TmnxSlotNum(TextualConvention, Integer32):
    description = 'The TmnxSlotNum data type is an integer that specifies a slot in an Alcatel 7x50 SR series chassis.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 128)

class TmnxSlotNumOrZero(TextualConvention, Integer32):
    description = 'The TmnxSlotNumOrZero data type is an integer that specifies a slot in an Alcatel 7x50 SR series chassis or zero.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 128)

class TmnxPortAdminStatus(TextualConvention, Integer32):
    description = 'The desired administrative status of this port.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("noop", 1), ("inService", 2), ("outOfService", 3), ("diagnose", 4))

class TmnxChassisMode(TextualConvention, Integer32):
    description = "The TmnxChassisMode data type is an enumerated integer that specifies the values used to identify which set of scaling numbers and features are effective for an Alcatel 7x50 SR series chassis. 'modeA' corresponds to the scaling and feature set on the existing iom-20g. 'modeB' corresponds to the scaling and features that come with iom-20g-b. 'modeC' corresponds to the scaling and features that come with iom2-20g."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("modeA", 1), ("modeB", 2), ("modeC", 3))

class TmnxSETSRefSource(TextualConvention, Integer32):
    description = 'The TmnxSETSRefSource data type is an enumerated integer that describes the values used to identify the Synchronous Equipment Timing Subsystem (SETS) timing reference source.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("reference1", 1), ("reference2", 2), ("bits", 3))

class TmnxSETSRefQualified(TextualConvention, Integer32):
    description = "The TmnxSETSRefQualified data type is an enumerated integer that describes the values used to identify whether the reference is 'qualified' or 'not-qualified' for use by SETS."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("qualified", 1), ("not-qualified", 2))

class TmnxSETSRefAlarm(TextualConvention, Bits):
    description = "The TmnxSETSRefAlarm data type is a bitmap that describes the values used to identify the alarms on the SETS timing reference source if the source is 'not-qualified'. 'los' - loss of signal 'oof' - out of frequency range 'oopir' - out of pull in range."
    status = 'current'
    namedValues = NamedValues(("los", 0), ("oof", 1), ("oopir", 2))

class TmnxBITSIfType(TextualConvention, Integer32):
    description = 'The TmnxBITSIfType data type is an enumerated integer that describes the values used to identify the interface and framing types of a BITS (Building Integrated Timing Supply) interface.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("none", 0), ("t1-esf", 1), ("t1-sf", 2), ("e1-pcm30crc", 3), ("e1-pcm31crc", 4))

class TmnxCcagId(TextualConvention, Integer32):
    description = "TmnxCcagId is an integer specifying the cross connect aggregation group. The value '0' is used when a ccag is not defined and is not a valid value when TmnxCcagId is used as an index."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8), )
class TmnxCcagRate(TextualConvention, Integer32):
    description = "TmnxCcagRate is an integer specifying the rate for a CCAG member in Kbps. The range of TmnxCcagRate is from 0 Kbps to 100Gbps. The value '-1' is used for maximum rate available."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100000000), )
class TmnxCcagRateOption(TextualConvention, Integer32):
    description = 'TmnxCcagRateOption specifies how the defined rate is applied to active Cross Connect Adaptors (CCAs). aggregate (1) - the defined rate is equally divided among the CCAs in the CCAG member list based on the number of active CCAs. cca (2) - the defined rate is applied to all CCAs in the CCAG member list.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("aggregate", 1), ("cca", 2))

tmnxChassisTotalNumber = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTotalNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTotalNumber.setDescription('The number of chassis installed in this system. For the first release of the Alcatel 7x50 series product, there is only 1 chassis per system. A multi-chassis system model is supported to allow for future product expansion.')
tmnxChassisLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisLastChange.setDescription('The value of sysUpTime when the tmnxChassisTable was last changed.')
tmnxChassisTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3), )
if mibBuilder.loadTexts: tmnxChassisTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTable.setDescription('The chassis table has an entry for each chassis in the system.')
tmnxChassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"))
if mibBuilder.loadTexts: tmnxChassisEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisEntry.setDescription('Each row entry represents a chassis in the system. The agent creates the row for the first chassis in the system, with tmnxChassisIndex = 1, which is auto-discovered by the active CPM card. Additional chassis entries can be created and deleted via SNMP SET operations. Creation requires a SET request containing at least tmnxChassisAdminMode and tmnxChassisRowStatus. Note that the first Alcatel 7x50 series product release does not support multiple chassis, therefore there will not be more than one row entry in this table; attempts to create additional rows in this table will be denied.')
tmnxChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 1), TmnxChassisIndex())
if mibBuilder.loadTexts: tmnxChassisIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisIndex.setDescription('The unique value which identifies this chassis in the system. The first release of the product only supports a single chassis in the system.')
tmnxChassisRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisRowStatus.setDescription('The row status. The creation or deletion of a chassis entry causes creation or deletion of corresponding entries in the tmnxCardTable with the same tmnxChassisIndex value. Note, the agent will disallow chassis deletion if its entries in the card table have not first been put into the proper state for removal. The row entry for tmnxChassisIndex equal 1 cannot be deleted.')
tmnxChassisName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 3), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisName.setDescription("The administrative name assigned this chassis. Setting tmnxChassisName to the empty string, ''H, resets tmnxChassisName to the TiMOS default value.")
tmnxChassisType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 4), TmnxChassisType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisType.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisType.setDescription('The type of chassis used in this Alcatel 7x50 system. The value of tmnxChassisType is the tmnxChassisTypeIndex for the entry in the tmnxChassisTypeTable that represents the Alcatel 7x50 SR series chassis model for this system. Chassis types are distinguished by their backplane type.')
tmnxChassisLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 5), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisLocation.setDescription('A user supplied string that indicates the on site location of this chassis. This could used for a Common Language Location Identifier, CLLI, code string if desired. A CLLI code is an 11-character standardized geographic identifier that uniquely identifies the geographic location of places and certain functional categories of equipment unique to the telecommunications industry. All valid CLLI codes are created, updated and maintained in the Central Location Online Entry System (CLONES) database.')
tmnxChassisCoordinates = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 6), TItemDescription().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisCoordinates.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCoordinates.setDescription("A user supplied string that indicates the Global Positioning System (GPS) coordinates for the location of this chassis. N 45 58 23, W 34 56 12 N37 37' 00 latitude, W122 22' 00 longitude N36*39.246' W121*40.121' Two-dimensional GPS positioning offers latitude and longitude information as a four dimensional vector: <Direction, hours, minutes, seconds> where Direction is one of the four basic values: N, S, W, E; hours ranges from 0 to 180 (for latitude) and 0 to 90 for longitude, and, finally, minutes and seconds range from 0 to 60. Thus <W, 122, 56, 89> is an example of longitude and <N, 85, 66, 43> is an example of latitude. Four bytes of addressing space (one byte for each of the four dimensions) are necessary to store latitude and four bytes are also sufficient to store longitude. Thus eight bytes total are necessary to address the whole surface of earth with precision down to 0.1 mile! Notice that if we desired precision down to 0.001 mile (1.8 meters) then we would need just five bytes for each component, or ten bytes together for the full address (as military versions provide).")
tmnxChassisNumSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumSlots.setDescription('The number of slots in this chassis that are available for plug-in cards. This includes both fabric and IOM cards')
tmnxChassisNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumPorts.setDescription('The total number of ports currently installed in this chassis. This count does not include the Ethernet ports on the CPM cards that are used for management access.')
tmnxChassisNumPwrSupplies = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumPwrSupplies.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumPwrSupplies.setDescription('The total number of power supplies installed in this chassis.')
tmnxChassisNumFanTrays = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumFanTrays.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumFanTrays.setDescription('The total number of fan trays installed in this chassis.')
tmnxChassisNumFans = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisNumFans.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNumFans.setDescription('The total number of fans installed in this chassis.')
tmnxChassisCriticalLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 12), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisCriticalLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCriticalLEDState.setDescription('The current state of the Critical LED in this chassis.')
tmnxChassisMajorLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 13), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisMajorLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMajorLEDState.setDescription('The current state of the Major LED in this chassis.')
tmnxChassisMinorLEDState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 14), TmnxLEDState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisMinorLEDState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisMinorLEDState.setDescription('The current state of the Minor LED in this chassis.')
tmnxChassisBaseMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 15), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisBaseMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisBaseMacAddress.setDescription('The base chassis ethernet MAC address. Special purpose MAC addresses used by the system software are constructed as offsets from this base address.')
tmnxChassisCLLICode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 16), DisplayString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisCLLICode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisCLLICode.setDescription('A Common Language Location Identifier (CLLI) code is an 11-character standardized geographic identifier that uniquely identifies the geographic location of places and certain functional categories of equipment unique to the telecommunications industry. If the set on this object specifies a non-null string, the string will automatically be truncated or padded(with spaces) to 11 characters.')
tmnxChassisReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 17), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisReboot.setDescription("Setting this tmnxChassisReboot to 'doAction' causes a soft-reboot of the entire chassis including all the CPM and IOM cards. Note that the reboot action is likely to occur before the SNMP SET response can be transmitted.")
tmnxChassisUpgrade = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 18), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisUpgrade.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgrade.setDescription("Setting this tmnxChassisUpgrade to 'doAction' causes an upgrade of all firmware and a reboot of the entire chassis including all the CPM and IOM cards. CAUTION: This upgrade and reboot may take several minutes to complete. The chassis MUST NOT be reset or powered down, nor cards inserted or removed, during this process. Any of these prohibited actions may cause the cards to be rendered inoperable. tmnxChassisUpgrade and tmnxChassisReboot must be set together in the same SNMP SET request PDU or else the SET request will fail with an inconsistentValue error. Note that the reboot action is likely to occur before the SNMP SET response can be transmitted.")
tmnxChassisAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 19), TmnxChassisMode().clone('modeA')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisAdminMode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminMode.setDescription("The value of tmnxChassisAdminMode specifies the scaling and feature set for the IOM cards in the chassis. Setting this variable to 'modeA' causes all IOM cards in the chassis to use the scaling and feature sets supported on the iom-20g card type. Setting tmnxChassisAdminMode to 'modeB' corresponds to the scaling and feature sets supported on the iom-20g-b card type. 'modeC' corresponds to the scaling and feature sets supported on the iom2-20g card type. An attempt to change the value of tmnxChassisAdminMode from 'modeA' to 'modeB' (upgrade) or 'modeC' (upgrade) without also setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request, will fail with an inconsistentValue error if there are any IOM cards in the chassis with a value of 'iom-20g' for tmnxCardAssignedType. An attempt to change the value of tmnxChassisAdminMode from 'modeB' to 'modeC' (upgrade) without also setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request, will fail with an inconsistentValue error if there are any IOM cards in the chassis with a value of 'iom-20g-b' for tmnxCardAssignedType. 'modeB' scaling and feature sets cannot be supported on the iom-20g card. 'modeC' scaling feature set cannot be supported on either on the iom-20g or the iom-20g-b.")
tmnxChassisOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 20), TmnxChassisMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisOperMode.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisOperMode.setDescription("The value of tmnxChassisOperMode indicates the operational scaling and feature set for the IOM cards in the chassis. Changing the value of tmnxChassisAdminMode from 'modeB' to 'modeA' (downgrade) will result in tmnxChassisAdminMode indicating 'modeA' while tmnxChassisOperMode indicates 'modeB' untill the configuration is saved and the system rebooted, at which point, the actual downgrade will take effect. Changing the value of tmnxChassisAdminMode from 'modeC' to either 'modeB' (downgrade) or 'modeA' (downgrade) will result in tmnxChassisAdminMode indicating 'modeB' or 'modeA' respectively while tmnxChassisOperMode indicates 'modeC' untill the configuration is saved and the system rebooted, at which point, the actual downgrade will take effect. 'modeB' scaling and feature sets cannot be supported on the iom-20g card. 'modeC' scaling feature set cannot be supported on either on the iom-20g or the iom-20g-b.")
tmnxChassisModeForce = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 21), TmnxActionType().clone('notApplicable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisModeForce.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisModeForce.setDescription("Setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request where tmnxChassisAdminMode is set to 'modeB' allows the chassis to be upgraded to 'modeB' even if there are IOM cards in the chassis with a value of 'iom-20g' for tmnxCardAssignedType. Setting tmnxChassisModeForce to a value of 'doAction' in the same SNMP SET request where tmnxChassisAdminMode is set to 'modeC' allows the chassis to be upgraded to 'modeC' even if there are IOM cards in the chassis with a value of 'iom2-20g' for tmnxCardAssignedType. An attempt to set tmnxChassisModeForce to 'doAction' without also setting tmnxChassisAdminMode, in the same SNMP SET request will fail with an inconsistentValue error. ----------------------------------------------------------------------- Mode change | Assigned card | Force | Result ----------------------------------------------------------------------- a to b (upgrade) | iom-20g | not-set | error a to b (upgrade) | iom-20g | set | mode b with warnings a to b (upgrade) | iom-20g-b | not-set | mode b a to b (upgrade) | iom-20g-b | set | mode b a to c (upgrade) | iom-20g | not-set | error a to c (upgrade) | iom-20g | set | mode c with warnings a to c (upgrade) | iom2-20g | not-set | mode c a to c (upgrade) | iom2-20g | set | mode c b to c (upgrade) | iom-20g-b | not-set | error b to c (upgrade) | iom-20g-b | set | mode c with warnings b to c (upgrade) | iom2-20g | not-set | mode c b to c (upgrade) | iom2-20g | set | mode c b to a (downgrade)| iom-20g | not-set | mode a on save and reboot b to a (downgrade)| iom-20g | set | mode a on save and reboot b to a (downgrade)| iom-20g-b | not-set | mode a on save and reboot b to a (downgrade)| iom-20g-b | set | mode a on save and reboot c to a (downgrade)| iom-20g | not-set | mode a on save and reboot c to a (downgrade)| iom-20g | set | mode a on save and reboot c to a (downgrade)| iom2-20g | not-set | mode a on save and reboot c to a (downgrade)| iom2-20g | set | mode a on save and reboot c to b (downgrade)| iom-20g-b | not-set | mode b on save and reboot c to b (downgrade)| iom-20g-b | set | mode b on save and reboot c to b (downgrade)| iom2-20g | not-set | mode b on save and reboot c to b (downgrade)| iom2-20g | set | mode b on save and reboot -----------------------------------------------------------------------")
tmnxChassisUpdateWaitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 600)).clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisUpdateWaitTime.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisUpdateWaitTime.setDescription('The value of tmnxChassisUpdateWaitTime specifies the time to wait before rebooting IOM cards running older software versions following a software upgrade or downgrade activity switchover. This object was obsoleted in release 5.0.')
tmnxChassisUpdateTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 23), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisUpdateTimeLeft.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpdateTimeLeft.setDescription('Following a software upgrade or downgrade activity switchover, the value of tmnxChassisUpdateTimeLeft indicates the time remaining before IOM cards or MDAs running older software versions will be rebooted.')
tmnxChassisOverTempState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 3, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("stateOk", 1), ("stateOverTemp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisOverTempState.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisOverTempState.setDescription('The current Over Temperature state of this chassis. stateOk Indicates chassis is below the temperature threshold. stateOverTemp Indicates chassis is above the temperature threshold. ')
tmnxChassisFanTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4), )
if mibBuilder.loadTexts: tmnxChassisFanTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanTable.setDescription('This table contains information about fan trays.')
tmnxChassisFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanIndex"))
if mibBuilder.loadTexts: tmnxChassisFanEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanEntry.setDescription('Contains information regarding a fan tray.')
tmnxChassisFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: tmnxChassisFanIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanIndex.setDescription('The unique value which identifies a specific fan tray in the chassis.')
tmnxChassisFanOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisFanOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanOperStatus.setDescription('Current status of the Fan tray.')
tmnxChassisFanSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("halfSpeed", 2), ("fullSpeed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisFanSpeed.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisFanSpeed.setDescription("The value of tmnxChassisFanSpeed indicates if the fans in this fan tray are running at 'halfSpeed' or 'fullSpeed'.")
tmnxChassisPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5), )
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTable.setDescription('This table contains information about power supply trays.')
tmnxChassisPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyId"))
if mibBuilder.loadTexts: tmnxChassisPowerSupplyEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyEntry.setDescription('Contains information regarding a power supply tray.')
tmnxChassisPowerSupplyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)))
if mibBuilder.loadTexts: tmnxChassisPowerSupplyId.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyId.setDescription('The unique identifier index for a power supply tray in the chassis.')
tmnxChassisPowerSupplyACStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyACStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyACStatus.setDescription("If the value of tmnxChassisPowerSupplyACStatus is 'deviceStateOk', the input AC voltage is within range. If the value is 'deviceStateFailed', an AC voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the AC power supply is not present.")
tmnxChassisPowerSupplyDCStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 3), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyDCStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyDCStatus.setDescription("If the value of tmnxChassisPowerSupplyDCStatus is 'deviceStateOk', the input DC voltage is within range. If the value is 'deviceStateFailed', an DC voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the DC power supply is not present.")
tmnxChassisPowerSupplyTempStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 4), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempStatus.setDescription("If the value of tmnxChassisPowerSupplyTempStatus is 'deviceStateOk', the current temperature is within acceptable range. If the value is 'deviceStateFailed', a temperature too high condition has been detected.")
tmnxChassisPowerSupplyTempThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 5), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyTempThreshold.setDescription("The temperature threshold for this power supply tray in degrees celsius. When the temperature raises above tmnxChassisPowerSupplyTempThreshold, a 'temperature too high' event will be generated.")
tmnxChassisPowerSupply1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 6), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupply1Status.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupply1Status.setDescription("The overall status of an equipped power supply. For AC multiple power supplies, this represents the overall status of the first power supply in the tray (or shelf). For any other type, this represents the overall status of the power supply. If tmnxChassisPowerSupply1Status is 'deviceStateOk', then all monitored statuses are 'deviceStateOk'. A value of 'deviceStateFailed' represents a condition where at least one monitored status is in a failed state.")
tmnxChassisPowerSupply2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 7), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupply2Status.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupply2Status.setDescription("The overall status of an equipped power supply. For AC multiple power supplies, this represents the overall status of the second power supply in the tray (or shelf). For any other type, this field is unused and set to 'deviceNotEquipped'. If tmnxChassisPowerSupply2Status is 'deviceStateOk', then all monitored statuses are 'deviceStateOk'. A value of 'deviceStateFailed' represents a condition where at least one monitored status is in a failed state.")
tmnxChassisPowerSupplyAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dc", 1), ("acSingle", 2), ("acMultiple", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyAssignedType.setDescription('tmnxChassisPowerSupplyAssignedType configures the type of power supply for a platform. Based on the value assigned to this object, various power supply monitoring signals will be interpreted. For example, if a platform is provisioned to use DC power supplies, then the signal that indicates an AC power supply is missing can be ignored. This is required for proper generation of traps and LED management.')
tmnxChassisPowerSupplyInputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 9), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyInputStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyInputStatus.setDescription("If the value of tmnxChassisPowerSupplyInputStatus is 'deviceStateOk', the input voltage of the power supply is within range. If the value is 'deviceStateFailed', an input voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the power supply is not present.")
tmnxChassisPowerSupplyOutputStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 5, 1, 10), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisPowerSupplyOutputStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisPowerSupplyOutputStatus.setDescription("If the value of tmnxChassisPowerSupplyOutputStatus is 'deviceStateOk', the output voltage of the power supply is within range. If the value is 'deviceStateFailed', an output voltage out of range condition has been detected. A value of 'deviceNotEquipped' indicates that the power supply is not present.")
tmnxChassisTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6), )
if mibBuilder.loadTexts: tmnxChassisTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeTable.setDescription('The chassis type table has an entry for each Alcatel 7x50 SR series chassis model.')
tmnxChassisTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeIndex"))
if mibBuilder.loadTexts: tmnxChassisTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series Chassis model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxChassisTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 1), TmnxChassisType())
if mibBuilder.loadTexts: tmnxChassisTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7x50 SR series chassis model.')
tmnxChassisTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeName.setDescription('The administrative name that identifies this type of Alcatel 7x50 SR series chassis model. This name string may be used in CLI commands to specify a particular chassis model type.')
tmnxChassisTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeDescription.setDescription('A detailed description of this Alcatel 7x50 SR series chassis model.')
tmnxChassisTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 6, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisTypeStatus.setDescription("When tmnxChassisTypeStatus has a value of 'true' it indicates that this chassis model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxHwLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxHwLastChange.setDescription('The value of sysUpTime when the tmnxHwTable was last changed.')
tmnxHwTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8), )
if mibBuilder.loadTexts: tmnxHwTable.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTable.setDescription("The tmnxHwTable has an entry for each managed hardware component in the Alcatel 7x50 SR series system's chassis. Examples of these hardware component types are IOM, Fabric, and CPM cards, MCM and CCM, and MDA modules. Similar information for physical ports is in the tmnxPortObjs.")
tmnxHwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwIndex"))
if mibBuilder.loadTexts: tmnxHwEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxHwEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series manufactured hardware component. Entries cannot be created and deleted via SNMP SET operations. When an entry is created in one of the card tables, IOM, CPM, Fabric or MDA, a tmnxHwEntry is created for the common hardware management information for that card in that chassis. When the card is removed from the chassis, its corresponding tmnxHwEntry is deleted. The tmnxHwIndex is bitmapped: | 32 25 | 24 17 | 16 9 | 8 1 | +-------------+-------------+-------------+-------------+ | TmnxHwClass | 00000000 | Slot | number | +-------------+-------------+-------------+-------------+ The Slot field is only used for components on cards in slots. It is zero for all others. The number field starts from 1 and indicates which component. E.g. Power supply 1 or 2.')
tmnxHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 1), TmnxHwIndex())
if mibBuilder.loadTexts: tmnxHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxHwIndex.setDescription('The value of tmnxHwIndex is a unique index that identifies common management information for Alcatel 7x50 SR series manufactured hardware components within the specified chassis.')
tmnxHwID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwID.setStatus('current')
if mibBuilder.loadTexts: tmnxHwID.setDescription("The value of tmnxHwID is an object identifier that points to the table and row entry with additional management information specific to this hardware component's class.")
tmnxHwMfgString = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 253))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgString.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgString.setDescription('The tmnxHwMfgString contains unspecified Alcatel 7x50 SR series manufacturing information and includes the Alcatel vendor information.')
tmnxHwMfgBoardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgBoardNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgBoardNumber.setDescription('The tmnxHwMfgBoardNumber contains the part number information.')
tmnxHwSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSerialNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSerialNumber.setDescription('The unique Alcatel 7x50 SR series serial number of the hardware component.')
tmnxHwManufactureDate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwManufactureDate.setStatus('current')
if mibBuilder.loadTexts: tmnxHwManufactureDate.setDescription("The manufacturing date of the hardware component in 'mmddyyyy' ascii format.")
tmnxHwClass = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 7), TmnxHwClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwClass.setStatus('current')
if mibBuilder.loadTexts: tmnxHwClass.setDescription("The value of tmnxHwClass indicates the general hardware type of this component. If no appropriate enumeration exists for this hardware component then the value 'other (1)' is used. If the agent cannot identify this hardware component then the value 'unknown (2)' is used.")
tmnxHwName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 8), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwName.setStatus('current')
if mibBuilder.loadTexts: tmnxHwName.setDescription("The value of tmnxHwName is the name of the component as assigned by the system software itself and is suitable for use in CLI commands. This may be a text name such as 'console' or a port ID such as '2/2'. If there is no predefined name then a zero length string is returned. Note that the value of tmnxHwName for two component entries will be the same if the CLI does not distinguish between them, e.g. the chassis slot-1 and the card in slot-1.")
tmnxHwAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 9), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAlias.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAlias.setDescription('The value of tmnxHwAlias is the administrative name assigned to this hardware component by the CLI user or network manager. It is saved across re-initializations and reboots of the system.')
tmnxHwAssetID = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 10), SnmpAdminString().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAssetID.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAssetID.setDescription("The value of tmnxHwAssetID is an administratively assigned asset tracking identifier for this hardware component. It is saved across re-initializations and reboots of the system. If no asset tracking information is associated with this hardware component, a zero-length string is returned to an SNMP get request. Some hardware components do not have asset tracking identifiers. Components for which tmnxHwIsFRU has a value of 'false' do not need their own unique asset tracking identifier. In this case, the agent denies write access to this object and returns a zero-length string to an SNMP get request.")
tmnxHwCLEI = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 11), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwCLEI.setReference('Bellcore (Telcordia Technologies) GR-485.')
if mibBuilder.loadTexts: tmnxHwCLEI.setStatus('current')
if mibBuilder.loadTexts: tmnxHwCLEI.setDescription("The Common Language Equipment Identifier, CLEI, code is a unique 10-character identifier, that is fixed by the manufacturer. It consists of ten alphanumeric characters. The first seven characters present a concise summary of an equipment entity's circuit or transport capabilities, e.g., functional, electrical, bandwidth, etc. CLEI codes for plug-in or portable equipment with the same first seven characters (CLEI-7) are considered bidirectionally interchangeable and group under a G level record. Most licensees plug-in inventories and records are controlled at the group level. The eighth character denotes the reference source used for coding the item, and the last two characters denote manufacturing vintage or version, and other complemental information. A ten-character CLEI code that is developed for a specific piece of equipment is unique within the CLEI code universe and is used in A level records; the code is not assigned to any other equipment piece. Equipment is coded to a first or major application. When the same equipment is usable in another application or system, it is not recorded nor are additional codes developed for that purpose.")
tmnxHwIsFRU = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwIsFRU.setStatus('current')
if mibBuilder.loadTexts: tmnxHwIsFRU.setDescription("The value of tmnxHwIsFRU indicates whether or not this hardware component is a Field Replaceable Unit (FRU) or not. Those components that are permanently contained within a FRU have a value of 'false'.")
tmnxHwContainedIn = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwContainedIn.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainedIn.setDescription('The value of tmnxHwContainedIn is the tmnxHwIndex value for the row entry of the hardware component that contains this component. A value of zero indicates that this component is not contained in any other component.')
tmnxHwParentRelPos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwParentRelPos.setStatus('current')
if mibBuilder.loadTexts: tmnxHwParentRelPos.setDescription("The value of tmnxHwParentRelPos indicates the relative position of this hardware component among all its 'sibling' components. A sibling component shares the same instance values for tmnxHwContainedIn and tmnxHwClass objects. If the associated value of tmnxHwContainedIn is zero, then the value -1 is returned.")
tmnxHwAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noop", 1), ("inService", 2), ("outOfService", 3), ("diagnose", 4), ("operateSwitch", 5))).clone('noop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAdminState.setDescription("The desired administrative status of this hardware component. Write access will be denied for those components that do not have administrative status. An attempt to set tmnxHwAdminState to 'operateSwitch (5)' will fail if the hardware component is not part of a redundant pair. Some examples of redundant hardware are the CPM cards and fabric cards.")
tmnxHwOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("unknown", 1), ("inService", 2), ("outOfService", 3), ("diagnosing", 4), ("failed", 5), ("booting", 6), ("empty", 7), ("provisioned", 8), ("unprovisioned", 9), ("upgrade", 10), ("downgrade", 11), ("inServiceUpgrade", 12), ("inServiceDowngrade", 13), ("resetPending", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwOperState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwOperState.setDescription("The actual operational status of this hardware component. unknown (1) Status cannot be determined inService (2) Online - If tmnxHwClass has a value of 'ioModule (8)' or 'cpmModule (9), the card is present, booted, configured, and running. outOfService (3) Ready - The hardware component is OK but is down because tmnxHwAdminState has a value of 'outOfService (3)'. diagnosing (4) Not implemented. failed (5) This hardware component has failed. The value of tmnxHwFailureReason indicates the type of failure. If tmnxHwClass has a value of 'ioModule(8)' or 'cpmModule(9)', there is a card in the slot but it has failed. booting (6) A card is in the transitional startup state. empty (7) There is no card in the slot and it has not been pre-configured. provisioned (8) There is no card in the slot but it has been pre-configured. unprovisioned (9) There is a card in the slot but it is not configured. upgrade (10) Card software version is compatible with and newer than that running on the current active CPM. downgrade (11) Card software version is compatible with and older than that running on the current active CPM. inServiceUpgrade (12) Card is inService and the card software version is compatible with and newer than that running on the current active CPM. This state applies only to a standby CPM card. This enumeration is no longer supported as of release 5.0. inServiceDowngrade (13) Card is inService and the card software is compatible with and older than that running on the current active CPM. This state applies only to a standby CPM card. This enumeration is no longer supported as of release 5.0. resetPending (14) Card is awaiting reset following an upgrade or downgrade activity switch. The card software version is upgrade or downgrade compatible but will be reset in order to update it to match the active CPM software. The value of tmnxChassisUpdateWaitTime indicates the how long the system will wait following an upgrade or downgrade activity switch before it resets IOM cards. This state applies only to IOM cards. This enumeration is no longer supported as of release 5.0. ")
tmnxHwTempSensor = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTempSensor.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTempSensor.setDescription('The value of tmnxHwTempSensor indicates whether or not this hardware component contains a temperature sensor.')
tmnxHwTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 18), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTemperature.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTemperature.setDescription("The current temperature reading in degrees celsius from this hardware component's temperature sensor. If this component does not contain a temperature sensor, then the value -1 is returned.")
tmnxHwTempThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 19), Integer32()).setUnits('degrees celsius').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwTempThreshold.setStatus('current')
if mibBuilder.loadTexts: tmnxHwTempThreshold.setDescription("The temperature threshold for this hardware component in degrees celsius. When the value of tmnxHwTemperature raises above tmnxHwTempThreshold, a 'temperature too high' event will be generated.")
tmnxHwBootCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwBootCodeVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxHwBootCodeVersion.setDescription('The version number of boot eprom on the card in this slot. If no specific software program is associated with this hardware component then this object will contain a zero length string.')
tmnxHwSoftwareCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSoftwareCodeVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSoftwareCodeVersion.setDescription('The software product release version number for the software image currently running on this IOM or CPM card. If no specific software program is associated with this hardware component then this object will contain a zero length string.')
tmnxHwSwLastBoot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 22), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwLastBoot.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSwLastBoot.setDescription('The date and time the software running on this IOM or CPM card was last rebooted. If this row entry represents a standby CPM card, the date and time indicated is when the standby completed its initial synchronization process and became ready to take over in case the active card fails or a manual switchover command is issued.')
tmnxHwSwState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 0), ("hwFailure", 1), ("swFailure", 2), ("hwInitting", 3), ("swDownloading", 4), ("swInitting", 5), ("swInitted", 6), ("swRunning", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwState.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHwSwState.setDescription('The state of the software running on this IOM or CPM card. The tmnxHwSwState object is obsolete. The Alcatel 7x50 platform cannot distinguish software status separate from the hardware status. Instead of using this object, additional operational states have been added to tmnxHwOperState. If no specific software program is associated with this hardware component then this object will contain a zero.')
tmnxHwAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 24), TmnxAlarmState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwAlarmState.setStatus('current')
if mibBuilder.loadTexts: tmnxHwAlarmState.setDescription('The value of tmnxHwAlarmState indicates the current alarm state for this hardware component.')
tmnxHwLastAlarmEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 25), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwLastAlarmEvent.setStatus('current')
if mibBuilder.loadTexts: tmnxHwLastAlarmEvent.setDescription("The value of tmnxHwLastAlarmEvent is an object identifier whose object name and instance values point to the row entry in the ALARM-MIB that contains the most recent alarm event associated with this hardware component. If the tmnxHwAlarmState has a value of 'alarmCleared', the most recent alarm event will be in the nlmAlarmClearedTable. If it has a value of 'alarmActive', the entry pointed to is in the nlmAlarmActiveTable. If the value of tmnxHwLastAlarmEvent is '0.0', then either there have not been any alarm events associated with this chassis since the system was last booted, or the last alarm event has aged out and its entry is no longer available in the ALARM-MIB tables.")
tmnxHwClearAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 26), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxHwClearAlarms.setStatus('current')
if mibBuilder.loadTexts: tmnxHwClearAlarms.setDescription('Setting this action variable causes all the active alarms associated with this hardware component to be moved from the ALARM-MIB nlmActiveAlarmTable to the nlmClearedAlarmTable. This action button is primarily meant for use as a code development aid. This object may be removed from the ALCATEL-IND1-TIMETRA-CHASSIS-MIB before product release.')
tmnxHwSwImageSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwSwImageSource.setStatus('current')
if mibBuilder.loadTexts: tmnxHwSwImageSource.setDescription('The value of tmnxHwSwImageSource indicates the location in the Boot Options File (BOF) where the software image file was found when the system last rebooted.')
tmnxHwMfgDeviations = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 28), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwMfgDeviations.setStatus('current')
if mibBuilder.loadTexts: tmnxHwMfgDeviations.setDescription('tmnxHwMfgDeviations contains a record of changes done by the manufacturing to the hardware or software and which is outside the normal revision control process.')
tmnxHwBaseMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 29), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwBaseMacAddress.setStatus('current')
if mibBuilder.loadTexts: tmnxHwBaseMacAddress.setDescription("tmnxHwBaseMacAddress contains the base MAC address of the hardware component. It is applicable only if tmnxHwClass is of type 'chassis', 'ioModule', 'cpmModule' or 'mdaModule'.")
tmnxHwFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 8, 1, 30), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwFailureReason.setStatus('current')
if mibBuilder.loadTexts: tmnxHwFailureReason.setDescription("tmnxHwFailureReason indicates the reason why a hardware component 'failed' as indicated in tmnxHwOperState.")
tmnxHwContainsTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9), )
if mibBuilder.loadTexts: tmnxHwContainsTable.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainsTable.setDescription('The tmnxHwContainsTable shows the container/containee relationship between entries in the tmnxHwTable. The hardware component containment tree can be constructed from information in the tmnxHwTable, but this table provides the information in a more convenient format for the manager system to use.')
tmnxHwContainsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if mibBuilder.loadTexts: tmnxHwContainsEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainsEntry.setDescription('Each row entry represents a single container/containee relationship. Entries cannot be created and deleted via SNMP SET operations.')
tmnxHwContainedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 9, 1, 1), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxHwContainedIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxHwContainedIndex.setDescription('The value of tmnxHwIndex for the contained hardware component.')
tmnxCcmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10), )
if mibBuilder.loadTexts: tmnxCcmTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTable.setDescription('This table contains information about CCM.')
tmnxCcmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmIndex"))
if mibBuilder.loadTexts: tmnxCcmEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmEntry.setDescription('Contains information regarding a CCM.')
tmnxCcmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: tmnxCcmIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmIndex.setDescription('The unique value which identifies a specific CCM instance in the chassis.')
tmnxCcmOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmOperStatus.setDescription('Current status of the CCM.')
tmnxCcmHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 3), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmHwIndex.setDescription('The value of tmnxCcmHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this CCM.')
tmnxCcmEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 10, 1, 4), TmnxCcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmEquippedType.setDescription('A bit-mask that identifies the CCM type that is physically inserted into this chassis. There will not be more than one bit set at a time in tmnxCcmEquippedType.')
tmnxCcmTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11), )
if mibBuilder.loadTexts: tmnxCcmTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeTable.setDescription('The card type table has an entry for each Alcatel 7710 series Chassis Control Module (CCM) model.')
tmnxCcmTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmTypeIndex"))
if mibBuilder.loadTexts: tmnxCcmTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeEntry.setDescription('Each row entry represents an Alcatel 7710 series CCM model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxCcmTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 1), TmnxCcmType())
if mibBuilder.loadTexts: tmnxCcmTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7710 series CCM model.')
tmnxCcmTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeName.setDescription('The administrative name that identifies this type of Alcatel 7710 series CCM model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxCcmTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeDescription.setDescription('A detailed description of this Alcatel 7710 series CCM model.')
tmnxCcmTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 1, 11, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcmTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcmTypeStatus.setDescription("When tmnxCcmTypeStatus has a value of 'true' it indicates that this CCM is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxCardLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxCardLastChange.setDescription('The value of sysUpTime when the tmnxCardTable was last changed.')
tmnxCardTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2), )
if mibBuilder.loadTexts: tmnxCardTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTable.setDescription('The tmnxCardTable has an entry for each IOM card slot in each chassis in the TMNX system.')
tmnxCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"))
if mibBuilder.loadTexts: tmnxCardEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCardEntry.setDescription('Each row entry represents an IOM card slot in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxCardEntry is created for each IOM card slot in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxCardEntry for that chassis must be in the proper state for removal.')
tmnxCardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 1), TmnxSlotNum())
if mibBuilder.loadTexts: tmnxCardSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSlotNum.setDescription('The unique value which identifies this IOM slot within a chassis in the system.')
tmnxCardSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 2), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxCardSupportedTypes.setDescription('A bit-mask that specifies what card types can be physically supported in this IOM slot in this chassis.')
tmnxCardAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 3), TmnxCardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxCardAllowedTypes.setDescription('A bit-mask that specifies what IOM card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. If a specific value has not yet been SET by the manager, tmnxCardAllowedTypes will return the same value to a GET request as tmnxCardSupportedTypes. The object was made obsolete in the 3.0 release.')
tmnxCardAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 4), TmnxCardType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCardAssignedType.setDescription("A bit-mask that identifies the administratively assigned (pre-provisioned) IOM card type that should occupy this slot in this chassis. If tmnxCardAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned. There must not be more than one bit set at a time in tmnxCardAssignedType.")
tmnxCardEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 5), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCardEquippedType.setDescription("A bit-mask that identifies the IOM card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxCardAssignedType is not equal 'unassigned', and the value of tmnxCardEquippedType is not the same as tmnxCardAssignedType, a mis-match alarm will be raised. If the slot has not been pre-provisioned, and the value of tmnxCardEquippedType is not one of the allowed types as specified by tmnxCardAllowedTypes, a mis-match alarm will be raised. There will not be more than one bit set at a time in tmnxCardEquippedType. A value of 0 indicates the IOM card type is not recognized by the software.")
tmnxCardHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 6), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCardHwIndex.setDescription('The value of tmnxCardHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this IOM card.')
tmnxCardClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 10), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCardClockSource.setDescription('The clock source used by the IOM card in this slot.')
tmnxCardNumMdaSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNumMdaSlots.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNumMdaSlots.setDescription('The number of Media Dependent Adapter (MDA) slots available on this IOM card.')
tmnxCardNumMdas = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNumMdas.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNumMdas.setDescription('The number of Media Dependent Adapters installed on this IOM card.')
tmnxCardReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 13), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxCardReboot.setDescription("Setting this variable to 'doAction' causes the IOM card to execute a soft-reboot.")
tmnxCardMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 14), Unsigned32()).setUnits('Mega-bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardMemorySize.setStatus('current')
if mibBuilder.loadTexts: tmnxCardMemorySize.setDescription('The value of tmnxCardMemorySize indicates the amount of memory, in mega-bytes, populated on this IOM card.')
tmnxCardNamedPoolAdminMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 15), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCardNamedPoolAdminMode.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNamedPoolAdminMode.setDescription("The value of tmnxCardNamedPoolAdminMode specifies whether or not an IOM is provisioned for the configuration of named pools. If the value of tmnxCardNamedPoolAdminMode is 'inService(2)', the system will change the way default pools are created and allow for the creation of MDA and port level named buffer pools. If the value of tmnxCardNamedPoolAdminMode is 'outOfService(3)', the system will not create per port pools, instead a default network and access pool is created for ingress and egress and is shared by queues on all ports. This object is used in conjunction with tmnxCardNamedPoolOperMode.")
tmnxCardNamedPoolOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 2, 1, 16), TmnxAdminState().clone('outOfService')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardNamedPoolOperMode.setStatus('current')
if mibBuilder.loadTexts: tmnxCardNamedPoolOperMode.setDescription("The value of tmnxCardNamedPoolOperMode specifies whether or not an IOM provisioned with tmnxCardNamedPoolAdminMode to a value of 'inService(2)' will activly use named pools or not. A value of 'outOfService(3) means that the named pool configurations will not be downloaded to the IOM until after a reset of the IOM is performed. A value of 'inService(2)' means that the named pool configurations are programmed by the IOM. On systems using a separate CPM and IOM combination the value of tmnxCardNamedPoolOperMode and tmnxCardNamedPoolAdminMode will always be in sync due to a mandatory reboot of the IOM. On systems using a combined image (CFM) these values will be out-of-sync until the chassis is rebooted.")
tmnxCpmCardLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardLastChange.setDescription('The value of sysUpTime when the tmnxCpmCardTable was last changed.')
tmnxCpmCardTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4), )
if mibBuilder.loadTexts: tmnxCpmCardTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardTable.setDescription('The tmnxCpmCardTable has an entry for each CPM card or module in each chassis in the TMNX system.')
tmnxCpmCardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardSlotNum"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardNum"))
if mibBuilder.loadTexts: tmnxCpmCardEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardEntry.setDescription('Each row entry represents a CPM card or module in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxCpmCardEntry is created for each CPM card or module in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxCpmCardEntry for that chassis must be in the proper state for removal.')
tmnxCpmCardSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 1), TmnxSlotNum())
if mibBuilder.loadTexts: tmnxCpmCardSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSlotNum.setDescription('The unique value which identifies this slot within a chassis in the system. Depending upon the value of tmnxChassisType, this may represent a fabric slot or a regular card slot. If this CPM module resides on a fabric card, tmnxCpmCardSlotNum has the value the corresponding tmnxFabricSlotNum. If this is a CPM module on a fabric card, tmnxCpmCardSlotNum is the fabric slot number in the chassis where this CPM module is located. Else if this is a CPM card, tmnxCpmCardSlotNum is a regular card slot number.')
tmnxCpmCardNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 2), Unsigned32())
if mibBuilder.loadTexts: tmnxCpmCardNum.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardNum.setDescription('The unique value which identifies this CPM module within a specific card slot within a chassis in the system.')
tmnxCpmCardSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 3), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSupportedTypes.setDescription('A bit-mask that specifies what CPM card types can be physically supported in this slot in this chassis.')
tmnxCpmCardAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 4), TmnxCardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxCpmCardAllowedTypes.setDescription('A bit-mask that specifies what CPM card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. If a specific value has not yet been SET by the manager, tmnxCpmCardAllowedTypes will return the same value to a GET request as tmnxCpmCardSupportedTypes. The object was made obsolete in the 3.0 release.')
tmnxCpmCardAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 5), TmnxCardType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardAssignedType.setDescription("A bit-mask that identifies the administratively assigned (pre-provisioned) CPM card type that should occupy this slot in this chassis. If tmnxCpmCardAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned. There must not be more than one bit set at a time in tmnxCpmCardAssignedType.")
tmnxCpmCardEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 6), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardEquippedType.setDescription("A bit-mask that identifies the CPM card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxCpmCardAssignedType is not equal 'unassigned', and the value of tmnxCpmCardEquippedType is not the same as tmnxCpmCardAssignedType, a mis-match alarm will be raised. If the slot has not been pre-provisioned, and the value of tmnxCpmCardEquippedType is not one of the allowed types as specified by tmnxCpmCardAllowedTypes, a mis-match alarm will be raised. There will not be more than one bit set at a time in tmnxCpmCardEquippedType.")
tmnxCpmCardHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 7), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardHwIndex.setDescription('The value of tmnxCpmCardHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this CPM card or module.')
tmnxCpmCardBootOptionVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 8), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionVersion.setDescription('The version number of boot option file (BOF) read by the CPM card in this slot.')
tmnxCpmCardBootOptionLastModified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastModified.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastModified.setDescription('The date and time the boot options file (BOF) for this card was last modified. If tmnxCpmCardBootOptionLastModified is more recent than tmnxHwSwLastBoot, the boot options file has been edited since the software was booted and different software images or configuration will likely be used when this card is next rebooted.')
tmnxCpmCardConfigBootedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 10), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigBootedVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigBootedVersion.setDescription('The version of the configuration file read when this CPM card was last rebooted.')
tmnxCpmCardIndexBootedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 11), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardIndexBootedVersion.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardIndexBootedVersion.setDescription('The version of the index file read when this CPM card was last rebooted.')
tmnxCpmCardConfigLastModified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 12), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigLastModified.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigLastModified.setDescription('The date and time the running configuration was last modified. If tmnxCpmCardConfigLastModified is more recent than tmnxHwSwLastBoot, the current configuration may be different than that in the configuration file read upon system initialization.')
tmnxCpmCardConfigLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 13), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigLastSaved.setDescription('The date and time the current configuration was last saved. If tmnxCpmCardConfigLastSaved is more recent the value of tmnxHwSwLastBoot, the initial configuration is likely to be different the next time the system is rebooted.')
tmnxCpmCardRedundant = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("singleton", 1), ("redundantActive", 2), ("redundantStandby", 3), ("redundantSplit", 4), ("redundantDisabled", 5), ("redundantSynching", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardRedundant.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardRedundant.setDescription("This variable indicates if the CPM card is standalone or part of a pair of redundant cards. If 'redundantDisabled', tmnxHwOperState indicates the specific reason why this redundant CPM card is not available. Note that the 'redudantSplit' option is not implemented.")
tmnxCpmCardClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 15), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardClockSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardClockSource.setDescription('The clock source used by the CPM card in this slot.')
tmnxCpmCardNumCpus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardNumCpus.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardNumCpus.setDescription('The value of tmnxCpmCardNumCpus indicates the number of CPU chips populated on this CPM module.')
tmnxCpmCardCpuType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("mips", 2), ("pentium-pc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardCpuType.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardCpuType.setDescription('The value of tmnxCpmCardCpuType indicates the type of CPU chips populated on this CPM module.')
tmnxCpmCardMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 18), Unsigned32()).setUnits('Mega-bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardMemorySize.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardMemorySize.setDescription('The value of tmnxCpmCardMemorySize indicates the amount of memory, in mega-bytes, populated on this CPM module.')
tmnxCpmCardSwitchToRedundantCard = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 19), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardSwitchToRedundantCard.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardSwitchToRedundantCard.setDescription('Setting this variable to doAction causes the switchover to the redundant CPM card.')
tmnxCpmCardReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 20), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardReboot.setDescription("Setting this variable to 'doAction' causes the CPM card to execute a soft-reboot.")
tmnxCpmCardRereadBootOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 21), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxCpmCardRereadBootOptions.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardRereadBootOptions.setDescription("Setting this variable to 'doAction' causes the Boot Options File (BOF) to be reread and applied.")
tmnxCpmCardConfigFileLastBooted = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBooted.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBooted.setDescription('tmnxCpmCardConfigFileLastBooted indicates the location and name of the configuration file from which the system last rebooted.')
tmnxCpmCardConfigFileLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastSaved.setDescription('tmnxCpmCardConfigFileLastSaved indicates the location and name of the file to which the configuration was last saved.')
tmnxCpmCardConfigFileLastBootedHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBootedHeader.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigFileLastBootedHeader.setDescription('tmnxCpmCardConfigFileLastBootedHeader contains the header of the configuration file from which the system last rebooted.')
tmnxCpmCardIndexFileLastBootedHeader = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardIndexFileLastBootedHeader.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardIndexFileLastBootedHeader.setDescription('tmnxCpmCardIndexFileLastBootedHeader contains the header of the index file from which the system last rebooted.')
tmnxCpmCardBootOptionSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 26), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionSource.setDescription("tmnxCpmCardBootOptionSource indicates the compact flash slot where the Boot Options File (BOF) file was found when the system last rebooted. For example, if the BOF file was found on compact flash slot 1, the value of this variable will be 'cf1:'")
tmnxCpmCardConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("primary", 1), ("secondary", 2), ("tertiary", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardConfigSource.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardConfigSource.setDescription('The value of tmnxCpmCardConfigSource indicates the location in the Boot Options File(BOF) where the configuration file was found when the system last rebooted.')
tmnxCpmCardBootOptionLastSaved = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 28), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastSaved.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardBootOptionLastSaved.setDescription('The date and time the boot options file (BOF) was last saved. If tmnxCpmCardBootOptionLastSaved is more recent than the value of tmnxHwSwLastBoot, the boot options file has been edited since the software was booted and different software images or configuration will likely be used when this card is next rebooted.')
tmnxCpmCardMasterSlaveRefState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primaryRef", 1), ("secondaryRef", 2), ("notInitialized", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmCardMasterSlaveRefState.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmCardMasterSlaveRefState.setDescription('The current Master/Slave clocking reference designation. primaryRef Indicates this card is designated as the primary clocking reference in a redundant system. secondaryRef Indicates this card is designated as the secondary clocking reference in a redundant system. notInitialized Indicates the clock is not initialized. ')
tmnxFabricLastChange = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricLastChange.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricLastChange.setDescription('The value of sysUpTime when the tmnxFabricTable was last changed.')
tmnxFabricTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6), )
if mibBuilder.loadTexts: tmnxFabricTable.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricTable.setDescription('The tmnxFabricTable has an entry for each fabric card slot in each chassis in the TMNX system.')
tmnxFabricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxFabricSlotNum"))
if mibBuilder.loadTexts: tmnxFabricEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricEntry.setDescription('Each row entry represents a fabric card slot in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxFabricEntry is created for each fabric card slot in that chassis. Before a tmnxChassisEntry can be deleted, each tmnxFabricEntry for that chassis must be in the proper state for removal.')
tmnxFabricSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)))
if mibBuilder.loadTexts: tmnxFabricSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricSlotNum.setDescription('The unique value which identifies this fabric slot within a chassis in the system. The CPM cards and IOM cards cannot be physically inserted into the switch fabric card slots. In some models, the CPM is not a separate card, but rather a module on a Fabric card.')
tmnxFabricAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 2), TmnxCardType().clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxFabricAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricAssignedType.setDescription('The administratively assigned switch fabric card type that should occupy this fabric slot in this chassis.')
tmnxFabricEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 3), TmnxCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricEquippedType.setDescription('The switch fabric card type that is physically inserted into this slot in this chassis.')
tmnxFabricHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 6, 1, 4), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxFabricHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxFabricHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable to locate the row entry that represents the hardware component information for this fabric card.')
tmnxCpmFlashTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7), )
if mibBuilder.loadTexts: tmnxCpmFlashTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashTable.setDescription('This table contains information about Flash devices on a CPM card.')
tmnxCpmFlashEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashId"))
if mibBuilder.loadTexts: tmnxCpmFlashEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashEntry.setDescription("Contains information regarding a CPM card's flash unit.")
tmnxCpmFlashId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: tmnxCpmFlashId.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashId.setDescription('The unique identifier index for a flash device on a CPM card.')
tmnxCpmFlashOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 2), TmnxDeviceState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashOperStatus.setDescription('Current status of this flash unit on this CPM card.')
tmnxCpmFlashSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashSerialNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashSerialNumber.setDescription('The serial number for this flash unit on this CPM card.')
tmnxCpmFlashFirmwareRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 4), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashFirmwareRevision.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashFirmwareRevision.setDescription('The firmware revision number for this flash unit on this CPM card.')
tmnxCpmFlashModelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 5), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashModelNumber.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashModelNumber.setDescription('The model number for this flash unit on this CPM card.')
tmnxCpmFlashCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 6), Unsigned32()).setUnits('sectors').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashCapacity.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashCapacity.setDescription('The value of tmnxCpmFlashCapacity indicates the maximum size of this flash unit in 512-byte sectors.')
tmnxCpmFlashUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 7), Unsigned32()).setUnits('sectors').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashUsed.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashUsed.setDescription("The value of tmnxCpmFlashUsed indicates the amount used, in 512-byte sectors, of this flash unit's total capacity.")
tmnxCpmFlashHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 7, 1, 8), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCpmFlashHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCpmFlashHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this flash unit.')
tmnxMDATable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8), )
if mibBuilder.loadTexts: tmnxMDATable.setStatus('current')
if mibBuilder.loadTexts: tmnxMDATable.setDescription('The tmnxMDATable has an entry for each MDA slot in each IOM card in this chassis in the TMNX system.')
tmnxMDAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDASlotNum"))
if mibBuilder.loadTexts: tmnxMDAEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEntry.setDescription('Each row entry represents a MDA slot in an IOM card in a chassis in the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxCardEntry has tmnxCardAssignedType or tmnxCardEquippedType equal to an IOM card type that supports MDA slots, a tmnxMDAEntry is created by the agent for each MDA slot on that IOM card. Before a tmnxCardEntry can be deleted, each tmnxMDAEntry for that card must be in the proper state for removal.')
tmnxMDASlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16)))
if mibBuilder.loadTexts: tmnxMDASlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASlotNum.setDescription('The unique value which identifies this MDA slot within a specific IOM card in the system. Rows with a tmnxMDASlotNum value of zero (0) represent the special case of an IOM card without MDA slots but that instead has its ports directly on the IOM card itself. In that case, there should be only that one row entry in the tmnxMDATable for that IOM card.')
tmnxMDASupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 2), TmnxMDASuppType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDASupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASupportedTypes.setDescription('A bit-mask that specifies what MDA card types can be physically supported in this slot in this chassis.')
tmnxMDAAllowedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 3), TmnxMdaType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAAllowedTypes.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAAllowedTypes.setDescription('An integer that specified what MDA card types the administrator has designated be allowed to be inserted into this slot. If the slot has not-been pre-provisioned and a MDA card that does not match one of the allowed types is inserted into this slot, a mis-match alarm will be raised. The object was made obsolete in the 3.0 release.')
tmnxMDAAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 4), TmnxMdaType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAAssignedType.setDescription("An integer that indicates the administratively assigned (pre-provisioned) MDA card type that should occupy this slot in this chassis. If tmnxMDAAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned.")
tmnxMDAEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 5), TmnxMdaType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEquippedType.setDescription("An integer that indicates the MDA card type that is physically inserted into this slot in this chassis. If the slot has been pre-provisioned, tmnxMDAAssignedType is not equal 'unassigned', and the value of tmnxMDAEquippedType is not the same as tmnxMDAAssignedType, a mis-match alarm will be raised. A value of 0 indicates the equipped MDA is not supported by this software release.")
tmnxMDAHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 6), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHwIndex.setDescription('The value of tmnxHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this MDA card.')
tmnxMDAMaxPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxPorts.setDescription('The maximum number of ports that can be equipped on this MDA card.')
tmnxMDAEquippedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAEquippedPorts.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEquippedPorts.setDescription('The value of tmnxMDAEquippedPorts indicates the number of ports equipped on this MDA card.')
tmnxMDATxTimingSelected = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cpm-card-A", 1), ("cpm-card-B", 2), ("local", 3), ("holdover", 4), ("not-applicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDATxTimingSelected.setStatus('current')
if mibBuilder.loadTexts: tmnxMDATxTimingSelected.setDescription("The transmit timing method which is presently selected and being used by this MDA. tmnxMDATxTimingSelected will be set to 'not-applicable' if this MDA does not use the transmit timing subsystem.")
tmnxMDASyncIfTimingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("qualified", 1), ("not-qualified", 2), ("not-applicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDASyncIfTimingStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMDASyncIfTimingStatus.setDescription("Indicates the status of the synchronous equipment timing subsystem. If the tmnxSyncIfTimingRef1Qualified and tmnxSyncIfTimingRef2Qualified are both set to 'not-qualified, then tmnxMDASyncIfTimingStatus is set to 'not-qualified'. If any of the timing references is in use, then tmnxMDASyncIfTimingStatus is set to 'qualified'. tmnxMDASyncIfTimingStatus will be set to 'not-applicable' if this MDA does not use the transmit timing subsystem.")
tmnxMDANetworkIngQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 12), TNamedItem().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDANetworkIngQueues.setStatus('current')
if mibBuilder.loadTexts: tmnxMDANetworkIngQueues.setDescription('Specifies the network queue policy being used for this object to define the queueing structure for this object.')
tmnxMDACapabilities = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 13), Bits().clone(namedValues=NamedValues(("isEthernet", 0), ("isSonet", 1), ("isTDM", 2), ("supportsPPP", 3), ("supportsFR", 4), ("supportsATM", 5), ("supportscHDLC", 6), ("isCMA", 7), ("supportsCEM", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDACapabilities.setStatus('current')
if mibBuilder.loadTexts: tmnxMDACapabilities.setDescription('tmnxMDACapabilities indicates the capabilities of this MDA. It identifies the type of MDA and the protocols that can run on it.')
tmnxMDAMinChannelization = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 14), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMinChannelization.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMinChannelization.setDescription('tmnxMDAMinChannelization indicates the minimum size of the channel that can exist on this MDA.')
tmnxMDAMaxChannelization = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 15), TmnxMDAChanType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxChannelization.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxChannelization.setDescription('tmnxMDAMaxChannelization indicates the maximum size of the channel that can exist on this MDA.')
tmnxMDAMaxChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMaxChannels.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMaxChannels.setDescription('tmnxMDAMaxChannels is applicable for SONET and TDM MDAs only. It indicates the total number of leaf SONET paths, TDM channels and bundles on the MDA that may be configured to pass traffic.')
tmnxMDAChannelsInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAChannelsInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAChannelsInUse.setDescription('tmnxMDAChannelsInUse is applicable for SONET and TDM MDAs only. It indicates the total number of leaf SONET paths, TDM channels and bundles on the MDA which are in use. A leaf SONET path or TDM channel which is currently capable of passing traffic is considered to be in use. Also, a SONET path or TDM channel which is channelized and has no subchannels capable of passing traffic is considered to be in use. A SONET path or TDM channel which is channelized and has one or more subchannels capable of passing traffic is not considered to be in use, although the subchannels themselves are considered to be in use. A bundle is considered to be a channel in use as are each of its members since they are TDM channels capable of passing traffic.')
tmnxMDACcagId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 18), TmnxCcagId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDACcagId.setStatus('current')
if mibBuilder.loadTexts: tmnxMDACcagId.setDescription("When tmnxMDAAssignedType has a value of 'cca' , the value of tmnxMDACcagId specifies the Cross Connect Aggregation Group (CCAG) entry this MDA is provisioned on. If this entry does not represent a 'cca' MDA or is not associated with a CCAG, tmnxMDACcagId has a value of zero. ")
tmnxMDAReboot = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 19), TmnxActionType().clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAReboot.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAReboot.setDescription("Setting this variable to 'doAction' causes the MDA to execute a soft-reboot.")
tmnxMDAHiBwMcastSource = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastSource.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastSource.setDescription("The value of tmnxMDAHiBwMcastSource specifies if this MDA should attempt to allocate separate fabric planes to allocate high bandwidth multicast traffic taps. tmnxMDAHiBwMcastGroup must be set in the same SNMP request PDU with tmnxMDAHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxMDAHiBwMcastAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 21), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastAlarm.setDescription('The value of tmnxMDAHiBwMcastAlarm specifies if a tmnxChassisHiBwMcastAlarm alarm is raised if there are more than one high bandwidth multicast traffic taps sharing a plane.')
tmnxMDAHiBwMcastTapCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastTapCount.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastTapCount.setDescription('The value of tmnxMDAHiBwMcastTapCount indicates the number of high bandwidth multicast traffic taps on this MDA.')
tmnxMDAHiBwMcastGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAHiBwMcastGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAHiBwMcastGroup.setDescription("The value of tmnxMDAHiBwMcastGroup specifies the group of high bandwidth multicast traffic taps to which this tap belongs. A value of '0' specifies that this tap is not a member of any High Bandwidth Multicast group. On an IOM of type 'iom-10g', the value of tmnxMDAHiBwMcastGroup should be the same as the value of tmnxMDAHiBwMcastGroup set on the other MDA residing on the IOM if the tmnxMDAHiBwMcastSource is set to 'true'. Attempt to set to different values will result in an 'inconsistentValue' error. tmnxMDAHiBwMcastGroup must be set in the same SNMP request PDU with tmnxMDAHiBwMcastSource or an 'inconsistentValue' error will be returned.")
tmnxMDAClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("adaptive", 1), ("differential", 2))).clone('notApplicable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAClockMode.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAClockMode.setDescription("The value of tmnxMDAClockMode specifies the clock mode of the MDA. notApplicable - The MDA does not support any clock modes or domains. adaptive - The MDA is in 'adaptive' clock mode. This allows adaptive clock domains to be created. differential - The MDA is in 'differential clock mode. This allows differential clock domains to be created. The value of tmnxMDAClockMode can be changed when there are no ports created on the MDA. If there are ports created, a shutdown of the MDA is required in order to change the value.")
tmnxMDADiffTimestampFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(19440, 19440), ValueRangeConstraint(77760, 77760), ValueRangeConstraint(103680, 103680), ))).setUnits('kilohertz').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDADiffTimestampFreq.setStatus('current')
if mibBuilder.loadTexts: tmnxMDADiffTimestampFreq.setDescription("The value of tmnxMDADiffTimestampFreq specifies the differential timestamp frequency of the differential clock on the MDA. The value must be a multiple of 8 KHz. This value can only be changed if the value of tmnxMDAClockMode is 'differential (2)' and there are no ports created on the MDA. If there are ports created, a shutdown of the MDA is required in order to change the value. If the value of tmnxMDAClockMode is 'differential (2) then the default is 103,680 KHz. If the value of tmnxMDAClockMode is not 'differential (2)' then this value is 0 KHz and cannot be changed.")
tmnxMDAMcPathMgmtBwPlcyName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 27), TNamedItem().clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBwPlcyName.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBwPlcyName.setDescription('The value of tmnxMDAMcPathMgmtBwPlcyName specifies the multicast policy name configured on the MDA.')
tmnxMDAMcPathMgmtPriPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriPathLimit.setDescription('The value of tmnxMDAMcPathMgmtPriPathLimit specifies the primary path limit for the MDA.')
tmnxMDAMcPathMgmtSecPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 29), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecPathLimit.setDescription('The value of tmnxMDAMcPathMgmtSecPathLimit specifies the secondary path limit for the MDA.')
tmnxMDAMcPathMgmtAncPathLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 5000), ))).setUnits('mega-bits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncPathLimit.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncPathLimit.setDescription('The value of tmnxMDAMcPathMgmtAncPathLimit specifies the ancillary path limit for the MDA.')
tmnxMDAMcPathMgmtAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 31), TmnxAdminState().clone('outOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAdminState.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAdminState.setDescription('The value of tmnxMDAMcPathMgmtAdminState specifies administrative state of this multicast path on the MDA.')
tmnxMDAIngNamedPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 32), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAIngNamedPoolPolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAIngNamedPoolPolicy.setDescription('The value of tmnxMDAIngNamedPoolPolicy specifies a named pool policy associated with an MDA ingress context. The policy governs the way named pools are created at the MDA level.')
tmnxMDAEgrNamedPoolPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 33), TNamedItemOrEmpty().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMDAEgrNamedPoolPolicy.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAEgrNamedPoolPolicy.setDescription('The value of tmnxMDAEgrNamedPoolPolicy specifies a named pool policy associated with an MDA egress context. The policy governs the way named pools are created at the MDA level.')
tmnxMDAMcPathMgmtPriInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtPriInUseBw.setDescription('The value of tmnxMDAMcPathMgmtPriInUseBw indicates the in use ingress multicast bandwidth for the primary forwarding path.')
tmnxMDAMcPathMgmtSecInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtSecInUseBw.setDescription('The value of tmnxMDAMcPathMgmtSecInUseBw indicates the in use ingress multicast bandwidth for the secondary forwarding path.')
tmnxMDAMcPathMgmtAncInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtAncInUseBw.setDescription('The value of tmnxMDAMcPathMgmtAncInUseBw indicates the in use ingress multicast bandwidth for the ancillary forwarding path.')
tmnxMDAMcPathMgmtBlkHoleInUseBw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 8, 1, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBlkHoleInUseBw.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtBlkHoleInUseBw.setDescription('The value of tmnxMDAMcPathMgmtBlkHoleInUseBw indicates the bandwidth of the ingress multicast traffic that is being black holed on the MDA.')
tmnxCardTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9), )
if mibBuilder.loadTexts: tmnxCardTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeTable.setDescription('The card type table has an entry for each Alcatel 7x50 SR series card model.')
tmnxCardTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardTypeIndex"))
if mibBuilder.loadTexts: tmnxCardTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series Card model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxCardTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 1), TmnxCardType())
if mibBuilder.loadTexts: tmnxCardTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7x50 SR series card model.')
tmnxCardTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeName.setDescription('The administrative name that identifies this type of Alcatel 7x50 SR series card model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxCardTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeDescription.setDescription('A detailed description of this Alcatel 7x50 SR series card model.')
tmnxCardTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 9, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCardTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCardTypeStatus.setDescription("When tmnxCardTypeStatus has a value of 'true' it indicates that this card model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxMdaTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10), )
if mibBuilder.loadTexts: tmnxMdaTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeTable.setDescription('The MDA type table has an entry for each Alcatel 7x50 SR series MDA card model.')
tmnxMdaTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeIndex"))
if mibBuilder.loadTexts: tmnxMdaTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeEntry.setDescription('Each row entry represents an Alcatel 7x50 SR series MDA card model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxMdaTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 1), TmnxMdaType())
if mibBuilder.loadTexts: tmnxMdaTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7x50 SR series MDA card model.')
tmnxMdaTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeName.setDescription('The administrative name that identifies this type of Alcatel 7x50 SR series MDA card model. This name string may be used in CLI commands to specify a particular MDA card model type.')
tmnxMdaTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeDescription.setDescription('A detailed description of this Alcatel 7x50 SR series MDA card model.')
tmnxMdaTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 10, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMdaTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMdaTypeStatus.setDescription("When tmnxMdaTypeStatus has a value of 'true' it indicates that this MDA card model is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxSyncIfTimingTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11), )
if mibBuilder.loadTexts: tmnxSyncIfTimingTable.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingTable.setDescription('The synchronous interface timing table has an entry for each cpm card in the system.')
tmnxSyncIfTimingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1), )
tmnxCpmCardEntry.registerAugmentions(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingEntry"))
tmnxSyncIfTimingEntry.setIndexNames(*tmnxCpmCardEntry.getIndexNames())
if mibBuilder.loadTexts: tmnxSyncIfTimingEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingEntry.setDescription('A row represents the configuration of synchronous equipment timing subsystem (SETS) of the system. Entries cannot be created and deleted via SNMP SET operations. When a tmnxCpmCardEntry is created, a tmnxSyncIfTimingEntry is created. Note that the first Alcatel 7x50 SR series product release does not support configuration of synchronous equipment on the secondary CPM. All SNMP operations with tmnxCpmCardSlotNum of the secondary CPM will be denied. If the value of the reference source port is a valid Port ID then the reference is a port. If the value of the source hardware is a valid non-zero HWIndex then the source is the hardware specified by the HWIndex.')
tmnxSyncIfTimingRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRevert.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRevert.setDescription("The value of tmnxSyncIfTimingRevert indicates whether the reference source will revert to a higher priority source that has been re-validated or newly validated. The synchronous interface timing subsystem is by default non-revertive ('false').")
tmnxSyncIfTimingRefOrder1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 2), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder1.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder1.setDescription('The value of tmnxSyncIfTimingRefOrder1 indicates the most preferred timing reference source. The synchronous equipment timing subsystem can lock to three different timing reference inputs, reference1, reference2 and bits. The subsystem chooses a reference based on priority.')
tmnxSyncIfTimingRefOrder2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 3), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder2.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder2.setDescription('The value of tmnxSyncIfTimingRefOrder2 indicates the second most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingRef1SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 4), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcPort.setDescription("The value of tmnxSyncIfTimingRef1SrcPort indicates the source port of the first timing reference. A value of '1e000000'H indicates that there is no source port for this reference.")
tmnxSyncIfTimingRef1AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 5), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1AdminStatus.setDescription('The value of tmnxSyncIfTimingRef1AdminStatus indicates the administrative status of the first timing reference.')
tmnxSyncIfTimingRef1InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1InUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1InUse.setDescription('The value of tmnxSyncIfTimingRef1InUse indicates whether the first timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingRef1Qualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 7), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Qualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Qualified.setDescription("The value of tmnxSyncIfTimingRef1Qualified indicates whether the first timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingRef1Qualified is set to 'not-qualified', then the object tmnxSyncIfTimingRef1Alarm gives the reason for disqualification.")
tmnxSyncIfTimingRef1Alarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 8), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1Alarm.setDescription("The value of tmnxSyncIfTimingRef1Alarm indicates the alarms on the first reference. If any of the bits is set to '1', then the first reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingRef1Qualified is set to 'not-qualified'. los - loss of signal oof - out of frequency range oopir - out of pull in range ")
tmnxSyncIfTimingRef2SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 9), TmnxPortID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcPort.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcPort.setDescription("The value of tmnxSyncIfTimingRef2SrcPort indicates the source port of the second timing reference. A value of '1e000000'H indicates that there is no source port for this reference.")
tmnxSyncIfTimingRef2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 10), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2AdminStatus.setDescription('The value of tmnxSyncIfTimingRef2AdminStatus indicates the administrative status of the second timing reference.')
tmnxSyncIfTimingRef2InUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2InUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2InUse.setDescription('The value of tmnxSyncIfTimingRef2InUse indicates whether the second timing reference is presently being used by the synchronous timing subsystem.')
tmnxSyncIfTimingRef2Qualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 12), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Qualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Qualified.setDescription("The value of tmnxSyncIfTimingRef2Qualified indicates whether the second timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingRef2Qualified is 'not-qualified' then the object tmnxSyncIfTimingRef2Alarm gives the reason for disqualification.")
tmnxSyncIfTimingRef2Alarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 13), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2Alarm.setDescription("The value of tmnxSyncIfTimingRef2Alarm indicates the alarms on the second reference. If any of the bits is set to '1', then the second reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingRef2Qualified is set to 'not-qualified'. los - loss of signal oof - out of frequency range oopir - out of pull in range ")
tmnxSyncIfTimingFreqOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 14), Integer32()).setUnits('parts-per-million').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingFreqOffset.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingFreqOffset.setDescription('The value of tmnxSyncIfTimingFreqOffset indicates the frequency offset of the current selected timing reference in parts per million (ppm).')
tmnxSyncIfTimingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("not-present", 1), ("master-freerun", 2), ("master-holdover", 3), ("master-locked", 4), ("slave", 5), ("acquiring", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingStatus.setDescription('The value of tmnxSyncIfTimingStatus indicates the present status of the synchronous timing equipment subsystem (SETS).')
tmnxSyncIfTimingRefOrder3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 16), TmnxSETSRefSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder3.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRefOrder3.setDescription('The value of tmnxSyncIfTimingRefOrder3 is the third most preferred timing reference for the synchronous equipment timing subsystem.')
tmnxSyncIfTimingBITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 17), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSIfType.setDescription('The value of tmnxSyncIfTimingBITSIfType indicates the interface type of the BITS (Building Integrated Timing Supply) timing reference. It also indicates the framing type of the interface.')
tmnxSyncIfTimingBITSAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 18), TmnxPortAdminStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAdminStatus.setDescription('The value of tmnxSyncIfTimingBITSAdminStatus indicates administrative status of the BITS (Building Integrated Timing Supply) timing reference.')
tmnxSyncIfTimingBITSInUse = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSInUse.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSInUse.setDescription('The value of tmnxSyncIfTimingBITSInUse indicates whether the BITS timing reference is presently being used by the synchronous timing subsystem. If it is in use, tmnxSyncIfTimingFreqOffset indicates the frequency offset for this reference.')
tmnxSyncIfTimingBITSQualified = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 20), TmnxSETSRefQualified()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSQualified.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSQualified.setDescription("The value of tmnxSyncIfTimingBITSQualified indicates whether the BITS timing reference is qualified for use by the synchronous timing subsystem. If tmnxSyncIfTimingBITSQualified is 'not-qualified', then the object tmnxSyncIfTimingBITSAlarm gives the reason for disqualification.")
tmnxSyncIfTimingBITSAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 21), TmnxSETSRefAlarm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingBITSAlarm.setDescription("The value of tmnxSyncIfTimingBITSAlarm indicates the alarms on the BITS reference. If any of the bits is set to '1', then the BITS reference is disqualified by the timing subsystem and the value of tmnxSyncIfTimingBITSQualified is set to 'not-qualified'.")
tmnxSyncIfTimingRef1SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 22), TmnxHwIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcHw.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1SrcHw.setDescription('The value of tmnxSyncIfTimingRef1SrcHw indicates the source HW index of the first timing reference if source is not a port.')
tmnxSyncIfTimingRef1BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 23), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef1BITSIfType.setDescription('The value of tmnxSyncIfTimingRef1BITSIfType indicates the interface type of the first timing reference if the source is BITS. It also indicates the framing type of the interface.')
tmnxSyncIfTimingRef2SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 24), TmnxHwIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcHw.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2SrcHw.setDescription('The value of tmnxSyncIfTimingRef2SrcHw indicates the source HW index of the second timing reference if source is not a port.')
tmnxSyncIfTimingRef2BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 11, 1, 25), TmnxBITSIfType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingRef2BITSIfType.setDescription('The value of tmnxSyncIfTimingRef2BITSIfType indicates the interface type of the second timing reference if the source is BITS. It also indicates the framing type of the interface.')
tmnxChassisAdminCtrlObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1))
tmnxChassisAdminValueObjs = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2))
tSyncIfTimingAdmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1), )
if mibBuilder.loadTexts: tSyncIfTimingAdmTable.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmTable.setDescription('Values for the synchronous interface timing for the chassis.')
tSyncIfTimingAdmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardSlotNum"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardNum"))
if mibBuilder.loadTexts: tSyncIfTimingAdmEntry.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmEntry.setDescription('Information about the synchronous interface timing. Entries are created by user. Entries are deleted by user. Note that the first Alcatel 7x50 SR series product release does not support configuration of synchronous timing equipment on the secondary CPM. All SNMP operations with tmnxCpmCardSlotNum of the secondary CPM will be denied. The 7x50 systems supports 3 timing references (reference1, reference2 and bits). The 7710 system only supports 2 timing references (reference1 and reference2). On 7710 system, references can be a source port or a BITS input on a CES CMA. If the value of the reference source port is a valid Port ID then the reference is a source port. If the value of the source hardware is a valid HWIndex of a CES CMA then the source is a BITS on the CES CMA.')
tSyncIfTimingAdmRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRevert.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRevert.setDescription("The value of tSyncIfTimingAdmRevert specifies whether the reference source will revert to a higher priority source that has been re-validated or newly validated. The synchronous interface timing subsystem is by default non-revertive ('false').")
tSyncIfTimingAdmRefOrder1 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 2), TmnxSETSRefSource().clone('bits')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder1.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder1.setDescription('The value of tSyncIfTimingAdmRefOrder1 specifies the most preferred timing reference source. The synchronous equipment timing subsystem can lock to three different timing reference inputs, reference1, reference2 and bits. The subsystem chooses a reference based on priority. tSyncIfTimingAdmRefOrder1 is used to configure the most preferred timing reference.')
tSyncIfTimingAdmRefOrder2 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 3), TmnxSETSRefSource().clone('reference1')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder2.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder2.setDescription('The value of tSyncIfTimingAdmRefOrder2 specifies the second most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmRef1SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 4), TmnxPortID().clone(503316480)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcPort.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcPort.setDescription('The value of tSyncIfTimingAdmRef1SrcPort specifies the source port of the first timing reference. This can only be set to a valid TmnxPortID if the value of tSyncIfTimingAdmRef1SrcHw is 0.')
tSyncIfTimingAdmRef1AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 5), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1AdminStatus.setDescription('The value of tSyncIfTimingAdmRef1AdminStatus specifies the desired administrative status of the first timing reference.')
tSyncIfTimingAdmRef2SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 6), TmnxPortID().clone(503316480)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcPort.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcPort.setDescription('The value of tSyncIfTimingAdmRef2SrcPort specifies the source port of the second timing reference. This can only be set to a valid TmnxPortID if the value of tSyncIfTimingAdmRef2SrcHw is 0.')
tSyncIfTimingAdmRef2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 7), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2AdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2AdminStatus.setDescription('The value of tSyncIfTimingAdmRef2AdminStatus specifies the desired administrative status of the second timing reference.')
tSyncIfTimingAdmChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 8), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmChanged.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmChanged.setDescription('The value of tSyncIfTimingAdmChanged is a bitmask that indicates which objects have been set, but not committed. bit values used here are: 0x0001: tSyncIfTimingAdmRevert 0x0002: tSyncIfTimingAdmRefOrder1 0x0004: tSyncIfTimingAdmRefOrder2 0x0008: tSyncIfTimingAdmRef1SrcPort 0x0010: tSyncIfTimingAdmRef1AdminStatus 0x0020: tSyncIfTimingAdmRef2SrcPort 0x0040: tSyncIfTimingAdmRef2AdminStatus 0x0080: tSyncIfTimingAdmRefOrder3 0x0100: tSyncIfTimingAdmBITSIfType 0x0200: tSyncIfTimingAdmBITSAdminStatus 0x0400: tSyncIfTimingAdmRef1SrcHw 0x0800: tSyncIfTimingAdmRef1BITSIfType 0x1000: tSyncIfTimingAdmRef2SrcHw 0x2000: tSyncIfTimingAdmRef2BITSIfType The agent sets these bits when an object in the row is set. This object is cleared to zero by setting tmnxChassisAdminControlApply to initialize(2) or commit(3). ')
tSyncIfTimingAdmRefOrder3 = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 9), TmnxSETSRefSource().clone('reference2')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder3.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRefOrder3.setDescription('The value of tSyncIfTimingAdmRefOrder3 indicates the third most preferred timing reference for the synchronous equipment timing subsystem.')
tSyncIfTimingAdmBITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 10), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSIfType.setDescription('The value of tSyncIfTimingAdmBITSIfType specifies the interface type of the BITS (Building Integrated Timing Supply) timing reference.')
tSyncIfTimingAdmBITSAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 11), TmnxPortAdminStatus().clone('outOfService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmBITSAdminStatus.setDescription('The value of tSyncIfTimingAdmBITSAdminStatus specifies the desired administrative status of the BITS (Building Integrated Timing Supply) timing reference.')
tSyncIfTimingAdmRef1SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 12), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcHw.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1SrcHw.setDescription("The value of tSyncIfTimingAdmRef1SrcHw specifies the source HW Index of the first timing reference if the source is not a port. This can only be set to a valid HW Index if the value of tSyncIfTimingAdmRef1SrcPort is '1e000000'H.")
tSyncIfTimingAdmRef1BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 13), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef1BITSIfType.setDescription('The value of tSyncIfTimingAdmRef1BITSIfType specifies the interface type of the first timing reference if the source is BITS.')
tSyncIfTimingAdmRef2SrcHw = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 14), TmnxHwIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcHw.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2SrcHw.setDescription("The value of tSyncIfTimingAdmRef2SrcHw specifies the source HW Index of the second timing reference if the source is not a port. This can only be set to a valid HW Index if the value of tSyncIfTimingAdmRef2SrcPort is '1e000000'H.")
tSyncIfTimingAdmRef2BITSIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 2, 1, 1, 15), TmnxBITSIfType().clone('t1-esf')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2BITSIfType.setStatus('current')
if mibBuilder.loadTexts: tSyncIfTimingAdmRef2BITSIfType.setDescription('The value of tSyncIfTimingAdmRef2BITSIfType specifies the interface type of the second timing reference if the source is BITS.')
tmnxChassisAdminOwner = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 1), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminOwner.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminOwner.setDescription('Who has last initialized the chassis administrative table, who is making all the changes, and who is expected to either commit or re-initialize (ABORT-TRANSACTION). tmnxChassisAdminOwner is advisory only. Before beginning a transaction, read tmnxChassisAdminOwner. if it is empty then proceed with the configuration. Set tmnxChassisAdminOwner after setting tmnxChassisAdminControlApply so that other users will be advised to not make changes to the Admin tables. Agent sets tmnxChassisAdminOwner to empty string after tmnxChassisAdminControlApply is set - either by user initializing or committing, or by agent timing out the uncommitted transactions (tmnxChassisAdminLastSetTimer). ')
tmnxChassisAdminControlApply = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("initialize", 2), ("commit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminControlApply.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminControlApply.setDescription('This object controls the use of tmnxChassisAdminTable. when set to initialize(2), the objects in tmnxChassisAdminTable are set to the current Operational values, from the tmnxChassisTable. Any uncommitted changes are lost, so setting this value corresponds to both BEGIN-TRANSACTION and ABORT-TRANSACTION. when set to commit(3) (END-TRANSACTION), all of the objects from tmnxChassisAdminTable are copied to the corresponding tmnxChassisTable table objects. ')
tmnxChassisAdminLastSetTimer = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 3), TimeInterval()).setUnits('centiseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimer.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimer.setDescription('The time remaining until the agent re-initializes the administrative tables. If tmnxChassisAdminControlApply is not set to commit(3) within tmnxChassisAdminLastSetTimeout centiseconds, the agent will set it to initialize(2) and all uncommitted changes will be lost. This way, uncommitted changes from failed (uncompleted) change sets will eventually be removed, and another transaction can safely begin. this object is reset to tmnxChassisAdminLastSetTimeout after SNMP SET operation to any of the tmnxChassisAdminValue tables. ')
tmnxChassisAdminLastSetTimeout = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 8, 1, 4), TimeInterval().clone(180000)).setUnits('centiseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimeout.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisAdminLastSetTimeout.setDescription('Timeout for tmnxChassisAdminLastSetTimer. The value zero is not allowed. ')
tmnxCcagTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12), )
if mibBuilder.loadTexts: tmnxCcagTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagTable.setDescription('The tmnxCcagTable has an entry for each Cross Connect Aggregation Group,CCAG, configured on this system.')
tmnxCcagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagId"))
if mibBuilder.loadTexts: tmnxCcagEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagEntry.setDescription('Each row entry represents a particular CCAG. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 1), TmnxCcagId())
if mibBuilder.loadTexts: tmnxCcagId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagId.setDescription('The value of tmnxCcagId is used to index into the tmnxCcagTable. It uniquely identifies a CCAG entry as configured on this system.')
tmnxCcagRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagRowStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagRowStatus.setDescription('The value of tmnxCcagRowStatus specifies the row status. It allows entries to be created and deleted in the tmnxCcagTable. tmnxCcagRowStatus does not support createAndWait. The status can only be active or notInService.')
tmnxCcagLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagLastChanged.setDescription('The value of tmnxCcagLastChanged indicates the time this row was last changed.')
tmnxCcagDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 4), DisplayString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagDescription.setDescription('The value of tmnxCcagDescription specifies a user provided description string of this CCAG entry.')
tmnxCcagAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 5), TmnxAdminState().clone('inService')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagAdminStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagAdminStatus.setDescription('The value of tmnxCcagAdminStatus specifies the desired state of this CCAG.')
tmnxCcagOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 6), TmnxOperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagOperStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagOperStatus.setDescription('The value of tmnxCcagOperStatus indicates the operational state of this CCAG.')
tmnxCcagCcaRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 7), TmnxCcagRate().clone(-1)).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagCcaRate.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagCcaRate.setDescription('The value of tmnxCcagCcaRate specifies the maximum forwarding rate for each CCA member within the CCAG.')
tmnxCcagAccessAdaptQos = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("distribute", 2))).clone('distribute')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagAccessAdaptQos.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagAccessAdaptQos.setDescription('The value of tmnxCcagAccessAdaptQos specifies how the CCAG SAP queue and virtual scheduler buffering and rate parameters are adapted over multiple active CCAs. link (1) - The CCAG will create the SAP queues and virtual schedulers on each CCA with the actual parameters specified in the tmnxCcagPathCcTable. distribute (2) - Each CCA will receive a portion of the parameters specified in the tmnxCcagPathCcTable.')
tmnxCcagPathTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13), )
if mibBuilder.loadTexts: tmnxCcagPathTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathTable.setDescription('The tmnxCcagPathTable has an entry for each Cross Connect Aggregation Group, CCAG, path configured on this system.')
tmnxCcagPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagId"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathId"))
if mibBuilder.loadTexts: tmnxCcagPathEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathEntry.setDescription('Each row entry represents a particular CCAG Path. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alpha", 1), ("beta", 2))))
if mibBuilder.loadTexts: tmnxCcagPathId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathId.setDescription('The value of tmnxCcagPathId is used as the secondary index into the tmnxCcagPathTable. Along with tmnxCcagId, it uniquely identifies a specific path, alpha or beta, on a CCAG.')
tmnxCcagPathLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathLastChanged.setDescription('The value of tmnxCcagPathLastChanged indicates the time this row was last changed.')
tmnxCcagPathRate = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 3), TmnxCcagRate().clone(-1)).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathRate.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathRate.setDescription('The value of tmnxCcagPathRate specifies the bandwidth rate limitation for this path on each member cross connect adaptor, CCA, in the CCAG.')
tmnxCcagPathRateOption = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 4), TmnxCcagRateOption().clone('aggregate')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathRateOption.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathRateOption.setDescription('The value of tmnxCcagPathRateOption specifies whether the rate in tmnxCcagPathRate is defined as an aggregate path rate for all CCAs in the CCAG or as a per CCA path rate.')
tmnxCcagPathWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 13, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(50)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathWeight.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathWeight.setDescription('The value of tmnxCcagPathWeight specifies the scheduling percentage for this path. It is applied to all CCAs in the CCAG membership list for this path.')
tmnxCcagPathCcTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14), )
if mibBuilder.loadTexts: tmnxCcagPathCcTable.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcTable.setDescription('The tmnxCcagPathCcTable has an entry for each type of Cross Connection on a Cross Connect Aggregation Group Path configured on this system.')
tmnxCcagPathCcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagId"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathId"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcType"))
if mibBuilder.loadTexts: tmnxCcagPathCcEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEntry.setDescription('Each row entry represents a particular CCAG Path Cross Connect. Entries are created/deleted by the user. There is no StorageType object, entries have a presumed StorageType of nonVolatile.')
tmnxCcagPathCcType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("sapsap", 1), ("sapnet", 2), ("netsap", 3))))
if mibBuilder.loadTexts: tmnxCcagPathCcType.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcType.setDescription('The value of tmnxCcagPathCcType is used as a third index into the tmnxCcagPathCcTable. Along with tmnxCcagId and tmnxCcagPathId, it uniquely identifies a cross connection type on a specific path in a particular CCAG. The types are: sapsap (1): the cross connection is between two saps, where both services are access. sapnet (2): the cross connection is between a sap and a network service. netsap (3): the cross connection is between a network and a sap service.')
tmnxCcagPathCcLastChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcLastChanged.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcLastChanged.setDescription('The value of tmnxCcagPathCcLastChanged indicates the time this row was last changed.')
tmnxCcagPathCcEgrPoolResvCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolResvCbs.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolResvCbs.setDescription("The value of tmnxCcagPathCcEgrPoolResvCbs specifies the percentage of pool size reserved for the committed burst size, CBS. The value '-1' implies that the reserved CBS should be computed as the sum of the CBS requested by the entities using this pool if the application point is 'network'. For 'access' application points the value '-1' means a default of 30%.")
tmnxCcagPathCcEgrPoolSlpPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 4), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolSlpPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcEgrPoolSlpPlcy.setDescription('The value of tmnxCcagPathCcEgrPoolSlpPlcy specifies the slope policy being used for the egress pool. The Slope policies define the nature of the RED Slopes for the high and the low priority traffic.')
tmnxCcagPathCcIngPoolResvCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolResvCbs.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolResvCbs.setDescription("The value of tmnxCcagPathCcIngPoolResvCbs specifies the percentage of pool size reserved for the committed burst size, CBS. The value '-1' implies that the reserved CBS should be computed as the sum of the CBS requested by the entities using this pool if the application point is 'network'. For 'access' application points the value '-1' means a default of 30%. tmnxCcagPathCcIngPoolResvCbs does not apply to tmnxCcagPathCcType 'netsap'.")
tmnxCcagPathCcIngPoolSlpPlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 6), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolSlpPlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcIngPoolSlpPlcy.setDescription("The value of tmnxCcagPathCcIngPoolSlpPlcy specifies the slope policy being used for the ingress pool. The Slope policies define the nature of the RED Slopes for the high and the low priority traffic. tmnxCcagPathCcIngPoolSlpPlcy does not apply to tmnxCcagPathCcType 'netsap'.")
tmnxCcagPathCcAcctPolicyId = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcAcctPolicyId.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcAcctPolicyId.setDescription("The value of tmnxCcagPathCcAcctPolicyId specifies the accounting policy which must be defined prior to associating it with the port. A non-zero value indicates the tmnxLogApPolicyId index identifying the policy entry in the tmnxLogApTable from the TIMETRA-LOG-MIB which is associated with this port. A zero value indicates that there is no accounting policy associated with this port. It is only meaningful when the tmnxCcagPathCcType is 'netsap'.")
tmnxCcagPathCcCollectStats = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 8), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcCollectStats.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcCollectStats.setDescription("The value of tmnxCcagPathCcCollectStats specifies whether the collection of accounting and statistical data for the network port is enabled/disabled, 'true'/'false'. When applying accounting policies the data by default will be collected in the appropriate records and written to the designated billing file. When the value is set to false, the statistics are still accumulated by the IOM cards, however, the CPU will not obtain the results and write them to the billing file. If the value of tmnxCcagPathCcType is not 'netsap', the value of this object is meaningless and an attempt to set it will result in an inconsistentValue error.")
tmnxCcagPathCcQueuePlcy = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 9), TNamedItem().clone('default')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcQueuePlcy.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcQueuePlcy.setDescription("The value of tmnxCcagPathCcQueuePlcy specifies the network egress queue policy. If the value of tmnxCcagPathCcType is not 'netsap', the value of this object is meaningless and an attempt to set it will result in an inconsistentValue error.")
tmnxCcagPathCcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 10), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcMac.setDescription('The value of tmnxCcagPathCcMac specifies the MAC address of the virtual LAG that maps to tmnxCcagPathId and tmnxCcagPathCcType. The default value of this object is derived from the chassis MAC address pool.')
tmnxCcagPathCcMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 11), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: tmnxCcagPathCcMtu.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcMtu.setDescription("The value of tmnxCcagPathCcMtu specifies the MTU of the path indexed by tmnxCcagId, tmnxCcagPathId, and tmnxCcagPathCcType. When the value is '0', the real MTU is calculated internally.")
tmnxCcagPathCcUserAssignedMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 12), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcUserAssignedMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcUserAssignedMac.setDescription("The value of tmnxCcagPathCcUserAssignedMac indicates whether the value of tmnxCcagPathCcMac has been explicitly assigned or inherited from tmnxCcagPathCcHwMac, 'true' and 'false', respectively.")
tmnxCcagPathCcHwMac = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 14, 1, 13), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxCcagPathCcHwMac.setStatus('current')
if mibBuilder.loadTexts: tmnxCcagPathCcHwMac.setDescription("The value of tmnxCcagPathCcHwMac is the system assigned MAC address of the virtual LAG that maps to tmnxCcagPathId and tmnxCcagPathCcType. When tmnxCcagPathCcUserAssignedMac is 'false', tmnxCcagPathCcMac inherits its value from this object.")
tmnxMcmTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15), )
if mibBuilder.loadTexts: tmnxMcmTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTable.setDescription('The tmnxMcmTable has an entry for each Mda Carrier module (MCM) on the 7710 system.')
tmnxMcmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisIndex"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardSlotNum"), (0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmSlotNum"))
if mibBuilder.loadTexts: tmnxMcmEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmEntry.setDescription('Each row entry represents a MCM in a chassis in the 7710 system. Entries in the table cannot be created and deleted via SNMP SET operations. When a tmnxChassisEntry is created, a tmnxMcmEntry is created in the chassis. Before a tmnxChassisEntry can be deleted, each tmnxMcmEntry for the chassis must be in the proper state for removal.')
tmnxMcmSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16)))
if mibBuilder.loadTexts: tmnxMcmSlotNum.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmSlotNum.setDescription('The unique value which identifies this MDA slot within a specific IOM card in the system. Since the MCM occupies two MDA slots in the chassis this value can only be an odd number.')
tmnxMcmSupportedTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 2), TmnxMcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmSupportedTypes.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmSupportedTypes.setDescription('A bit-mask that specifies what MCM types can be physically supported in this chassis.')
tmnxMcmAssignedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 3), TmnxMcmType().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tmnxMcmAssignedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmAssignedType.setDescription("A bit-mask that identifies the administratively assigned (pre-provisioned) MCM type that should occupy this chassis. If tmnxMcmAssignedType has a value of 'unassigned', this slot has not yet been pre-provisioned. There must not be more than one bit set at a time in tmnxMcmAssignedType.")
tmnxMcmEquippedType = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 4), TmnxMcmType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmEquippedType.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmEquippedType.setDescription("A bit-mask that identifies the MCM type that is physically inserted into this chassis. If the chassis has been pre-provisioned, tmnxMcmAssignedType is not equal 'unassigned', and the value of tmnxMcmEquippedType is not the same as tmnxMcmAssignedType, a mis-match alarm will be raised. If the chassis has not been pre-provisioned, and the value of tmnxMcmEquippedType is not one of the supported types as specified by tmnxMcmSupportedTypes, a mis-match alarm will be raised. There will not be more than one bit set at a time in tmnxMcmEquippedType.")
tmnxMcmHwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 15, 1, 5), TmnxHwIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmHwIndex.setDescription('The value of tmnxMcmHwIndex is the index into the tmnxHwTable for the row entry that represents the hardware component information for this MCM.')
tmnxMcmTypeTable = MibTable((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16), )
if mibBuilder.loadTexts: tmnxMcmTypeTable.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeTable.setDescription('The card type table has an entry for each Alcatel 7710 series Mda Carrier Module (MCM) model.')
tmnxMcmTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1), ).setIndexNames((0, "ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmTypeIndex"))
if mibBuilder.loadTexts: tmnxMcmTypeEntry.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeEntry.setDescription('Each row entry represents an Alcatel 7710 series MCM model. Rows in this table are created by the agent at initialization and cannot be created or destroyed by SNMP Get or Set requests.')
tmnxMcmTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 1), TmnxMcmType())
if mibBuilder.loadTexts: tmnxMcmTypeIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeIndex.setDescription('The unique index value which identifies this type of Alcatel 7710 series MCM model.')
tmnxMcmTypeName = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 2), TNamedItemOrEmpty()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeName.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeName.setDescription('The administrative name that identifies this type of Alcatel 7710 series MCM model. This name string may be used in CLI commands to specify a particular card model type.')
tmnxMcmTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 3), TItemDescription()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeDescription.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeDescription.setDescription('A detailed description of this Alcatel 7710 series MCM model.')
tmnxMcmTypeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 3, 16, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tmnxMcmTypeStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxMcmTypeStatus.setDescription("When tmnxMcmTypeStatus has a value of 'true' it indicates that this MCM is supported in this revision of the management software. When it has a value of 'false' there is no support.")
tmnxEqNotificationRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 1), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxEqNotificationRow.setStatus('current')
if mibBuilder.loadTexts: tmnxEqNotificationRow.setDescription('used by tmnx chassis Notifications, the OID indicates the table and entry.')
tmnxEqTypeNotificationRow = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 2), RowPointer()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxEqTypeNotificationRow.setStatus('current')
if mibBuilder.loadTexts: tmnxEqTypeNotificationRow.setDescription('used by tmnx chassis notifications, the OID indicates the table and entry with the equipment model type information.')
tmnxChassisNotifyChassisId = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 3), TmnxChassisIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyChassisId.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyChassisId.setDescription('Used by tmnx chassis and port Notifications, indicates the chassis associated with the alarm.')
tmnxChassisNotifyHwIndex = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 4), TmnxHwIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyHwIndex.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyHwIndex.setDescription('Used by tmnx chassis and port Notifications, indicates the entry in the tmnxHwTable for the hardware component associated with an alarm.')
tmnxRedSecondaryCPMStatus = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("fail", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatus.setStatus('current')
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatus.setDescription('Used by the tmnxRedSecondaryCPMStatusChange Notification, indicates the status of the secondary CPM.')
tmnxChassisNotifyOID = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 6), ObjectIdentifier()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyOID.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyOID.setDescription('Used by the tmnxChassisNotificationClear trap, the OID identifies the trap which is getting cleared.')
tmnxSyncIfTimingNotifyAlarm = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notUsed", 0), ("los", 1), ("oof", 2), ("oopir", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifyAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxSyncIfTimingNotifyAlarm.setDescription('Used by tmnx Synchronous interface timing notifications, the value of tmnxSyncIfTimingNotifyAlarm indicates the reason a timing reference alarm has been raised.')
tmnxChassisNotifyMismatchedVer = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 8), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyMismatchedVer.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyMismatchedVer.setDescription('Used by tmnxPeSoftwareVersionMismatch, the value of tmnxChassisNotifyMismatchedVer indicates the software version of the mismatched CPM/IOM card.')
tmnxChassisNotifySoftwareLocation = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 9), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifySoftwareLocation.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifySoftwareLocation.setDescription('Used by tmnxPeSoftwareLoadFailed, the value of tmnxChassisNotifySoftwareLocation contains the location of the software.')
tmnxChassisNotifyCardFailureReason = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 10), DisplayString()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyCardFailureReason.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyCardFailureReason.setDescription('Used by tmnxEqCardFailure, the value of tmnxChassisNotifyCardFailureReason contains the reason for card failure.')
tmnxChassisNotifyCardName = MibScalar((1, 3, 6, 1, 4, 1, 6527, 3, 1, 2, 2, 6, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: tmnxChassisNotifyCardName.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyCardName.setDescription('Used by tmnxEqCardInserted and tmnxEqCardRemoved, the value of tmnxChassisNotifyCardName specifies the name of the affected card.')
tmnxHwConfigChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 1)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxHwConfigChange.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxHwConfigChange.setDescription('A tmnxHwConfigChange notification is generated when the value of tmnxHwLastChange is updated. It can be used by the NMS to trigger maintenance polls of the hardware configuration information. Only one tmnxHwConfigChange notification event will be generated in a 5 second throttling time period. A notification event is the transmission of a single trap to a list of notification destinations configured in the SNMP-TARGET-MIB. If additional hardware configuration change occurs within the throttling period, the notification events for these changes are suppressed until the throttling period expires. At the end of the throttling period, one notification event is generated if any addition configuration changes occurred within the just completed throttling period and another throttling period is started. The NMS should periodically check the value of tmnxHwConfigChange to detect any missed tmnxHwConfigChange traps. This notification was made obsolete in the 2.1 release. The tmnxHwConfigChange notification has been replaced with the generic change notifications from the TIMETRA-SYSTEM-MIB: tmnxConfigModify, tmnxConfigCreate, tmnxConfigDelete, tmnxStateChange.')
tmnxEnvTempTooHigh = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 2)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"))
if mibBuilder.loadTexts: tmnxEnvTempTooHigh.setStatus('current')
if mibBuilder.loadTexts: tmnxEnvTempTooHigh.setDescription('Generated when the temperature sensor reading on an equipment object is greater than its configured threshold.')
tmnxEqPowerSupplyFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 3)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyInputStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyOutputStatus"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyFailure.setDescription("Generated when one of the chassis's power supplies fails.")
tmnxEqPowerSupplyInserted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 4)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyInserted.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyInserted.setDescription("Generated when one of the chassis's power supplies is inserted.")
tmnxEqPowerSupplyRemoved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 5)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqPowerSupplyRemoved.setStatus('current')
if mibBuilder.loadTexts: tmnxEqPowerSupplyRemoved.setDescription("Generated when one of the chassis's power supplies is removed.")
tmnxEqFanFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 6)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"))
if mibBuilder.loadTexts: tmnxEqFanFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFanFailure.setDescription('Generated when one of the fans in a fan tray has failed.')
tmnxEqCardFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 7)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardFailureReason"))
if mibBuilder.loadTexts: tmnxEqCardFailure.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardFailure.setDescription('Generated when one of the cards in a chassis has failed. The card type may be IOM, Fabric, MDA, MCM, CCM, CPM module, compact flash module, etc. tmnxChassisNotifyCardFailureReason contains the reason for card failure.')
tmnxEqCardInserted = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 8)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"))
if mibBuilder.loadTexts: tmnxEqCardInserted.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardInserted.setDescription('Generated when a card is inserted into the chassis. The card type may be IOM, Fabric, MDA, MCM, CCM CPM module, compact flash module, etc.')
tmnxEqCardRemoved = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 9)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"))
if mibBuilder.loadTexts: tmnxEqCardRemoved.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardRemoved.setDescription('Generated when a card is removed from the chassis. The card type may be IOM, Fabric, MDA, MCM, CCM, CPM module, compact flash module, etc.')
tmnxEqWrongCard = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 10)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqWrongCard.setStatus('current')
if mibBuilder.loadTexts: tmnxEqWrongCard.setDescription('Generated when the wrong type of card is inserted into a slot of the chassis. Even though a card may be physically supported by the slot, it may have been administratively configured to allow only certain card types in a particular slot location. The card type may be IOM, Fabric, MDA, MCM, CPM module, etc.')
tmnxEqCpuFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 11)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqCpuFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqCpuFailure.setDescription('Generated when a failure is detected for a CPU on an IOM card or CPM module. This notification was made obsolete in the 2.1 release. A cpu failure on a CPM card is detected by the hardware bootup and is indicated by the boot diagnostic display. If there is no working redundant CPM card, the system does not come up. A failure of an IOM card or standby redundant CPM card causes the tmnxEqCardFailure notification to be sent.')
tmnxEqMemoryFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 12)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqMemoryFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqMemoryFailure.setDescription("Generated when a memory module failure is detected for an IOM card or CPM module. This notification was made obsolete in the 2.1 release. A failure of the memory device is detected by the hardware bootup and is indicated by the boot diagnostic display. If there is no working redundant CPM card, the system does not come up. A failure of the memory device during run-time causes the system to fail and the 'admin tech-support' information to be saved. A failure of an IOM card or standby redundant CPM card causes the tmnxEqCardFailure notification to be sent.")
tmnxEqBackdoorBusFailure = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 13)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"))
if mibBuilder.loadTexts: tmnxEqBackdoorBusFailure.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxEqBackdoorBusFailure.setDescription('Generated when the backdoor bus has failed. This notification was made obsolete in the 2.1 release.')
tmnxPeSoftwareError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 14)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeSoftwareError.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeSoftwareError.setDescription("Generated when a software error has been detected. This notification was made obsolete in the 2.1 release. Many of the other notifications more specifically indicate detection of some type of software error. The 'admin tech-support' information helps developers diagnose a failure of the software in the field.")
tmnxPeSoftwareAbnormalHalt = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 15)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeSoftwareAbnormalHalt.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeSoftwareAbnormalHalt.setDescription("Generated when the software has abnormally terminated. This notification was made obsolete in the 2.1 release. Many of the other notifications more specifically indicate detection of some type of software error. The 'admin tech-support' information helps developers diagnose a failure of the software in the field.")
tmnxPeSoftwareVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 16)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeSoftwareVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeSoftwareVersionMismatch.setDescription('Generated when there is a mismatch between software versions of the active CPM and standby CPM or the CPM and IOM. tmnxChassisNotifyHwIndex identifies the mismatched CPM/IOM card and tmnxChassisNotifyMismatchedVer will contain the version of the mismatched card. The tmnxHwSoftwareCodeVersion object will contain the expected version.')
tmnxPeOutOfMemory = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 17)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeOutOfMemory.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeOutOfMemory.setDescription('Generated when there is an out of memory error detected. This notification was made obsolete in the 2.1 release. The tmnxPeOutOfMemory notification has been replaced with the module specific notification from the TIMETRA-SYSTEM-MIB: tmnxModuleMallocFailed.')
tmnxPeConfigurationError = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 18)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeConfigurationError.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeConfigurationError.setDescription("Generated when a configuration error has been detected. This notification was made obsolete in the 2.1 release. Many other notifications more specifically indicate detection of a configuration error. In most cases the SNMP SET request that tries to make an invalid configuration results in an error response. In some cases the configuration parameters are valid and the SNMP SET request succeeds but the system cannot successfully apply the new parameters. The affected object may then put into an operational 'down' state. A state change notification such as tmnxStateChange or a more specific notification is sent to alert about the problem. For example, an attempt to create an event log with a file-type destination when the specified cflash media is full or not present results in TIMETRA-LOG-MIB notifications tmnxLogSpaceContention, tmnxLogAdminLocFailed, or tmnxLogBackupLocFailed.")
tmnxPeStorageProblem = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 19)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeStorageProblem.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeStorageProblem.setDescription("Generated when there is a storage capacity problem. This notification was made obsolete in the 2.1 release. The only 'storage' devices on the SR7750 are the cflash drives. Cflash write errors cause a tmnxEqFlashDataLoss notification to be sent. The tmnxEqFlashDiskFull notification is sent when the driver detects that the cflash device is full.")
tmnxPeCpuCyclesExceeded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 20)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxPeCpuCyclesExceeded.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxPeCpuCyclesExceeded.setDescription('Generated when the CPU cycle usage limit has been exceeded. This notification was made obsolete in the 2.1 release. It does not apply. The SR7750 software architecture does not restrict CPU cycles used by a specific code module.')
tmnxRedPrimaryCPMFail = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 21)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedPrimaryCPMFail.setStatus('current')
if mibBuilder.loadTexts: tmnxRedPrimaryCPMFail.setDescription('Generated when the primary CPM fails.')
tmnxRedSecondaryCPMStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 22)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatus"))
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatusChange.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedSecondaryCPMStatusChange.setDescription('Generated when there is a change in the secondary CPM status. This notification was made obsolete in the 2.1 release. There is no way to administratively enable or disable CPM cards so there is no need for a status change event for administrative state changes. Operational changes detected about the standby CPM card are indicated by more specific notifications such as tmnxEqCardFailure, tmnxEqCardRemoved, tmnxEqCardInserted TIMETRA-SYSTEM-MIB::ssiRedStandbyReady, TIMETRA-SYSTEM-MIB::ssiRedStandbySyncLost, and TIMETRA-SYSTEM-MIB::ssiRedStandbySyncLost.')
tmnxRedRestoreSuccess = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 23)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedRestoreSuccess.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedRestoreSuccess.setDescription('Generated when the secondary CPM successfully restores the config and state. This notification was made obsolete in the 2.1 release. It does not apply. This event was originally created for an early redundancy mechanism that was never released.')
tmnxRedRestoreFail = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 24)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxRedRestoreFail.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxRedRestoreFail.setDescription('Generated when the secondary CPM fails to restore the config and state. This notification was made obsolete in the 2.1 release. It does not apply. This event was originally created for an early redundancy mechanism that was never released.')
tmnxChassisNotificationClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 25)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyOID"))
if mibBuilder.loadTexts: tmnxChassisNotificationClear.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotificationClear.setDescription('A trap indicating the clear of a chassis notification identified by tmnxChassisNotifyOID.')
tmnxEqSyncIfTimingHoldover = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 26)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldover.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldover.setDescription('Generated when the synchronous equipment timing subsystem transitions into a holdover state. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingHoldoverClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 27)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldoverClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingHoldoverClear.setDescription('Generated when the synchronous equipment timing subsystem transitions out of the holdover state. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef1Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 28)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1Alarm.setDescription('Generated when an alarm condition on the first timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef1AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 29)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef1AlarmClear.setDescription('Generated when an alarm condition on the first timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef2Alarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 30)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Alarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2Alarm.setDescription('Generated when an alarm condition on the second timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingRef2AlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 31)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2AlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingRef2AlarmClear.setDescription('Generated when an alarm condition on the second timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqFlashDataLoss = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 32)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwOperState"))
if mibBuilder.loadTexts: tmnxEqFlashDataLoss.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFlashDataLoss.setDescription('tmnxEqFlashDataLoss is generated when there was an error while data was getting written on to the compact flash. This notification indicates a probable data loss.')
tmnxEqFlashDiskFull = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 33)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwOperState"))
if mibBuilder.loadTexts: tmnxEqFlashDiskFull.setStatus('current')
if mibBuilder.loadTexts: tmnxEqFlashDiskFull.setDescription('tmnxEqFlashDiskFull is generated when there is no space left on the compact flash. No more data can be written to it.')
tmnxPeSoftwareLoadFailed = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 34)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifySoftwareLocation"))
if mibBuilder.loadTexts: tmnxPeSoftwareLoadFailed.setStatus('current')
if mibBuilder.loadTexts: tmnxPeSoftwareLoadFailed.setDescription('Generated when the CPM fails to load the software from a specified location. tmnxChassisNotifyHwIndex identifies the card for which the software load failed and tmnxChassisNotifySoftwareLocation contains the location from where the software load was attempted.')
tmnxPeBootloaderVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 35)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeBootloaderVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeBootloaderVersionMismatch.setDescription('Generated when there is a mismatch between the CPM and boot loader versions. tmnxChassisNotifyHwIndex identifies the CPM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of bootloader and tmnxHwSoftwareCodeVersion contains the expected version of the bootloader.')
tmnxPeBootromVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 36)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeBootromVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeBootromVersionMismatch.setDescription('Generated when there is a mismatch between the boot rom versions. tmnxChassisNotifyHwIndex identifies the IOM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of bootrom and tmnxHwSoftwareCodeVersion contains the expected version of the bootrom.')
tmnxPeFPGAVersionMismatch = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 37)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"))
if mibBuilder.loadTexts: tmnxPeFPGAVersionMismatch.setStatus('current')
if mibBuilder.loadTexts: tmnxPeFPGAVersionMismatch.setDescription('Generated when there is a mismatch between the FPGA versions. tmnxChassisNotifyHwIndex identifies the IOM card. tmnxChassisNotifyMismatchedVer contains the mismatched version of FPGA and tmnxHwSoftwareCodeVersion contains the expected version of the FPGA.')
tmnxEqSyncIfTimingBITSAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 38)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarm.setDescription('Generated when an alarm condition on the BITS timing reference is detected. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqSyncIfTimingBITSAlarmClear = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 39)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"))
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarmClear.setStatus('current')
if mibBuilder.loadTexts: tmnxEqSyncIfTimingBITSAlarmClear.setDescription('Generated when an alarm condition on the BITS timing reference is cleared. This notification will have the same indices as those of the tmnxCpmCardTable.')
tmnxEqCardFirmwareUpgraded = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 40)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqCardFirmwareUpgraded.setStatus('current')
if mibBuilder.loadTexts: tmnxEqCardFirmwareUpgraded.setDescription('Generated when a card is hot-inserted into the chassis and its firmware is automatically upgraded. The card type may be IOM or CPM module.')
tmnxChassisUpgradeInProgress = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 41)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisUpgradeInProgress.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgradeInProgress.setDescription('The tmnxChassisUpgradeInProgress notification is generated only after a CPM switchover occurs and the new active CPM is running new software, while the IOMs are still running old software. This is the start of the upgrade process. The tmnxChassisUpgradeInProgress notification will continue to be generated every 30 minutes while at least one IOM is still running older software.')
tmnxChassisUpgradeComplete = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 42)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisUpgradeComplete.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisUpgradeComplete.setDescription('The tmnxChassisUpgradeComplete notification is generated to indicate that all the IOMs are running matching software version in reference to the active CPM software version changed as part of the upgrade process.')
tmnxChassisHiBwMcastAlarm = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 43)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxChassisHiBwMcastAlarm.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisHiBwMcastAlarm.setDescription('The tmnxChassisHiBwMcastAlarm notification is generated when a plane is shared by more than one high bandwidth multicast tap.')
tmnxEqMdaCfgNotCompatible = NotificationType((1, 3, 6, 1, 4, 1, 6527, 3, 1, 3, 2, 1, 0, 44)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"))
if mibBuilder.loadTexts: tmnxEqMdaCfgNotCompatible.setStatus('current')
if mibBuilder.loadTexts: tmnxEqMdaCfgNotCompatible.setDescription("Generated when a supported MDA is inserted into a slot of an IOM, the MDA is compatible with the currently provisioned MDA, but the current configuration on the MDA's ports is not compatible with the inserted MDA.")
tmnxChassisCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1))
tmnxChassisGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2))
tmnxChassisV4v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 4)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV4v0Compliance = tmnxChassisV4v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV4v0Compliance.setDescription('The compliance statement for management of chassis features in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassisV5v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 6)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0Compliance = tmnxChassisV5v0Compliance.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV5v0Compliance.setDescription('The compliance statement for management of chassis features in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassis7750V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 7)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7750V6v0Compliance = tmnxChassis7750V6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxChassis7750V6v0Compliance.setDescription('The compliance statement for management of chassis features on the 7750 in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassis7450V6v0Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 8)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassis7450V6v0Compliance = tmnxChassis7450V6v0Compliance.setStatus('current')
if mibBuilder.loadTexts: tmnxChassis7450V6v0Compliance.setDescription('The compliance statement for management of chassis features on the 7450 in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710 = MibIdentifier((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5))
tmnxChassisComp7710V3v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 1)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V3v0 = tmnxChassisComp7710V3v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V3v0.setDescription('The compliance statement for management of chassis features for the 7710 in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V5v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 2)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V5v0 = tmnxChassisComp7710V5v0.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisComp7710V5v0.setDescription('The compliance statement for management of chassis features for the 7710 in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassisComp7710V6v0 = ModuleCompliance((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 1, 5, 3)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisV5v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAV4v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx7710HwV3v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx77x0CESMDAV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnx7710SETSRefSrcHwV6v0Group"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardV6v0NamedPoolPlcyGroup"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtV6v0Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisComp7710V6v0 = tmnxChassisComp7710V6v0.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisComp7710V6v0.setDescription('The compliance statement for management of chassis features for the 7710 in the ALCATEL-IND1-TIMETRA-CHASSIS-MIB.')
tmnxChassisNotifyObjsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 4)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqNotificationRow"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqTypeNotificationRow"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyChassisId"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyOID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingNotifyAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyMismatchedVer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifySoftwareLocation"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardFailureReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsGroup = tmnxChassisNotifyObjsGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsGroup.setDescription('The group of objects supporting chassis hardware notifications on Alcatel 7x50 SR series systems.')
tmnxChassisNotifyObsoleteGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 7)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwConfigChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCpuFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqMemoryFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqBackdoorBusFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareError"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareAbnormalHalt"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeOutOfMemory"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeConfigurationError"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeStorageProblem"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeCpuCyclesExceeded"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedSecondaryCPMStatusChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedRestoreSuccess"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedRestoreFail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObsoleteGroup = tmnxChassisNotifyObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObsoleteGroup.setDescription('The group of notifications supporting the management of chassis hardware made obsolete for revision 2.1 on Alcatel 7x50 SR series systems.')
tmnxChassisV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 9)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTotalNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisRowStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisLocation"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCoordinates"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumSlots"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumPwrSupplies"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumFanTrays"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumFans"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCriticalLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisMajorLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisMinorLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisBaseMacAddress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCLLICode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisReboot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgrade"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisOperMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisModeForce"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateWaitTime"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateTimeLeft"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgString"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgBoardNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSerialNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwManufactureDate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAlias"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAssetID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwCLEI"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwIsFRU"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwContainedIn"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwParentRelPos"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAdminState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTempSensor"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwBootCodeVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSwLastBoot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAlarmState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClearAlarms"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSwImageSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgDeviations"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwBaseMacAddress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwFailureReason"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV3v0Group = tmnxChassisV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisV3v0Group.setDescription('The group of objects supporting management of chassis hardware capabilities on release 3.0 of Alcatel 7x50 SR series systems.')
tmnxMDAV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 10)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDASupportedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDATxTimingSelected"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDASyncIfTimingStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDANetworkIngQueues"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDACapabilities"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMinChannelization"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannelization"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannels"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAChannelsInUse"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDACcagId"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagRowStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagAdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagCcaRate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagAccessAdaptQos"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathRate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathRateOption"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathWeight"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolResvCbs"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolSlpPlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolResvCbs"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolSlpPlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcCollectStats"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcQueuePlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMac"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMtu"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcHwMac"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcUserAssignedMac"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV3v0Group = tmnxMDAV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxMDAV3v0Group.setDescription('The group of objects supporting management of MDAs on Alcatel 7x50 SR series systems.')
tmnxChassisObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 11)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSwState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardAllowedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardAllowedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAAllowedTypes"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisObsoleteGroup = tmnxChassisObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisObsoleteGroup.setDescription('The group of objects supporting the allowed types of CPM cards, IOM cards and MDA made obsolete for revision 3.0 on Alcatel 7x50 SR series systems.')
tmnxCardV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 12)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardSupportedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardClockSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardNumMdaSlots"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardNumMdas"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardReboot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardMemorySize"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardSupportedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionLastModified"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigBootedVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardIndexBootedVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigLastModified"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigLastSaved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardRedundant"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardClockSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardNumCpus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardCpuType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardMemorySize"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardSwitchToRedundantCard"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardReboot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardRereadBootOptions"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastBooted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastSaved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigFileLastBootedHeader"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardIndexFileLastBootedHeader"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardConfigSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardBootOptionLastSaved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxFabricLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxFabricAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxFabricEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxFabricHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashSerialNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashFirmwareRevision"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashModelNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashCapacity"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashUsed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmFlashHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRevert"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder1"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder2"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1SrcPort"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1AdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1InUse"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1Qualified"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2SrcPort"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2AdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2InUse"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2Qualified"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingFreqOffset"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRefOrder3"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSIfType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSAdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSInUse"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSQualified"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingBITSAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRevert"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder1"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder2"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1SrcPort"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1AdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2SrcPort"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2AdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRefOrder3"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSIfType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmBITSAdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminOwner"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminControlApply"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminLastSetTimer"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminLastSetTimeout"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV3v0Group = tmnxCardV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV3v0Group.setDescription('The group of objects supporting management of hardware cards on Alcatel 7x50 SR series systems.')
tmnxMDAV4v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 13)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDASupportedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAEquippedPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDATxTimingSelected"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDASyncIfTimingStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDANetworkIngQueues"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDACapabilities"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMinChannelization"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannelization"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMaxChannels"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAChannelsInUse"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDACcagId"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMdaTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAReboot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagRowStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagAdminStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagCcaRate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagAccessAdaptQos"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathRate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathRateOption"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathWeight"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcLastChanged"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolResvCbs"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcEgrPoolSlpPlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolResvCbs"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcIngPoolSlpPlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcAcctPolicyId"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcCollectStats"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcQueuePlcy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMac"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcMtu"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcHwMac"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcagPathCcUserAssignedMac"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastTapCount"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAHiBwMcastGroup"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAV4v0Group = tmnxMDAV4v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAV4v0Group.setDescription('The group of objects supporting management of MDAs for release 4.0 on Alcatel 7x50 SR series systems.')
tmnxChassisNotificationV4v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 14)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV4v0Group = tmnxChassisNotificationV4v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV4v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 4.0 on Alcatel 7x50 SR series systems.')
tmnx7710HwV3v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 15)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisOverTempState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCpmCardMasterSlaveRefState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCcmTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmSupportedTypes"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmEquippedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmHwIndex"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMcmTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyInputStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyOutputStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAReboot"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710HwV3v0Group = tmnx7710HwV3v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx7710HwV3v0Group.setDescription('The group of objects supporting management of hardware specific to the Alcatel 7710 SR series systems.')
tmnxChassisV5v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 16)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTotalNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisRowStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisLocation"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCoordinates"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumSlots"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumPorts"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumPwrSupplies"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumFanTrays"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNumFans"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCriticalLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisMajorLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisMinorLEDState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisBaseMacAddress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisCLLICode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisReboot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgrade"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisAdminMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisOperMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisModeForce"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateTimeLeft"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanOperStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisFanSpeed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyACStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyDCStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyTempThreshold"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply1Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupply2Status"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisPowerSupplyAssignedType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeDescription"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisTypeStatus"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwLastChange"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgString"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgBoardNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSerialNumber"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwManufactureDate"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClass"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAlias"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAssetID"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwCLEI"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwIsFRU"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwContainedIn"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwParentRelPos"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAdminState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwOperState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTempSensor"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTemperature"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwTempThreshold"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwBootCodeVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSoftwareCodeVersion"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSwLastBoot"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwAlarmState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwLastAlarmEvent"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwClearAlarms"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwSwImageSource"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwMfgDeviations"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwBaseMacAddress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwFailureReason"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxHwContainedIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0Group = tmnxChassisV5v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV5v0Group.setDescription('The group of objects supporting management of chassis hardware capabilities on release 5.0 of Alcatel 7x50 SR series systems.')
tmnxChassisV5v0ObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 17)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpdateWaitTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisV5v0ObsoleteGroup = tmnxChassisV5v0ObsoleteGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisV5v0ObsoleteGroup.setDescription('The group of onbsolete objects for managing the chassis hardware capabilities on release 5.0 of Alcatel 7x50 SR series systems.')
tmnx77x0CESMDAV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 18)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAClockMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDADiffTimestampFreq"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAIngNamedPoolPolicy"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAEgrNamedPoolPolicy"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx77x0CESMDAV6v0Group = tmnx77x0CESMDAV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx77x0CESMDAV6v0Group.setDescription('The group of objects supporting management of CES MDAs for release 6.0 on Alcatel 77x0 SR series systems.')
tmnxChassisNotificationV3v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 20)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV3v0Group = tmnxChassisNotificationV3v0Group.setStatus('obsolete')
if mibBuilder.loadTexts: tmnxChassisNotificationV3v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 3.0 on Alcatel 7x50 SR series systems.')
tmnxChassisNotificationV6v0Group = NotificationGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 21)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEnvTempTooHigh"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqPowerSupplyRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFanFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFailure"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardInserted"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardRemoved"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqWrongCard"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxRedPrimaryCPMFail"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotificationClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldover"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingHoldoverClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef1AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2Alarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingRef2AlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDataLoss"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqFlashDiskFull"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeSoftwareLoadFailed"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootloaderVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeBootromVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxPeFPGAVersionMismatch"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqSyncIfTimingBITSAlarmClear"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqCardFirmwareUpgraded"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeInProgress"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisUpgradeComplete"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisHiBwMcastAlarm"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxEqMdaCfgNotCompatible"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotificationV6v0Group = tmnxChassisNotificationV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotificationV6v0Group.setDescription('The group of notifications supporting the management of chassis hardware for release 6.0 on Alcatel 7x50 SR series systems.')
tmnx7710SETSRefSrcHwV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 22)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1SrcHw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef1BITSIfType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2SrcHw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxSyncIfTimingRef2BITSIfType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1SrcHw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef1BITSIfType"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2SrcHw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tSyncIfTimingAdmRef2BITSIfType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnx7710SETSRefSrcHwV6v0Group = tmnx7710SETSRefSrcHwV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnx7710SETSRefSrcHwV6v0Group.setDescription("The group of objects supporting management of 'Synchronous Equipment Timing' (SETS) when the references are of type 'Building Integrated Timing Supply' (BITS) for release 6.0 on Alcatel 7710 SR series systems.")
tmnxMDAMcPathMgmtV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 24)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtBwPlcyName"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtPriPathLimit"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtSecPathLimit"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAncPathLimit"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAdminState"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtPriInUseBw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtSecInUseBw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtAncInUseBw"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxMDAMcPathMgmtBlkHoleInUseBw"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxMDAMcPathMgmtV6v0Group = tmnxMDAMcPathMgmtV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxMDAMcPathMgmtV6v0Group.setDescription('The group of objects supporting management of Multicast Path Management feature for release 6.0 on Alcatel 7x50 SR series systems.')
tmnxCardV6v0NamedPoolPlcyGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 25)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardNamedPoolAdminMode"), ("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxCardNamedPoolOperMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxCardV6v0NamedPoolPlcyGroup = tmnxCardV6v0NamedPoolPlcyGroup.setStatus('current')
if mibBuilder.loadTexts: tmnxCardV6v0NamedPoolPlcyGroup.setDescription('The group of objects supporting named buffer pools for release 6.0 on Alcatel 7x50 SR series systems.')
tmnxChassisNotifyObjsV6v0Group = ObjectGroup((1, 3, 6, 1, 4, 1, 6527, 3, 1, 1, 2, 1, 2, 26)).setObjects(("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", "tmnxChassisNotifyCardName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    tmnxChassisNotifyObjsV6v0Group = tmnxChassisNotifyObjsV6v0Group.setStatus('current')
if mibBuilder.loadTexts: tmnxChassisNotifyObjsV6v0Group.setDescription('The group of objects added in 6.0 release to support chassis hardware notifications on Alcatel 7x50 SR series systems.')
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", tmnxEqTypeNotificationRow=tmnxEqTypeNotificationRow, tmnxCcagPathCcEntry=tmnxCcagPathCcEntry, tmnxCcagRowStatus=tmnxCcagRowStatus, TmnxCcmType=TmnxCcmType, tmnxRedRestoreSuccess=tmnxRedRestoreSuccess, tmnxHwContainedIn=tmnxHwContainedIn, tmnxSyncIfTimingRef2AdminStatus=tmnxSyncIfTimingRef2AdminStatus, tmnxFabricTable=tmnxFabricTable, tmnxSyncIfTimingRevert=tmnxSyncIfTimingRevert, tmnxCcagPathLastChanged=tmnxCcagPathLastChanged, tmnxSyncIfTimingRef1SrcHw=tmnxSyncIfTimingRef1SrcHw, tmnxMcmAssignedType=tmnxMcmAssignedType, tSyncIfTimingAdmRef2AdminStatus=tSyncIfTimingAdmRef2AdminStatus, tmnxMDAHiBwMcastTapCount=tmnxMDAHiBwMcastTapCount, TmnxSlotNum=TmnxSlotNum, tmnxCpmCardNumCpus=tmnxCpmCardNumCpus, tmnxSyncIfTimingBITSAlarm=tmnxSyncIfTimingBITSAlarm, tmnxCpmCardConfigFileLastSaved=tmnxCpmCardConfigFileLastSaved, tmnxMDASlotNum=tmnxMDASlotNum, tmnxChassisHiBwMcastAlarm=tmnxChassisHiBwMcastAlarm, tmnxChassisNotifyObjsGroup=tmnxChassisNotifyObjsGroup, tSyncIfTimingAdmRef1BITSIfType=tSyncIfTimingAdmRef1BITSIfType, tmnxCcagPathCcEgrPoolSlpPlcy=tmnxCcagPathCcEgrPoolSlpPlcy, tmnxChassisAdminObjects=tmnxChassisAdminObjects, tmnxCcmTypeStatus=tmnxCcmTypeStatus, tmnxCcagLastChanged=tmnxCcagLastChanged, TmnxChassisIndex=TmnxChassisIndex, tmnxHwManufactureDate=tmnxHwManufactureDate, tmnxCpmCardSwitchToRedundantCard=tmnxCpmCardSwitchToRedundantCard, tmnxMcmEquippedType=tmnxMcmEquippedType, tmnxHwSerialNumber=tmnxHwSerialNumber, tmnxEqCardInserted=tmnxEqCardInserted, tmnxCpmCardEntry=tmnxCpmCardEntry, tmnxMDAEquippedType=tmnxMDAEquippedType, tmnxChassisOverTempState=tmnxChassisOverTempState, tmnxPeCpuCyclesExceeded=tmnxPeCpuCyclesExceeded, tmnxCpmCardConfigSource=tmnxCpmCardConfigSource, tmnxMDAMcPathMgmtSecPathLimit=tmnxMDAMcPathMgmtSecPathLimit, tmnxMcmHwIndex=tmnxMcmHwIndex, tmnxMcmSlotNum=tmnxMcmSlotNum, TmnxCcagId=TmnxCcagId, tmnxChassis7450V6v0Compliance=tmnxChassis7450V6v0Compliance, tmnxHwConformance=tmnxHwConformance, tmnxChassisTypeEntry=tmnxChassisTypeEntry, tmnxMDAMcPathMgmtV6v0Group=tmnxMDAMcPathMgmtV6v0Group, TmnxMDASuppType=TmnxMDASuppType, tmnxPeSoftwareVersionMismatch=tmnxPeSoftwareVersionMismatch, tmnxCpmFlashEntry=tmnxCpmFlashEntry, tmnxCcmIndex=tmnxCcmIndex, tmnxMDAMcPathMgmtBlkHoleInUseBw=tmnxMDAMcPathMgmtBlkHoleInUseBw, tmnxPeStorageProblem=tmnxPeStorageProblem, tmnxEqSyncIfTimingRef2Alarm=tmnxEqSyncIfTimingRef2Alarm, tmnxChassisCompliances=tmnxChassisCompliances, tmnxPeSoftwareAbnormalHalt=tmnxPeSoftwareAbnormalHalt, tmnxCcmTypeIndex=tmnxCcmTypeIndex, tmnxHwMfgString=tmnxHwMfgString, tmnxMDAMaxChannelization=tmnxMDAMaxChannelization, tmnxMdaTypeStatus=tmnxMdaTypeStatus, tmnxEqMemoryFailure=tmnxEqMemoryFailure, tmnxCcagDescription=tmnxCcagDescription, tmnxHwTemperature=tmnxHwTemperature, tmnxChassisOperMode=tmnxChassisOperMode, tmnxChassisTypeIndex=tmnxChassisTypeIndex, tmnxChassisV5v0Compliance=tmnxChassisV5v0Compliance, tmnxMDAMcPathMgmtPriPathLimit=tmnxMDAMcPathMgmtPriPathLimit, tSyncIfTimingAdmRefOrder2=tSyncIfTimingAdmRefOrder2, tmnxCardV3v0Group=tmnxCardV3v0Group, tmnxChassisCLLICode=tmnxChassisCLLICode, tmnxCcmHwIndex=tmnxCcmHwIndex, tmnxEqSyncIfTimingBITSAlarm=tmnxEqSyncIfTimingBITSAlarm, tmnxChassisNotificationV6v0Group=tmnxChassisNotificationV6v0Group, tmnxMDAHiBwMcastGroup=tmnxMDAHiBwMcastGroup, tmnxFabricSlotNum=tmnxFabricSlotNum, tmnxCcagPathCcLastChanged=tmnxCcagPathCcLastChanged, TmnxPortAdminStatus=TmnxPortAdminStatus, tSyncIfTimingAdmRefOrder1=tSyncIfTimingAdmRefOrder1, tmnxSyncIfTimingRef1AdminStatus=tmnxSyncIfTimingRef1AdminStatus, tmnxChassisPowerSupplyId=tmnxChassisPowerSupplyId, tmnxCpmCardBootOptionVersion=tmnxCpmCardBootOptionVersion, tmnxMDAMcPathMgmtBwPlcyName=tmnxMDAMcPathMgmtBwPlcyName, tmnxCardLastChange=tmnxCardLastChange, tmnxHwCLEI=tmnxHwCLEI, tmnxSyncIfTimingBITSQualified=tmnxSyncIfTimingBITSQualified, tmnxCpmCardRereadBootOptions=tmnxCpmCardRereadBootOptions, tmnxMdaTypeTable=tmnxMdaTypeTable, tmnxPeSoftwareError=tmnxPeSoftwareError, tmnxRedPrimaryCPMFail=tmnxRedPrimaryCPMFail, PYSNMP_MODULE_ID=tmnxChassisMIBModule, tmnxHwFailureReason=tmnxHwFailureReason, tmnxEqCpuFailure=tmnxEqCpuFailure, tmnxChassisTypeDescription=tmnxChassisTypeDescription, tmnxCcagCcaRate=tmnxCcagCcaRate, TmnxSETSRefSource=TmnxSETSRefSource, tmnxChassisCriticalLEDState=tmnxChassisCriticalLEDState, TmnxHwIndexOrZero=TmnxHwIndexOrZero, tmnxFabricAssignedType=tmnxFabricAssignedType, tmnxCardNamedPoolOperMode=tmnxCardNamedPoolOperMode, tmnxMcmTypeEntry=tmnxMcmTypeEntry, tmnxMdaTypeEntry=tmnxMdaTypeEntry, tmnxCardTable=tmnxCardTable, tmnxCcagPathCcQueuePlcy=tmnxCcagPathCcQueuePlcy, tmnxCpmCardBootOptionLastSaved=tmnxCpmCardBootOptionLastSaved, tmnxCpmCardIndexFileLastBootedHeader=tmnxCpmCardIndexFileLastBootedHeader, tmnxRedSecondaryCPMStatusChange=tmnxRedSecondaryCPMStatusChange, tmnxMDAEntry=tmnxMDAEntry, tmnxHwTable=tmnxHwTable, tmnxCardReboot=tmnxCardReboot, tmnxCpmCardMemorySize=tmnxCpmCardMemorySize, tmnxCpmFlashHwIndex=tmnxCpmFlashHwIndex, tmnxMDADiffTimestampFreq=tmnxMDADiffTimestampFreq, tmnxCardTypeIndex=tmnxCardTypeIndex, tmnxChassisComp7710V5v0=tmnxChassisComp7710V5v0, tmnxCcmTypeDescription=tmnxCcmTypeDescription, TmnxMDAChanType=TmnxMDAChanType, tmnxChassisTypeName=tmnxChassisTypeName, tmnxChassisNotifyMismatchedVer=tmnxChassisNotifyMismatchedVer, tmnxHwAlias=tmnxHwAlias, tmnxChassisPowerSupplyAssignedType=tmnxChassisPowerSupplyAssignedType, tmnxCcagOperStatus=tmnxCcagOperStatus, tmnxMcmTypeTable=tmnxMcmTypeTable, tmnxPeConfigurationError=tmnxPeConfigurationError, tmnxSyncIfTimingStatus=tmnxSyncIfTimingStatus, tmnxSyncIfTimingTable=tmnxSyncIfTimingTable, tmnxHwOperState=tmnxHwOperState, tmnxFabricEquippedType=tmnxFabricEquippedType, tmnxChassisV5v0Group=tmnxChassisV5v0Group, tmnxCpmCardSupportedTypes=tmnxCpmCardSupportedTypes, tSyncIfTimingAdmBITSIfType=tSyncIfTimingAdmBITSIfType, tmnxMcmTypeName=tmnxMcmTypeName, tmnxChassisAdminMode=tmnxChassisAdminMode, tmnxChassisPowerSupplyTempStatus=tmnxChassisPowerSupplyTempStatus, tmnxCardNumMdaSlots=tmnxCardNumMdaSlots, tmnxCcagPathCcMac=tmnxCcagPathCcMac, tmnxMcmEntry=tmnxMcmEntry, tmnxChassisNotifyCardName=tmnxChassisNotifyCardName, tmnxCpmCardLastChange=tmnxCpmCardLastChange, tSyncIfTimingAdmRef2SrcPort=tSyncIfTimingAdmRef2SrcPort, tmnxCardTypeDescription=tmnxCardTypeDescription, TmnxSETSRefAlarm=TmnxSETSRefAlarm, tmnxChassisLastChange=tmnxChassisLastChange, tmnxPeOutOfMemory=tmnxPeOutOfMemory, tmnxCcagPathCcAcctPolicyId=tmnxCcagPathCcAcctPolicyId, tmnxCpmCardSlotNum=tmnxCpmCardSlotNum, tSyncIfTimingAdmRevert=tSyncIfTimingAdmRevert, tmnxCardTypeName=tmnxCardTypeName, tmnxFabricLastChange=tmnxFabricLastChange, tmnxChassisUpdateTimeLeft=tmnxChassisUpdateTimeLeft, tmnxChassisFanOperStatus=tmnxChassisFanOperStatus, tmnxCcagPathCcIngPoolResvCbs=tmnxCcagPathCcIngPoolResvCbs, tmnxChassisModeForce=tmnxChassisModeForce, tmnxCpmCardRedundant=tmnxCpmCardRedundant, tmnxChassisEntry=tmnxChassisEntry, TmnxBITSIfType=TmnxBITSIfType, tmnxChassisFanIndex=tmnxChassisFanIndex, tmnxChassisUpgrade=tmnxChassisUpgrade, tmnxHwNotification=tmnxHwNotification, TmnxSlotNumOrZero=TmnxSlotNumOrZero, tmnxMDACcagId=tmnxMDACcagId, tmnxMDAReboot=tmnxMDAReboot, tmnxHwTempSensor=tmnxHwTempSensor, tmnxSyncIfTimingRef2Alarm=tmnxSyncIfTimingRef2Alarm, tmnxEqSyncIfTimingHoldover=tmnxEqSyncIfTimingHoldover, tmnxChassisTypeStatus=tmnxChassisTypeStatus, tmnxChassisNotifyChassisId=tmnxChassisNotifyChassisId, tmnxPeBootloaderVersionMismatch=tmnxPeBootloaderVersionMismatch, tmnxCardMemorySize=tmnxCardMemorySize, tmnxHwIsFRU=tmnxHwIsFRU, tmnxEqSyncIfTimingBITSAlarmClear=tmnxEqSyncIfTimingBITSAlarmClear, tmnxMDAHwIndex=tmnxMDAHwIndex, tmnxCpmCardConfigFileLastBooted=tmnxCpmCardConfigFileLastBooted, tmnxMDAHiBwMcastAlarm=tmnxMDAHiBwMcastAlarm, tmnxMDAAllowedTypes=tmnxMDAAllowedTypes, tmnxHwConfigChange=tmnxHwConfigChange, tmnxCpmCardCpuType=tmnxCpmCardCpuType, tmnxHwAlarmState=tmnxHwAlarmState, tmnxPeFPGAVersionMismatch=tmnxPeFPGAVersionMismatch, tmnx7710HwV3v0Group=tmnx7710HwV3v0Group, tmnxMDAMcPathMgmtPriInUseBw=tmnxMDAMcPathMgmtPriInUseBw, tmnxChassisUpgradeComplete=tmnxChassisUpgradeComplete, tmnxChassisType=tmnxChassisType, tmnxCardNamedPoolAdminMode=tmnxCardNamedPoolAdminMode, tmnxHwEntry=tmnxHwEntry, tmnxEqFlashDiskFull=tmnxEqFlashDiskFull, tmnxMDAV3v0Group=tmnxMDAV3v0Group, tmnxCpmCardIndexBootedVersion=tmnxCpmCardIndexBootedVersion, tmnxMDAMaxChannels=tmnxMDAMaxChannels, tmnxChassisFanSpeed=tmnxChassisFanSpeed, tmnxChassisNumPorts=tmnxChassisNumPorts, tmnxCpmCardEquippedType=tmnxCpmCardEquippedType, tmnxMDAMcPathMgmtSecInUseBw=tmnxMDAMcPathMgmtSecInUseBw, tmnxCcagPathCcUserAssignedMac=tmnxCcagPathCcUserAssignedMac, tmnxCcagPathCcMtu=tmnxCcagPathCcMtu, tmnxChassisPowerSupplyOutputStatus=tmnxChassisPowerSupplyOutputStatus, tmnxMdaTypeName=tmnxMdaTypeName, tmnxChassisNotificationV3v0Group=tmnxChassisNotificationV3v0Group, tmnxChassisNotificationObjects=tmnxChassisNotificationObjects, tmnxChassisObjs=tmnxChassisObjs, tmnxMcmTable=tmnxMcmTable, tmnxCpmFlashSerialNumber=tmnxCpmFlashSerialNumber, tmnxHwLastChange=tmnxHwLastChange, tmnxChassisNumPwrSupplies=tmnxChassisNumPwrSupplies, tmnxChassisConformance=tmnxChassisConformance, tmnxCcagTable=tmnxCcagTable, tmnxCardTypeTable=tmnxCardTypeTable, tSyncIfTimingAdmRef1SrcPort=tSyncIfTimingAdmRef1SrcPort, tmnxSyncIfTimingRefOrder2=tmnxSyncIfTimingRefOrder2, tmnxCpmCardHwIndex=tmnxCpmCardHwIndex, tmnxCpmFlashModelNumber=tmnxCpmFlashModelNumber, tmnxPeBootromVersionMismatch=tmnxPeBootromVersionMismatch, tSyncIfTimingAdmTable=tSyncIfTimingAdmTable, tmnxHwSoftwareCodeVersion=tmnxHwSoftwareCodeVersion, tmnxCcmEquippedType=tmnxCcmEquippedType, tmnxChassisPowerSupplyInputStatus=tmnxChassisPowerSupplyInputStatus, tSyncIfTimingAdmRef1AdminStatus=tSyncIfTimingAdmRef1AdminStatus, TmnxCcagRate=TmnxCcagRate, tmnxChassisMajorLEDState=tmnxChassisMajorLEDState, tmnxCcmTable=tmnxCcmTable, TmnxCcagRateOption=TmnxCcagRateOption, tmnxChassisV3v0Group=tmnxChassisV3v0Group, tmnxChassisFanEntry=tmnxChassisFanEntry, tmnxEqCardFirmwareUpgraded=tmnxEqCardFirmwareUpgraded, tmnxHwContainsTable=tmnxHwContainsTable, tmnxCcmTypeEntry=tmnxCcmTypeEntry, tmnxHwBootCodeVersion=tmnxHwBootCodeVersion, tmnxChassisAdminLastSetTimer=tmnxChassisAdminLastSetTimer, tmnxSlotObjs=tmnxSlotObjs, tmnxEqSyncIfTimingRef2AlarmClear=tmnxEqSyncIfTimingRef2AlarmClear, tmnxCpmCardClockSource=tmnxCpmCardClockSource, tmnxEqPowerSupplyInserted=tmnxEqPowerSupplyInserted, tmnxMDAAssignedType=tmnxMDAAssignedType, tmnxChassisNotifyObsoleteGroup=tmnxChassisNotifyObsoleteGroup, tmnxCpmCardMasterSlaveRefState=tmnxCpmCardMasterSlaveRefState, TmnxMcmType=TmnxMcmType, tmnxMdaTypeIndex=tmnxMdaTypeIndex, tmnxCcagPathWeight=tmnxCcagPathWeight, tmnxCcagPathCcHwMac=tmnxCcagPathCcHwMac, tmnxMcmTypeStatus=tmnxMcmTypeStatus, tmnxEnvTempTooHigh=tmnxEnvTempTooHigh, tmnxMDAHiBwMcastSource=tmnxMDAHiBwMcastSource, tmnxEqSyncIfTimingRef1Alarm=tmnxEqSyncIfTimingRef1Alarm, tmnxCcagPathCcEgrPoolResvCbs=tmnxCcagPathCcEgrPoolResvCbs, tmnxChassisNotifyOID=tmnxChassisNotifyOID, tmnxChassisBaseMacAddress=tmnxChassisBaseMacAddress, tmnxChassisAdminControlApply=tmnxChassisAdminControlApply, tmnxCcagPathRateOption=tmnxCcagPathRateOption, tSyncIfTimingAdmEntry=tSyncIfTimingAdmEntry, TmnxLEDState=TmnxLEDState, tmnxChassisNotificationV4v0Group=tmnxChassisNotificationV4v0Group, tmnxCcagAccessAdaptQos=tmnxCcagAccessAdaptQos, tmnxCcmOperStatus=tmnxCcmOperStatus, tmnxEqBackdoorBusFailure=tmnxEqBackdoorBusFailure, tmnxCardEquippedType=tmnxCardEquippedType, tmnxMDAIngNamedPoolPolicy=tmnxMDAIngNamedPoolPolicy, tmnxCpmCardBootOptionSource=tmnxCpmCardBootOptionSource)
mibBuilder.exportSymbols("ALCATEL-IND1-TIMETRA-CHASSIS-MIB", tmnxChassisUpgradeInProgress=tmnxChassisUpgradeInProgress, tSyncIfTimingAdmChanged=tSyncIfTimingAdmChanged, tmnxEqFlashDataLoss=tmnxEqFlashDataLoss, TmnxSETSRefQualified=TmnxSETSRefQualified, tmnxCpmCardReboot=tmnxCpmCardReboot, tmnxSyncIfTimingFreqOffset=tmnxSyncIfTimingFreqOffset, tmnxChassisTotalNumber=tmnxChassisTotalNumber, tmnxHwSwState=tmnxHwSwState, tmnxSyncIfTimingRef2BITSIfType=tmnxSyncIfTimingRef2BITSIfType, tmnxChassisIndex=tmnxChassisIndex, tmnxCcagPathTable=tmnxCcagPathTable, tmnxEqCardRemoved=tmnxEqCardRemoved, tmnxSyncIfTimingRef1BITSIfType=tmnxSyncIfTimingRef1BITSIfType, tmnx7710SETSRefSrcHwV6v0Group=tmnx7710SETSRefSrcHwV6v0Group, tmnxChassisRowStatus=tmnxChassisRowStatus, tmnxSyncIfTimingRefOrder1=tmnxSyncIfTimingRefOrder1, tmnxCpmCardConfigLastModified=tmnxCpmCardConfigLastModified, tmnxSyncIfTimingNotifyAlarm=tmnxSyncIfTimingNotifyAlarm, TmnxMdaType=TmnxMdaType, tmnxHwObjs=tmnxHwObjs, tmnxEqSyncIfTimingHoldoverClear=tmnxEqSyncIfTimingHoldoverClear, tmnxChassisNotificationClear=tmnxChassisNotificationClear, tmnxCardNumMdas=tmnxCardNumMdas, tmnxChassisPowerSupplyDCStatus=tmnxChassisPowerSupplyDCStatus, tmnxMcmTypeIndex=tmnxMcmTypeIndex, tmnxMDASyncIfTimingStatus=tmnxMDASyncIfTimingStatus, tmnxChassisNumFanTrays=tmnxChassisNumFanTrays, tmnxRedRestoreFail=tmnxRedRestoreFail, tmnxChassisReboot=tmnxChassisReboot, tmnxMDAMaxPorts=tmnxMDAMaxPorts, tmnxCcagEntry=tmnxCcagEntry, tmnxPeSoftwareLoadFailed=tmnxPeSoftwareLoadFailed, tmnxCpmCardNum=tmnxCpmCardNum, tmnxChassisName=tmnxChassisName, tmnxChassisTypeTable=tmnxChassisTypeTable, tmnxChassisLocation=tmnxChassisLocation, tmnxHwLastAlarmEvent=tmnxHwLastAlarmEvent, tmnxCardEntry=tmnxCardEntry, tmnxMDAMcPathMgmtAncInUseBw=tmnxMDAMcPathMgmtAncInUseBw, tmnxChassisTable=tmnxChassisTable, tmnxHwAdminState=tmnxHwAdminState, tmnxChassisUpdateWaitTime=tmnxChassisUpdateWaitTime, tmnxCpmCardConfigFileLastBootedHeader=tmnxCpmCardConfigFileLastBootedHeader, tmnxMcmSupportedTypes=tmnxMcmSupportedTypes, tmnxHwTempThreshold=tmnxHwTempThreshold, TmnxChassisMode=TmnxChassisMode, tmnxCardV6v0NamedPoolPlcyGroup=tmnxCardV6v0NamedPoolPlcyGroup, tmnxMDATxTimingSelected=tmnxMDATxTimingSelected, tmnxMDAMinChannelization=tmnxMDAMinChannelization, tmnxChassisObsoleteGroup=tmnxChassisObsoleteGroup, tmnxHwID=tmnxHwID, tmnxSyncIfTimingRef1SrcPort=tmnxSyncIfTimingRef1SrcPort, tmnxHwMfgDeviations=tmnxHwMfgDeviations, tmnxCpmCardAllowedTypes=tmnxCpmCardAllowedTypes, tmnxSyncIfTimingRef1Alarm=tmnxSyncIfTimingRef1Alarm, tmnxChassisPowerSupply2Status=tmnxChassisPowerSupply2Status, tmnxHwParentRelPos=tmnxHwParentRelPos, tmnxCcagPathCcCollectStats=tmnxCcagPathCcCollectStats, tmnxChassisPowerSupply1Status=tmnxChassisPowerSupply1Status, tSyncIfTimingAdmBITSAdminStatus=tSyncIfTimingAdmBITSAdminStatus, tmnxCcagId=tmnxCcagId, tmnxCcagPathEntry=tmnxCcagPathEntry, tmnxChassisComp7710V3v0=tmnxChassisComp7710V3v0, tmnxSyncIfTimingRef2SrcPort=tmnxSyncIfTimingRef2SrcPort, tmnxHwIndex=tmnxHwIndex, tmnxMDATable=tmnxMDATable, tmnxChassisAdminLastSetTimeout=tmnxChassisAdminLastSetTimeout, tmnxCardSupportedTypes=tmnxCardSupportedTypes, tmnxEqCardFailure=tmnxEqCardFailure, tmnxHwBaseMacAddress=tmnxHwBaseMacAddress, tmnxMDANetworkIngQueues=tmnxMDANetworkIngQueues, tmnxSyncIfTimingRef2InUse=tmnxSyncIfTimingRef2InUse, tmnxChassisNotifyObjsV6v0Group=tmnxChassisNotifyObjsV6v0Group, tmnxHwContainsEntry=tmnxHwContainsEntry, tmnxMDASupportedTypes=tmnxMDASupportedTypes, tmnxChassisPowerSupplyTempThreshold=tmnxChassisPowerSupplyTempThreshold, tmnxCardClockSource=tmnxCardClockSource, tmnxHwClass=tmnxHwClass, tmnxFabricEntry=tmnxFabricEntry, tmnxCpmFlashOperStatus=tmnxCpmFlashOperStatus, tmnxChassisPowerSupplyACStatus=tmnxChassisPowerSupplyACStatus, tmnxChassisComp7710=tmnxChassisComp7710, TmnxChassisType=TmnxChassisType, tmnxCcagAdminStatus=tmnxCcagAdminStatus, tmnxSyncIfTimingRef2Qualified=tmnxSyncIfTimingRef2Qualified, tmnxSyncIfTimingRef1InUse=tmnxSyncIfTimingRef1InUse, TmnxHwClass=TmnxHwClass, tmnxChassisAdminCtrlObjs=tmnxChassisAdminCtrlObjs, TmnxCardType=TmnxCardType, tmnxMDACapabilities=tmnxMDACapabilities, tmnxHwSwImageSource=tmnxHwSwImageSource, tSyncIfTimingAdmRef2SrcHw=tSyncIfTimingAdmRef2SrcHw, tmnxEqWrongCard=tmnxEqWrongCard, tmnxChassisPowerSupplyTable=tmnxChassisPowerSupplyTable, TmnxDeviceState=TmnxDeviceState, tmnxChassisNumSlots=tmnxChassisNumSlots, tmnxSyncIfTimingBITSInUse=tmnxSyncIfTimingBITSInUse, tmnxMDAMcPathMgmtAdminState=tmnxMDAMcPathMgmtAdminState, tmnxCcmTypeTable=tmnxCcmTypeTable, tmnxHwSwLastBoot=tmnxHwSwLastBoot, tmnxSyncIfTimingRefOrder3=tmnxSyncIfTimingRefOrder3, tmnxEqNotificationRow=tmnxEqNotificationRow, tmnxCpmCardAssignedType=tmnxCpmCardAssignedType, TmnxHwIndex=TmnxHwIndex, tmnxCcagPathCcTable=tmnxCcagPathCcTable, tmnxChassisCoordinates=tmnxChassisCoordinates, tmnxChassisNotifyHwIndex=tmnxChassisNotifyHwIndex, tmnxCcagPathCcIngPoolSlpPlcy=tmnxCcagPathCcIngPoolSlpPlcy, tmnxHwClearAlarms=tmnxHwClearAlarms, tSyncIfTimingAdmRef1SrcHw=tSyncIfTimingAdmRef1SrcHw, tmnxChassisNotifyPrefix=tmnxChassisNotifyPrefix, tmnx77x0CESMDAV6v0Group=tmnx77x0CESMDAV6v0Group, tmnxChassisAdminOwner=tmnxChassisAdminOwner, tmnxCardTypeEntry=tmnxCardTypeEntry, tmnxEqPowerSupplyFailure=tmnxEqPowerSupplyFailure, tmnxCpmCardBootOptionLastModified=tmnxCpmCardBootOptionLastModified, tmnxMDAChannelsInUse=tmnxMDAChannelsInUse, tmnxCcagPathId=tmnxCcagPathId, tmnxCardObjs=tmnxCardObjs, tmnxMDAClockMode=tmnxMDAClockMode, tmnxEqFanFailure=tmnxEqFanFailure, tmnxMDAMcPathMgmtAncPathLimit=tmnxMDAMcPathMgmtAncPathLimit, tSyncIfTimingAdmRef2BITSIfType=tSyncIfTimingAdmRef2BITSIfType, tmnxSyncIfTimingRef1Qualified=tmnxSyncIfTimingRef1Qualified, tmnxCardAssignedType=tmnxCardAssignedType, tmnxMDAV4v0Group=tmnxMDAV4v0Group, tmnxFabricHwIndex=tmnxFabricHwIndex, tmnxChassisComp7710V6v0=tmnxChassisComp7710V6v0, tmnxSyncIfTimingBITSAdminStatus=tmnxSyncIfTimingBITSAdminStatus, tmnxChassisPowerSupplyEntry=tmnxChassisPowerSupplyEntry, tmnxHwContainedIndex=tmnxHwContainedIndex, tmnxChassisMIBModule=tmnxChassisMIBModule, tmnxCardHwIndex=tmnxCardHwIndex, tmnxCpmFlashCapacity=tmnxCpmFlashCapacity, tmnxCcmTypeName=tmnxCcmTypeName, tmnxCpmFlashTable=tmnxCpmFlashTable, tmnxCpmFlashId=tmnxCpmFlashId, tmnxCardSlotNum=tmnxCardSlotNum, tmnxChassisNotifyCardFailureReason=tmnxChassisNotifyCardFailureReason, tmnxCardAllowedTypes=tmnxCardAllowedTypes, tmnxHwAssetID=tmnxHwAssetID, tmnxChassisMinorLEDState=tmnxChassisMinorLEDState, tmnxEqPowerSupplyRemoved=tmnxEqPowerSupplyRemoved, tmnxEqSyncIfTimingRef1AlarmClear=tmnxEqSyncIfTimingRef1AlarmClear, tmnxChassis7750V6v0Compliance=tmnxChassis7750V6v0Compliance, tmnxCpmFlashFirmwareRevision=tmnxCpmFlashFirmwareRevision, tmnxChassisAdminValueObjs=tmnxChassisAdminValueObjs, tmnxEqMdaCfgNotCompatible=tmnxEqMdaCfgNotCompatible, tmnxRedSecondaryCPMStatus=tmnxRedSecondaryCPMStatus, tmnxMdaTypeDescription=tmnxMdaTypeDescription, tmnxChassisNotifySoftwareLocation=tmnxChassisNotifySoftwareLocation, tmnxHwMfgBoardNumber=tmnxHwMfgBoardNumber, tmnxChassisV4v0Compliance=tmnxChassisV4v0Compliance, TmnxAlarmState=TmnxAlarmState, tmnxChassisNumFans=tmnxChassisNumFans, tmnxHwName=tmnxHwName, tmnxSyncIfTimingEntry=tmnxSyncIfTimingEntry, tmnxCpmFlashUsed=tmnxCpmFlashUsed, tmnxCcagPathRate=tmnxCcagPathRate, tmnxChassisFanTable=tmnxChassisFanTable, tmnxMDAEquippedPorts=tmnxMDAEquippedPorts, tmnxMcmTypeDescription=tmnxMcmTypeDescription, tmnxMDAEgrNamedPoolPolicy=tmnxMDAEgrNamedPoolPolicy, tmnxChassisNotification=tmnxChassisNotification, tmnxCpmCardConfigLastSaved=tmnxCpmCardConfigLastSaved, tmnxSyncIfTimingBITSIfType=tmnxSyncIfTimingBITSIfType, tmnxCpmCardTable=tmnxCpmCardTable, tmnxCcmEntry=tmnxCcmEntry, tmnxCardTypeStatus=tmnxCardTypeStatus, tmnxSyncIfTimingRef2SrcHw=tmnxSyncIfTimingRef2SrcHw, tmnxCcagPathCcType=tmnxCcagPathCcType, tmnxChassisGroups=tmnxChassisGroups, tmnxCpmCardConfigBootedVersion=tmnxCpmCardConfigBootedVersion, tmnxChassisV5v0ObsoleteGroup=tmnxChassisV5v0ObsoleteGroup, tSyncIfTimingAdmRefOrder3=tSyncIfTimingAdmRefOrder3)

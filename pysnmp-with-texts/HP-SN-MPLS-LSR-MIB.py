#
# PySNMP MIB module HP-SN-MPLS-LSR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-SN-MIBS
# Produced by pysmi-0.3.4 at Wed May  1 13:36:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
MplsLSPID, MplsBitRate, MplsLabel, mplsMIB, MplsInitialCreationSource, MplsBurstSize = mibBuilder.importSymbols("HP-SN-MPLS-TC-MIB", "MplsLSPID", "MplsBitRate", "MplsLabel", "mplsMIB", "MplsInitialCreationSource", "MplsBurstSize")
snMpls, = mibBuilder.importSymbols("HP-SN-ROOT-MIB", "snMpls")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressIPv6, InetAddressIPv4, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddressIPv4", "InetAddressType")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Bits, MibIdentifier, TimeTicks, Integer32, NotificationType, Unsigned32, Gauge32, Counter64, iso, ObjectIdentity, Counter32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibIdentifier", "TimeTicks", "Integer32", "NotificationType", "Unsigned32", "Gauge32", "Counter64", "iso", "ObjectIdentity", "Counter32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity")
StorageType, TextualConvention, TruthValue, DisplayString, TimeStamp, RowPointer, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "TruthValue", "DisplayString", "TimeStamp", "RowPointer", "RowStatus")
mplsLsrMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2))
mplsLsrMIB.setRevisions(('2002-01-04 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsLsrMIB.setRevisionsDescriptions(('Initial revision, published as part of RFC XXXX.',))
if mibBuilder.loadTexts: mplsLsrMIB.setLastUpdated('200201041200Z')
if mibBuilder.loadTexts: mplsLsrMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsLsrMIB.setContactInfo(' Cheenu Srinivasan Postal: Parama Networks, Inc. 1030 Broad Street Shrewsbury, NJ 07702 Tel: +1-732-544-9120 x731 Email: cheenu@paramanet.com Arun Viswanathan Postal: Force10 Networks, Inc. 1440 McCarthy Blvd Milpitas, CA 95035 Tel: +1-408-571-3516 Email: arun@force10networks.com Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-244-3051 Email: tnadeau@cisco.com ')
if mibBuilder.loadTexts: mplsLsrMIB.setDescription('This MIB contains managed object definitions for the Multiprotocol Label Switching (MPLS) Router as defined in: Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, RFC 3031, January 2001.')
mplsLsrObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1))
mplsLsrNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 2))
mplsLsrNotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 2, 0))
mplsLsrConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3))
mplsInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1), )
if mibBuilder.loadTexts: mplsInterfaceConfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfTable.setDescription('This table specifies per-interface MPLS capability and associated information.')
mplsInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsInterfaceConfIndex"))
if mibBuilder.loadTexts: mplsInterfaceConfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfEntry.setDescription('An entry in this table is created by an LSR for every interface capable of supporting MPLS. Each entry in this table will exist only if a corresponding entry in ifTable exists. If the associated entry in ifTable is deleted, the corresponding entry in this table must also be deleted shortly thereafter. The entry with index 0 represents the per-platform label space and contains parameters that apply to all interfaces that participate in the per-platform label space. Other entries defined in this table represent additional MPLS interfaces that may participate in either the per-platform or per-interface label spaces, or both. Additional information about label space participation of an interface is provided in the description clause of mplsInterfaceLabelParticipationType.')
mplsInterfaceConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setReference('RFC 2863 - The Interfaces Group MIB, McCloghrie, K., and F. Kastenholtz, June 2000')
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceConfIndex.setDescription('This is a unique index for an entry in the MplsInterfaceConfTable. A non-zero index for an entry indicates the ifIndex for the corresponding interface entry in of the MPLS-layer in the ifTable. Note that the per-platform label space may apply to several interfaces, and therefore the configuration of the per-platform label space interface parameters will apply to all of the interfaces that are participating in the per-platform label space.')
mplsInterfaceLabelMinIn = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 2), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinIn.setDescription('This is the minimum value of an MPLS label that this LSR is willing to receive on this interface.')
mplsInterfaceLabelMaxIn = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 3), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxIn.setDescription('This is the maximum value of an MPLS label that this LSR is willing to receive on this interface.')
mplsInterfaceLabelMinOut = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 4), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMinOut.setDescription('This is the minimum value of an MPLS label that this LSR is willing to send on this interface.')
mplsInterfaceLabelMaxOut = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 5), MplsLabel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelMaxOut.setDescription('This is the maximum value of an MPLS label that this LSR is willing to send on this interface.')
mplsInterfaceTotalBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 6), MplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceTotalBandwidth.setDescription('This value indicates the total amount of usable bandwidth on this interface and is specified in kilobits per second (Kbps). This variable is not applicable when applied to the interface with index 0. When this value cannot be measured, this value should contain the nominal bandwidth.')
mplsInterfaceAvailableBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 7), MplsBitRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceAvailableBandwidth.setDescription('This value indicates the total amount of available bandwidth available on this interface and is specified in kilobits per second (Kbps). This value is calculated as the difference between the amount of bandwidth currently in use and that specified in mplsInterfaceTotalBandwidth. This variable is not applicable when applied to the interface with index 0. When this value cannot be measured, this value should contain the nominal bandwidth.')
mplsInterfaceLabelParticipationType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 1, 1, 8), Bits().clone(namedValues=NamedValues(("perPlatform", 0), ("perInterface", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setReference('Rosen, E., Viswanathan, A., and R. Callon, Multiprotocol Label Switching Architecture, RFC 3031, January 2001.')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceLabelParticipationType.setDescription('Either the perPlatform(0) or perInterface(1) bit MUST be set. If the value of the mplsInterfaceConfIndex for this entry is zero, then only the perPlatform(0) bit MUST be set and the perInterface(1) bit is meaningless. If the perInterface(1) bit is set then the value of mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn, mplsInterfaceLabelMinOut, and mplsInterfaceLabelMaxOut for this entry reflect the label ranges for this interface. If only the perPlatform(0) bit is set, then the value of mplsInterfaceLabelMinIn, mplsInterfaceLabelMaxIn, mplsInterfaceLabelMinOut, and mplsInterfaceLabelMaxOut for this entry must be identical to the instance of these objects with index 0.')
mplsInterfacePerfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2), )
if mibBuilder.loadTexts: mplsInterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfTable.setDescription('This table provides MPLS performance information on a per-interface basis.')
mplsInterfacePerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2, 1), )
mplsInterfaceConfEntry.registerAugmentions(("HP-SN-MPLS-LSR-MIB", "mplsInterfacePerfEntry"))
mplsInterfacePerfEntry.setIndexNames(*mplsInterfaceConfEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInterfacePerfEntry.setDescription('An entry in this table is created by the LSR for every interface capable of supporting MPLS. Its is an extension to the mplsInterfaceConfEntry table.')
mplsInterfaceInLabelsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceInLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceInLabelsUsed.setDescription('This object counts the number of labels that are in use at this point in time on this interface in the incoming direction. If the interface participates in the per-platform label space only, then this instance of this object MUST be identical with the instance with index 0. If the interface participates in the per-interface label space, then this instance of this object MUST represent the number of of per- interface labels that are in use at this point in time on this interface.')
mplsInterfaceFailedLabelLookup = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceFailedLabelLookup.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceFailedLabelLookup.setDescription('This object counts the number of labeled packets that have been received on this interface and were discarded because there was no matching cross- connect entry. This object MUST count on a per- interface basis regardless of which label space the interface participates in.')
mplsInterfaceOutLabelsUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutLabelsUsed.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutLabelsUsed.setDescription('This object counts the number of top-most labels in the outgoing label stacks that are in use at this point in time on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
mplsInterfaceOutFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInterfaceOutFragments.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceOutFragments.setDescription('This object counts the number of outgoing MPLS packets that required fragmentation before transmission on this interface. This object MUST count on a per-interface basis regardless of which label space the interface participates in.')
mplsInSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3), )
if mibBuilder.loadTexts: mplsInSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTable.setDescription('This table contains a collection of incoming segments to an LSR.')
mplsInSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsInSegmentIfIndex"), (0, "HP-SN-MPLS-LSR-MIB", "mplsInSegmentLabel"))
if mibBuilder.loadTexts: mplsInSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentEntry.setDescription('An entry in this table represents one incoming segment. An entry can be created by a network administrator or an SNMP agent, or an MPLS signaling protocol. The creator of the entry is denoted by mplsInSegmentOwner. An entry in this table is indexed by the ifIndex of the incoming interface and the (top) label. The value of mplsInSegmentRowStatus cannot be active(1)unless the ifTable entry corresponding to mplsInSegmentIfIndex exists.')
mplsInSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsInSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentIfIndex.setDescription('This is a unique index for an entry in the MplsInSegmentTable. This value represents the interface index for the incoming MPLS interface. A value of zero represents an incoming label from the per-platform label space. In this case, the mplsInSegmentLabel is interpreted to be an MPLS-type label.')
mplsInSegmentLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 2), MplsLabel())
if mibBuilder.loadTexts: mplsInSegmentLabel.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentLabel.setDescription('The incoming label for this segment.')
mplsInSegmentNPop = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentNPop.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentNPop.setDescription('The number of labels to pop from the incoming packet. Normally only the top label is popped from the packet and used for all switching decisions for that packet. Note that technologies which do not support label popping should set this value to its default value of 1. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentAddrFamily = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 4), AddressFamilyNumbers().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentAddrFamily.setDescription('The IANA address family [IANAFamily] of the incoming packet. A value of other(0) indicates that the family type is either unknown or undefined. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross- connect entry this segment is part of. A value of zero indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this in-segment is a part of, this object is automatically updated to reflect the value of mplsXCIndex of that cross-connect entry.')
mplsInSegmentOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 6), MplsInitialCreationSource().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOwner.setDescription('Denotes the entity that created and is responsible for managing this segment. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 7), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this in-segment. This value may point at an entry in the mplsTrafficParamTable to indicate which mplsTrafficParamEntry is to be assigned to this segment. This value may optionally point at an externally defined traffic parameter specification table. A value of zero-dot-zero indicates best-effort treatment. By having the same value of this object, two or more segments can indicate resource sharing. This object cannot be modified if mplsInSegmentRowStatus is active(1).')
mplsInSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentRowStatus.setDescription('This variable is used to create, modify, and/or delete a row in this table.')
mplsInSegmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 3, 1, 9), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsInSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentStorageType.setDescription('This variable indicates the storage type for this object. This object cannot be modified if mplsInSegmentRowStatus is active(1). If this variable is set to readOnly(5), and the corresponding TFIB entry is removed, then the agent must remove this row shortly thereafter.')
mplsInSegmentPerfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4), )
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfTable.setDescription('This table contains statistical information for incoming MPLS segments to an LSR.')
mplsInSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1), )
mplsInSegmentEntry.registerAugmentions(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentPerfEntry"))
mplsInSegmentPerfEntry.setIndexNames(*mplsInSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one incoming segment which was configured in the mplsInSegmentTable. The counters in this entry should behave in a manner similar to that of the interface.')
mplsInSegmentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentOctets.setDescription('This value represents the total number of octets received by this segment.')
mplsInSegmentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPackets.setDescription('Total number of packets received by this segment.')
mplsInSegmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentErrors.setDescription('The number of errored packets received on this segment.')
mplsInSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentDiscards.setDescription('The number of labeled packets received on this in- segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
mplsInSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentHCOctets.setDescription('The total number of octets received. This is the 64 bit version of mplsInSegmentOctets.')
mplsInSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
mplsOutSegmentIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndexNext.setDescription('This object contains the next appropriate value to be used for mplsOutSegmentIndex when creating entries in the mplsOutSegmentTable. If the number of unassigned entries is exhausted, this object will take on the value of 0. To obtain the mplsOutSegmentIndex value for a new entry, the manager must first issue a management protocol retrieval operation to obtain the current value of this object. The agent should modify the value to reflect the next unassigned index after each retrieval operation. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsOutSegmentTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6), )
if mibBuilder.loadTexts: mplsOutSegmentTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTable.setDescription('This table contains a representation of the outgoing segments from an LSR.')
mplsOutSegmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsOutSegmentIndex"))
if mibBuilder.loadTexts: mplsOutSegmentEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentEntry.setDescription('An entry in this table represents one outgoing segment. An entry can be created by a network administrator or an SNMP agent, or an MPLS signaling protocol. The object mplsOutSegmentOwner indicates the creator of this entry. The value of mplsOutSegmentRowStatus cannot be active(1)unless the ifTable entry corresponding to mplsOutSegmentIfIndex exists.')
mplsOutSegmentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: mplsOutSegmentIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIndex.setDescription('This value contains a unique index for this row. While a value of 0 is not valid as an index for this row it can be supplied as a valid value to index mplsXCTable to access entries for which no out- segment has been configured.')
mplsOutSegmentIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentIfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentIfIndex.setDescription('This value must contain the interface index of the outgoing interface. This object may only take the value of 0 during the create-and-wait row creation operation if the management station has not yet set the value of this object. This object cannot be modified if mplsOutSegmentRowStatus is active(1). The mplsOutSegmentRowStatus cannot be set to active(1) until this object is set to a value corresponding to a valid ifEntry.')
mplsOutSegmentPushTopLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 3), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPushTopLabel.setDescription("This value indicates whether or not a top label should be pushed onto the outgoing packet's label stack. The value of this variable MUST be set to true if the outgoing interface does not support pop- and-go (for example an ATM interface) or if it is a tunnel origination. Note that it is considered an error in the case that mplsOutSegmentPushTopLabel is set to false, but the cross-connect entry which refers to this out-segment has a non-zero mplsLabelStackIndex. The LSR MUST ensure that this situation does not happen. This object cannot be modified if mplsOutSegmentRowStatus is active(1).")
mplsOutSegmentTopLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 4), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTopLabel.setDescription("If mplsOutSegmentPushTopLabel is true then this represents the label that should be pushed onto the top of the outgoing packet's label stack. Otherwise this value SHOULD be set to 0 by the management station and MUST be ignored by the agent. This object cannot be modified if mplsOutSegmentRowStatus is active(1).")
mplsOutSegmentNextHopIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 5), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpAddrType.setDescription('Indicates whether the next hop address is IPv4 or IPv6. Note that a value of unknown (0) is valid only when the outgoing interface is of type point-to- point. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentNextHopIpv4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 6), InetAddressIPv4()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv4Addr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv4Addr.setDescription('IPv4 Address of the next hop. Its value is significant only when mplsOutSegmentNextHopIpAddrType is ipV4 (1), otherwise it SHOULD return a value of 0. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentNextHopIpv6Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 7), InetAddressIPv6()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv6Addr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentNextHopIpv6Addr.setDescription('IPv6 address of the next hop. Its value is significant only when mplsOutSegmentNextHopIpAddrType is ipV6 (2), otherwise it SHOULD return a value of 0. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentXCIndex.setDescription('Index into mplsXCTable which identifies which cross- connect entry this segment is part of. A value of zero indicates that this entry is not referred to by any cross-connect entry. When a cross-connect entry is created which this out-segment is a part of, this object is automatically updated to reflect the value of mplsXCIndex of that cross-connect entry.')
mplsOutSegmentOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 9), MplsInitialCreationSource().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentOwner.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOwner.setDescription('Denotes the entity which created and is responsible for managing this segment. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentTrafficParamPtr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 10), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentTrafficParamPtr.setDescription('This variable represents a pointer to the traffic parameter specification for this out-segment. This value may point at an entry in the mplsTrafficParamTable to indicate which mplsTrafficParamEntry is to be assigned to this segment. This value may optionally point at an externally defined traffic parameter specification table. A value of zero-dot-zero indicates best- effort treatment. By having the same value of this object, two or more segments can indicate resource sharing. This object cannot be modified if mplsOutSegmentRowStatus is active(1).')
mplsOutSegmentRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsOutSegmentStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 6, 1, 12), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentStorageType.setDescription('This variable indicates the storage type for this object. This object cannot be modified if mplsOutSegmentRowStatus is active(1). If this variable is set to readOnly(5), and the corresponding TFIB entry is removed, then the agent must remove this row shortly thereafter.')
mplsOutSegmentPerfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7), )
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfTable.setDescription('This table contains statistical information about outgoing segments from an LSR. The counters in this entry should behave in a manner similar to that of the interface.')
mplsOutSegmentPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1), )
mplsOutSegmentEntry.registerAugmentions(("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentPerfEntry"))
mplsOutSegmentPerfEntry.setIndexNames(*mplsOutSegmentEntry.getIndexNames())
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfEntry.setDescription('An entry in this table contains statistical information about one outgoing segment configured in mplsOutSegmentTable.')
mplsOutSegmentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentOctets.setDescription('This value contains the total number of octets sent on this segment.')
mplsOutSegmentPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPackets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPackets.setDescription('This value contains the total number of packets sent on this segment.')
mplsOutSegmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentErrors.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentErrors.setDescription('Number of packets that could not be sent due to errors on this segment.')
mplsOutSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentDiscards.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentDiscards.setDescription('The number of labeled packets received on this out- segment, which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a labeled packet could be to free up buffer space.')
mplsOutSegmentHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentHCOctets.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentHCOctets.setDescription('Total number of octets sent. This is the 64 bit version of mplsOutSegmentOctets.')
mplsOutSegmentPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 7, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this segment's Counter32 or Counter64 suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
mplsXCIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndexNext.setDescription('This object contains an appropriate value to be used for mplsXCIndex when creating entries in the mplsXCTable. The value 0 indicates that no unassigned entries are available. To obtain the value of mplsXCIndex for a new entry in the mplsXCTable, the manager issues a management protocol retrieval operation to obtain the current value of mplsXCIndex. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsXCTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9), )
if mibBuilder.loadTexts: mplsXCTable.setStatus('current')
if mibBuilder.loadTexts: mplsXCTable.setDescription('This table specifies information for switching between LSP segments. It supports point-to-point, point-to-multipoint and multipoint-to-point connections. mplsLabelStackTable specifies the label stack information for a cross-connect LSR and is referred to from mplsXCTable.')
mplsXCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsXCIndex"), (0, "HP-SN-MPLS-LSR-MIB", "mplsInSegmentIfIndex"), (0, "HP-SN-MPLS-LSR-MIB", "mplsInSegmentLabel"), (0, "HP-SN-MPLS-LSR-MIB", "mplsOutSegmentIndex"))
if mibBuilder.loadTexts: mplsXCEntry.setStatus('current')
if mibBuilder.loadTexts: mplsXCEntry.setDescription('A row in this table represents one cross-connect entry. The following objects index it: - cross-connect index mplsXCIndex that uniquely identifies a group of cross-connect entries - interface index of the in-segment, mplsInSegmentIfIndex - incoming label(s), mplsInSegmentLabel - out-segment index, mplsOutSegmentIndex Originating LSPs: These are represented by using the special combination of values mplsInSegmentIfIndex=0 and mplsInSegmentLabel=0 as indexes. In this case the mplsOutSegmentIndex MUST be non-zero. Terminating LSPs: These are represented by using the special value mplsOutSegmentIndex=0 as index. Special labels: Entries indexed by reserved MPLS label values 0 through 15 imply terminating LSPs and MUST have mplsOutSegmentIfIndex = 0. Note that situations where LSPs are terminated with incoming label equal to 0, should have mplsInSegmentIfIndex = 0 as well, but can be distinguished from originating LSPs because the mplsOutSegmentIfIndex = 0. The mplsOutSegmentIfIndex MUST only be set to 0 in cases of terminating LSPs. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
mplsXCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsXCIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCIndex.setDescription('Primary index for the conceptual row identifying a group of cross-connect segments.')
mplsXCLspId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 2), MplsLSPID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLspId.setStatus('current')
if mibBuilder.loadTexts: mplsXCLspId.setDescription('This value identifies the label switched path that this cross-connect entry belongs to. This object cannot be modified if mplsXCRowStatus is active(1).')
mplsXCLabelStackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsXCLabelStackIndex.setDescription('Primary index into mplsLabelStackTable identifying a stack of labels to be pushed beneath the top label. Note that the top label identified by the out- segment ensures that all the components of a multipoint-to-point connection have the same outgoing label. A value of 0 indicates that no labels are to be stacked beneath the top label. This object cannot be modified if mplsXCRowStatus is active(1).')
mplsXCIsPersistent = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCIsPersistent.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsPersistent.setDescription('Denotes whether or not this cross-connect entry and associated in- and out-segments should be restored automatically after failures. This value MUST be set to false in cases where this cross-connect entry was created by a signaling protocol. This object cannot be modified if mplsXCRowStatus is active(1).')
mplsXCOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 5), MplsInitialCreationSource()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCOwner.setStatus('current')
if mibBuilder.loadTexts: mplsXCOwner.setDescription('Denotes the entity that created and is responsible for managing this cross-connect. This object cannot be modified if mplsXCRowStatus is active(1).')
mplsXCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsXCStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 7), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsXCStorageType.setDescription('Defines the storage type for this object. This object cannot be modified if mplsXCRowStatus is active(1). If this variable is set to readOnly(5), and the corresponding TFIB entry is removed, then the agent must remove this row shortly thereafter.')
mplsXCAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsXCAdminStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCAdminStatus.setDescription('The desired operational status of this segment.')
mplsXCOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 9, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ("unknown", 4), ("dormant", 5), ("notPresent", 6), ("lowerLayerDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsXCOperStatus.setStatus('current')
if mibBuilder.loadTexts: mplsXCOperStatus.setDescription('The actual operational status of this cross- connect.')
mplsMaxLabelStackDepth = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setStatus('current')
if mibBuilder.loadTexts: mplsMaxLabelStackDepth.setDescription('The maximum stack depth supported by this LSR.')
mplsLabelStackIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndexNext.setDescription('This object contains an appropriate value to be used for mplsLabelStackIndex when creating entries in the mplsLabelStackTable. The value 0 indicates that no unassigned entries are available. To obtain an mplsLabelStackIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsLabelStackTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12), )
if mibBuilder.loadTexts: mplsLabelStackTable.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackTable.setDescription('This table specifies the label stack to be pushed onto a packet, beneath the top label. Entries into this table are referred to from mplsXCTable.')
mplsLabelStackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsLabelStackIndex"), (0, "HP-SN-MPLS-LSR-MIB", "mplsLabelStackLabelIndex"))
if mibBuilder.loadTexts: mplsLabelStackEntry.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackEntry.setDescription('An entry in this table represents one label which is to be pushed onto an outgoing packet, beneath the top label. An entry can be created by a network administrator or by an SNMP agent as instructed by an MPLS signaling protocol.')
mplsLabelStackIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLabelStackIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackIndex.setDescription('Primary index for this row identifying a stack of labels to be pushed on an outgoing packet, beneath the top label.')
mplsLabelStackLabelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabelIndex.setDescription('Secondary index for this row identifying one label of the stack. Note that an entry with a smaller mplsLabelStackLabelIndex would refer to a label higher up the label stack and would be popped at a downstream LSR before a label represented by a higher mplsLabelStackLabelIndex at a downstream LSR.')
mplsLabelStackLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1, 3), MplsLabel()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackLabel.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackLabel.setDescription('The label to pushed.')
mplsLabelStackRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsLabelStackStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 12, 1, 5), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLabelStackStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackStorageType.setDescription('Defines the storage type for this object. If this variable is set to readOnly(5), and the corresponding TFIB entry is removed, then the agent must remove this row shortly thereafter.')
mplsTrafficParamIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsTrafficParamIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamIndexNext.setDescription('This object contains an appropriate value which will be used for mplsTrafficParamIndex when creating entries in the mplsTrafficParamTable. The value 0 indicates that no unassigned entries are available. To obtain the mplsTrafficParamIndex value for a new entry, the manager issues a management protocol retrieval operation to obtain the current value of this object. After each retrieval operation, the agent should modify the value to reflect the next unassigned index. After a manager retrieves a value the agent will determine through its local policy when this index value will be made available for reuse.')
mplsTrafficParamTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14), )
if mibBuilder.loadTexts: mplsTrafficParamTable.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamTable.setDescription('This table specifies the Traffic Parameter objects for in and out-segments.')
mplsTrafficParamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1), ).setIndexNames((0, "HP-SN-MPLS-LSR-MIB", "mplsTrafficParamIndex"))
if mibBuilder.loadTexts: mplsTrafficParamEntry.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamEntry.setDescription('An entry in this table represents the TrafficParam objects for one or more in or out segments. A single entry can be pointed to by multiple segments indicating resource sharing.')
mplsTrafficParamIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mplsTrafficParamIndex.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamIndex.setDescription('Uniquely identifies this row of the table. Note that zero represents an invalid index.')
mplsTrafficParamMaxRate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 2), MplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMaxRate.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMaxRate.setDescription('Maximum rate in kilobits/second.')
mplsTrafficParamMeanRate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 3), MplsBitRate()).setUnits('kilobits per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMeanRate.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMeanRate.setDescription('Mean rate in kilobits/second.')
mplsTrafficParamMaxBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 4), MplsBurstSize()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamMaxBurstSize.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamMaxBurstSize.setDescription('Maximum burst size in bytes.')
mplsTrafficParamRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamRowStatus.setDescription('For creating, modifying, and deleting this row.')
mplsTrafficParamStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 14, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsTrafficParamStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamStorageType.setDescription('The storage type for this object. If this variable is set to readOnly(5), and the corresponding TFIB entry is removed, then the agent must remove this row shortly thereafter.')
mplsXCTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 1, 15), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsXCTrapEnable.setStatus('current')
if mibBuilder.loadTexts: mplsXCTrapEnable.setDescription('If this object is set to true(1), then it enables the emission of mplsXCUp and mplsXCDown notifications; otherwise these notifications are not emitted.')
mplsXCUp = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 2, 0, 1)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCOperStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCUp.setStatus('current')
if mibBuilder.loadTexts: mplsXCUp.setDescription('This notification is generated when the mplsXCOperStatus object for one or more contiguous entries in mplsXCTable are about to enter the up(1) state from some other. The included values of mplsXCOperStatus MUST both be set equal to this other state. The two instances of mplsXCOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the up(1) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two mplsXCOperStatus objects MUST be the identical.')
mplsXCDown = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 2, 0, 2)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCOperStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsXCOperStatus"))
if mibBuilder.loadTexts: mplsXCDown.setStatus('current')
if mibBuilder.loadTexts: mplsXCDown.setDescription(' This notification is generated when the mplsXCOperStatus object for one or more contiguous entries in mplsXCTable are about to enter the down(2) state from some other. The included values of mplsXCOperStatus MUST both be set equal to this other state. The two instances of mplsXCOperStatus in this notification indicate the range of indexes that are affected. Note that all the indexes of the two ends of the range can be derived from the instance identifiers of these two objects. For cases where a contiguous range of cross-connects have transitioned into the down(2) state at roughly the same time, the device SHOULD issue a single notification for each range of contiguous indexes in an effort to minimize the emission of a large number of notifications. If a notification has to be issued for just a single cross-connect entry, then the instance identifier (and values) of the two mplsXCOperStatus objects MUST be the identical.')
mplsLsrGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1))
mplsLsrCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 2))
mplsLsrModuleCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 2, 1)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsXCGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsPerfGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsSegmentDiscontinuityGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsHCInSegmentPerfGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsHCOutSegmentPerfGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsXCIsPersistentGroup"), ("HP-SN-MPLS-LSR-MIB", "mplsXCIsNotPersistentGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrModuleCompliance = mplsLsrModuleCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsLsrModuleCompliance.setDescription('Compliance statement for agents that support the MPLS LSR MIB.')
mplsInterfaceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 1)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInterfaceLabelMinIn"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceLabelMaxIn"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceLabelMinOut"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceLabelMaxOut"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceTotalBandwidth"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceAvailableBandwidth"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceLabelParticipationType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInterfaceGroup = mplsInterfaceGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInterfaceGroup.setDescription('Collection of objects needed for MPLS interface configuration and performance information.')
mplsInSegmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 2)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentNPop"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentAddrFamily"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentXCIndex"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentOctets"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentDiscards"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentOwner"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentRowStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentStorageType"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsInSegmentGroup = mplsInSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsInSegmentGroup.setDescription('Collection of objects needed to implement an in- segment.')
mplsOutSegmentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 3)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentIndexNext"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentIfIndex"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentPushTopLabel"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentTopLabel"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentNextHopIpAddrType"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentNextHopIpv4Addr"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentNextHopIpv6Addr"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentXCIndex"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentOwner"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentOctets"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentDiscards"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentErrors"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentRowStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentStorageType"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentTrafficParamPtr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsOutSegmentGroup = mplsOutSegmentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsOutSegmentGroup.setDescription('Collection of objects needed to implement an out- segment.')
mplsXCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 4)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCIndexNext"), ("HP-SN-MPLS-LSR-MIB", "mplsXCLabelStackIndex"), ("HP-SN-MPLS-LSR-MIB", "mplsXCOwner"), ("HP-SN-MPLS-LSR-MIB", "mplsXCAdminStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsXCOperStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsXCRowStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsXCTrapEnable"), ("HP-SN-MPLS-LSR-MIB", "mplsXCStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCGroup = mplsXCGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCGroup.setDescription('Collection of objects needed to implement a cross-connect entry.')
mplsXCOptionalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 5)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCLspId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCOptionalGroup = mplsXCOptionalGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCOptionalGroup.setDescription('Collection of optional objects for implementing a cross-connect entry.')
mplsPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 6)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentOctets"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentPackets"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentErrors"), ("HP-SN-MPLS-LSR-MIB", "mplsInSegmentDiscards"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentOctets"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentPackets"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentDiscards"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceInLabelsUsed"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceFailedLabelLookup"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceOutFragments"), ("HP-SN-MPLS-LSR-MIB", "mplsInterfaceOutLabelsUsed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsPerfGroup = mplsPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsPerfGroup.setDescription('Collection of objects providing performance information about an LSR.')
mplsHCInSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 7)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCInSegmentPerfGroup = mplsHCInSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCInSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object mplsInterfaceInOctets wraps around too quickly.')
mplsHCOutSegmentPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 8)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentHCOctets"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsHCOutSegmentPerfGroup = mplsHCOutSegmentPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsHCOutSegmentPerfGroup.setDescription('Object(s) providing performance information specific to out-segments for which the object mplsInterfaceOutOctets wraps around too quickly.')
mplsTrafficParamGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 9)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamIndexNext"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamMaxRate"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamMeanRate"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamMaxBurstSize"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamRowStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsTrafficParamStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsTrafficParamGroup = mplsTrafficParamGroup.setStatus('current')
if mibBuilder.loadTexts: mplsTrafficParamGroup.setDescription('Object(s) required for supporting QoS resource reservation.')
mplsXCIsPersistentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 10)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCIsPersistentGroup = mplsXCIsPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsPersistentGroup.setDescription('Objects needed to support persistent cross- connects.')
mplsXCIsNotPersistentGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 11)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCIsPersistent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsXCIsNotPersistentGroup = mplsXCIsNotPersistentGroup.setStatus('current')
if mibBuilder.loadTexts: mplsXCIsNotPersistentGroup.setDescription('Objects needed to support non-persistent cross- connects.')
mplsLabelStackGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 12)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsLabelStackLabel"), ("HP-SN-MPLS-LSR-MIB", "mplsLabelStackRowStatus"), ("HP-SN-MPLS-LSR-MIB", "mplsLabelStackStorageType"), ("HP-SN-MPLS-LSR-MIB", "mplsMaxLabelStackDepth"), ("HP-SN-MPLS-LSR-MIB", "mplsLabelStackIndexNext"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLabelStackGroup = mplsLabelStackGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLabelStackGroup.setDescription('Objects needed to support label stacking.')
mplsSegmentDiscontinuityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 13)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsInSegmentPerfDiscontinuityTime"), ("HP-SN-MPLS-LSR-MIB", "mplsOutSegmentPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsSegmentDiscontinuityGroup = mplsSegmentDiscontinuityGroup.setStatus('current')
if mibBuilder.loadTexts: mplsSegmentDiscontinuityGroup.setDescription(' A collection of objects providing information specific to segment discontinuities..')
mplsLsrNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 3, 7, 11, 12, 2, 15, 15, 2, 3, 1, 14)).setObjects(("HP-SN-MPLS-LSR-MIB", "mplsXCUp"), ("HP-SN-MPLS-LSR-MIB", "mplsXCDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsLsrNotificationGroup = mplsLsrNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: mplsLsrNotificationGroup.setDescription('Set of notifications implemented in this module. None is mandatory.')
mibBuilder.exportSymbols("HP-SN-MPLS-LSR-MIB", mplsInSegmentErrors=mplsInSegmentErrors, mplsOutSegmentErrors=mplsOutSegmentErrors, mplsXCEntry=mplsXCEntry, mplsOutSegmentRowStatus=mplsOutSegmentRowStatus, mplsXCIndex=mplsXCIndex, mplsInterfaceLabelMaxOut=mplsInterfaceLabelMaxOut, mplsOutSegmentNextHopIpAddrType=mplsOutSegmentNextHopIpAddrType, mplsLabelStackStorageType=mplsLabelStackStorageType, mplsTrafficParamRowStatus=mplsTrafficParamRowStatus, mplsInSegmentStorageType=mplsInSegmentStorageType, mplsHCInSegmentPerfGroup=mplsHCInSegmentPerfGroup, mplsInterfaceFailedLabelLookup=mplsInterfaceFailedLabelLookup, mplsInSegmentDiscards=mplsInSegmentDiscards, mplsXCOwner=mplsXCOwner, mplsInSegmentPerfEntry=mplsInSegmentPerfEntry, mplsOutSegmentNextHopIpv4Addr=mplsOutSegmentNextHopIpv4Addr, mplsInterfaceOutLabelsUsed=mplsInterfaceOutLabelsUsed, mplsOutSegmentNextHopIpv6Addr=mplsOutSegmentNextHopIpv6Addr, mplsInterfaceConfTable=mplsInterfaceConfTable, mplsXCOperStatus=mplsXCOperStatus, mplsOutSegmentOctets=mplsOutSegmentOctets, mplsXCTrapEnable=mplsXCTrapEnable, mplsInterfaceConfIndex=mplsInterfaceConfIndex, mplsLsrMIB=mplsLsrMIB, mplsLsrNotifications=mplsLsrNotifications, mplsInSegmentXCIndex=mplsInSegmentXCIndex, mplsHCOutSegmentPerfGroup=mplsHCOutSegmentPerfGroup, mplsInterfaceGroup=mplsInterfaceGroup, mplsLsrConformance=mplsLsrConformance, mplsTrafficParamGroup=mplsTrafficParamGroup, mplsXCUp=mplsXCUp, mplsInterfaceLabelMaxIn=mplsInterfaceLabelMaxIn, mplsXCIsPersistentGroup=mplsXCIsPersistentGroup, mplsInterfaceLabelMinIn=mplsInterfaceLabelMinIn, mplsTrafficParamStorageType=mplsTrafficParamStorageType, mplsLsrGroups=mplsLsrGroups, mplsXCAdminStatus=mplsXCAdminStatus, mplsInSegmentPerfTable=mplsInSegmentPerfTable, mplsInterfaceLabelParticipationType=mplsInterfaceLabelParticipationType, mplsXCIndexNext=mplsXCIndexNext, mplsTrafficParamMaxRate=mplsTrafficParamMaxRate, mplsLsrNotifyPrefix=mplsLsrNotifyPrefix, mplsLabelStackGroup=mplsLabelStackGroup, mplsInSegmentPackets=mplsInSegmentPackets, mplsOutSegmentStorageType=mplsOutSegmentStorageType, mplsTrafficParamIndex=mplsTrafficParamIndex, mplsInSegmentTrafficParamPtr=mplsInSegmentTrafficParamPtr, mplsOutSegmentEntry=mplsOutSegmentEntry, mplsXCIsPersistent=mplsXCIsPersistent, mplsTrafficParamIndexNext=mplsTrafficParamIndexNext, mplsInterfaceOutFragments=mplsInterfaceOutFragments, mplsLabelStackLabelIndex=mplsLabelStackLabelIndex, mplsInSegmentEntry=mplsInSegmentEntry, mplsOutSegmentIndexNext=mplsOutSegmentIndexNext, mplsXCLspId=mplsXCLspId, mplsInSegmentGroup=mplsInSegmentGroup, mplsOutSegmentHCOctets=mplsOutSegmentHCOctets, mplsXCRowStatus=mplsXCRowStatus, mplsOutSegmentIndex=mplsOutSegmentIndex, mplsXCLabelStackIndex=mplsXCLabelStackIndex, mplsLabelStackIndexNext=mplsLabelStackIndexNext, mplsXCStorageType=mplsXCStorageType, mplsXCDown=mplsXCDown, mplsOutSegmentTrafficParamPtr=mplsOutSegmentTrafficParamPtr, mplsInSegmentRowStatus=mplsInSegmentRowStatus, mplsLabelStackRowStatus=mplsLabelStackRowStatus, mplsInSegmentOwner=mplsInSegmentOwner, mplsLabelStackTable=mplsLabelStackTable, mplsLsrNotificationGroup=mplsLsrNotificationGroup, mplsOutSegmentXCIndex=mplsOutSegmentXCIndex, mplsTrafficParamMeanRate=mplsTrafficParamMeanRate, mplsInterfacePerfEntry=mplsInterfacePerfEntry, mplsTrafficParamEntry=mplsTrafficParamEntry, mplsMaxLabelStackDepth=mplsMaxLabelStackDepth, mplsOutSegmentPerfTable=mplsOutSegmentPerfTable, mplsSegmentDiscontinuityGroup=mplsSegmentDiscontinuityGroup, mplsInSegmentPerfDiscontinuityTime=mplsInSegmentPerfDiscontinuityTime, mplsInSegmentLabel=mplsInSegmentLabel, mplsLsrCompliances=mplsLsrCompliances, mplsOutSegmentOwner=mplsOutSegmentOwner, mplsInterfaceConfEntry=mplsInterfaceConfEntry, mplsLsrModuleCompliance=mplsLsrModuleCompliance, mplsOutSegmentPackets=mplsOutSegmentPackets, mplsXCOptionalGroup=mplsXCOptionalGroup, mplsPerfGroup=mplsPerfGroup, mplsOutSegmentPerfDiscontinuityTime=mplsOutSegmentPerfDiscontinuityTime, mplsLsrObjects=mplsLsrObjects, mplsInterfaceTotalBandwidth=mplsInterfaceTotalBandwidth, mplsXCGroup=mplsXCGroup, mplsOutSegmentPerfEntry=mplsOutSegmentPerfEntry, mplsInterfaceAvailableBandwidth=mplsInterfaceAvailableBandwidth, PYSNMP_MODULE_ID=mplsLsrMIB, mplsInSegmentOctets=mplsInSegmentOctets, mplsLabelStackIndex=mplsLabelStackIndex, mplsOutSegmentPushTopLabel=mplsOutSegmentPushTopLabel, mplsInterfaceInLabelsUsed=mplsInterfaceInLabelsUsed, mplsInSegmentTable=mplsInSegmentTable, mplsXCTable=mplsXCTable, mplsInterfaceLabelMinOut=mplsInterfaceLabelMinOut, mplsInSegmentAddrFamily=mplsInSegmentAddrFamily, mplsInterfacePerfTable=mplsInterfacePerfTable, mplsTrafficParamTable=mplsTrafficParamTable, mplsInSegmentHCOctets=mplsInSegmentHCOctets, mplsOutSegmentTopLabel=mplsOutSegmentTopLabel, mplsLabelStackEntry=mplsLabelStackEntry, mplsOutSegmentGroup=mplsOutSegmentGroup, mplsOutSegmentIfIndex=mplsOutSegmentIfIndex, mplsTrafficParamMaxBurstSize=mplsTrafficParamMaxBurstSize, mplsOutSegmentTable=mplsOutSegmentTable, mplsOutSegmentDiscards=mplsOutSegmentDiscards, mplsInSegmentIfIndex=mplsInSegmentIfIndex, mplsInSegmentNPop=mplsInSegmentNPop, mplsLabelStackLabel=mplsLabelStackLabel, mplsXCIsNotPersistentGroup=mplsXCIsNotPersistentGroup)

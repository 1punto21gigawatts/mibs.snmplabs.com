#
# PySNMP MIB module PSAMP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PSAMP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:42:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Unsigned64TC, = mibBuilder.importSymbols("APPLICATION-MIB", "Unsigned64TC")
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
Float64TC, = mibBuilder.importSymbols("FLOAT-TC-MIB", "Float64TC")
ipfixSelectorFunctions, = mibBuilder.importSymbols("IPFIX-SELECTOR-MIB", "ipfixSelectorFunctions")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
iso, TimeTicks, IpAddress, NotificationType, Unsigned32, Bits, Counter32, ObjectIdentity, Gauge32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, mib_2, MibIdentifier, ModuleIdentity, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "TimeTicks", "IpAddress", "NotificationType", "Unsigned32", "Bits", "Counter32", "ObjectIdentity", "Gauge32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "mib-2", "MibIdentifier", "ModuleIdentity", "Counter64")
TruthValue, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TextualConvention", "DisplayString")
psampMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 212))
psampMIB.setRevisions(('2012-09-05 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: psampMIB.setRevisionsDescriptions(('Initial version, published as RFC 6727.',))
if mibBuilder.loadTexts: psampMIB.setLastUpdated('201209051200Z')
if mibBuilder.loadTexts: psampMIB.setOrganization('IETF IPFIX Working Group')
if mibBuilder.loadTexts: psampMIB.setContactInfo('WG charter: http://datatracker.ietf.org/wg/ipfix/charter/ Mailing Lists: General Discussion: ipfix@ietf.org To Subscribe: https://www.ietf.org/mailman/listinfo/ipfix Archive: http://www.ietf.org/mail-archive/web/ipfix/current/maillist.html Thomas Dietz (editor) NEC Europe Ltd. NEC Laboratories Europe Network Research Division Kurfuersten-Anlage 36 69115 Heidelberg Germany Phone: +49 6221 4342-128 EMail: Thomas.Dietz@neclab.eu Benoit Claise Cisco Systems, Inc. De Kleetlaan 6a b1 Diegem 1831 Belgium Phone: +32 2 704 5622 EMail: bclaise@cisco.com Juergen Quittek NEC Europe Ltd. NEC Laboratories Europe Network Research Division Kurfuersten-Anlage 36 69115 Heidelberg Germany Phone: +49 6221 4342-115 EMail: quittek@neclab.eu')
if mibBuilder.loadTexts: psampMIB.setDescription("The PSAMP MIB defines managed objects for packet sampling and filtering. These objects provide information about managed nodes supporting packet sampling, including packet sampling capabilities, configuration, and statistics. The PSAMP MIB module registers additional top-level OIDs for the parameter subtrees of its Selector functions in the IPFIX-SELECTOR-MIB Function sub-registry according to the procedures defined in RFC 6615. Copyright (c) 2012 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). This version of this MIB module is part of RFC 6727; see the RFC itself for full legal notices.")
psampObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 212, 1))
psampConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 212, 2))
psampSampCountBased = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 2))
psampSampCountBasedAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampCountBasedAvail.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedAvail.setDescription('This object indicates the availability of systematic count-based sampling at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampSampCountBasedParamSetTable = MibTable((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 2), )
if mibBuilder.loadTexts: psampSampCountBasedParamSetTable.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedParamSetTable.setDescription('This table lists configurations of systematic count-based packet sampling. A parameter set describing a configuration contains two parameters: the sampling interval length and space.')
psampSampCountBasedParamSetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 2, 1), ).setIndexNames((0, "PSAMP-MIB", "psampSampCountBasedIndex"))
if mibBuilder.loadTexts: psampSampCountBasedParamSetEntry.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedParamSetEntry.setDescription('Defines an entry in the psampSampCountBasedParamSetTable.')
psampSampCountBasedIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: psampSampCountBasedIndex.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedIndex.setDescription('The index of this parameter set in the psampSampCountBasedParamSetTable. It is used in the object ipfixSelectionProcessSelectorFunction entries of the ipfixSelectionProcessTable in the IPFIX-MIB as reference to this parameter set.')
psampSampCountBasedInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 2, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampCountBasedInterval.setReference('RFC 5475 (Section 5.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampCountBasedInterval.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedInterval.setDescription('This object specifies the number of packets that are consecutively sampled. A value of 100 means that 100 consecutive packets are sampled.')
psampSampCountBasedSpace = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 2, 2, 1, 3), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampCountBasedSpace.setReference('RFC 5475 (Section 5.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampCountBasedSpace.setStatus('current')
if mibBuilder.loadTexts: psampSampCountBasedSpace.setDescription('This object specifies the number of packets between two intervals specified by the object psampSampCountBasedInterval. A value of 100 means that the next interval starts 100 packets (which are not sampled) after the current psampSampCountBasedInterval is over.')
psampSampTimeBased = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 3))
psampSampTimeBasedAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampTimeBasedAvail.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedAvail.setDescription('This object indicates the availability of systematic time-based sampling at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampSampTimeBasedParamSetTable = MibTable((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 2), )
if mibBuilder.loadTexts: psampSampTimeBasedParamSetTable.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedParamSetTable.setDescription('This table lists configurations of systematic time-based packet sampling. A parameter set describing a configuration contains two parameters: the sampling interval length and the space.')
psampSampTimeBasedParamSetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 2, 1), ).setIndexNames((0, "PSAMP-MIB", "psampSampTimeBasedIndex"))
if mibBuilder.loadTexts: psampSampTimeBasedParamSetEntry.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedParamSetEntry.setDescription('Defines an entry in the psampSampTimeBasedParamSetTable.')
psampSampTimeBasedIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: psampSampTimeBasedIndex.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedIndex.setDescription('The index of this parameter set in the psampSampTimeBasedParamSetTable. It is used in the object ipfixSelectionProcessSelectorFunction entries of the ipfixSelectionProcessTable in the IPFIX-MIB as reference to this parameter set.')
psampSampTimeBasedInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 2, 1, 2), Unsigned32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampTimeBasedInterval.setReference('RFC 5475 (Section 5.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampTimeBasedInterval.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedInterval.setDescription('This object specifies the time interval in microseconds during which all arriving packets are sampled.')
psampSampTimeBasedSpace = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 3, 2, 1, 3), Unsigned32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampTimeBasedSpace.setReference('RFC 5475 (Section 5.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampTimeBasedSpace.setStatus('current')
if mibBuilder.loadTexts: psampSampTimeBasedSpace.setDescription('This object specifies the time interval in microseconds between two intervals specified by the object psampSampTimeBasedInterval. A value of 100 means that the next interval starts 100 microseconds (during which no packets are sampled) after the current psampSampTimeBasedInterval is over.')
psampSampRandOutOfN = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 4))
psampSampRandOutOfNAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampRandOutOfNAvail.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNAvail.setDescription('This object indicates the availability of random n-out-of-N sampling at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampSampRandOutOfNParamSetTable = MibTable((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 2), )
if mibBuilder.loadTexts: psampSampRandOutOfNParamSetTable.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNParamSetTable.setDescription('This table lists configurations of random n-out-of-N sampling. A parameter set describing a configuration contains two parameters: the sampling size and the parent population.')
psampSampRandOutOfNParamSetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 2, 1), ).setIndexNames((0, "PSAMP-MIB", "psampSampRandOutOfNIndex"))
if mibBuilder.loadTexts: psampSampRandOutOfNParamSetEntry.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNParamSetEntry.setDescription('Defines an entry in the psampSampRandOutOfNParamSetTable.')
psampSampRandOutOfNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: psampSampRandOutOfNIndex.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNIndex.setDescription('The index of this parameter set in the psampSampRandOutOfNParamSetTable. It is used in the object ipfixSelectionProcessSelectorFunction entries of the ipfixSelectionProcessTable in the IPFIX-MIB as reference to this parameter set.')
psampSampRandOutOfNSize = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 2, 1, 2), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampRandOutOfNSize.setReference('RFC 5475 (Section 5.2.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampRandOutOfNSize.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNSize.setDescription('This object specifies the number of elements taken from the parent Population specified in psampSampRandOutOfNPopulation.')
psampSampRandOutOfNPopulation = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 4, 2, 1, 3), Unsigned32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampRandOutOfNPopulation.setReference('RFC 5475 (Section 5.2.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampRandOutOfNPopulation.setStatus('current')
if mibBuilder.loadTexts: psampSampRandOutOfNPopulation.setDescription('This object specifies the number of elements in the parent Population.')
psampSampUniProb = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 5))
psampSampUniProbAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 5, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampUniProbAvail.setStatus('current')
if mibBuilder.loadTexts: psampSampUniProbAvail.setDescription('This object indicates the availability of random uniform probabilistic sampling at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampSampUniProbParamSetTable = MibTable((1, 3, 6, 1, 2, 1, 194, 1, 1, 5, 2), )
if mibBuilder.loadTexts: psampSampUniProbParamSetTable.setStatus('current')
if mibBuilder.loadTexts: psampSampUniProbParamSetTable.setDescription('This table lists configurations of random probabilistic sampling. A parameter set describing a configuration contains a single parameter only: the sampling probability.')
psampSampUniProbParamSetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 194, 1, 1, 5, 2, 1), ).setIndexNames((0, "PSAMP-MIB", "psampSampUniProbIndex"))
if mibBuilder.loadTexts: psampSampUniProbParamSetEntry.setStatus('current')
if mibBuilder.loadTexts: psampSampUniProbParamSetEntry.setDescription('Defines an entry in the psampSampUniProbParamSetTable.')
psampSampUniProbIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: psampSampUniProbIndex.setStatus('current')
if mibBuilder.loadTexts: psampSampUniProbIndex.setDescription('The index of this parameter set in the psampSampUniProbParamSetTable. It is used in the object ipfixSelectionProcessSelectorFunction entries of the ipfixSelectionProcessTable in the IPFIX-MIB as reference to this parameter set.')
psampSampUniProbProbability = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 5, 2, 1, 2), Float64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampSampUniProbProbability.setReference('RFC 5475 (Section 5.2.2.1) and RFC 5477 (Section 8.2)')
if mibBuilder.loadTexts: psampSampUniProbProbability.setStatus('current')
if mibBuilder.loadTexts: psampSampUniProbProbability.setDescription('This object specifies the probability that a packet is sampled, expressed as a value between 0 and 1. The probability is equal for every packet. A value of 0 means no packet is sampled since the probability is 0. A value of 1 means all packets are sampled since the probability is 1. NaN (not a number) and infinity MUST NOT be used.')
psampFiltPropMatch = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 6))
psampFiltPropMatchAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 6, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltPropMatchAvail.setStatus('current')
if mibBuilder.loadTexts: psampFiltPropMatchAvail.setDescription('This object indicates the availability of property match filtering at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampFiltHash = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 7))
psampFiltHashAvail = MibScalar((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashAvail.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashAvail.setDescription('This object indicates the availability of hash filtering at the managed node. A Selector may be unavailable if it is implemented but currently disabled due to, e.g., administrative reasons, lack of resources, or similar.')
psampFiltHashCapabilities = MibIdentifier((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 2))
psampFiltHashParamSetTable = MibTable((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3), )
if mibBuilder.loadTexts: psampFiltHashParamSetTable.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashParamSetTable.setDescription('This table lists configurations of hash filtering. A parameter set describing a configuration contains eight parameters describing the hash function.')
psampFiltHashParamSetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1), ).setIndexNames((0, "PSAMP-MIB", "psampFiltHashIndex"))
if mibBuilder.loadTexts: psampFiltHashParamSetEntry.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashParamSetEntry.setDescription('Defines an entry in the psampFiltHashParamSetTable.')
psampFiltHashIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: psampFiltHashIndex.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashIndex.setDescription('The index of this parameter set in the psampFiltHashParamSetTable. It is used in the object ipfixSelectionProcessSelectorFunction entries of the ipfixSelectionProcessTable in the IPFIX-MIB as reference to this parameter set.')
psampFiltHashFunction = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("crc32", 1), ("ipsx", 2), ("bob", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashFunction.setReference('RFC 5475 (Section 6.2 and Appendixes A.1 and A.2) and RFC 1141')
if mibBuilder.loadTexts: psampFiltHashFunction.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashFunction.setDescription('The hash function used by this filter. The PSAMP-MIB defines the following hash functions: crc32(1): The CRC-32 Hash Function as defined in RFC 1141. ipsx(2): The IPSX Hash Function as described in RFC 5475, Appendix A.1. bob(3): The BOB Hash Function as described in RFC 5475, Appendix A.2. ')
psampFiltHashInitializerValue = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 3), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashInitializerValue.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashInitializerValue.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashInitializerValue.setDescription('This object specifies the initializer value to the hash function.')
psampFiltHashIpPayloadOffset = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 4), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashIpPayloadOffset.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashIpPayloadOffset.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashIpPayloadOffset.setDescription('This object specifies the IP payload offset used by a Hash-based Selection Selector.')
psampFiltHashIpPayloadSize = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 5), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashIpPayloadSize.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashIpPayloadSize.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashIpPayloadSize.setDescription('This object specifies the IP payload size used by a Hash-based Selection Selector.')
psampFiltHashSelectedRangeMin = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 6), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMin.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMin.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMin.setDescription("This object specifies the value for the beginning of a hash function's selected range.")
psampFiltHashSelectedRangeMax = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 7), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMax.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMax.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashSelectedRangeMax.setDescription("This object specifies the value for the end of a hash function's selected range.")
psampFiltHashOutputRangeMin = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 8), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashOutputRangeMin.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashOutputRangeMin.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashOutputRangeMin.setDescription("This object specifies the value for the beginning of a hash function's potential output range.")
psampFiltHashOutputRangeMax = MibTableColumn((1, 3, 6, 1, 2, 1, 194, 1, 1, 7, 3, 1, 9), Unsigned64TC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psampFiltHashOutputRangeMax.setReference('RFC 5475, Sections 6.2, 3.8, and 7.1')
if mibBuilder.loadTexts: psampFiltHashOutputRangeMax.setStatus('current')
if mibBuilder.loadTexts: psampFiltHashOutputRangeMax.setDescription("This object specifies the value for the end of a hash function's potential output range.")
psampCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 212, 2, 1))
psampGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 212, 2, 2))
psampCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 212, 2, 1, 1)).setObjects(("PSAMP-MIB", "psampGroupSampCountBased"), ("PSAMP-MIB", "psampGroupSampTimeBased"), ("PSAMP-MIB", "psampGroupSampRandOutOfN"), ("PSAMP-MIB", "psampGroupSampUniProb"), ("PSAMP-MIB", "psampGroupFiltPropMatch"), ("PSAMP-MIB", "psampGroupFiltHash"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampCompliance = psampCompliance.setStatus('current')
if mibBuilder.loadTexts: psampCompliance.setDescription('The implementation of all objects is optional and depends on the implementation of the corresponding functionality in the equipment.')
psampGroupSampCountBased = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 1)).setObjects(("PSAMP-MIB", "psampSampCountBasedAvail"), ("PSAMP-MIB", "psampSampCountBasedInterval"), ("PSAMP-MIB", "psampSampCountBasedSpace"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupSampCountBased = psampGroupSampCountBased.setStatus('current')
if mibBuilder.loadTexts: psampGroupSampCountBased.setDescription('These objects are needed if count based sampling is implemented.')
psampGroupSampTimeBased = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 2)).setObjects(("PSAMP-MIB", "psampSampTimeBasedAvail"), ("PSAMP-MIB", "psampSampTimeBasedInterval"), ("PSAMP-MIB", "psampSampTimeBasedSpace"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupSampTimeBased = psampGroupSampTimeBased.setStatus('current')
if mibBuilder.loadTexts: psampGroupSampTimeBased.setDescription('These objects are needed if time based sampling is implemented.')
psampGroupSampRandOutOfN = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 3)).setObjects(("PSAMP-MIB", "psampSampRandOutOfNAvail"), ("PSAMP-MIB", "psampSampRandOutOfNSize"), ("PSAMP-MIB", "psampSampRandOutOfNPopulation"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupSampRandOutOfN = psampGroupSampRandOutOfN.setStatus('current')
if mibBuilder.loadTexts: psampGroupSampRandOutOfN.setDescription('These objects are needed if random n-out-of-N sampling is implemented.')
psampGroupSampUniProb = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 4)).setObjects(("PSAMP-MIB", "psampSampUniProbAvail"), ("PSAMP-MIB", "psampSampUniProbProbability"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupSampUniProb = psampGroupSampUniProb.setStatus('current')
if mibBuilder.loadTexts: psampGroupSampUniProb.setDescription('These objects are needed if uniform probabilistic sampling is implemented.')
psampGroupFiltPropMatch = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 5)).setObjects(("PSAMP-MIB", "psampFiltPropMatchAvail"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupFiltPropMatch = psampGroupFiltPropMatch.setStatus('current')
if mibBuilder.loadTexts: psampGroupFiltPropMatch.setDescription('These objects are needed if property match filtering is implemented.')
psampGroupFiltHash = ObjectGroup((1, 3, 6, 1, 2, 1, 212, 2, 2, 6)).setObjects(("PSAMP-MIB", "psampFiltHashAvail"), ("PSAMP-MIB", "psampFiltHashFunction"), ("PSAMP-MIB", "psampFiltHashInitializerValue"), ("PSAMP-MIB", "psampFiltHashIpPayloadOffset"), ("PSAMP-MIB", "psampFiltHashIpPayloadSize"), ("PSAMP-MIB", "psampFiltHashSelectedRangeMin"), ("PSAMP-MIB", "psampFiltHashSelectedRangeMax"), ("PSAMP-MIB", "psampFiltHashOutputRangeMin"), ("PSAMP-MIB", "psampFiltHashOutputRangeMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    psampGroupFiltHash = psampGroupFiltHash.setStatus('current')
if mibBuilder.loadTexts: psampGroupFiltHash.setDescription('These objects are needed if hash filtering is implemented.')
mibBuilder.exportSymbols("PSAMP-MIB", psampFiltHashFunction=psampFiltHashFunction, psampFiltHashOutputRangeMin=psampFiltHashOutputRangeMin, psampGroups=psampGroups, psampGroupFiltHash=psampGroupFiltHash, psampSampTimeBasedAvail=psampSampTimeBasedAvail, psampFiltHashInitializerValue=psampFiltHashInitializerValue, psampSampCountBasedParamSetEntry=psampSampCountBasedParamSetEntry, psampSampUniProbParamSetEntry=psampSampUniProbParamSetEntry, psampSampUniProbIndex=psampSampUniProbIndex, psampSampRandOutOfNParamSetTable=psampSampRandOutOfNParamSetTable, psampSampUniProb=psampSampUniProb, psampSampRandOutOfNAvail=psampSampRandOutOfNAvail, psampFiltHashAvail=psampFiltHashAvail, psampGroupSampRandOutOfN=psampGroupSampRandOutOfN, psampFiltHashIndex=psampFiltHashIndex, psampFiltHashIpPayloadOffset=psampFiltHashIpPayloadOffset, psampFiltPropMatch=psampFiltPropMatch, psampGroupSampCountBased=psampGroupSampCountBased, psampSampRandOutOfN=psampSampRandOutOfN, psampFiltHashParamSetTable=psampFiltHashParamSetTable, psampSampUniProbProbability=psampSampUniProbProbability, psampGroupSampUniProb=psampGroupSampUniProb, psampSampTimeBasedSpace=psampSampTimeBasedSpace, psampSampTimeBased=psampSampTimeBased, psampSampCountBasedParamSetTable=psampSampCountBasedParamSetTable, psampSampTimeBasedInterval=psampSampTimeBasedInterval, psampSampCountBasedIndex=psampSampCountBasedIndex, psampSampUniProbParamSetTable=psampSampUniProbParamSetTable, psampObjects=psampObjects, psampFiltPropMatchAvail=psampFiltPropMatchAvail, psampFiltHashSelectedRangeMax=psampFiltHashSelectedRangeMax, psampSampCountBasedAvail=psampSampCountBasedAvail, psampCompliances=psampCompliances, psampSampCountBasedSpace=psampSampCountBasedSpace, psampFiltHashOutputRangeMax=psampFiltHashOutputRangeMax, psampFiltHashIpPayloadSize=psampFiltHashIpPayloadSize, psampSampTimeBasedParamSetEntry=psampSampTimeBasedParamSetEntry, psampSampCountBased=psampSampCountBased, psampCompliance=psampCompliance, psampFiltHashParamSetEntry=psampFiltHashParamSetEntry, psampSampRandOutOfNSize=psampSampRandOutOfNSize, psampGroupSampTimeBased=psampGroupSampTimeBased, psampGroupFiltPropMatch=psampGroupFiltPropMatch, psampSampTimeBasedIndex=psampSampTimeBasedIndex, psampSampRandOutOfNPopulation=psampSampRandOutOfNPopulation, psampSampRandOutOfNIndex=psampSampRandOutOfNIndex, psampSampUniProbAvail=psampSampUniProbAvail, psampSampTimeBasedParamSetTable=psampSampTimeBasedParamSetTable, psampSampCountBasedInterval=psampSampCountBasedInterval, PYSNMP_MODULE_ID=psampMIB, psampFiltHash=psampFiltHash, psampConformance=psampConformance, psampSampRandOutOfNParamSetEntry=psampSampRandOutOfNParamSetEntry, psampFiltHashCapabilities=psampFiltHashCapabilities, psampFiltHashSelectedRangeMin=psampFiltHashSelectedRangeMin, psampMIB=psampMIB)

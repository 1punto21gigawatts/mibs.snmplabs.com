#
# PySNMP MIB module ASKEY-SYSTEM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ASKEY-SYSTEM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:29:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ipDslam, = mibBuilder.importSymbols("ASKEY-DSLAM-MIB", "ipDslam")
aeAlarmPhysicalIndex, = mibBuilder.importSymbols("ASKEY-ENTITY-ALARM-MIB", "aeAlarmPhysicalIndex")
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
InterfaceIndex, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex")
InetAddress, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress")
EnabledStatus, = mibBuilder.importSymbols("P-BRIDGE-MIB", "EnabledStatus")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, Integer32, ObjectIdentity, Unsigned32, TimeTicks, NotificationType, Counter32, Gauge32, Counter64, ModuleIdentity, MibIdentifier, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "Integer32", "ObjectIdentity", "Unsigned32", "TimeTicks", "NotificationType", "Counter32", "Gauge32", "Counter64", "ModuleIdentity", "MibIdentifier", "IpAddress")
TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DisplayString")
askeySystemMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1))
if mibBuilder.loadTexts: askeySystemMib.setLastUpdated('200311260000Z')
if mibBuilder.loadTexts: askeySystemMib.setOrganization('ASKEY Inc.')
if mibBuilder.loadTexts: askeySystemMib.setContactInfo('ASKEY Inc. E-mail: cwfu@askey.com.tw')
if mibBuilder.loadTexts: askeySystemMib.setDescription('ASKEY ADSL MIB OID defines and documentation.')
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class IPSectionIndex(TextualConvention, Integer32):
    description = 'A unique value, greater than zero, for denoting an IP section. The IP section represents a range of the IP address from some IP to another IP.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 10)

class VLANList(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight VLAN IDs, with the first octet specifying VLAN ID 0 through 7, the second octet specifying VLAN ID 8 through 15, etc. Within each octet, the most significant bit represents the lowest numbered VLAN ID, and the least significant bit represents the highest numbered VLAN ID. Thus, each VLAN ID is represented by a single bit within the value of this object. If that bit has a value of '1' then that VLAN is included in the set of VLANs; the VLAN is not included if its bit has a value of '0'."
    status = 'current'

ipConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1))
nodeIP = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 1))
nodeIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeIPAddr.setStatus('current')
if mibBuilder.loadTexts: nodeIPAddr.setDescription('The IP address of node. It applies to the trunk (up-link) port.')
nodeIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nodeIPNetMask.setStatus('current')
if mibBuilder.loadTexts: nodeIPNetMask.setDescription('The subnet mask associated with the IP address of this node. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
nodeMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeMACAddr.setStatus('current')
if mibBuilder.loadTexts: nodeMACAddr.setDescription('The MAC address of the trunk (up-link) port.')
gatewayIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: gatewayIPAddr.setStatus('current')
if mibBuilder.loadTexts: gatewayIPAddr.setDescription('The gateway IP address of node. It applies to the trunk (up-link) port.')
mgmtIP = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 2))
mgmtIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtIPAddr.setStatus('current')
if mibBuilder.loadTexts: mgmtIPAddr.setDescription('The IP address of the management (out-band) port.')
mgmtIPNetMask = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgmtIPNetMask.setStatus('current')
if mibBuilder.loadTexts: mgmtIPNetMask.setDescription('The subnet mask associated with the IP address of the management port. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
mgmtMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 1, 2, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgmtMACAddr.setStatus('current')
if mibBuilder.loadTexts: mgmtMACAddr.setDescription('The MAC address of the manaement (out-band) port.')
nodeTime = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 2))
time = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(14, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: time.setStatus('current')
if mibBuilder.loadTexts: time.setDescription('The time <yyyy-mm-dd hh:mm:ss> of the system.')
zone = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: zone.setStatus('current')
if mibBuilder.loadTexts: zone.setDescription('The time zone of the system.')
snmpTrapMib = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6))
snmpTrapTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1), )
if mibBuilder.loadTexts: snmpTrapTable.setStatus('current')
if mibBuilder.loadTexts: snmpTrapTable.setDescription('This table contains information for SNMP Trap.')
snmpTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1, 1), ).setIndexNames((0, "ASKEY-SYSTEM-MIB", "snmpTrapStation"))
if mibBuilder.loadTexts: snmpTrapEntry.setStatus('current')
if mibBuilder.loadTexts: snmpTrapEntry.setDescription('An entry of parameters in snmpTrap table.')
snmpTrapStation = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: snmpTrapStation.setStatus('current')
if mibBuilder.loadTexts: snmpTrapStation.setDescription('The IP address of the workstation which the SNMP Trap is sent to.')
snmpTrapCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpTrapCommunity.setStatus('current')
if mibBuilder.loadTexts: snmpTrapCommunity.setDescription("DURABLE: { 'public','':all } The SNMPv1/v2c community name string. Duplicate community names are not allowed in this table. Note that a null string is not a valid community name. Attempting to set this object to a null string or to a duplicate value results in the agent returning a 'badValue' error for SNMPv1 or 'inconsistentValue' error for SNMPv2c/v3.")
snmpTrapSNMPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("snmpv1", 1), ("snmpv2c", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpTrapSNMPVersion.setStatus('current')
if mibBuilder.loadTexts: snmpTrapSNMPVersion.setDescription('This object indicates the version of SNMPv1 or SNMPv2c.')
snmpTrapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 6, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpTrapRowStatus.setStatus('current')
if mibBuilder.loadTexts: snmpTrapRowStatus.setDescription('This object indicates the status of SNMP trap.')
snmpCommunityMib = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7))
snmpCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7, 1), )
if mibBuilder.loadTexts: snmpCommunityTable.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityTable.setDescription('A table of SNMPv1/v2c community string to SNMPv3 view name mappings.')
snmpCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7, 1, 1), ).setIndexNames((1, "ASKEY-SYSTEM-MIB", "snmpCommunityName"))
if mibBuilder.loadTexts: snmpCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityEntry.setDescription('An entry containing objects about SNMP community at this systemp.')
snmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: snmpCommunityName.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityName.setDescription("The SNMPv1/v2c community name string. Duplicate community names are not allowed in this table. Note that a null string is not a valid community name. Attempting to set this object to a null string or to a duplicate value results in the agent returning a 'badValue' error for SNMPv1 or 'inconsistentValue' error for SNMPv2c/v3.")
snmpCommunityPermission = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readOnly", 1), ("readWrite", 2))).clone('readWrite')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpCommunityPermission.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityPermission.setDescription("This object specifies the type of access allowed. 'readOnly(1)' allows GET operations (i.e., GET, GET-NEXT, GET-BULK) and 'readWrite(2)' allows both GET and SET operations.")
snmpCommunityRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 7, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpCommunityRowStatus.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityRowStatus.setDescription("This object indicates the status of this entry. A row in this table can be created using the 'createAndGo(4)' (if all objects without default values are supplied with valid values in a single SNMP PDU) or the 'createAndWait(5)' action states. Until all parameters are valid for a conceptual row, this object is 'notReady(3)'. All parameters must be valid before this object can be set to 'active(1)'. Any object in a conceptual row can be modified independent of the value of this object (that is, can be changed while 'active(1)', notInService(2) or 'notReady(3)').")
askeyDslamFdbTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9), )
if mibBuilder.loadTexts: askeyDslamFdbTable.setStatus('current')
if mibBuilder.loadTexts: askeyDslamFdbTable.setDescription('A table that contains information about unicast entries for which the IP-DSLAM has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame.')
askeyDslamFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ASKEY-SYSTEM-MIB", "fdbMacIndex"))
if mibBuilder.loadTexts: askeyDslamFdbEntry.setStatus('current')
if mibBuilder.loadTexts: askeyDslamFdbEntry.setDescription('Information about a specific unicast MAC address on a specific line for which the IP-DSLAM has some forwarding and/or filtering information.')
fdbMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbMacIndex.setStatus('current')
if mibBuilder.loadTexts: fdbMacIndex.setDescription("A simple index into 'askeyDslamFdbTable'.")
fdbVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbVpi.setStatus('current')
if mibBuilder.loadTexts: fdbVpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
fdbVci = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fdbVci.setStatus('current')
if mibBuilder.loadTexts: fdbVci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the atmInterfaceMaxVciBits.')
macAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macAddress.setStatus('current')
if mibBuilder.loadTexts: macAddress.setDescription('A unicast MAC address for which the bridge has forwarding and/or filtering information.')
askeyDslamFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("learned-unique", 1), ("learned-spoofed-active", 2), ("learned-spoofed-inactive", 3), ("mgmt-forbid", 4), ("mgmt-permit", 5), ("learned-routed", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyDslamFdbStatus.setStatus('current')
if mibBuilder.loadTexts: askeyDslamFdbStatus.setDescription("The status of this entry. The meanings of the values are: learned_unique(1): the value of the corresponding instance of macAddress was learned, and is being used. It indicates that the macAddress is an unique one and there is no duplicated (spoofed) one detected in the IP-DSLAM. learned_spoofed_active(2) : the value of the corresponding instance of macAddress was learned, and is being used. It indicates that there is an duplicated (spoofed) one detected in theIP-DSLAM. learned_spoofed_inactive(3) : the value of the corresponding instance of macAddress was learned, and is NOT being used. It indicates that there is an duplicated(spoofed) one detected in the IP-DSLAM. mgmt_forbid(4): the value of the corresponding instance of macAddress was set by the operator. It indicates that an Ethernet frame of srcMac='macAddress' is to be dropped by the IP-DSLAM. mgmt_permit(5): the value of the corresponding instance of macAddress was set by the operator. It indicates that an Ethernet frame of srcMac='macAddress' is to be forwarded by the IP-DSLAM. learned_routed(6): the value of the corresponding instance of macAddress was learned, and is being used. It indicates that the macAddress is added by the IP-DSLAM.")
configDataMib = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("save", 1), ("restore", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configDataMib.setStatus('current')
if mibBuilder.loadTexts: configDataMib.setDescription('save(1): save the current configuration data to NVRAM(flash) as the main configuration data. restore(2): replace the main configuration data with the backup configuration data.')
askeyCardInfoTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11), )
if mibBuilder.loadTexts: askeyCardInfoTable.setStatus('current')
if mibBuilder.loadTexts: askeyCardInfoTable.setDescription('This table is information about card/slot on ASKEY IPDSLAM.')
askeyCardInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1), ).setIndexNames((0, "ASKEY-ENTITY-ALARM-MIB", "aeAlarmPhysicalIndex"))
if mibBuilder.loadTexts: askeyCardInfoEntry.setStatus('current')
if mibBuilder.loadTexts: askeyCardInfoEntry.setDescription('An entry about information of the card/slot.')
askeyCardPlannedType = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyCardPlannedType.setStatus('current')
if mibBuilder.loadTexts: askeyCardPlannedType.setDescription('Supposed type of this card.')
askeyCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardType.setStatus('current')
if mibBuilder.loadTexts: askeyCardType.setDescription('Current working type of this card.')
askeyCardHWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardHWVersion.setStatus('current')
if mibBuilder.loadTexts: askeyCardHWVersion.setDescription('The Hardware version of this card.')
askeyCardSWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardSWVersion.setStatus('current')
if mibBuilder.loadTexts: askeyCardSWVersion.setDescription('The Software version of this card.')
askeyCardImage = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardImage.setStatus('current')
if mibBuilder.loadTexts: askeyCardImage.setDescription('Description for the location of the image.')
askeyCardUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardUptime.setStatus('current')
if mibBuilder.loadTexts: askeyCardUptime.setDescription('The uptime (in seconds) of this card.')
askeyCardRole = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("standby", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardRole.setStatus('current')
if mibBuilder.loadTexts: askeyCardRole.setDescription('This object descibes the card role.')
askeyCardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardSerialNumber.setStatus('current')
if mibBuilder.loadTexts: askeyCardSerialNumber.setDescription('The card serial number which is an unique number.')
askeyCardAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyCardAdminStatus.setStatus('current')
if mibBuilder.loadTexts: askeyCardAdminStatus.setDescription("The operation of this card. Only value is 'reset(1)' will reset this card.")
askeyCardOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCardOperStatus.setStatus('current')
if mibBuilder.loadTexts: askeyCardOperStatus.setDescription("This object indicates the card's operational status. The notPresent(3) status indicates the card is physically removed (note this may or may not be possible depending on the type of card.) The operational(1) status indicates that the card is enabled (see rptrPortAdminStatus) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState). If this object has the value operational(1) and cwmAdminStatus is set to disabled(2), it is expected that this object's value will soon change to notOperational(2).")
lineCardAdminVlanTagPassEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineCardAdminVlanTagPassEnabled.setStatus('current')
if mibBuilder.loadTexts: lineCardAdminVlanTagPassEnabled.setDescription('Enable(1) or disable VLAN tag pass through function.')
lineCardOperVlanTagPassEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineCardOperVlanTagPassEnabled.setStatus('current')
if mibBuilder.loadTexts: lineCardOperVlanTagPassEnabled.setDescription('Current status of VLAN tag passes through funtion.')
lineCardAdminRfc2684Encap = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("llc", 1), ("vcMux", 2))).clone('llc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineCardAdminRfc2684Encap.setStatus('current')
if mibBuilder.loadTexts: lineCardAdminRfc2684Encap.setDescription('Setting this object to LLC (1) to encapsulate the packet to LLC style. Setting it to vcMux (2) to encapsulate the packet to VC-MUX style.')
lineCardOperRfc2684Encap = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("llc", 1), ("vcMux", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineCardOperRfc2684Encap.setStatus('current')
if mibBuilder.loadTexts: lineCardOperRfc2684Encap.setDescription('Current applied rfc2684 encapsulation method.')
lineCardServiceTypeControl = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineCardServiceTypeControl.setStatus('current')
if mibBuilder.loadTexts: lineCardServiceTypeControl.setDescription('Set or get applied control of service type.')
shdslFirmwareUpgrade = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("upgrade", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shdslFirmwareUpgrade.setStatus('current')
if mibBuilder.loadTexts: shdslFirmwareUpgrade.setDescription('Upgrade SHDSL line card firmware.')
shdslFirmwareUpgradeState = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 0), ("inital", 1), ("transmission", 2), ("burning", 3), ("finished", 4), ("failedToBurn", 5), ("driverError", 6), ("noFirmwareImage", 7), ("failedToTransmitImage", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shdslFirmwareUpgradeState.setStatus('current')
if mibBuilder.loadTexts: shdslFirmwareUpgradeState.setDescription('SHDSL line card firmware pgrade state.')
taggedModeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tagged-only", 1), ("untagged-only", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: taggedModeAdminStatus.setStatus('current')
if mibBuilder.loadTexts: taggedModeAdminStatus.setDescription('Card administrative tagged mode. This entry indicates tagged mode configured on the specific card.')
taggedModeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tagged-only", 1), ("untagged-only", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: taggedModeOperStatus.setStatus('current')
if mibBuilder.loadTexts: taggedModeOperStatus.setDescription("Card operational tagged mode. This entry indicates tagged mode running on the specific card. All ports of the tagged type card will drop packets that don't have tagged header. And all ports of untagged type card will drop packets that have tagged header. Do nothing for 'noAction' case.")
linePortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12))
linePortInfoTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1), )
if mibBuilder.loadTexts: linePortInfoTable.setStatus('current')
if mibBuilder.loadTexts: linePortInfoTable.setDescription('A list of line port information entries.')
linePortInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: linePortInfoEntry.setStatus('current')
if mibBuilder.loadTexts: linePortInfoEntry.setDescription('An information entry containing objects for each line port.')
linePortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("testing", 3), ("reset", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: linePortAdminStatus.setStatus('current')
if mibBuilder.loadTexts: linePortAdminStatus.setDescription('The desired state of the line port. The enable(1) state ready to pass packets. The disable(2) state stop passing any packets. The testing(3) state indicates that no operational packets can be passed, it is for debug only. Finally, reset(4) state will reset this line port.')
linePortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: linePortOperStatus.setStatus('current')
if mibBuilder.loadTexts: linePortOperStatus.setDescription("This object indicates the line port's operational status. The notPresent(3) status indicates the line port is physically removed (note this may or may not be possible depending on the type of port). The operational(1) status indicates that the port is enabled (see rptrPortAdminStatus) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState). If this object has the value operational(1) and rptrPortAdminStatus is set to disabled(2), it is expected that this object's value will soon change to notOperational(2).")
circuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: circuitID.setStatus('current')
if mibBuilder.loadTexts: circuitID.setDescription("The identity for this circuit. The value is 'shelf.slot.port'.")
remoteID = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 12, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: remoteID.setStatus('current')
if mibBuilder.loadTexts: remoteID.setDescription('The string is sent transparently to authorization service.')
dot1TpMACAging = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aged", 1), ("nonaged", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1TpMACAging.setStatus('current')
if mibBuilder.loadTexts: dot1TpMACAging.setDescription('This object decides MAC enrties aged out or not. aged: MAC entries will be aged out nonaged: MAC entries will never be aged out')
askeyRebootSystemAction = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reboot", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyRebootSystemAction.setStatus('current')
if mibBuilder.loadTexts: askeyRebootSystemAction.setDescription('Reboot the system.')
askeyDslamOam = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15))
oamF5 = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15, 1))
oamF5IfIndex = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oamF5IfIndex.setStatus('current')
if mibBuilder.loadTexts: oamF5IfIndex.setDescription('The ifIndex of the line.')
oamF5Vpi = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oamF5Vpi.setStatus('current')
if mibBuilder.loadTexts: oamF5Vpi.setDescription('The VPI value of the VCL. The maximum VPI value cannot exceed the value allowable by the atmInterfaceMaxVpiBits.')
oamF5Vci = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oamF5Vci.setStatus('current')
if mibBuilder.loadTexts: oamF5Vci.setDescription('The VCI value of the VCL. The maximum VCI value cannot exceed the value allowable by the atmInterfaceMaxVciBits.')
oamF5Scope = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("end-to-end", 1), ("segment-to-segment", 2), ("both-end2end-segment2segment", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oamF5Scope.setStatus('current')
if mibBuilder.loadTexts: oamF5Scope.setDescription('The scope of the OAM F5 loopback cell. Set this object will trigger OAM processing.')
askeySystemManagementInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16))
askeyEmsVlanId = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyEmsVlanId.setStatus('current')
if mibBuilder.loadTexts: askeyEmsVlanId.setDescription('In-band management VLAN ID.')
askeyBootDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 2))
askeyNextBootDevice = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("opCodeA", 1), ("opCodeB", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyNextBootDevice.setStatus('current')
if mibBuilder.loadTexts: askeyNextBootDevice.setDescription('Configure the next boot partition.')
askeyCurrentBootDevice = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("network", 0), ("opCodeA", 1), ("opCodeB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCurrentBootDevice.setStatus('current')
if mibBuilder.loadTexts: askeyCurrentBootDevice.setDescription('Show current the boot partition.')
askeySystemManagementIgmp = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enableIgmpsnoop", 1), ("enableIgmpproxy", 2), ("disableIgmp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeySystemManagementIgmp.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementIgmp.setDescription('Configure the IGMP proxy and IGMP snoop.')
askeyRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 4))
askeyRedundancyAutoSyncEnabled = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyRedundancyAutoSyncEnabled.setStatus('current')
if mibBuilder.loadTexts: askeyRedundancyAutoSyncEnabled.setDescription('The Askey IPDSLAM can auto synchronize standby NC configuration with active NC. This object enables or disables such synchronization.')
askeyRedundancyAutoSyncPeriod = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyRedundancyAutoSyncPeriod.setStatus('current')
if mibBuilder.loadTexts: askeyRedundancyAutoSyncPeriod.setDescription('Auto synchronization period. The value unit is in second.')
askeyRedundancySync = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("syncNow", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyRedundancySync.setStatus('current')
if mibBuilder.loadTexts: askeyRedundancySync.setDescription('Synchronize redundancy immediately.')
askeySystemManagementInfoVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5))
askeySystemManagementInfoVlanMacLimitTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5, 1), )
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitTable.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitTable.setDescription('A table that contains information about the MAC limit per VLAN ID.')
askeySystemManagementInfoVlanMacLimitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5, 1, 1), ).setIndexNames((0, "ASKEY-SYSTEM-MIB", "askeySystemManagementInfoVlanID"))
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitEntry.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitEntry.setDescription('Information about the MAC limit per VLAN.')
askeySystemManagementInfoVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: askeySystemManagementInfoVlanID.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementInfoVlanID.setDescription('The ID of target VLAN which MAC limits.')
askeySystemManagementInfoVlanMacLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 50000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimit.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimit.setDescription('MAC limit on specific VLAN. Default values are 5376 for AM0021 and 1568 for AM0031.')
askeySystemManagementInfoVlanMacLimitEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 16, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("unknown", 0), ("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitEnabled.setStatus('current')
if mibBuilder.loadTexts: askeySystemManagementInfoVlanMacLimitEnabled.setDescription('Enable or disable MAC limit.')
askeyCosQueue = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 18))
askeyCosQueueMappingTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 18, 1), )
if mibBuilder.loadTexts: askeyCosQueueMappingTable.setStatus('current')
if mibBuilder.loadTexts: askeyCosQueueMappingTable.setDescription('A table that contains information about COS queues mapping with 802.1p.')
askeyCosQueueMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 18, 1, 1), ).setIndexNames((0, "ASKEY-SYSTEM-MIB", "askeyCosQueueMapping8021p"))
if mibBuilder.loadTexts: askeyCosQueueMappingEntry.setStatus('current')
if mibBuilder.loadTexts: askeyCosQueueMappingEntry.setDescription('Information about COS queue mapping.')
askeyCosQueueMapping8021p = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: askeyCosQueueMapping8021p.setStatus('current')
if mibBuilder.loadTexts: askeyCosQueueMapping8021p.setDescription('The identity of the specific 802.1p priority mapping.')
askeyCosQueueIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: askeyCosQueueIndex.setStatus('current')
if mibBuilder.loadTexts: askeyCosQueueIndex.setDescription('The index of COS queue.')
askeySystemUserAccountTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19), )
if mibBuilder.loadTexts: askeySystemUserAccountTable.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountTable.setDescription('This table contains information of system user account. One entry in this table reflects a user information.')
askeySystemUserAccountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19, 1), ).setIndexNames((0, "ASKEY-SYSTEM-MIB", "askeySystemUserAccountUserName"))
if mibBuilder.loadTexts: askeySystemUserAccountEntry.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountEntry.setDescription('An entry reflects a user information.')
askeySystemUserAccountUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: askeySystemUserAccountUserName.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountUserName.setDescription('The name of account user.')
askeySystemUserAccountPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: askeySystemUserAccountPassword.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountPassword.setDescription('The password of account user.')
askeySystemUserAccountGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("guest", 1), ("admin", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: askeySystemUserAccountGroup.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountGroup.setDescription('The group which account belongs to.')
askeySystemUserAccountRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 19, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: askeySystemUserAccountRowStatus.setStatus('current')
if mibBuilder.loadTexts: askeySystemUserAccountRowStatus.setDescription('This object controls creation/deletion of the associated entry in this table as per the semantics of RowStatus.')
askeyPPPoE = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 20))
suboption = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 20, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: suboption.setStatus('current')
if mibBuilder.loadTexts: suboption.setDescription("Enable or disable PPPoE suboption. The circuit information recorded on 'linePortInfo' table will be transferred to authorization service, for example, a radius server, if this function enabled.")
dnsService = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 21))
dnsServer1IPAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 21, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsServer1IPAddress.setStatus('current')
if mibBuilder.loadTexts: dnsServer1IPAddress.setDescription('The IP address of DNS server. This server is used first priority.')
dnsServer2IPAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 21, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsServer2IPAddress.setStatus('current')
if mibBuilder.loadTexts: dnsServer2IPAddress.setDescription('The IP address of DNS server. This server is used second priority.')
dnsServer3IPAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 21, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsServer3IPAddress.setStatus('current')
if mibBuilder.loadTexts: dnsServer3IPAddress.setDescription('The IP address of DNS server. This server is used lowest priority.')
timeService = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22))
protocol = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("sntp", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: protocol.setStatus('current')
if mibBuilder.loadTexts: protocol.setDescription('The time service is used which protocol.')
updatePeriod = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1440))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: updatePeriod.setStatus('current')
if mibBuilder.loadTexts: updatePeriod.setDescription('Synchronize time which system update time by time servers. This object unit is in minute.')
timeServer1InetAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServer1InetAddress.setStatus('current')
if mibBuilder.loadTexts: timeServer1InetAddress.setDescription('The address of time server1. This server is used first priority.')
timeServer2InetAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServer2InetAddress.setStatus('current')
if mibBuilder.loadTexts: timeServer2InetAddress.setDescription('The address of time server2. This server is used second priority.')
timeServer3InetAddress = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 5), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeServer3InetAddress.setStatus('current')
if mibBuilder.loadTexts: timeServer3InetAddress.setDescription('The address of time server3. This server is used lowest priority.')
timeServer1Status = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notSet", 0), ("networkTimeSource", 1), ("backupMode", 2), ("failToResolveDomainName", 3), ("serverNoResponse", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServer1Status.setStatus('current')
if mibBuilder.loadTexts: timeServer1Status.setDescription('server1 current status.')
timeServer2Status = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notSet", 0), ("networkTimeSource", 1), ("backupMode", 2), ("failToResolveDomainName", 3), ("serverNoResponse", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServer2Status.setStatus('current')
if mibBuilder.loadTexts: timeServer2Status.setDescription('server2 current status.')
timeServer3Status = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notSet", 0), ("networkTimeSource", 1), ("backupMode", 2), ("failToResolveDomainName", 3), ("serverNoResponse", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeServer3Status.setStatus('current')
if mibBuilder.loadTexts: timeServer3Status.setDescription('server3 current status.')
timeZone = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 22, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 13))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeZone.setStatus('current')
if mibBuilder.loadTexts: timeZone.setDescription('The system time zone.')
ugeMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23))
ugeAutoNegotiationTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 2), )
if mibBuilder.loadTexts: ugeAutoNegotiationTable.setStatus('current')
if mibBuilder.loadTexts: ugeAutoNegotiationTable.setDescription('The table indicates UGE auto negotiation states.')
ugeAutoNegotionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ugeAutoNegotionEntry.setStatus('current')
if mibBuilder.loadTexts: ugeAutoNegotionEntry.setDescription('An entry indicates UGE auto negotiation states.')
autoNegotiationState = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: autoNegotiationState.setStatus('current')
if mibBuilder.loadTexts: autoNegotiationState.setDescription('Enable or disable UGE port auto negotiation.')
ugePauseFrameStatisticTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 3), )
if mibBuilder.loadTexts: ugePauseFrameStatisticTable.setStatus('current')
if mibBuilder.loadTexts: ugePauseFrameStatisticTable.setDescription('The table indicates UGE pause packet statistic.')
ugePauseFrameStatisticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ugePauseFrameStatisticEntry.setStatus('current')
if mibBuilder.loadTexts: ugePauseFrameStatisticEntry.setDescription('An entry indicates UGE pause packet statistic.')
rxPausePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rxPausePackets.setStatus('current')
if mibBuilder.loadTexts: rxPausePackets.setDescription('The counter indicates pause packets received from this UGE.')
txPausePackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: txPausePackets.setStatus('current')
if mibBuilder.loadTexts: txPausePackets.setDescription('The counter indicates pause packets transmitted by this UGE.')
subtendVLANTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 4), )
if mibBuilder.loadTexts: subtendVLANTable.setStatus('current')
if mibBuilder.loadTexts: subtendVLANTable.setDescription('The table indicates which VLAN packets can pass through subtending ports.')
subtendVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: subtendVLANEntry.setStatus('current')
if mibBuilder.loadTexts: subtendVLANEntry.setDescription('An entry for subtendVLANTable.')
subtendState = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subtendState.setStatus('current')
if mibBuilder.loadTexts: subtendState.setDescription('Enable or disable NC VLAN subtend.')
subtendVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 4, 1, 2), VLANList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subtendVLAN.setStatus('current')
if mibBuilder.loadTexts: subtendVLAN.setDescription('Specify what VLAN can pass through by subtending port.')
ugeVLANTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 5), )
if mibBuilder.loadTexts: ugeVLANTable.setStatus('current')
if mibBuilder.loadTexts: ugeVLANTable.setDescription('This table indicates relation between UGEs and packets with specific VLAN tags. Only packets with tag values can been send out from UGEs, otherwise will not.')
ugeVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ugeVLANEntry.setStatus('current')
if mibBuilder.loadTexts: ugeVLANEntry.setDescription('An entry for ugeVLANTable.')
ugeVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 23, 5, 1, 1), VLANList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ugeVLAN.setStatus('current')
if mibBuilder.loadTexts: ugeVLAN.setDescription('Specify what VLAN can pass through by UGE port.')
securedHosts = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24))
securedHostAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securedHostAdminStatus.setStatus('current')
if mibBuilder.loadTexts: securedHostAdminStatus.setDescription('Enable or disable secured host function.')
securedHostTable = MibTable((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2), )
if mibBuilder.loadTexts: securedHostTable.setStatus('current')
if mibBuilder.loadTexts: securedHostTable.setDescription('This table provides the information of the secured hosts which may access managed system.')
securedHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2, 1), ).setIndexNames((0, "ASKEY-SYSTEM-MIB", "securedIPSectorIndex"))
if mibBuilder.loadTexts: securedHostEntry.setStatus('current')
if mibBuilder.loadTexts: securedHostEntry.setDescription('An entry to information of the secured hosts which may access managed system.')
securedIPSectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2, 1, 1), IPSectionIndex())
if mibBuilder.loadTexts: securedIPSectorIndex.setStatus('current')
if mibBuilder.loadTexts: securedIPSectorIndex.setDescription('An IP sector index.')
securedIPSectorStartIP = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securedIPSectorStartIP.setStatus('current')
if mibBuilder.loadTexts: securedIPSectorStartIP.setDescription('An IP address expresses IP sector starting.')
securedIPSectorEndIP = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securedIPSectorEndIP.setStatus('current')
if mibBuilder.loadTexts: securedIPSectorEndIP.setDescription('An IP address expresses IP sector ending.')
allowedServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 24, 2, 1, 4), Bits().clone(namedValues=NamedValues(("snmp", 0), ("telnet", 1), ("ftp", 2), ("tftp", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: allowedServiceType.setStatus('current')
if mibBuilder.loadTexts: allowedServiceType.setDescription('Contains indicates whether access mode is enabled or disabled. This is a bit-map of possible settings.')
netBIOSFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 25))
netBIOSFilterAction = MibScalar((1, 3, 6, 1, 4, 1, 3646, 1300, 2, 1, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dropping", 1), ("forwarding", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: netBIOSFilterAction.setStatus('current')
if mibBuilder.loadTexts: netBIOSFilterAction.setDescription('Drop or forward NetBIOS/NetBEUI packets.')
mibBuilder.exportSymbols("ASKEY-SYSTEM-MIB", askeyNextBootDevice=askeyNextBootDevice, askeySystemManagementInfoVlanID=askeySystemManagementInfoVlanID, linePortAdminStatus=linePortAdminStatus, fdbVci=fdbVci, snmpTrapMib=snmpTrapMib, timeServer3Status=timeServer3Status, askeyCardType=askeyCardType, askeySystemMib=askeySystemMib, snmpCommunityRowStatus=snmpCommunityRowStatus, askeyDslamFdbStatus=askeyDslamFdbStatus, securedHosts=securedHosts, linePortInfoEntry=linePortInfoEntry, askeyDslamOam=askeyDslamOam, nodeTime=nodeTime, ugeMIBObjects=ugeMIBObjects, askeyCardImage=askeyCardImage, dot1TpMACAging=dot1TpMACAging, askeyCardSerialNumber=askeyCardSerialNumber, dnsServer1IPAddress=dnsServer1IPAddress, mgmtIPAddr=mgmtIPAddr, oamF5Vci=oamF5Vci, askeyCosQueue=askeyCosQueue, askeyCosQueueMappingTable=askeyCosQueueMappingTable, askeyCardAdminStatus=askeyCardAdminStatus, askeySystemManagementIgmp=askeySystemManagementIgmp, askeySystemUserAccountRowStatus=askeySystemUserAccountRowStatus, snmpCommunityMib=snmpCommunityMib, askeyPPPoE=askeyPPPoE, ugeAutoNegotionEntry=ugeAutoNegotionEntry, askeyCardPlannedType=askeyCardPlannedType, taggedModeOperStatus=taggedModeOperStatus, askeyCosQueueIndex=askeyCosQueueIndex, ugeVLANEntry=ugeVLANEntry, askeyRedundancy=askeyRedundancy, macAddress=macAddress, fdbMacIndex=fdbMacIndex, timeServer3InetAddress=timeServer3InetAddress, fdbVpi=fdbVpi, askeyCardSWVersion=askeyCardSWVersion, timeServer2InetAddress=timeServer2InetAddress, linePortInfo=linePortInfo, IPSectionIndex=IPSectionIndex, askeySystemUserAccountUserName=askeySystemUserAccountUserName, suboption=suboption, askeyRebootSystemAction=askeyRebootSystemAction, timeZone=timeZone, dnsServer3IPAddress=dnsServer3IPAddress, ugeVLAN=ugeVLAN, nodeIPAddr=nodeIPAddr, zone=zone, lineCardAdminRfc2684Encap=lineCardAdminRfc2684Encap, askeyEmsVlanId=askeyEmsVlanId, askeySystemUserAccountTable=askeySystemUserAccountTable, subtendVLAN=subtendVLAN, rxPausePackets=rxPausePackets, askeySystemUserAccountEntry=askeySystemUserAccountEntry, timeServer1InetAddress=timeServer1InetAddress, ugePauseFrameStatisticTable=ugePauseFrameStatisticTable, askeyCosQueueMapping8021p=askeyCosQueueMapping8021p, securedHostAdminStatus=securedHostAdminStatus, configDataMib=configDataMib, snmpTrapTable=snmpTrapTable, nodeIP=nodeIP, subtendState=subtendState, askeyRedundancyAutoSyncEnabled=askeyRedundancyAutoSyncEnabled, snmpTrapSNMPVersion=snmpTrapSNMPVersion, askeyCardUptime=askeyCardUptime, askeyCardInfoTable=askeyCardInfoTable, lineCardServiceTypeControl=lineCardServiceTypeControl, askeySystemManagementInfoVlanMacLimitEnabled=askeySystemManagementInfoVlanMacLimitEnabled, timeServer1Status=timeServer1Status, ugeVLANTable=ugeVLANTable, askeyCardInfoEntry=askeyCardInfoEntry, ipConfig=ipConfig, oamF5Vpi=oamF5Vpi, nodeIPNetMask=nodeIPNetMask, askeyRedundancyAutoSyncPeriod=askeyRedundancyAutoSyncPeriod, askeyCosQueueMappingEntry=askeyCosQueueMappingEntry, updatePeriod=updatePeriod, oamF5IfIndex=oamF5IfIndex, shdslFirmwareUpgrade=shdslFirmwareUpgrade, askeyCurrentBootDevice=askeyCurrentBootDevice, linePortInfoTable=linePortInfoTable, securedIPSectorEndIP=securedIPSectorEndIP, securedIPSectorStartIP=securedIPSectorStartIP, oamF5Scope=oamF5Scope, snmpCommunityPermission=snmpCommunityPermission, askeyRedundancySync=askeyRedundancySync, mgmtIPNetMask=mgmtIPNetMask, snmpTrapStation=snmpTrapStation, circuitID=circuitID, shdslFirmwareUpgradeState=shdslFirmwareUpgradeState, askeySystemManagementInfoVlanMacLimitTable=askeySystemManagementInfoVlanMacLimitTable, askeyCardHWVersion=askeyCardHWVersion, lineCardOperVlanTagPassEnabled=lineCardOperVlanTagPassEnabled, ugePauseFrameStatisticEntry=ugePauseFrameStatisticEntry, netBIOSFilterAction=netBIOSFilterAction, askeySystemUserAccountGroup=askeySystemUserAccountGroup, askeyBootDevice=askeyBootDevice, askeyDslamFdbTable=askeyDslamFdbTable, askeyDslamFdbEntry=askeyDslamFdbEntry, allowedServiceType=allowedServiceType, MacAddress=MacAddress, askeySystemManagementInfo=askeySystemManagementInfo, snmpTrapCommunity=snmpTrapCommunity, askeySystemUserAccountPassword=askeySystemUserAccountPassword, dnsService=dnsService, snmpCommunityName=snmpCommunityName, timeServer2Status=timeServer2Status, securedIPSectorIndex=securedIPSectorIndex, timeService=timeService, ugeAutoNegotiationTable=ugeAutoNegotiationTable, taggedModeAdminStatus=taggedModeAdminStatus, askeySystemManagementInfoVlanMacLimitEntry=askeySystemManagementInfoVlanMacLimitEntry, netBIOSFilter=netBIOSFilter, time=time, mgmtIP=mgmtIP, subtendVLANEntry=subtendVLANEntry, txPausePackets=txPausePackets, securedHostEntry=securedHostEntry, oamF5=oamF5, gatewayIPAddr=gatewayIPAddr, protocol=protocol, autoNegotiationState=autoNegotiationState, subtendVLANTable=subtendVLANTable, mgmtMACAddr=mgmtMACAddr, snmpTrapRowStatus=snmpTrapRowStatus, remoteID=remoteID, askeySystemManagementInfoVlanMacLimit=askeySystemManagementInfoVlanMacLimit, askeySystemManagementInfoVlan=askeySystemManagementInfoVlan, snmpTrapEntry=snmpTrapEntry, linePortOperStatus=linePortOperStatus, dnsServer2IPAddress=dnsServer2IPAddress, askeyCardOperStatus=askeyCardOperStatus, PYSNMP_MODULE_ID=askeySystemMib, lineCardOperRfc2684Encap=lineCardOperRfc2684Encap, snmpCommunityEntry=snmpCommunityEntry, askeyCardRole=askeyCardRole, lineCardAdminVlanTagPassEnabled=lineCardAdminVlanTagPassEnabled, VLANList=VLANList, snmpCommunityTable=snmpCommunityTable, securedHostTable=securedHostTable, nodeMACAddr=nodeMACAddr)

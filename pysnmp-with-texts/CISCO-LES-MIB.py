#
# PySNMP MIB module CISCO-LES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-LES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:04:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
CiscoVciInteger, CiscoVpiInteger = mibBuilder.importSymbols("CISCO-BUS-MIB", "CiscoVciInteger", "CiscoVpiInteger")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
AtmLaneAddress, = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "AtmLaneAddress")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, NotificationType, TimeTicks, iso, Counter64, ModuleIdentity, Counter32, Gauge32, MibIdentifier, Unsigned32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "TimeTicks", "iso", "Counter64", "ModuleIdentity", "Counter32", "Gauge32", "MibIdentifier", "Unsigned32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
MacAddress, RowStatus, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC-v1", "MacAddress", "RowStatus", "DisplayString", "TimeStamp")
ciscoLesMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39))
ciscoLesMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 1))
les = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1))
leClient = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2))
register = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3))
ciscoLesMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2))
ciscoLesMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1))
ciscoLesMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 2))
lesTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1), )
if mibBuilder.loadTexts: lesTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesTable.setDescription(' A (conceptual) table containing all instances of LESs on this device.')
lesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-LES-MIB", "lesElanName"), (0, "CISCO-LES-MIB", "lesIndex"))
if mibBuilder.loadTexts: lesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesEntry.setDescription(' An entry (conceptual row) in the lesTable.')
lesElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: lesElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lesElanName.setDescription(' The name associated with the emulated LAN which this LES services.')
lesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesIndex.setDescription(' A unique identifier for this LES servicing this ELAN. This value must remain constant while the entry is in existence and during the operation of the agent (i.e. It is allowed to change after reboot). For implementations that do not allow more than one LES entity per ELAN per device, it is sufficient to always report 1 for this object and to only accept one for row creation.')
lesAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 3), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrSpec.setDescription(' The ATM address of the designated LES. Note that setting this object will have the side effect of reinitializing the LES and consequently dropping all clients connected to it. If this object is not specified at row creation time then the LES will choose a value for itself and attempt to register with the switch with that value. If an address is specified which is not acceptable to the switch then the lesOperStatus will remain inactive until an acceptable address is set.')
lesAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrMask.setDescription(" An address mask that when used with the lesAtmAddrSpec specifies the portion of the LES' ATM address that is desired to be configured. Note that setting this object will result in the reinitialization of the LES,consequently dropping all clients connected to it. Note that this object cannot be set at row creation time without also supplying a value for the lesAtmAddrSpec object. If the LES ATM address is omitted at creation time then this object defaults to the value of all zeros (none of the lesAtmAddrSpec value is relevant). If the LES ATM address is specified at creation time but this object omitted, then this object defaults to the value of all ones (all of the lesAtmAddrSpec is relevant).")
lesAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 5), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrActual.setDescription(' The resultant ATM address in use by the LES. This object is a product of the specified ATM address, mask and interaction with the switch via the ILMI.')
lesIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesIfIndex.setDescription(' The interface that a LES will receive control connections on. The value specified for this object must equate to a value of ifIndex in the ifTable. The interface will be for that particular ATM port (the physical interface, not a logical layer on top of it). This object can only be specified upon row creation and cannot be altered there after.')
lesSubIfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesSubIfNum.setStatus('mandatory')
if mibBuilder.loadTexts: lesSubIfNum.setDescription(' Specifies the sub-interface number that the LES will reside on. This sub-interface may be shared with a LEC or BUS of the same ELAN but is not required to do so. If no value is specified for this object at row creation time, then a sub-interface will be chosen by the agent. This object may only be specified at row creation time and cannot be altered thereafter.')
lesColocBusAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 8), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesColocBusAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lesColocBusAtmAddrSpec.setDescription(' For those implementations who do not allow the separate creation/deletion of the LES and BUS this object allows the operator to specify the ATM address of the BUS at LES creation time. For implementations that allow separate process creation this object is optional. Otherwise this is the ATM address of the designated BUS. Note that setting this object will have the side effect of reinitializing the BUS and consequently dropping all clients connected to it. If this object is not specified at row creation time then the BUS will choose a value for itself and attempt to register with the switch with that value. If an address is specified which is not acceptable to the switch then the busOperStatus will remain inactive until an acceptable address is set.')
lesColocBusAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesColocBusAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lesColocBusAtmAddrMask.setDescription(" An address mask that when used with the lesColocatedBusAtmAddr specifies the portion of the BUS' ATM address desired by management. Note that setting this object will have the side effect of reinitializing the BUS and consequently dropping all clients connected to it. Note that this object cannot be set at row creation time without also supplying a value for the lesColocBusAtmAddrSpec object. If the BUS ATM address is omitted at creation time then this object defaults to the value of all zeros (none of the lesColocBusAtmAddrSpec value is relevant). If the BUS ATM address is specified at creation time but this object omitted, then this object defaults to the value of all ones (all of the lesColocBusAtmAddrSpec is relevant).")
lesColocBusAtmAddrActl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 10), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesColocBusAtmAddrActl.setStatus('mandatory')
if mibBuilder.loadTexts: lesColocBusAtmAddrActl.setDescription(' The ATM address in use by the BUS. This object is a product of the specified ATM address, its mask and interaction with the switch through the ILMI.')
lesUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: lesUpTime.setDescription(' The value of sysUpTime when this LES became activated.')
lesLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dot3", 1), ("dot5", 2))).clone('dot3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLanType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLanType.setDescription(' The type of legacy LAN that this LES emulates.')
lesMaxFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1516, 4544, 9234, 18190))).clone(namedValues=NamedValues(("dot3", 1516), ("tr4Mb", 4544), ("rfc1626", 9234), ("tr16Mb", 18190))).clone('dot3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesMaxFrm.setStatus('mandatory')
if mibBuilder.loadTexts: lesMaxFrm.setDescription(' The maximum frame size that the specified LAN type can accept.')
lesJoinTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesJoinTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: lesJoinTimeout.setDescription(' The number of seconds that must elapse before a Join request can be timed-out.')
lesLecsAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 15), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecsAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecsAtmAddr.setDescription(" The ATM address associated with the LECS used by this LES. If no LECS is in use by the LES then this object will have the value of all 0's (i.e 0x0000...). If it is desired that the LES get the address of the LECS through the ILMI then this object may be left unspecified at row activation. If the ILMI fails then the lesOperStatus will be inactive(2) and this column still not present.")
lesControlDistVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 16), CiscoVpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesControlDistVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesControlDistVpi.setDescription(' The virtual path identifier of the control distribute VCC to all clients, if it exits. ')
lesControlDistVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 17), CiscoVciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesControlDistVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesControlDistVci.setDescription(' The virtual channel identifier of the control distribute VCC to all clients, if it exists. ')
lesOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('active')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesOperStatus.setDescription(" This object reflects the actual state of the LES which may differ from that of the lesAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding lesAdminStatus is 'active'.")
lesAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesAdminStatus.setDescription(' The desired state of the designated LES as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lesOperStatus.')
lesStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 20), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatus.setDescription(' The status of this entry (conceptual row). This row cannot be set to active until an appropiate value of lesIfIndex has been specified. ')
lesSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: lesSegmentID.setDescription(' The segment ID of the emulated LAN this LES is servicing. This object is only valid if the lesLanType is dot5(2).')
lesStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2), )
if mibBuilder.loadTexts: lesStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatsTable.setDescription(' A (conceptual) table of statistics associated with LES instances on the device.')
lesStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-LES-MIB", "lesElanName"), (0, "CISCO-LES-MIB", "lesIndex"))
if mibBuilder.loadTexts: lesStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatsEntry.setDescription(' A (conceptual) row in the lesStatsTable which corresponds to the statistics kept by a particular instance of a LES.')
lesInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: lesInErrors.setDescription(' The number of frames received by the LES which were either malformed or did not follow standard protocol (i.e. receiving a LE-ARP request for a multicast address).')
lesInErrorLastLec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInErrorLastLec.setStatus('mandatory')
if mibBuilder.loadTexts: lesInErrorLastLec.setDescription(' The ATM address of the LE client whose last frame to the LES resulted in an increment to the lesInErrors counter.')
lesInFlushReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInFlushReplies.setStatus('mandatory')
if mibBuilder.loadTexts: lesInFlushReplies.setDescription(' The number of Flush replies that have been received by the LES and forwarded onto its clients.')
lesInJoinReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInJoinReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesInJoinReqs.setDescription(' The number of LE_JOIN_REQUESTs received by this LES since activation.')
lesOutJoinFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOutJoinFails.setStatus('mandatory')
if mibBuilder.loadTexts: lesOutJoinFails.setDescription(' The number of rejection LE_JOIN_RESPONSEs transmitted by this LES since activation.')
lesJoinLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesJoinLastFailCause.setStatus('mandatory')
if mibBuilder.loadTexts: lesJoinLastFailCause.setDescription(' The cause for the transmission of the last rejection LE_JOIN_RESPONSE. This is the value of the status field within the rejection response. If the server has never issued a rejection response then this object will have the value of 0.')
lesJoinLastFailLec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 7), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesJoinLastFailLec.setStatus('mandatory')
if mibBuilder.loadTexts: lesJoinLastFailLec.setDescription(" The ATM address of the client whose last LE_JOIN_REQUEST resulted in a rejection by this server. If the server has never issued a rejection response then this object will have the value of all 0's (i.e. 0x000...).")
lesOutConfigReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOutConfigReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesOutConfigReqs.setDescription(' The number of LE_CONFIGURE_REQUESTs sent by this LES since activation.')
lesInConfigResps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInConfigResps.setStatus('mandatory')
if mibBuilder.loadTexts: lesInConfigResps.setDescription(' The number of successful LE_CONFIGURE_RESPONSEs received by this LES since activation.')
lesInConfigFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInConfigFails.setStatus('mandatory')
if mibBuilder.loadTexts: lesInConfigFails.setDescription(' The number of rejection LE_CONFIGURE_RESPONSEs received by this LES since activation.')
lesInRegisReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInRegisReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesInRegisReqs.setDescription(' The number of LE_REGISTER_REQUESTs received by this LES since activation.')
lesOutRegisFails = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOutRegisFails.setStatus('mandatory')
if mibBuilder.loadTexts: lesOutRegisFails.setDescription(' The number of rejection LE_REGISTER_RESPONSEs transmitted by this LES since activation.')
lesRegisLastFailCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesRegisLastFailCause.setStatus('mandatory')
if mibBuilder.loadTexts: lesRegisLastFailCause.setDescription(' The cause for the transmission of the last rejection LE_REGISTER_RESPONSE. This variable has the value of the status field within the last failure register response. If the server has never issued a failed registration response then the value of this object shall be 0.')
lesRegisLastFailLec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 14), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesRegisLastFailLec.setStatus('mandatory')
if mibBuilder.loadTexts: lesRegisLastFailLec.setDescription(" The ATM address of the client whose last LE_REGISTER_REQUEST to this LES resulted in failure. If the server has never issued a failed registration response then the value of this object shall be all 0's (i.e. x0000...).")
lesInUnregReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInUnregReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesInUnregReqs.setDescription(' The number of valid LE_UNREGISTER_REQUESTs received by this LES since activation.')
lesInLearpUcasts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInLearpUcasts.setStatus('mandatory')
if mibBuilder.loadTexts: lesInLearpUcasts.setDescription(' The number of LE_ARP_REQUESTs received by this LES since activation and responded to directly. This applies to all LE_ARP requests for addresses registered by LE clients with the LES. Note that a LES is not required to answer LE_ARP requests directly and may forward the request on to the control distribute regardless. This counter does not apply to those requests the BUS (the broadcast address).')
lesInLearpBroadcasts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInLearpBroadcasts.setStatus('mandatory')
if mibBuilder.loadTexts: lesInLearpBroadcasts.setDescription(" The number of LE_ARP_REQUEST received by the LES for the broadcast address. These requests are responded to with the BUS' ATM address.")
lesOutLearpFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOutLearpFwd.setStatus('mandatory')
if mibBuilder.loadTexts: lesOutLearpFwd.setDescription(' The number of LE_ARP_REQUEST frames forwarded onto the control distribute VC.')
lesInLearpResps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInLearpResps.setStatus('mandatory')
if mibBuilder.loadTexts: lesInLearpResps.setDescription(' The number of LE_ARP_RESPONSEs received by this LES and forwarded onto the control distribute. ')
lesInNarpReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInNarpReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesInNarpReqs.setDescription(' The number of Negative LE_ARP requests received by this LES and forwarded on to the control distribute VC.')
lesInTopolReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesInTopolReqs.setStatus('mandatory')
if mibBuilder.loadTexts: lesInTopolReqs.setDescription(' The number of LE_TOPOLOGY_REQUESTs received by this LES since activation.')
lesClientTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1), )
if mibBuilder.loadTexts: lesClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientTable.setDescription(' A (conceptual) table listing the clients associated with a LES. Note that the local or network management will not create or destroy rows in this table but may only inspect what LECs are currently joined with the LES.')
lesClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-LES-MIB", "lesElanName"), (0, "CISCO-LES-MIB", "lesIndex"), (0, "CISCO-LES-MIB", "lesClientLecid"))
if mibBuilder.loadTexts: lesClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientEntry.setDescription(' An entry (conceptual) row that denotes a client that is joined with the LES.')
lesClientLecid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65279)))
if mibBuilder.loadTexts: lesClientLecid.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientLecid.setDescription(' The LECID selected for an LEC by the LES during the JOIN phase.')
lesClientAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesClientAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientAtmAddr.setDescription(' The primary ATM address associated with the designated LEC.')
lesClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("connected", 1), ("joinRecv", 2), ("verify", 3), ("addLec", 4), ("busConnect", 5), ("operational", 6), ("terminating", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesClientState.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientState.setDescription(" The current state of the LEC. Note that busConnect is only a monitorable state if the BUS is colocated with the LES. In the event that it is not then the client state should proceed immediately to operational within this table (though it may not do so in actuality). Note that there is no relation between the client's internal state and the state reflected here. The state here is only the LES's observed state of the LEC.")
lesClientIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesClientIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientIfIndex.setDescription(' The interface of the bi-directional control direct connection between the LEC and LES.')
lesClientControlVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 5), CiscoVpiInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesClientControlVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientControlVpi.setDescription(' The VPI of the bi-directional control direct connection between the LEC and LES.')
lesClientControlVci = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 6), CiscoVciInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesClientControlVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientControlVci.setDescription(' The VCI of the bi-directional control direct connection between the LEC and LES.')
lesClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 2, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesClientStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesClientStatus.setDescription(' The status of the (conceptual) row. Note that this object may only return the active(1) state. The only value which may be written to this object is the destroy(6) state which will cause the client to be dropped from the ELAN.')
lesMacRegTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 1), )
if mibBuilder.loadTexts: lesMacRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesMacRegTable.setDescription(' A (conceptual) table of MAC addresses registered with the LES by its clients.')
lesMacRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-LES-MIB", "lesElanName"), (0, "CISCO-LES-MIB", "lesIndex"), (0, "CISCO-LES-MIB", "lesMacRegMacAddress"))
if mibBuilder.loadTexts: lesMacRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesMacRegEntry.setDescription(' An entry (conceptual row) that denotes a registered MAC address and the ATM address that corresponds to it.')
lesMacRegMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 1, 1, 1), MacAddress())
if mibBuilder.loadTexts: lesMacRegMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lesMacRegMacAddress.setDescription(' The MAC address of a registered client.')
lesMacRegAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 1, 1, 3), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesMacRegAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesMacRegAtmAddr.setDescription(' The ATM address of the LEC that corresponds to the registered MAC address.')
lesMacRegLecid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesMacRegLecid.setStatus('mandatory')
if mibBuilder.loadTexts: lesMacRegLecid.setDescription(' The LECID of the client who registered the designated MAC address.')
lesRDRegTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2), )
if mibBuilder.loadTexts: lesRDRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegTable.setDescription(' A (conceptual) table of Route Descriptors registered with the LES by its clients.')
lesRDRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-LES-MIB", "lesElanName"), (0, "CISCO-LES-MIB", "lesIndex"), (0, "CISCO-LES-MIB", "lesRDRegSegmentId"), (0, "CISCO-LES-MIB", "lesRDRegBridgeNum"))
if mibBuilder.loadTexts: lesRDRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegEntry.setDescription(' An entry (conceptual row) that denotes a registered Route Descriptor address and the ATM address that corresponds to it.')
lesRDRegSegmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: lesRDRegSegmentId.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegSegmentId.setDescription(' The segment ID of a registered client.')
lesRDRegBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lesRDRegBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegBridgeNum.setDescription(' The bridge number of a registered client going to the designated segment.')
lesRDRegAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2, 1, 3), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesRDRegAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegAtmAddr.setDescription(' The ATM address of the LEC that corresponds to the registered Route Descriptor.')
lesRDRegLecid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 39, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesRDRegLecid.setStatus('mandatory')
if mibBuilder.loadTexts: lesRDRegLecid.setDescription(' The LECID of the client who registered the designated Route Descriptor address.')
ciscoLesGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 1))
ciscoLesStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 2))
ciscoLesColocatedGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 3))
ciscoLesLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 4))
ciscoLesCntrlDistGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 5))
ciscoLesSubIfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 6))
ciscoLesClientGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 7))
ciscoLesTokenRingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 1, 8))
ciscoLesMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 39, 2, 2, 1))
mibBuilder.exportSymbols("CISCO-LES-MIB", lesJoinLastFailCause=lesJoinLastFailCause, lesJoinLastFailLec=lesJoinLastFailLec, ciscoLesGroup=ciscoLesGroup, lesTable=lesTable, lesInJoinReqs=lesInJoinReqs, lesAtmAddrSpec=lesAtmAddrSpec, lesEntry=lesEntry, lesClientStatus=lesClientStatus, lesClientState=lesClientState, lesUpTime=lesUpTime, lesInLearpBroadcasts=lesInLearpBroadcasts, leClient=leClient, lesMacRegMacAddress=lesMacRegMacAddress, lesRDRegTable=lesRDRegTable, ciscoLesMIBCompliances=ciscoLesMIBCompliances, lesInTopolReqs=lesInTopolReqs, lesIfIndex=lesIfIndex, lesInLearpResps=lesInLearpResps, lesControlDistVci=lesControlDistVci, ciscoLesMIBCompliance=ciscoLesMIBCompliance, lesStatus=lesStatus, lesMaxFrm=lesMaxFrm, lesStatsTable=lesStatsTable, lesInLearpUcasts=lesInLearpUcasts, lesInNarpReqs=lesInNarpReqs, lesColocBusAtmAddrMask=lesColocBusAtmAddrMask, lesOutConfigReqs=lesOutConfigReqs, lesRDRegEntry=lesRDRegEntry, lesOutRegisFails=lesOutRegisFails, lesLanType=lesLanType, lesInErrors=lesInErrors, register=register, lesInFlushReplies=lesInFlushReplies, lesElanName=lesElanName, lesControlDistVpi=lesControlDistVpi, lesAtmAddrActual=lesAtmAddrActual, lesOperStatus=lesOperStatus, lesSegmentID=lesSegmentID, lesIndex=lesIndex, lesClientLecid=lesClientLecid, lesClientTable=lesClientTable, ciscoLesClientGroup=ciscoLesClientGroup, lesRegisLastFailCause=lesRegisLastFailCause, ciscoLesMIBConformance=ciscoLesMIBConformance, lesAtmAddrMask=lesAtmAddrMask, lesStatsEntry=lesStatsEntry, ciscoLesColocatedGroup=ciscoLesColocatedGroup, ciscoLesStatsGroup=ciscoLesStatsGroup, lesClientEntry=lesClientEntry, ciscoLesMIBObjects=ciscoLesMIBObjects, lesInConfigFails=lesInConfigFails, lesColocBusAtmAddrActl=lesColocBusAtmAddrActl, lesClientIfIndex=lesClientIfIndex, lesRDRegSegmentId=lesRDRegSegmentId, lesInConfigResps=lesInConfigResps, lesColocBusAtmAddrSpec=lesColocBusAtmAddrSpec, ciscoLesMIBGroups=ciscoLesMIBGroups, lesJoinTimeout=lesJoinTimeout, ciscoLesMIB=ciscoLesMIB, lesClientAtmAddr=lesClientAtmAddr, lesRDRegBridgeNum=lesRDRegBridgeNum, lesClientControlVci=lesClientControlVci, ciscoLesCntrlDistGroup=ciscoLesCntrlDistGroup, lesMacRegLecid=lesMacRegLecid, lesAdminStatus=lesAdminStatus, lesMacRegTable=lesMacRegTable, lesRegisLastFailLec=lesRegisLastFailLec, lesInUnregReqs=lesInUnregReqs, lesMacRegAtmAddr=lesMacRegAtmAddr, ciscoLesLecsGroup=ciscoLesLecsGroup, lesRDRegLecid=lesRDRegLecid, lesLecsAtmAddr=lesLecsAtmAddr, ciscoLesSubIfGroup=ciscoLesSubIfGroup, lesRDRegAtmAddr=lesRDRegAtmAddr, lesInRegisReqs=lesInRegisReqs, lesClientControlVpi=lesClientControlVpi, lesInErrorLastLec=lesInErrorLastLec, lesMacRegEntry=lesMacRegEntry, lesSubIfNum=lesSubIfNum, les=les, lesOutJoinFails=lesOutJoinFails, ciscoLesTokenRingGroup=ciscoLesTokenRingGroup, lesOutLearpFwd=lesOutLearpFwd)

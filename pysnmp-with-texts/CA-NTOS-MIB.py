#
# PySNMP MIB module CA-NTOS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CA-NTOS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:43:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, Integer32, Unsigned32, Bits, Counter64, ObjectIdentity, enterprises, MibIdentifier, iso, Counter32, TimeTicks, NotificationType, IpAddress, Gauge32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Integer32", "Unsigned32", "Bits", "Counter64", "ObjectIdentity", "enterprises", "MibIdentifier", "iso", "Counter32", "TimeTicks", "NotificationType", "IpAddress", "Gauge32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cai = MibIdentifier((1, 3, 6, 1, 4, 1, 791))
caiSysMgr = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2))
agentWorks = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9))
nt = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2))
caiNtOs = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2))
ntConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2))
ntStatusGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3))
ntPollGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4))
ntAvailableGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5))
ntGeneralConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2))
ntAgentVersion = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAgentVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ntAgentVersion.setDescription('&<caiNtOs.100>The currently installed version of NT System Agent.')
ntAgentColdStartTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAgentColdStartTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAgentColdStartTimestamp.setDescription('&<caiNtOs.101>The date and time that NT System Agent was last initiated.')
ntAgentWarmStartTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAgentWarmStartTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAgentWarmStartTimestamp.setDescription('&<caiNtOs.102>The date and time that NT System Agent was last reset.')
ntFilesystemPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFilesystemPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesystemPollTimestamp.setDescription('&<caiNtOs.103>The date and time that NT System Agent last polled for filesystem information.')
ntFilePollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFilePollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilePollTimestamp.setDescription('&<caiNtOs.104>The date and time that NT System Agent last polled for file information.')
ntProcessPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessPollTimestamp.setDescription('&<caiNtOs.105>The date and time that NT System Agent last polled for process information.')
ntServicePollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntServicePollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntServicePollTimestamp.setDescription('&<caiNtOs.106>The date and time that NT System Agent last polled for service information.')
ntPrinterPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntPrinterPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrinterPollTimestamp.setDescription('&<caiNtOs.107>The date and time that NT System Agent last polled for printer information.')
ntMemoryPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntMemoryPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntMemoryPollTimestamp.setDescription('&<caiNtOs.108>The date and time that NT System Agent last polled for memory information.')
ntProcessorPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessorPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorPollTimestamp.setDescription('&<caiNtOs.109>The date and time that NT System Agent last polled for % CPU utilization information.')
ntRegistryPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntRegistryPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryPollTimestamp.setDescription('&<caiNtOs.110>The date and time that NT System Agent last polled for registry information.')
ntLogPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 2, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogPollTimestamp.setDescription('&<caiNtOs.111>The date and time that NT System Agent last polled for event log information.')
ntFileSystemConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3))
ntFSPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFSPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSPollInterval.setDescription('&<caiNtOs.112>Filesystem Poll Interval.')
ntDefFSWarnThresh = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFSWarnThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFSWarnThresh.setDescription('&<caiNtOs.113>Default utilization warning threshold defined in terms of percentage of filesystem total capacity.')
ntDefFSCriticalThresh = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFSCriticalThresh.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFSCriticalThresh.setDescription('&<caiNtOs.114>Default utilization critical threshold defined in terms of percentage of filesystem total capacity.')
ntDefFSDelta = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFSDelta.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFSDelta.setDescription('&<caiNtOs.115>Default delta threshold defined in terms of percentage of total capacity.')
ntFSMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFSMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSMonitored.setDescription('&<caiNtOs.116>Number of Filesystems currently being monitored.')
ntFSAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFSAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSAdd.setDescription('&<caiNtOs.117>User enters new filesystems for monitoring here, referencing by drive letter. e.g. c:\\')
ntFSRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 3, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFSRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSRemove.setDescription('&<caiNtOs.118>User removes filesystems from the monitoring list, referencing by drive letter. e.g. c:\\')
ntFileConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4))
ntFilePollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFilePollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilePollInterval.setDescription('&<caiNtOs.119>File Poll Interval.')
ntDefFileSizeWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFileSizeWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFileSizeWarning.setDescription('&<caiNtOs.120>Initial Warning threshold, defined in terms of percentage of current size (when the file was added for monitoring).')
ntDefFileSizeCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFileSizeCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFileSizeCritical.setDescription('&<caiNtOs.121>Initial Critical threshold, defined in terms of percentage of current size (when the file was added for monitoring).')
ntDefFileSizeChangeFlag = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFileSizeChangeFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFileSizeChangeFlag.setDescription('&<caiNtOs.122>Flag indicating whether, by default, files should be monitored for size change.')
ntDefFileSizeChange = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFileSizeChange.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFileSizeChange.setDescription('&<caiNtOs.123>Percentage file size change over ntFileSizeChangePolls required to raise an alert.')
ntDefFileTimestampFlag = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefFileTimestampFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefFileTimestampFlag.setDescription('&<caiNtOs.124>Flag indicating at what alert level the file should be monitored for a timestamp change.')
ntFilesMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFilesMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesMonitored.setDescription('&<caiNtOs.125>Number of Files currently being monitored')
ntFileAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFileAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileAdd.setDescription('&<caiNtOs.126>Full pathname of a file to add to the monitoring list.')
ntFileRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 4, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntFileRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileRemove.setDescription('&<caiNtOs.127>Full pathname of a file to remove from the monitoring list.')
ntProcessConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5))
ntProcPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntProcPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcPollInterval.setDescription('&<caiNtOs.128>Process Poll Interval.')
ntDefProcAlertLevel = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-monitored", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefProcAlertLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefProcAlertLevel.setDescription('&<caiNtOs.129>Default level of alert to be signalled.')
ntDefProcExist = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alert-if-exist", 1), ("alert-if-not-exist", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefProcExist.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefProcExist.setDescription("&<caiNtOs.130>Flag indicating whether, by default, an alert is raised if the process exists or doesn't exist.")
ntDefProcInstanceAlert = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefProcInstanceAlert.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefProcInstanceAlert.setDescription('&<caiNtOs.131>Flag indicating whether, by default, the instances of the process should be monitored.')
ntDefProcThreadAlert = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("above", 2), ("below", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefProcThreadAlert.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefProcThreadAlert.setDescription('&<caiNtOs.132>Value indicating whether, by default, the thread count of the process should be monitored.')
ntProcessesMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessesMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessesMonitored.setDescription('&<caiNtOs.133>Number of Processes currently being monitored')
ntProcAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntProcAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcAdd.setDescription('&<caiNtOs.134>Process to add to the monitoring list.')
ntProcRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 5, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntProcRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcRemove.setDescription('&<caiNtOs.135>Process to the remove from the monitoring list.')
ntServiceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6))
ntServPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntServPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntServPollInterval.setDescription('&<caiNtOs.136>Service Poll Interval.')
ntDefServAlertOn = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefServAlertOn.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefServAlertOn.setDescription('&<caiNtOs.137>Default configuration indicating when to raise an event, either never, when the service is active or when it is inactive.')
ntServicesMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntServicesMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntServicesMonitored.setDescription('&<caiNtOs.138>Number of Services currently being monitored.')
ntServiceAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntServiceAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntServiceAdd.setDescription('&<caiNtOs.139>Service to add to the monitoring list, this is the Service Name, not the description provided by the vendor.')
ntServiceRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 6, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntServiceRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntServiceRemove.setDescription('&<caiNtOs.140>Process to remove from the monitoring list, this is the Service Name, not the description provided by the vendor.')
ntPrinterConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7))
ntPrinterPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrinterPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrinterPollInterval.setDescription('&<caiNtOs.141>Printer Poll Interval.')
ntDefPrintEventMonitor = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefPrintEventMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefPrintEventMonitor.setDescription('&<caiNtOs.142>Flag indicating whether, by default. alerts should be raised on printer events, and if so, the level of alert to raise.')
ntDefPrinterQFlag = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefPrinterQFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefPrinterQFlag.setDescription("&<caiNtOs.143>Flag indicating whether, by default. the printer's job queue should be monitored.")
ntDefPrinterQWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefPrinterQWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefPrinterQWarning.setDescription("&<caiNtOs.144>Default Warning threshold for the number of jobs in the printer'squeue.")
ntDefPrinterQCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefPrinterQCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefPrinterQCritical.setDescription("&<caiNtOs.145>Default Critical threshold for the number of jobs in the printer's queue.")
ntPrintersMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntPrintersMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrintersMonitored.setDescription('&<caiNtOs.146>Number of Printers currently being monitored.')
ntPrinterAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrinterAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrinterAdd.setDescription('&<caiNtOs.147>Printer to add to the monitoring list.')
ntPrinterRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 7, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntPrinterRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrinterRemove.setDescription('&<caiNtOs.148>Printer to remove from the monitoring list.')
ntMemoryConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8))
ntMemPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntMemPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntMemPollInterval.setDescription('&<caiNtOs.149>Memory Monitoring Poll Interval.')
ntDefMemLoadWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemLoadWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemLoadWarning.setDescription('&<caiNtOs.150>Current Memory Load Warning Threshold, in terms of percentage. This threshold should be lower, or equal to the Critical Threshold.')
ntDefMemLoadCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemLoadCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemLoadCritical.setDescription('&<caiNtOs.151>Current Memory Load Critical Threshold, in terms of percentage. This threshold should be higher, or equal to the Warning Threshold.')
ntDefMemLoadCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemLoadCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemLoadCount.setDescription('&<caiNtOs.152>The number of successive polling periods that Memory Load must exceed cross a threshold before a status change is signalled.')
ntDefMemPhysWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemPhysWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemPhysWarning.setDescription('&<caiNtOs.153>Available Physical Memory Warning Threshold, in terms of percentage of total Physical Memory on the system. This threshold should be higher, or equal, to the Critical Threshold.')
ntDefMemPhysCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemPhysCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemPhysCritical.setDescription('&<caiNtOs.154>Available Physical Memory Critical Threshold, in terms of percentage of total Physical Memory on the system. This threshold should be lower, or equal, to the Warning Threshold.')
ntDefMemPhysCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemPhysCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemPhysCount.setDescription('&<caiNtOs.155>The number of successive polling periods that Physical Memory must exceed cross a threshold before a status change is signalled.')
ntDefMemSwapWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemSwapWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemSwapWarning.setDescription('&<caiNtOs.156>Available Swapspace Warning Threshold, in terms of percentage of total Swapspace (Page File Memory) available on the system. This threshold should be higher, or equal, to the Critical Threshold.')
ntDefMemSwapCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemSwapCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemSwapCritical.setDescription('&<caiNtOs.157>Available Swapspace Critical Threshold, in terms of percentage of total Swapspace (Page File Memory) available on the system. This threshold should be lower, or equal, to the Warning Threshold')
ntDefMemSwapCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 8, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefMemSwapCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefMemSwapCount.setDescription('&<caiNtOs.158>The number of successive polling periods that available Swapspace must exceed cross a threshold before a status change is signalled.')
ntProcessorConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9))
ntCPUPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntCPUPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUPollInterval.setDescription('&<caiNtOs.159>Processor Monitoring Poll Interval.')
ntDefCPUWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefCPUWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefCPUWarning.setDescription('&<caiNtOs.160>Default CPU Warning Threshold, defined in terms of %Total CPU. This should be lower, or equal to, the Critical Threshold.')
ntDefCPUCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefCPUCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefCPUCritical.setDescription('&<caiNtOs.161>Default CPU Critical Threshold, defined in terms of %Total CPU. This should be greater than, or equal to, the Warning Threshold.')
ntDefCPUCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefCPUCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefCPUCount.setDescription('&<caiNtOs.162>The number of successive polling periods that %Total CPU must exceed cross a threshold before a status change is signalled.')
ntCPUsMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 9, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUsMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUsMonitored.setDescription('&<caiNtOs.163>Number of CPUs currently being monitored.')
ntRegistryConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10))
ntRegPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntRegPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegPollInterval.setDescription('&<caiNtOs.164>Registry Monitoring Poll Interval.')
ntDefRegMonitorLevel = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("change", 2), ("thresholds", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefRegMonitorLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefRegMonitorLevel.setDescription('&<caiNtOs.165>Defines the default type of value monitoring to be performed, this may be not to monitor, monitor for a change or to monitor against thresholds. For leaves of string type requests to monitor against thresholds are ignored.')
ntDefRegWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefRegWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefRegWarning.setDescription('&<caiNtOs.166>Default Warning Threshold for integer type leaves, defined as a percentage of the original leaf value at initiation. (This value is ignored if the leaf is of string type).')
ntDefRegCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefRegCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefRegCritical.setDescription('&<caiNtOs.167>Default Critical Threshold for integer type leaves, defined as a percentage of the original leaf value at initiation. (This value is ignored if the leaf is of string type).')
ntRegLeavesMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntRegLeavesMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegLeavesMonitored.setDescription('&<caiNtOs.168>Number of Registry Leaves currently being monitored.')
ntRegistryLeafAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntRegistryLeafAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryLeafAdd.setDescription("&<caiNtOs.169>Registry leaf to add to the monitoring list. This should be explicit and in the form Table\\Leaf (for example 'HKEY-LOCAL-MACHINE\\SOFTWARE\\MyApp\\Version').")
ntRegistryLeafRemove = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 10, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntRegistryLeafRemove.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryLeafRemove.setDescription('&<caiNtOs.170>Registry leaf to remove from the monitoring list.')
ntEventLogConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11))
ntLogPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntLogPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogPollInterval.setDescription('&<caiNtOs.171>The interval at which the agent checks the event logs.')
ntLogApplicationCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogApplicationCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogApplicationCount.setDescription('&<caiNtOs.172>The number of events currently in the application event log.')
ntLogSecurityCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSecurityCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSecurityCount.setDescription('&<caiNtOs.173>The number of events currently in the security event log.')
ntLogSystemCount = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSystemCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSystemCount.setDescription('&<caiNtOs.174>The number of events currently in the system event log.')
ntDefLogMonitorLevel = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntDefLogMonitorLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntDefLogMonitorLevel.setDescription('&<caiNtOs.175>Defines the default type of value monitoring to be performed, this may be not to raise traps or raise warning or critical level traps.')
ntLogsMonitored = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogsMonitored.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogsMonitored.setDescription('&<caiNtOs.176>Number of Event Log Watches')
ntLogAdd = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 2, 11, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntLogAdd.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogAdd.setDescription('&<caiNtOs.177>Comma-separated description of the event watcher to be configured. The format is:LOG/S,SOURCE,SEVERITY/s,EVENTID,USER,COMPUTER')
ntStatusSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2))
ntStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatus.setDescription("&<caiNtOs.178>The overall status of the NT System Agent, aggregated from it's component managed objects. This is a 'worst case' aggregation.")
ntTotalWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntTotalWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntTotalWarning.setDescription('&<caiNtOs.179>The total number of managed objects with a Warning Status.')
ntTotalCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntTotalCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntTotalCritical.setDescription('&<caiNtOs.180>The total number of managed objects with a Critical Status.')
ntFSWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFSWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSWarnStatus.setDescription('&<caiNtOs.181>The total number of filesystems with a Warning state.')
ntFSCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFSCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntFSCriticalStatus.setDescription('&<caiNtOs.182>The total number of filesystems with a Critical state.')
ntFileWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileWarnStatus.setDescription('&<caiNtOs.183>The total number of monitored files with a Warning state.')
ntFileCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileCriticalStatus.setDescription('&<caiNtOs.184>The total number of monitored files with a Critical state.')
ntProcessWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessWarnStatus.setDescription('&<caiNtOs.185>The total number of processes with a Warning state.')
ntProcessCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessCriticalStatus.setDescription('&<caiNtOs.186>The total number of processes with a Critical state.')
ntServicesWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntServicesWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntServicesWarnStatus.setDescription('&<caiNtOs.187>The total number of services with a Warning state.')
ntServicesCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntServicesCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntServicesCriticalStatus.setDescription('&<caiNtOs.188>The total number of services with a Critical state.')
ntPrintWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntPrintWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrintWarnStatus.setDescription('&<caiNtOs.189>The total number of monitored printers with a Warning state.')
ntPrintCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntPrintCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrintCriticalStatus.setDescription('&<caiNtOs.190>The total number of monitored printers with a Critical state.')
ntMemoryWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntMemoryWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntMemoryWarnStatus.setDescription('&<caiNtOs.191>The total number of monitored memory attributes with a Warning state.')
ntMemoryCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntMemoryCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntMemoryCriticalStatus.setDescription('&<caiNtOs.192>The total number of monitored memory attributes with a Critical state.')
ntProcessorWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessorWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorWarnStatus.setDescription('&<caiNtOs.193>The total number of processors with a Warning state.')
ntProcessorCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessorCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorCriticalStatus.setDescription('&<caiNtOs.194>The total number of processors with a Critical state.')
ntRegistryWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntRegistryWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryWarnStatus.setDescription("&<caiNtOs.195>The total number of 'registry watches' with a Warning state.")
ntRegistryCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntRegistryCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryCriticalStatus.setDescription("&<caiNtOs.196>The total number of 'registry watches' with a Critical state.")
ntEventLogWarnStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntEventLogWarnStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntEventLogWarnStatus.setDescription("&<caiNtOs.197>The total number of 'event log watches' with a Warning state.")
ntEventLogCriticalStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 2, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntEventLogCriticalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntEventLogCriticalStatus.setDescription("&<caiNtOs.198>The total number of 'event log watches' with a Critical state.")
ntFilesystemStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3), )
if mibBuilder.loadTexts: ntFilesystemStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesystemStTable.setDescription('&<caiNtOs.199>List of information about monitored filesystems.')
ntFilesystemStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusFSDriveLetter"))
if mibBuilder.loadTexts: ntFilesystemStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesystemStTableEntry.setDescription('&<caiNtOs.200>A table entry containing information about a monitored filesystem.')
ntStatusFSDriveLetter = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSDriveLetter.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDriveLetter.setDescription('&<caiNtOs.201>The drive letter of the filesystem as recognised by the operating system.')
ntStatusFSDriveLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSDriveLabel.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDriveLabel.setDescription('&<caiNtOs.202>The drive label of the filesystem.')
ntStatusFSDriveType = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSDriveType.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDriveType.setDescription('&<caiNtOs.203>Drive type as determined by the operating system (removeable, fixed, CDROM etc.).')
ntStatusFSDriveFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSDriveFormat.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDriveFormat.setDescription('&<caiNtOs.204>Format type as determined by the operating system (FAT, NTFS, CDFS etc).')
ntStatusFSTotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSTotalCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSTotalCapacity.setDescription('&<caiNtOs.205>Total Filesystem Capacity in Kbytes.')
ntStatusFSUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSUtilization.setDescription('&<caiNtOs.206>Current Utilization of the Filesystem in Kbytes.')
ntStatusFSFree = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSFree.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSFree.setDescription('&<caiNtOs.207>Current Free Space on the Filesystem in Kbytes.')
ntStatusFSStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("down", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSStatus.setDescription('&<caiNtOs.208>Current status of the filesystem.')
ntStatusFSPcntWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSPcntWarn.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSPcntWarn.setDescription('&<caiNtOs.209>Filesystem Utilization Warning Threshold defined in terms of percentage of total capacity. This value must be less than, or equal to, the Critical threshold. Changes to this value are automatically reflected in ntStatusKFSByteWarn.')
ntStatusFSPcntCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSPcntCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSPcntCritical.setDescription('&<caiNtOs.210>Filesystem Utilization Critical Threshold defined in terms of percentage of total capacity. This value must be greater than, or equal to, the Warning threshold. Changes to this value are automatically reflected in ntStatusFSKByteCritical.')
ntStatusFSKByteWarn = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSKByteWarn.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSKByteWarn.setDescription('&<caiNtOs.211>Filesystem Utilization Warning Threshold defined in terms of Kbytes utilized. This value must be less than, or equal to, the Critical threshold. Changes to this value are automatically reflected in ntStatusFSPcntWarn.')
ntStatusFSKByteCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSKByteCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSKByteCritical.setDescription('&<caiNtOs.212>Filesystem Utilization Critical Threshold defined in terms of Kbytes utilized. This value must be greater than, or equal to, the Warning threshold. Changes to this value are automatically reflected in ntStatusFSPcntCritical.')
ntStatusFSAvgUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSAvgUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSAvgUtil.setDescription('&<caiNtOs.213>Average filesystem utilization over the up-time of the agent, expressed in Kbytes.')
ntStatusFSMinUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSMinUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSMinUtil.setDescription('&<caiNtOs.214>Minimum filesystem utilization over the up-time of the agent, expressed in Kbytes.')
ntStatusFSMaxUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSMaxUtil.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSMaxUtil.setDescription('&<caiNtOs.215>Maximum filesystem utilization over the up-time of the agent, expressed in Kbytes.')
ntStatusFSUtilDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFSUtilDelta.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSUtilDelta.setDescription('&<caiNtOs.216>Difference in filesystem utilization between the current and previous polls, in terms of percentage of total capacity.')
ntStatusFSDeltaLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSDeltaLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDeltaLevel.setDescription('&<caiNtOs.217>Level of alert to be raised on delta monitoring.')
ntStatusFSDeltaThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSDeltaThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDeltaThreshold.setDescription('&<caiNtOs.218>Filesystem Delta Threshold defines, in terms of percentage of total filesystem capacity, the delta value at which to raise an alert at the level defined in ntStatusFSDeltaLevel.')
ntStatusFSDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 3, 2, 20), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFSDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFSDescription.setDescription('&<caiNtOs.219>Description of the filesystem to be amended by the user, primary use, manufacturer etc..')
ntFileStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4), )
if mibBuilder.loadTexts: ntFileStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileStTable.setDescription('&<caiNtOs.220>List of information about monitored files.')
ntFileStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusFileName"))
if mibBuilder.loadTexts: ntFileStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileStTableEntry.setDescription('&<caiNtOs.221>A table entry containing information about a monitored file.')
ntStatusFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileName.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileName.setDescription('&<caiNtOs.222>The complete pathname of the file on the managed system.')
ntStatusFileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileStatus.setDescription('&<caiNtOs.223>Current status of the file, which is an aggregation of the file size status, file size change and timestamp status.')
ntStatusFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSize.setDescription('&<caiNtOs.224>Current file size in bytes.')
ntStatusFileSizeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileSizeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeStatus.setDescription('&<caiNtOs.225>File Size Status, determined according to the File Size thresholds.')
ntStatusFileSizeWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileSizeWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeWarning.setDescription('&<caiNtOs.226>File Size Warning threshold defined as a percentage of ntStatusFileSizeBase, this value should be less than, or equal to, the Critical Threshold.')
ntStatusFileSizeCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileSizeCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeCritical.setDescription('&<caiNtOs.227>File Size Critical threshold defined as a of percentage of ntStatusFileSizeBase, this value should be greater than, or equal to, the Warning Threshold.')
ntStatusFileTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileTimestamp.setDescription('&<caiNtOs.228>File timestamp.')
ntStatusFileTimestampFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileTimestampFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileTimestampFlag.setDescription('&<caiNtOs.229>Monitoring configuration for timestamp monitoring')
ntStatusFileTimestampStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("not-monitored", 4), ("reset", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileTimestampStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileTimestampStatus.setDescription("&<caiNtOs.230>Timestamp Monitoring status - set to 'Reset' to reset timestamp")
ntStatusFileSizeChFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileSizeChFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeChFlag.setDescription('&<caiNtOs.231>Flag indicating whether the file should be monitored for size change.')
ntStatusFileSizeCh = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileSizeCh.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeCh.setDescription('&<caiNtOs.232>File size change calculated over number of periods defined in ntFileConfig. If this has not been possible to calculate yet -1 is stored.')
ntStatusFileSizeChState = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("not-monitored", 4), ("reset", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileSizeChState.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeChState.setDescription('&<caiNtOs.233>File Size Change status according to the File Size Change threshold values.')
ntStatusFileSizeChBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileSizeChBytes.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeChBytes.setDescription('&<caiNtOs.234>Number of bytes of size growth.')
ntStatusFileMinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileMinSize.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileMinSize.setDescription('&<caiNtOs.235>Minimum file size recorded over the up-time of the agent, in bytes.')
ntStatusFileMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileMaxSize.setDescription('&<caiNtOs.236>Maximum file size recorded over the up-time of the agent, in bytes.')
ntStatusFileAvgSize = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileAvgSize.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileAvgSize.setDescription('&<caiNtOs.237>Average file size recorded over the up-time of the agent, in bytes.')
ntStatusFileDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusFileDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileDescription.setDescription('&<caiNtOs.238>Description of the file, defined by the user.')
ntStatusFileSizeBase = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 4, 2, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusFileSizeBase.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusFileSizeBase.setDescription('&<caiNtOs.239>Original file size in bytes used as base size in calculations of File Size thresholds.')
ntProcessStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5), )
if mibBuilder.loadTexts: ntProcessStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessStTable.setDescription('&<caiNtOs.240>List of information about monitored processes.')
ntProcessStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusProcName"))
if mibBuilder.loadTexts: ntProcessStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessStTableEntry.setDescription('&<caiNtOs.241>A table entry containing information about a monitored process.')
ntStatusProcName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcName.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcName.setDescription('&<caiNtOs.242>The name of the process, as returned from the NT Registry.')
ntStatusProcStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcStatus.setDescription('&<caiNtOs.243>Current status of the process, which is an aggregation of the status of the existance, thread and instance monitoring.')
ntStatusProcAlertLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcAlertLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcAlertLevel.setDescription('&<caiNtOs.244>Level of alert to be signalled for an existance check.')
ntStatusProcExist = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("alert-if-exist", 1), ("alert-if-not-exist", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcExist.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcExist.setDescription("&<caiNtOs.245>Flag indicating whether, by default, an alert is raised if the process exists or doesn't exist.")
ntStatusProcInst = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcInst.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcInst.setDescription('&<caiNtOs.246>Number of instances of the process.')
ntStatusProcInstMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcInstMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcInstMonitor.setDescription('&<caiNtOs.247>Flag indicating whether the process should be monitored for instance count.')
ntStatusProcInstWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcInstWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcInstWarning.setDescription('&<caiNtOs.248>Instance Warning threshold, in terms of a count of instances. This should be less than, or equal to, the Critical Threshold.')
ntStatusProcInstCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcInstCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcInstCritical.setDescription('&<caiNtOs.249>Instance Critical threshold, in terms of a count of instances. This should be greater than, or equal to, the Warning Threshold.')
ntStatusProcThd = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcThd.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcThd.setDescription('&<caiNtOs.250>Current thread count, for more than one instance, the maximum is shown.')
ntStatusProcThdMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("above", 2), ("below", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcThdMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcThdMonitor.setDescription('&<caiNtOs.251>Flag indicating whether the process is monitored for thread count, and if so whether to alert on exceeding or dropping below the reference value.')
ntStatusProcThdRef = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcThdRef.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcThdRef.setDescription('&<caiNtOs.252>Reference number of threads to measure state against.')
ntStatusProcThdMax = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcThdMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcThdMax.setDescription('&<caiNtOs.253>Current maximum number of threads of any instance of the process.')
ntStatusProcThdMin = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusProcThdMin.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcThdMin.setDescription('&<caiNtOs.254>Current minimum number of threads of any instance of the process.')
ntStatusProcDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 5, 2, 17), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusProcDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusProcDescription.setDescription('&<caiNtOs.255>Description of the process, supplied by the user.')
ntServiceStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6), )
if mibBuilder.loadTexts: ntServiceStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntServiceStTable.setDescription('&<caiNtOs.256>List of information about monitored services.')
ntServiceStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusServName"))
if mibBuilder.loadTexts: ntServiceStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntServiceStTableEntry.setDescription('&<caiNtOs.257>A table entry containing information about a monitored service.')
ntStatusServName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusServName.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusServName.setDescription('&<caiNtOs.258>The shortname of the service, as defined to the NT Service Manager.')
ntStatusServDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusServDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusServDescription.setDescription('&<caiNtOs.259>The description of the service, as defined to the NT Service Manager.')
ntStatusServState = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("stopped", 1), ("start-pending", 2), ("stop-pending", 3), ("running", 4), ("continue-pending", 5), ("pause-pending", 6), ("paused", 7), ("unknown", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusServState.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusServState.setDescription('&<caiNtOs.260>Operational state of the service returned by the NT Service Manager.')
ntStatusServStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("down", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusServStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusServStatus.setDescription('&<caiNtOs.261>Status of the service according to monitoring rules.')
ntStatusServAlertOn = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 6, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusServAlertOn.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusServAlertOn.setDescription('&<caiNtOs.262>Flag indicating when to raise an event.')
ntPrinterStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7), )
if mibBuilder.loadTexts: ntPrinterStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntPrinterStTable.setDescription('&<caiNtOs.263>List of information about monitored printers.')
ntStatusPrintTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusPrintName"))
if mibBuilder.loadTexts: ntStatusPrintTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintTableEntry.setDescription('&<caiNtOs.264>A table entry containing information about a monitored printer.')
ntStatusPrintName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintName.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintName.setDescription('&<caiNtOs.265>The printer name as known to the operating system.')
ntStatusPrintStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintStatus.setDescription('&<caiNtOs.266>Current status of the printer, which is an aggregation of the status of the job queue monitoring and event monitoring.')
ntStatusPrintEventMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusPrintEventMonitor.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintEventMonitor.setDescription('&<caiNtOs.267>Flag indicating whether alerts should be raised on printer events signalled by Windows NT, and if so, the level of alert to raise.')
ntStatusPrintEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintEventStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintEventStatus.setDescription('&<caiNtOs.268>Current event status.')
ntStatusPrintEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintEventDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintEventDescription.setDescription('&<caiNtOs.269>Textual description of any flagged events on the printer.')
ntStatusPrintQFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusPrintQFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQFlag.setDescription("&<caiNtOs.270>Flag indicating whether the printer's job queue should be monitored.")
ntStatusPrintQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintQueue.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQueue.setDescription("&<caiNtOs.271>Number of jobs currently on the printer's queue.")
ntStatusPrintQStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintQStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQStatus.setDescription('&<caiNtOs.272>Current event status.')
ntStatusPrintQWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusPrintQWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQWarning.setDescription('&<caiNtOs.273>Warning threshold defined in terms of the number of jobs in the queue.')
ntStatusPrintQCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusPrintQCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQCritical.setDescription('&<caiNtOs.274>Critical threshold defined in terms of the number of jobs in the queue.')
ntStatusPrintQMax = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusPrintQMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintQMax.setDescription('&<caiNtOs.275>Maximum number of jobs recorded on the queue since agent up-time.')
ntStatusPrintDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 7, 2, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusPrintDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusPrintDescription.setDescription('&<caiNtOs.276>Description of the Printer, defaulting to that described to NT')
ntMemorySt = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8))
ntStatusMemLoad = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemLoad.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemLoad.setDescription('&<caiNtOs.277>Current Memory Load, defined as a percentage.')
ntStatusMemLoadStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemLoadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemLoadStatus.setDescription('&<caiNtOs.278>Current Memory Load status, as determined by the thresholds defined in ntMemoryConfig.')
ntStatusMemLoadAvg = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemLoadAvg.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemLoadAvg.setDescription('&<caiNtOs.279>Average Memory Load recorded over the agent up-time, as a percentage.')
ntStatusMemLoadMax = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemLoadMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemLoadMax.setDescription('&<caiNtOs.280>Maximum Memory Load recorded over the agent up-time, as a percentage.')
ntStatusMemLoadMin = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemLoadMin.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemLoadMin.setDescription('&<caiNtOs.281>Minimum Memory Load recorded over the agent up-time, as a percentage.')
ntStatusMemPhysTotal = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhysTotal.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhysTotal.setDescription('&<caiNtOs.282>Total Physical Memory available on the system, expressed in bytes.')
ntStatusMemPhys = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhys.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhys.setDescription('&<caiNtOs.283>Current Physical Memory available, expressed in bytes.')
ntStatusMemPhysStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhysStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhysStatus.setDescription('&<caiNtOs.284>Current Physical Memory status, as determined by the thresholds defined in ntMemoryConfig.')
ntStatusMemPhysAvg = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhysAvg.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhysAvg.setDescription('&<caiNtOs.285>Average available Physical Memory recorded over the agent up-time, expressed in bytes.')
ntStatusMemPhysMax = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhysMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhysMax.setDescription('&<caiNtOs.286>Maximum available Physical Memory recorded over the agent up-time, expressed in bytes.')
ntStatusMemPhysMin = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemPhysMin.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemPhysMin.setDescription('&<caiNtOs.287>Minimum available Physical Memory recorded over the agent up-time, expressed in bytes.')
ntStatusMemSwapTotal = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwapTotal.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwapTotal.setDescription('&<caiNtOs.288>Total Swapspace (Paging Memory) available on the system, expressed in bytes.')
ntStatusMemSwap = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwap.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwap.setDescription('&<caiNtOs.289>Current Swapspace (Paging Memory) available over the agent up-time, expressed in bytes.')
ntStatusMemSwapStatus = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwapStatus.setDescription('&<caiNtOs.290>Current Swapspace (Paging Memory) status, as determined by the thresholds defined in ntMemoryConfig.')
ntStatusMemSwapAvg = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwapAvg.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwapAvg.setDescription('&<caiNtOs.291>Average available Swapspace (Paging Memory) recorded over the agent up-time, expressed in bytes.')
ntStatusMemSwapMax = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwapMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwapMax.setDescription('&<caiNtOs.292>Maximum available Swapspace (Paging Memory) recorded over the agent up-time, expressed in bytes.')
ntStatusMemSwapMin = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 8, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusMemSwapMin.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusMemSwapMin.setDescription('&<caiNtOs.293>Minimum available Swapspace (Paging Memory) recorded over the agent up-time, expressed in bytes.')
ntProcessorStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9), )
if mibBuilder.loadTexts: ntProcessorStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorStTable.setDescription('&<caiNtOs.294>List of information about processors.')
ntProcessorStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusCPUNumber"))
if mibBuilder.loadTexts: ntProcessorStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorStTableEntry.setDescription('&<caiNtOs.295>A table entry containing information about the status of a processor.')
ntStatusCPUNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUNumber.setDescription('&<caiNtOs.296>Processor identification number.')
ntStatusCPUStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUStatus.setDescription('&<caiNtOs.297>Status of of processor, determined by the thresholds.')
ntStatusCPUTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUTotal.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUTotal.setDescription('&<caiNtOs.298>Current %Total utilization on the processor.')
ntStatusCPUWarning = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusCPUWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUWarning.setDescription('&<caiNtOs.299>Default %Total utilization Warning threshold level.')
ntStatusCPUCritical = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusCPUCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUCritical.setDescription('&<caiNtOs.300>Default %utilization Critical threshold level.')
ntStatusCPUCount = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusCPUCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUCount.setDescription('&<caiNtOs.301>The number of successive polling periods over which %Total CPU must cross a threshold before a status change is signalled.')
ntStatusCPUAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUAvg.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUAvg.setDescription('&<caiNtOs.302>Average %Total utilization calculated since the agent was started.')
ntStatusCPUMax = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUMax.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUMax.setDescription("&<caiNtOs.303>%Total utilization 'high water mark' over the agent up-time.")
ntStatusCPUMin = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUMin.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUMin.setDescription('&<caiNtOs.304>Minimum %Total utilization over the agent up-time.')
ntStatusCPUDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusCPUDelta.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUDelta.setDescription('&<caiNtOs.305>The difference of %Total utilization between this and the last poll.')
ntStatusCPUDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 9, 2, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusCPUDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusCPUDescription.setDescription('&<caiNtOs.306>Description of the Processor.')
ntRegistryStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10), )
if mibBuilder.loadTexts: ntRegistryStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryStTable.setDescription('&<caiNtOs.307>List of information about the status of configured Registry Leaf monitors.')
ntRegistryStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntStatusRegHandle"), (0, "CA-NTOS-MIB", "ntStatusRegKey"), (0, "CA-NTOS-MIB", "ntStatusRegLeaf"))
if mibBuilder.loadTexts: ntRegistryStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntRegistryStTableEntry.setDescription('&<caiNtOs.308>A table entry containing information about the status of a configured Registry Leaf monitor.')
ntStatusRegHandle = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("hkey-local-machine", 1), ("hkey-current-user", 2), ("hkey-users", 3), ("hkey-classes-root", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegHandle.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegHandle.setDescription('&<caiNtOs.309>Handle for the leaf.')
ntStatusRegKey = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegKey.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegKey.setDescription('&<caiNtOs.310>leaf location in the registry.')
ntStatusRegLeaf = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegLeaf.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegLeaf.setDescription('&<caiNtOs.311>The leaf itself.')
ntStatusRegDataType = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("integer", 1), ("string", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegDataType.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegDataType.setDescription('&<caiNtOs.312>Type of data contained at the location.')
ntStatusRegValue = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegValue.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegValue.setDescription('&<caiNtOs.313>Value stored in the Registry.')
ntStatusRegPrevValue = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegPrevValue.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegPrevValue.setDescription('&<caiNtOs.314>Previous value stored at the location.')
ntStatusRegStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("reset", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusRegStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegStatus.setDescription('&<caiNtOs.315>Registry watch status.')
ntStatusRegAvgTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegAvgTicks.setStatus('optional')
if mibBuilder.loadTexts: ntStatusRegAvgTicks.setDescription('&<caiNtOs.316>(For integer values) Poll count used in the calculation of the average value.')
ntStatusRegAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegAvg.setStatus('optional')
if mibBuilder.loadTexts: ntStatusRegAvg.setDescription('&<caiNtOs.317>(For integer values) Average value recorded at the location.')
ntStatusRegMax = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegMax.setStatus('optional')
if mibBuilder.loadTexts: ntStatusRegMax.setDescription('&<caiNtOs.318>(For integer values) Maximum value recorded at the location.')
ntStatusRegMin = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusRegMin.setStatus('optional')
if mibBuilder.loadTexts: ntStatusRegMin.setDescription("&<caiNtOs.319>(For integer values) Minimum value recorded at the location. If this is prefixed with a '-' then the threshold is set if the value at the leaf drops below ntStatusRegMax.")
ntStatusRegMonitorLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("change", 2), ("thresholds", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusRegMonitorLevel.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegMonitorLevel.setDescription('&<caiNtOs.320>Defines the type of value monitoring to be performed. For leaves of string type value of 3 is ignored.')
ntStatusRegWarning = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusRegWarning.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegWarning.setDescription('&<caiNtOs.321>warning threshold for integer type leaves.')
ntStatusRegCritical = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 10, 2, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusRegCritical.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusRegCritical.setDescription('&<caiNtOs.322>Critical threshold for integer type leaves.')
ntEventLogStTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11), )
if mibBuilder.loadTexts: ntEventLogStTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntEventLogStTable.setDescription('&<caiNtOs.323>List of information about the status of Event Log Watchers, the attributes defining a logical AND on matching.')
ntEventLogStTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2), )
if mibBuilder.loadTexts: ntEventLogStTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntEventLogStTableEntry.setDescription('&<caiNtOs.324>A table entry containing information about the status of an Event Log Watcher, the attributes defining a logical AND on matching.')
ntStatusLogLogs = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogLogs.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogLogs.setDescription('&<caiNtOs.325>Event Log/s to watch. May be a combination of these numbers; ( 1=Application, 2=Security, 3=System ).')
ntStatusLogSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSeverity.setDescription('&<caiNtOs.326>Severity level to record at, as defined by NT. May be a combination of these numbers; ( 1 = Information, 2=warning,3=Error, 4=Success, 5=Failure Audit).')
ntStatusLogSource = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogSource.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSource.setDescription("&<caiNtOs.327>Source string to match against. '*' wildcard is permitted.")
ntStatusLogEventID = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogEventID.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogEventID.setDescription("&<caiNtOs.328>Event ID to match against. '*' wildcard is permitted.")
ntStatusLogUser = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogUser.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogUser.setDescription("&<caiNtOs.329>User name to match against. '*' wildcard is permitted.")
ntStatusLogComputer = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogComputer.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogComputer.setDescription("&<caiNtOs.330>Computer name to match against. '*' wildcard is permitted.")
ntStatusLogStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("warning", 2), ("critical", 3), ("reset", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogStatus.setDescription("&<caiNtOs.331>Event log watch status. Setting 'reset' will reset status to 'ok', alerts will the be raised with respect to current levels.")
ntStatusLogAlertOn = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("do-not-monitor", 1), ("warning", 2), ("critical", 3), ("remove-watcher", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogAlertOn.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogAlertOn.setDescription('&<caiNtOs.332>How the watcher is to raise alerts. Either not raising alerts (i.e. informational monitoring only) or raising a warning or critical level trap when the number of matching events changes. Selecting remove-watcher will delete the current watc her from the table.')
ntStatusLogStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogStartTime.setDescription('&<caiNtOs.333>The time at which the watcher should start looking for events in the log. Initially this will be set to the earliest event time recorded in any of the three logs. Number represents number of seconds elapsed since 0:00.00 on 1 January 1970.')
ntStatusLogStartTimeInText = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogStartTimeInText.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogStartTimeInText.setDescription('&<caiNtOs.334>The time at which the watcher should start looking for events in the log displayed in textual form.')
ntStatusLogAppLogMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogAppLogMatches.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogAppLogMatches.setDescription('&<caiNtOs.335>Number of matches recorded in the Application log.')
ntStatusLogAppLogLastMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogAppLogLastMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogAppLogLastMatch.setDescription('&<caiNtOs.336>The time of the last matching event in the Application Log.')
ntStatusLogSecLogMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogSecLogMatches.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSecLogMatches.setDescription('&<caiNtOs.337>Number of matches recorded in the Security log.')
ntStatusLogSecLogLastMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogSecLogLastMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSecLogLastMatch.setDescription('&<caiNtOs.338>The time of the last matching event in the Security Log.')
ntStatusLogSysLogMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogSysLogMatches.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSysLogMatches.setDescription('&<caiNtOs.339>Number of matches recorded in the System log.')
ntStatusLogSysLogLastMatch = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogSysLogLastMatch.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogSysLogLastMatch.setDescription('&<caiNtOs.340>The time of the last matching event in the System Log.')
ntStatusLogWatcherIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntStatusLogWatcherIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogWatcherIndex.setDescription('&<caiNtOs.341>This is the index number for this watcher within the Event Log watcher table.')
ntStatusLogDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 3, 11, 2, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntStatusLogDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ntStatusLogDescription.setDescription("&<caiNtOs.342>Description of what the event watcher defined is looking for e.g. 'SQL Server event watcher' - for information only.")
ntFilesystemPollTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2), )
if mibBuilder.loadTexts: ntFilesystemPollTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesystemPollTable.setDescription('&<caiNtOs.343>List of information about filesystems.')
ntFilesystemPollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntFsysDriveLetter"))
if mibBuilder.loadTexts: ntFilesystemPollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilesystemPollTableEntry.setDescription('&<caiNtOs.344>A table entry containing information about a filesystem.')
ntFsysDriveLetter = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysDriveLetter.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysDriveLetter.setDescription('&<caiNtOs.345>The drive letter of the filesystem as recognised by the operating system.')
ntFsysTotalCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysTotalCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysTotalCapacity.setDescription('&<caiNtOs.346>Total disk capacity in bytes.')
ntFsysFree = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysFree.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysFree.setDescription('&<caiNtOs.347>Number of free bytes on the filesystem.')
ntFsysUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysUtilization.setDescription('&<caiNtOs.348>Number of bytes of the filesystem utilized.')
ntFsysLastUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysLastUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysLastUtilization.setDescription('&<caiNtOs.349>Number of bytes utilized at the last polling interval.')
ntFsysAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysAverage.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysAverage.setDescription('&<caiNtOs.350>Current average calculation value.')
ntFsysAvgTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 2, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFsysAvgTicks.setStatus('mandatory')
if mibBuilder.loadTexts: ntFsysAvgTicks.setDescription('&<caiNtOs.351>Number of polling intervals since last average calculation.')
ntFilePollTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3), )
if mibBuilder.loadTexts: ntFilePollTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilePollTable.setDescription('&<caiNtOs.352>List of information about monitored files.')
ntFilePollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntFileName"))
if mibBuilder.loadTexts: ntFilePollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntFilePollTableEntry.setDescription('&<caiNtOs.353>A table entry containing information about a monitored file.')
ntFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileName.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileName.setDescription('&<caiNtOs.354>The full pathname of the file on the managed system.')
ntFileTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileTimestamp.setDescription('&<caiNtOs.355>File timestamp.')
ntFileRefTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileRefTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileRefTimestamp.setDescription('&<caiNtOs.356>File timestamp.')
ntFileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileSize.setDescription('&<caiNtOs.357>Current file size in bytes.')
ntFileSizeChangeReference = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileSizeChangeReference.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileSizeChangeReference.setDescription('&<caiNtOs.358>Reference file size for change calculation.')
ntFileSizeChangeCount = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileSizeChangeCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileSizeChangeCount.setDescription('&<caiNtOs.359>Number of polls since last file size change calculation.')
ntFileSizeAvgTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 3, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntFileSizeAvgTicks.setStatus('mandatory')
if mibBuilder.loadTexts: ntFileSizeAvgTicks.setDescription('&<caiNtOs.360>Number of polling intervals since last average calculation.')
ntProcessPollTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4), )
if mibBuilder.loadTexts: ntProcessPollTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessPollTable.setDescription('&<caiNtOs.361>List of information about processes.')
ntProcessPollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntProcessName"))
if mibBuilder.loadTexts: ntProcessPollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessPollTableEntry.setDescription('&<caiNtOs.362>A table entry containing information about a monitored process.')
ntProcessName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessName.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessName.setDescription('&<caiNtOs.363>The name of the process, as returned from the NT Registry.')
ntProcessInstCount = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessInstCount.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessInstCount.setDescription('&<caiNtOs.364>Current number of instances of the process running on the system.')
ntProcessMaxThread = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessMaxThread.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessMaxThread.setDescription('&<caiNtOs.365>Maximum number of threads of any instance of the process.')
ntProcessMinThread = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 4, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntProcessMinThread.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessMinThread.setDescription('&<caiNtOs.366>Minimum number of threads of any instance of the process.')
ntProcessorPollTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5), )
if mibBuilder.loadTexts: ntProcessorPollTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorPollTable.setDescription('&<caiNtOs.367>List of information about printers.')
ntProcessorPollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2), ).setIndexNames((0, "CA-NTOS-MIB", "ntCPUNumber"))
if mibBuilder.loadTexts: ntProcessorPollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntProcessorPollTableEntry.setDescription('&<caiNtOs.368>A table entry containing information about a printer.')
ntCPUNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUNumber.setDescription('&<caiNtOs.369>Processor identification number.')
ntCPUDPCTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUDPCTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUDPCTime.setDescription('&<caiNtOs.370>%DPC (Deferred Procedure Call) time for the processor.')
ntCPUInterruptTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUInterruptTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUInterruptTime.setDescription('&<caiNtOs.371>%Interrupt time (handling hardware interrupts) for the processor.')
ntCPUPrivilegedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUPrivilegedTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUPrivilegedTime.setDescription('&<caiNtOs.372>%Privileged time (time spent in privileged mode in non-idle threads) for the processor.')
ntCPUProcessorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUProcessorTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUProcessorTime.setDescription('&<caiNtOs.373>%Processor time (time spent executing non-idle threads) for the processor.')
ntCPUUserTime = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUUserTime.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUUserTime.setDescription('&<caiNtOs.374>%User time (time spent in user mode executing non-idle threads) for the processor.')
ntCPUTicks = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUTicks.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUTicks.setDescription('&<caiNtOs.375>Counter for Average CPU calculation.')
ntCPUCountsSoFar = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 5, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntCPUCountsSoFar.setStatus('mandatory')
if mibBuilder.loadTexts: ntCPUCountsSoFar.setDescription('&<caiNtOs.376>Number of counts on a potential state change.')
ntLogPollTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6), )
if mibBuilder.loadTexts: ntLogPollTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogPollTable.setDescription('&<caiNtOs.377>List of information about configured Log watchers.')
ntLogPollTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1), )
if mibBuilder.loadTexts: ntLogPollTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogPollTableEntry.setDescription('&<caiNtOs.378>A table entry containing information about a configured Log watcher.')
ntLogAppStart = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogAppStart.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogAppStart.setDescription('&<caiNtOs.379>Starting Event for Application Log.')
ntLogSecStart = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSecStart.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSecStart.setDescription('&<caiNtOs.380>Starting Event for Security Log.')
ntLogSysStart = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSysStart.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSysStart.setDescription('&<caiNtOs.381>Starting Event for System Log.')
ntLogAppLast = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogAppLast.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogAppLast.setDescription('&<caiNtOs.382>Last Checked Event in the Application Log.')
ntLogSecLast = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSecLast.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSecLast.setDescription('&<caiNtOs.383>Last Checked Event in the Security Log.')
ntLogSysLast = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 4, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntLogSysLast.setStatus('mandatory')
if mibBuilder.loadTexts: ntLogSysLast.setDescription('&<caiNtOs.384>Last Checked Event in the System Log.')
ntAvailConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1))
ntAvailFSPeriod = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 1), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntAvailFSPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSPeriod.setDescription('&<caiNtOs.385>Polling Interval to check for current local Filesystem availability.')
ntAvailFSPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailFSPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSPollTimestamp.setDescription('&<caiNtOs.386>The date and time that NT System Agent last polled for current local Filesystem availability.')
ntAvailProcPeriod = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntAvailProcPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailProcPeriod.setDescription('&<caiNtOs.387>Polling Interval to update the table of current process activity.')
ntAvailProcTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailProcTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailProcTimestamp.setDescription('&<caiNtOs.388>The date and time that NT System Agent last polled for current process activity.')
ntAvailServPeriod = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntAvailServPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServPeriod.setDescription('&<caiNtOs.389>Polling Interval to update the table of current service availability.')
ntAvailServPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailServPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServPollTimestamp.setDescription('&<caiNtOs.390>The date and time that NT System Agent last polled for current service availability.')
ntAvailPrinterPeriod = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntAvailPrinterPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterPeriod.setDescription('&<caiNtOs.391>Polling Interval to check for current local printer availability.')
ntAvailPrinterPollTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailPrinterPollTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterPollTimestamp.setDescription('&<caiNtOs.392>The date and time that NT System Agent last polled for current local printer availability.')
ntAvailFSTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 2), )
if mibBuilder.loadTexts: ntAvailFSTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSTable.setDescription('&<caiNtOs.393>Table containing Filesystems available for monitoring.')
ntAvailFSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 2, 1), ).setIndexNames((0, "CA-NTOS-MIB", "ntAvailFSDriveLetter"))
if mibBuilder.loadTexts: ntAvailFSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSEntry.setDescription('&<caiNtOs.394>A table entry containing information Filesystems available for monitoring.')
ntAvailFSDriveLetter = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailFSDriveLetter.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSDriveLetter.setDescription('&<caiNtOs.395>The drive letter of the Filesystem as recognised by the operating system.')
ntAvailFSDriveLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailFSDriveLabel.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSDriveLabel.setDescription('&<caiNtOs.396>The drive label of the Filesystem.')
ntAvailFSDriveType = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailFSDriveType.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailFSDriveType.setDescription('&<caiNtOs.397>Drive type as determined by the operating system (removeable, fixed, CDROM etc.).')
ntAvailProcTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 3), )
if mibBuilder.loadTexts: ntAvailProcTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailProcTable.setDescription('&<caiNtOs.398>Table containing Processes currently running.')
ntAvailProcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 3, 1), ).setIndexNames((0, "CA-NTOS-MIB", "ntAvailProcessName"))
if mibBuilder.loadTexts: ntAvailProcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailProcEntry.setDescription('&<caiNtOs.399>A table entry containing information Logsystems available for monitoring.')
ntAvailProcessName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailProcessName.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailProcessName.setDescription('&<caiNtOs.400>The name of a process currently running')
ntAvailServiceTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 4), )
if mibBuilder.loadTexts: ntAvailServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServiceTable.setDescription('&<caiNtOs.401>Table containing Services currently registered with the Service Manager.')
ntAvailServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 4, 1), ).setIndexNames((0, "CA-NTOS-MIB", "ntAvailServiceName"))
if mibBuilder.loadTexts: ntAvailServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServiceEntry.setDescription('&<caiNtOs.402>A table entry containing information Logsystems available for monitoring.')
ntAvailServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 4, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServiceName.setDescription('&<caiNtOs.403>The name of a service currently running.')
ntAvailServiceDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailServiceDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServiceDescr.setDescription('&<caiNtOs.404>The decsription of a service currently running.')
ntAvailServiceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("stopped", 1), ("start-pending", 2), ("stop-pending", 3), ("running", 4), ("continue-pending", 5), ("pause-pending", 6), ("paused", 7), ("unknown", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailServiceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailServiceStatus.setDescription('&<caiNtOs.405>The name of a process currently running.')
ntAvailPrinterTable = MibTable((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5), )
if mibBuilder.loadTexts: ntAvailPrinterTable.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterTable.setDescription('&<caiNtOs.406>Table containing Printers available for monitoring.')
ntAvailPrinterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5, 1), ).setIndexNames((0, "CA-NTOS-MIB", "ntAvailPrinterName"))
if mibBuilder.loadTexts: ntAvailPrinterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterEntry.setDescription('&<caiNtOs.407>A table entry containing information Logsystems available for monitoring.')
ntAvailPrinterName = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailPrinterName.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterName.setDescription('&<caiNtOs.408>The name of a Printer local to the machine.')
ntAvailPrinterDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailPrinterDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterDescr.setDescription('&<caiNtOs.409>Description of the Printer as defined to Print Manager.')
ntAvailPrinterType = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailPrinterType.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterType.setDescription('&<caiNtOs.410>Type of Printer according to driver settings.')
ntAvailPrinterLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2, 5, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ntAvailPrinterLocation.setStatus('mandatory')
if mibBuilder.loadTexts: ntAvailPrinterLocation.setDescription('&<caiNtOs.411>Location of the Printer as defined to Print Manager.')
ntFSUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,1))
if mibBuilder.loadTexts: ntFSUnknown.setDescription('&<caiNtOs.412>A monitored file system is in an unknown state. The varbind entry contains the name of the file system whose state changed.')
ntFSok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,2))
if mibBuilder.loadTexts: ntFSok.setDescription('&<caiNtOs.413>A monitored file system is in the ok state. The varbind entry contains the name of the file system whose state changed.')
ntFSwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,3))
if mibBuilder.loadTexts: ntFSwarning.setDescription('&<caiNtOs.414>A monitored file system is in the warning state. The varbind entry contains the name of the file system whose state changed.')
ntFScritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,4))
if mibBuilder.loadTexts: ntFScritical.setDescription('&<caiNtOs.415>A monitored file system is in the critical state. The varbind entry contains the name of the file system whose state changed.')
ntFileUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,5))
if mibBuilder.loadTexts: ntFileUnknown.setDescription('&<caiNtOs.416>A monitored file is in an unknown state. The varbind entry contains the name of the file whose state changed.')
ntFileok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,6))
if mibBuilder.loadTexts: ntFileok.setDescription('&<caiNtOs.417>A monitored file is in the ok state. The varbind entry contains the name of the file whose state changed.')
ntFilewarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,7))
if mibBuilder.loadTexts: ntFilewarning.setDescription('&<caiNtOs.418>A monitored file is in the warning state. The varbind entry contains the name of the file whose state changed.')
ntFilecritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,8))
if mibBuilder.loadTexts: ntFilecritical.setDescription('&<caiNtOs.419>A monitored file is in the critical state. The varbind entry contains the name of the file whose state changed.')
ntProcessUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,9))
if mibBuilder.loadTexts: ntProcessUnknown.setDescription('&<caiNtOs.420>A monitored Process is in an unknown state. The varbind entry contains the name of the Process whose state changed.')
ntProcessok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,10))
if mibBuilder.loadTexts: ntProcessok.setDescription('&<caiNtOs.421>A monitored Process is in the ok state. The varbind entry contains the name of the Process whose state changed.')
ntProcesswarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,11))
if mibBuilder.loadTexts: ntProcesswarning.setDescription('&<caiNtOs.422>A monitored Process is in the warning state. The varbind entry contains the name of the Process whose state changed.')
ntProcesscritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,12))
if mibBuilder.loadTexts: ntProcesscritical.setDescription('&<caiNtOs.423>A monitored Process is in the critical state. The varbind entry contains the name of the Process whose state changed.')
ntServiceUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,13))
if mibBuilder.loadTexts: ntServiceUnknown.setDescription('&<caiNtOs.424>A monitored Service is in an unknown state. The varbind entry contains the name of the Service whose state changed.')
ntServiceok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,14))
if mibBuilder.loadTexts: ntServiceok.setDescription('&<caiNtOs.425>A monitored Service is in the ok state. The varbind entry contains the name of the Service whose state changed.')
ntServicewarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,15))
if mibBuilder.loadTexts: ntServicewarning.setDescription('&<caiNtOs.426>A monitored Service is in the warning state. The varbind entry contains the name of the Service whose state changed.')
ntServicecritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,16))
if mibBuilder.loadTexts: ntServicecritical.setDescription('&<caiNtOs.427>A monitored Service is in the critical state. The varbind entry contains the name of the Service whose state changed.')
ntPrinterUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,17))
if mibBuilder.loadTexts: ntPrinterUnknown.setDescription('&<caiNtOs.428>A monitored Printer is in an unknown state. The varbind entry contains the name of the Printer whose state changed.')
ntPrinterok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,18))
if mibBuilder.loadTexts: ntPrinterok.setDescription('&<caiNtOs.429>A monitored Printer is in the ok state. The varbind entry contains the name of the Printer whose state changed.')
ntPrinterwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,19))
if mibBuilder.loadTexts: ntPrinterwarning.setDescription('&<caiNtOs.430>A monitored Printer is in the warning state. The varbind entry contains the name of the Printer whose state changed.')
ntPrintercritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,20))
if mibBuilder.loadTexts: ntPrintercritical.setDescription('&<caiNtOs.431>A monitored Printer is in the critical state. The varbind entry contains the name of the Printer whose state changed.')
ntCPUUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,21))
if mibBuilder.loadTexts: ntCPUUnknown.setDescription('&<caiNtOs.432>A monitored CPU is in an unknown state. The varbind entry contains the name of the CPU whose state changed.')
ntCPUok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,22))
if mibBuilder.loadTexts: ntCPUok.setDescription('&<caiNtOs.433>A monitored CPU is in the ok state. The varbind entry contains the name of the CPU whose state changed.')
ntCPUwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,23))
if mibBuilder.loadTexts: ntCPUwarning.setDescription('&<caiNtOs.434>A monitored CPU is in the warning state. The varbind entry contains the name of the CPU whose state changed.')
ntCPUcritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,24))
if mibBuilder.loadTexts: ntCPUcritical.setDescription('&<caiNtOs.435>A monitored CPU is in the critical state. The varbind entry contains the name of the CPU whose state changed.')
ntMemLoadok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,25))
if mibBuilder.loadTexts: ntMemLoadok.setDescription('&<caiNtOs.436>Memory Load is in the ok state.')
ntMemLoadwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,26))
if mibBuilder.loadTexts: ntMemLoadwarning.setDescription('&<caiNtOs.437>Memory Load is in the warning state.')
ntMemLoadcritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,27))
if mibBuilder.loadTexts: ntMemLoadcritical.setDescription('&<caiNtOs.438>Memory Load is in the critical state.')
ntMemPhysok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,28))
if mibBuilder.loadTexts: ntMemPhysok.setDescription('&<caiNtOs.439>Available Physical Memory is in the ok state.')
ntMemPhyswarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,29))
if mibBuilder.loadTexts: ntMemPhyswarning.setDescription('&<caiNtOs.440>Available Physical Memory is in the warning state.')
ntMemPhyscritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,30))
if mibBuilder.loadTexts: ntMemPhyscritical.setDescription('&<caiNtOs.441>Available Physical Memory is in the critical state.')
ntMemSwapok = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,31))
if mibBuilder.loadTexts: ntMemSwapok.setDescription('&<caiNtOs.442>Available Swapspace is in the ok state.')
ntMemSwapwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,32))
if mibBuilder.loadTexts: ntMemSwapwarning.setDescription('&<caiNtOs.443>Available Swapspace is in the warning state.')
ntMemSwapcritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,33))
if mibBuilder.loadTexts: ntMemSwapcritical.setDescription('&<caiNtOs.444>Available Swapspace is in the critical state.')
ntRegUnknown = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,34))
if mibBuilder.loadTexts: ntRegUnknown.setDescription('&<caiNtOs.445>A monitored registry leaf is in an unknown state. The varbind entry contains details of the registry leaf whose state changed.')
ntRegOK = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,35))
if mibBuilder.loadTexts: ntRegOK.setDescription('&<caiNtOs.446>A monitored registry leaf is in the ok state. The varbind entry contains details of the registry leaf whose state changed.')
ntRegwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,36))
if mibBuilder.loadTexts: ntRegwarning.setDescription('&<caiNtOs.447>A monitored registry leaf is in the warning state. The varbind entry contains details of the registry leaf whose state changed')
ntRegcritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,37))
if mibBuilder.loadTexts: ntRegcritical.setDescription('&<caiNtOs.448>A monitored registry leaf is in the critical state. The varbind entry contains the details of the registry leaf whose state changed')
ntLogOK = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,38))
if mibBuilder.loadTexts: ntLogOK.setDescription('&<caiNtOs.449>A monitored event log watcher is in the ok state.')
ntLogwarning = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,39))
if mibBuilder.loadTexts: ntLogwarning.setDescription('&<caiNtOs.450>A monitored event log watcher is in the warning state. This means one or more event records match the criteria and have not been acknowledged.')
ntLogcritical = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,40))
if mibBuilder.loadTexts: ntLogcritical.setDescription('&<caiNtOs.451>A monitored event log watcher is in the critical state. This means one or more event records match the criteria and have not been acknowledged.')
ntAdd = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,41))
if mibBuilder.loadTexts: ntAdd.setDescription('&<caiNtOs.452>An object has been added to the list of monitored objects. e.g. filesystems, files, processes, etc.')
ntRemove = NotificationType((1, 3, 6, 1, 4, 1, 791, 2, 9, 2, 2) + (0,42))
if mibBuilder.loadTexts: ntRemove.setDescription('&<caiNtOs.453>An object has been removed from the list of monitored objects. e.g. filesystems, files, processes, etc.')
mibBuilder.exportSymbols("CA-NTOS-MIB", ntFileTimestamp=ntFileTimestamp, ntDefRegWarning=ntDefRegWarning, ntPrinterConfig=ntPrinterConfig, ntEventLogCriticalStatus=ntEventLogCriticalStatus, ntDefProcExist=ntDefProcExist, ntStatusLogStatus=ntStatusLogStatus, ntStatusFileSizeChBytes=ntStatusFileSizeChBytes, ntStatusLogWatcherIndex=ntStatusLogWatcherIndex, ntDefCPUCritical=ntDefCPUCritical, ntStatusLogAppLogMatches=ntStatusLogAppLogMatches, ntStatusCPUAvg=ntStatusCPUAvg, ntStatusFSPcntCritical=ntStatusFSPcntCritical, cai=cai, ntStatusFSDriveFormat=ntStatusFSDriveFormat, ntDefFileSizeChangeFlag=ntDefFileSizeChangeFlag, ntDefServAlertOn=ntDefServAlertOn, ntFilePollTableEntry=ntFilePollTableEntry, ntStatusLogSource=ntStatusLogSource, ntProcessStTableEntry=ntProcessStTableEntry, ntProcPollInterval=ntProcPollInterval, ntStatusRegMonitorLevel=ntStatusRegMonitorLevel, ntCPUok=ntCPUok, ntStatusPrintEventDescription=ntStatusPrintEventDescription, ntEventLogStTable=ntEventLogStTable, ntFileSystemConfig=ntFileSystemConfig, ntFsysUtilization=ntFsysUtilization, ntFileStTable=ntFileStTable, ntStatusPrintQCritical=ntStatusPrintQCritical, ntLogSecStart=ntLogSecStart, ntFileSizeChangeCount=ntFileSizeChangeCount, ntAvailableGroup=ntAvailableGroup, ntFileAdd=ntFileAdd, ntAvailServiceEntry=ntAvailServiceEntry, ntEventLogStTableEntry=ntEventLogStTableEntry, ntCPUCountsSoFar=ntCPUCountsSoFar, caiSysMgr=caiSysMgr, ntDefMemLoadCount=ntDefMemLoadCount, ntStatusCPUMax=ntStatusCPUMax, ntServicesCriticalStatus=ntServicesCriticalStatus, ntFsysTotalCapacity=ntFsysTotalCapacity, ntServiceRemove=ntServiceRemove, ntRegcritical=ntRegcritical, ntStatusMemLoadStatus=ntStatusMemLoadStatus, ntDefFileTimestampFlag=ntDefFileTimestampFlag, ntStatusRegHandle=ntStatusRegHandle, ntProcessPollTimestamp=ntProcessPollTimestamp, ntStatusFileTimestamp=ntStatusFileTimestamp, ntStatusFileSizeCritical=ntStatusFileSizeCritical, ntMemSwapcritical=ntMemSwapcritical, ntAvailPrinterDescr=ntAvailPrinterDescr, ntProcessesMonitored=ntProcessesMonitored, ntFSok=ntFSok, ntFileWarnStatus=ntFileWarnStatus, ntStatusRegDataType=ntStatusRegDataType, ntLogSecurityCount=ntLogSecurityCount, ntStatusFileTimestampFlag=ntStatusFileTimestampFlag, ntFilesystemStTable=ntFilesystemStTable, ntStatusProcName=ntStatusProcName, ntDefLogMonitorLevel=ntDefLogMonitorLevel, ntStatusRegMax=ntStatusRegMax, ntStatusFileSizeCh=ntStatusFileSizeCh, ntAvailProcTimestamp=ntAvailProcTimestamp, ntServicesMonitored=ntServicesMonitored, agentWorks=agentWorks, ntStatusMemSwapMax=ntStatusMemSwapMax, ntDefProcAlertLevel=ntDefProcAlertLevel, ntFsysLastUtilization=ntFsysLastUtilization, ntFSCriticalStatus=ntFSCriticalStatus, ntStatusPrintQStatus=ntStatusPrintQStatus, ntFsysAverage=ntFsysAverage, ntRegLeavesMonitored=ntRegLeavesMonitored, ntStatusFSDeltaThreshold=ntStatusFSDeltaThreshold, ntFSwarning=ntFSwarning, ntFsysAvgTicks=ntFsysAvgTicks, ntStatusPrintStatus=ntStatusPrintStatus, ntStatusLogSysLogLastMatch=ntStatusLogSysLogLastMatch, ntMemPollInterval=ntMemPollInterval, ntFSAdd=ntFSAdd, ntStatusMemLoadMax=ntStatusMemLoadMax, ntStatusMemLoadAvg=ntStatusMemLoadAvg, ntCPUPollInterval=ntCPUPollInterval, ntRegistryCriticalStatus=ntRegistryCriticalStatus, ntStatusProcThdMin=ntStatusProcThdMin, ntProcessConfig=ntProcessConfig, ntProcessPollTable=ntProcessPollTable, ntDefMemSwapWarning=ntDefMemSwapWarning, ntStatusMemPhys=ntStatusMemPhys, ntRegistryStTable=ntRegistryStTable, ntProcAdd=ntProcAdd, ntAvailProcEntry=ntAvailProcEntry, ntDefMemPhysCritical=ntDefMemPhysCritical, ntServicewarning=ntServicewarning, ntStatusProcAlertLevel=ntStatusProcAlertLevel, ntDefFSCriticalThresh=ntDefFSCriticalThresh, ntStatusFSUtilization=ntStatusFSUtilization, ntTotalWarning=ntTotalWarning, ntStatusFileSizeChState=ntStatusFileSizeChState, ntRegistryWarnStatus=ntRegistryWarnStatus, ntProcessorConfig=ntProcessorConfig, ntStatusMemSwapMin=ntStatusMemSwapMin, ntCPUUnknown=ntCPUUnknown, ntStatusFileStatus=ntStatusFileStatus, ntStatusProcInst=ntStatusProcInst, ntServiceConfig=ntServiceConfig, ntConfigGroup=ntConfigGroup, ntDefPrinterQWarning=ntDefPrinterQWarning, ntCPUNumber=ntCPUNumber, ntStatusFileMinSize=ntStatusFileMinSize, ntCPUTicks=ntCPUTicks, ntStatusMemPhysStatus=ntStatusMemPhysStatus, ntProcessMinThread=ntProcessMinThread, ntAvailProcessName=ntAvailProcessName, ntStatusFileSizeBase=ntStatusFileSizeBase, ntProcessorPollTimestamp=ntProcessorPollTimestamp, ntProcessWarnStatus=ntProcessWarnStatus, ntDefProcInstanceAlert=ntDefProcInstanceAlert, ntAvailPrinterEntry=ntAvailPrinterEntry, ntProcessorWarnStatus=ntProcessorWarnStatus, ntRegistryConfig=ntRegistryConfig, ntLogPollTimestamp=ntLogPollTimestamp, ntFileStTableEntry=ntFileStTableEntry, ntServicecritical=ntServicecritical, ntEventLogWarnStatus=ntEventLogWarnStatus, ntDefMemLoadCritical=ntDefMemLoadCritical, ntStatusFSKByteWarn=ntStatusFSKByteWarn, ntDefFileSizeChange=ntDefFileSizeChange, ntLogPollInterval=ntLogPollInterval, ntFilePollTable=ntFilePollTable, ntPrinterPollInterval=ntPrinterPollInterval, ntStatusLogAlertOn=ntStatusLogAlertOn, ntStatusLogSysLogMatches=ntStatusLogSysLogMatches, ntFileSize=ntFileSize, ntCPUPrivilegedTime=ntCPUPrivilegedTime, ntFilePollTimestamp=ntFilePollTimestamp, ntAvailServiceTable=ntAvailServiceTable, ntStatusCPUStatus=ntStatusCPUStatus, ntPrintWarnStatus=ntPrintWarnStatus, ntStatusProcThdMax=ntStatusProcThdMax, ntDefCPUCount=ntDefCPUCount, ntDefFSWarnThresh=ntDefFSWarnThresh, ntStatusMemPhysMax=ntStatusMemPhysMax, ntProcessok=ntProcessok, ntStatusFSDeltaLevel=ntStatusFSDeltaLevel, ntLogSystemCount=ntLogSystemCount, ntDefMemLoadWarning=ntDefMemLoadWarning, ntDefRegCritical=ntDefRegCritical, ntTotalCritical=ntTotalCritical, ntAvailFSPeriod=ntAvailFSPeriod, ntStatusPrintQFlag=ntStatusPrintQFlag, ntStatusFileAvgSize=ntStatusFileAvgSize, ntStatusFSMaxUtil=ntStatusFSMaxUtil, ntProcessMaxThread=ntProcessMaxThread, ntMemoryCriticalStatus=ntMemoryCriticalStatus, ntPrinterwarning=ntPrinterwarning, ntDefMemPhysCount=ntDefMemPhysCount, ntAvailServiceDescr=ntAvailServiceDescr, ntLogAppStart=ntLogAppStart, ntStatusServDescription=ntStatusServDescription, ntMemPhyscritical=ntMemPhyscritical, ntPrintercritical=ntPrintercritical, ntAgentColdStartTimestamp=ntAgentColdStartTimestamp, ntStatusServAlertOn=ntStatusServAlertOn, ntServiceStTableEntry=ntServiceStTableEntry, ntStatusLogComputer=ntStatusLogComputer, ntCPUDPCTime=ntCPUDPCTime, ntAvailFSEntry=ntAvailFSEntry, ntCPUcritical=ntCPUcritical, ntServiceUnknown=ntServiceUnknown, ntProcessPollTableEntry=ntProcessPollTableEntry, ntProcessInstCount=ntProcessInstCount, ntStatusFSStatus=ntStatusFSStatus, ntFileRemove=ntFileRemove, ntFileConfig=ntFileConfig, ntStatusFSUtilDelta=ntStatusFSUtilDelta, ntStatusCPUDelta=ntStatusCPUDelta, ntAvailServiceStatus=ntAvailServiceStatus, ntStatusFileDescription=ntStatusFileDescription, ntStatusLogStartTime=ntStatusLogStartTime, ntMemPhyswarning=ntMemPhyswarning, ntLogSecLast=ntLogSecLast, ntStatusMemLoad=ntStatusMemLoad, ntProcessorCriticalStatus=ntProcessorCriticalStatus, ntStatusFileName=ntStatusFileName, ntProcessStTable=ntProcessStTable, ntAgentWarmStartTimestamp=ntAgentWarmStartTimestamp, ntStatusPrintEventStatus=ntStatusPrintEventStatus, ntDefCPUWarning=ntDefCPUWarning, ntPrinterUnknown=ntPrinterUnknown, ntFilePollInterval=ntFilePollInterval, ntStatusLogDescription=ntStatusLogDescription, ntLogAppLast=ntLogAppLast, ntPrinterPollTimestamp=ntPrinterPollTimestamp, ntProcessorStTableEntry=ntProcessorStTableEntry, ntProcRemove=ntProcRemove, ntStatusRegStatus=ntStatusRegStatus, ntAvailServPollTimestamp=ntAvailServPollTimestamp, ntAvailConfig=ntAvailConfig, ntMemSwapok=ntMemSwapok, ntDefMemPhysWarning=ntDefMemPhysWarning, ntAvailFSTable=ntAvailFSTable, ntStatusLogStartTimeInText=ntStatusLogStartTimeInText, ntLogApplicationCount=ntLogApplicationCount, ntRegUnknown=ntRegUnknown, ntAdd=ntAdd, ntStatusMemSwapTotal=ntStatusMemSwapTotal, ntFSPollInterval=ntFSPollInterval, ntServiceok=ntServiceok, ntStatusFSTotalCapacity=ntStatusFSTotalCapacity, ntStatusMemSwapAvg=ntStatusMemSwapAvg, ntStatusProcInstMonitor=ntStatusProcInstMonitor, ntStatusPrintQWarning=ntStatusPrintQWarning, ntStatusCPUNumber=ntStatusCPUNumber, ntStatusFSFree=ntStatusFSFree, ntServicesWarnStatus=ntServicesWarnStatus, ntPrinterRemove=ntPrinterRemove, ntRegistryLeafAdd=ntRegistryLeafAdd, ntServicePollTimestamp=ntServicePollTimestamp, ntStatusProcThd=ntStatusProcThd, ntMemLoadok=ntMemLoadok, ntStatusPrintQMax=ntStatusPrintQMax, ntRegwarning=ntRegwarning, ntLogSysStart=ntLogSysStart, ntStatusCPUWarning=ntStatusCPUWarning, ntMemLoadcritical=ntMemLoadcritical, ntAvailFSDriveType=ntAvailFSDriveType, ntPollGroup=ntPollGroup, ntDefProcThreadAlert=ntDefProcThreadAlert, ntStatusProcThdRef=ntStatusProcThdRef, ntStatusPrintTableEntry=ntStatusPrintTableEntry, ntAvailPrinterType=ntAvailPrinterType, ntStatusFileSizeWarning=ntStatusFileSizeWarning, ntStatusPrintQueue=ntStatusPrintQueue, ntDefPrinterQCritical=ntDefPrinterQCritical, ntStatusMemPhysMin=ntStatusMemPhysMin, ntFilesystemPollTableEntry=ntFilesystemPollTableEntry, ntRegistryStTableEntry=ntRegistryStTableEntry, ntPrinterok=ntPrinterok, ntFsysFree=ntFsysFree, ntLogSysLast=ntLogSysLast, ntStatusMemPhysAvg=ntStatusMemPhysAvg, ntFileCriticalStatus=ntFileCriticalStatus, ntLogOK=ntLogOK, ntStatusLogUser=ntStatusLogUser, ntDefFSDelta=ntDefFSDelta, ntStatus=ntStatus, ntLogAdd=ntLogAdd, ntStatusFileSizeChFlag=ntStatusFileSizeChFlag, ntStatusProcInstCritical=ntStatusProcInstCritical, ntPrinterStTable=ntPrinterStTable, ntAvailPrinterPollTimestamp=ntAvailPrinterPollTimestamp, ntStatusFSKByteCritical=ntStatusFSKByteCritical, ntLogPollTable=ntLogPollTable, ntStatusMemPhysTotal=ntStatusMemPhysTotal, ntStatusRegMin=ntStatusRegMin)
mibBuilder.exportSymbols("CA-NTOS-MIB", ntStatusCPUTotal=ntStatusCPUTotal, ntStatusRegPrevValue=ntStatusRegPrevValue, ntFilesMonitored=ntFilesMonitored, ntAvailPrinterTable=ntAvailPrinterTable, ntLogwarning=ntLogwarning, ntStatusRegAvgTicks=ntStatusRegAvgTicks, ntDefPrinterQFlag=ntDefPrinterQFlag, ntRegistryLeafRemove=ntRegistryLeafRemove, ntFileRefTimestamp=ntFileRefTimestamp, ntFileUnknown=ntFileUnknown, ntStatusFileSize=ntStatusFileSize, ntFilewarning=ntFilewarning, ntCPUwarning=ntCPUwarning, ntLogcritical=ntLogcritical, ntStatusFSMinUtil=ntStatusFSMinUtil, ntStatusFSAvgUtil=ntStatusFSAvgUtil, ntMemoryWarnStatus=ntMemoryWarnStatus, ntStatusLogSecLogLastMatch=ntStatusLogSecLogLastMatch, ntAvailFSDriveLetter=ntAvailFSDriveLetter, ntServPollInterval=ntServPollInterval, ntFilesystemStTableEntry=ntFilesystemStTableEntry, ntDefMemSwapCritical=ntDefMemSwapCritical, ntDefFileSizeWarning=ntDefFileSizeWarning, ntPrintersMonitored=ntPrintersMonitored, ntLogPollTableEntry=ntLogPollTableEntry, ntAvailProcTable=ntAvailProcTable, ntProcessUnknown=ntProcessUnknown, ntFileSizeAvgTicks=ntFileSizeAvgTicks, ntAvailFSDriveLabel=ntAvailFSDriveLabel, ntStatusCPUDescription=ntStatusCPUDescription, ntStatusProcDescription=ntStatusProcDescription, ntFSMonitored=ntFSMonitored, ntStatusRegValue=ntStatusRegValue, ntStatusProcExist=ntStatusProcExist, ntAvailPrinterPeriod=ntAvailPrinterPeriod, ntStatusRegCritical=ntStatusRegCritical, ntAvailServPeriod=ntAvailServPeriod, ntStatusCPUCritical=ntStatusCPUCritical, ntDefMemSwapCount=ntDefMemSwapCount, ntEventLogConfig=ntEventLogConfig, ntFilesystemPollTable=ntFilesystemPollTable, ntMemPhysok=ntMemPhysok, ntRegOK=ntRegOK, nt=nt, ntMemoryConfig=ntMemoryConfig, ntProcessCriticalStatus=ntProcessCriticalStatus, ntStatusFileTimestampStatus=ntStatusFileTimestampStatus, ntStatusPrintDescription=ntStatusPrintDescription, ntMemSwapwarning=ntMemSwapwarning, ntFilesystemPollTimestamp=ntFilesystemPollTimestamp, ntProcessorStTable=ntProcessorStTable, ntStatusProcStatus=ntStatusProcStatus, ntStatusProcThdMonitor=ntStatusProcThdMonitor, ntProcesscritical=ntProcesscritical, ntFSRemove=ntFSRemove, ntStatusRegLeaf=ntStatusRegLeaf, caiNtOs=caiNtOs, ntStatusMemSwapStatus=ntStatusMemSwapStatus, ntRemove=ntRemove, ntAgentVersion=ntAgentVersion, ntStatusFSDriveType=ntStatusFSDriveType, ntStatusServName=ntStatusServName, ntRegPollInterval=ntRegPollInterval, ntStatusRegWarning=ntStatusRegWarning, ntGeneralConfig=ntGeneralConfig, ntStatusFSDriveLetter=ntStatusFSDriveLetter, ntProcessorPollTableEntry=ntProcessorPollTableEntry, ntAvailPrinterName=ntAvailPrinterName, ntStatusServStatus=ntStatusServStatus, ntCPUsMonitored=ntCPUsMonitored, ntStatusFileSizeStatus=ntStatusFileSizeStatus, ntFSWarnStatus=ntFSWarnStatus, ntStatusServState=ntStatusServState, ntMemLoadwarning=ntMemLoadwarning, ntAvailProcPeriod=ntAvailProcPeriod, ntStatusLogAppLogLastMatch=ntStatusLogAppLogLastMatch, ntFSUnknown=ntFSUnknown, ntStatusFSPcntWarn=ntStatusFSPcntWarn, ntStatusGroup=ntStatusGroup, ntDefPrintEventMonitor=ntDefPrintEventMonitor, ntStatusPrintEventMonitor=ntStatusPrintEventMonitor, ntStatusMemSwap=ntStatusMemSwap, ntStatusProcInstWarning=ntStatusProcInstWarning, ntStatusRegAvg=ntStatusRegAvg, ntStatusLogSecLogMatches=ntStatusLogSecLogMatches, ntStatusLogSeverity=ntStatusLogSeverity, ntStatusSummary=ntStatusSummary, ntDefRegMonitorLevel=ntDefRegMonitorLevel, ntStatusFSDescription=ntStatusFSDescription, ntCPUInterruptTime=ntCPUInterruptTime, ntProcessorPollTable=ntProcessorPollTable, ntRegistryPollTimestamp=ntRegistryPollTimestamp, ntFilecritical=ntFilecritical, ntDefFileSizeCritical=ntDefFileSizeCritical, ntPrinterAdd=ntPrinterAdd, ntFileok=ntFileok, ntStatusFileMaxSize=ntStatusFileMaxSize, ntLogsMonitored=ntLogsMonitored, ntStatusFSDriveLabel=ntStatusFSDriveLabel, ntStatusCPUCount=ntStatusCPUCount, ntMemorySt=ntMemorySt, ntAvailFSPollTimestamp=ntAvailFSPollTimestamp, ntProcessName=ntProcessName, ntFileSizeChangeReference=ntFileSizeChangeReference, ntAvailPrinterLocation=ntAvailPrinterLocation, ntServiceStTable=ntServiceStTable, ntAvailServiceName=ntAvailServiceName, ntMemoryPollTimestamp=ntMemoryPollTimestamp, ntStatusPrintName=ntStatusPrintName, ntFileName=ntFileName, ntStatusRegKey=ntStatusRegKey, ntStatusLogLogs=ntStatusLogLogs, ntStatusCPUMin=ntStatusCPUMin, ntFScritical=ntFScritical, ntServiceAdd=ntServiceAdd, ntStatusMemLoadMin=ntStatusMemLoadMin, ntFsysDriveLetter=ntFsysDriveLetter, ntCPUUserTime=ntCPUUserTime, ntStatusLogEventID=ntStatusLogEventID, ntPrintCriticalStatus=ntPrintCriticalStatus, ntProcesswarning=ntProcesswarning, ntCPUProcessorTime=ntCPUProcessorTime)

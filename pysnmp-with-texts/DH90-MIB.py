#
# PySNMP MIB module DH90-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DH90-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:46:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, TimeTicks, Unsigned32, enterprises, MibIdentifier, Gauge32, IpAddress, Integer32, ObjectIdentity, Bits, NotificationType, ModuleIdentity, iso, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "TimeTicks", "Unsigned32", "enterprises", "MibIdentifier", "Gauge32", "IpAddress", "Integer32", "ObjectIdentity", "Bits", "NotificationType", "ModuleIdentity", "iso", "Counter64")
PhysAddress, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "PhysAddress", "DisplayString", "TextualConvention")
dec = MibIdentifier((1, 3, 6, 1, 4, 1, 36))
ema = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2))
decMIBextension = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18))
decExp = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3))
dh90 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1))
da90 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2))
ds90L = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3))
drpt90 = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4))
db90ext = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5))
db90system = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1))
db90interfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2))
db90bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3))
dh90Type = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("invalid", 2), ("standAloneCommunity", 3), ("dechub90", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90Type.setStatus('mandatory')
if mibBuilder.loadTexts: dh90Type.setDescription('Identifies the type of Hub defined and identifies standalone configurations managed by DECagent 90 modules. Setting this variable to invalid deletes the community associated with the community string and releases the RAM and flash memory resources used by the community.')
dh90Backplane = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("ethernet", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90Backplane.setStatus('mandatory')
if mibBuilder.loadTexts: dh90Backplane.setDescription('Media on backplane of hub.')
dh90LastChange = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90LastChange.setStatus('mandatory')
if mibBuilder.loadTexts: dh90LastChange.setDescription('The value of the sysUpTime at the time this hub added or removed a module.')
dh90NumberSlots = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90NumberSlots.setStatus('mandatory')
if mibBuilder.loadTexts: dh90NumberSlots.setDescription('Number of slots in backplane. Setting this variable to values of 1, 8 or 16 defines the size of a hub in a particular community.')
dh90SlotTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5), )
if mibBuilder.loadTexts: dh90SlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotTable.setDescription('A list of modules installed in the DEChub 90. The number of entries is given in dh90SlotNumber. To create a new row (module) in the slot table, set a EMPTY dh90SlotModuleType to the appropriate value. If adding a bridge or server, next set the dh90SlotPhysicalAddress for the row. Sets of the other variables in the row must be done in separate PDUs AFTER the mac address of the device has been set correctly.')
dh90SlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1), ).setIndexNames((0, "DH90-MIB", "dh90SlotIndex"))
if mibBuilder.loadTexts: dh90SlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotEntry.setDescription('Contains objects defining characteristics of modules in the DEChub 90')
dh90SlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotIndex.setDescription('The slot number containing the module ')
dh90SlotModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unknown", 1), ("empty", 2), ("decserver90L", 3), ("decbridge90", 4), ("decrepeater90C", 5), ("decrepeater90T", 6), ("decagent90", 7), ("decserver90Lplus", 8), ("decserver90LT", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotModuleType.setDescription('The type of the module in a slot. If the slot is known to be empty, a value of empty is used. If the slot is occupied by a module of unknown type, a value of unknown is used.')
dh90SlotModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotModuleName.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotModuleName.setDescription('A textual description of the module')
dh90SlotModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotModuleVersion.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotModuleVersion.setDescription('A textual description of the version level of the hardware and firmware of the module')
dh90SlotCounterTime = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotCounterTime.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotCounterTime.setDescription('Time since the counters of this module were zeroed')
dh90SlotIfBase = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotIfBase.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotIfBase.setDescription('An index into the ifTable for the first interface on this module. Add one to this value to reference the ifTable entry which corresponds to the second interface, etc. If no interface(s) is/are supported on the module, a value of zero is returned.')
dh90SlotIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotIfNumber.setDescription('Number of interfaces on this module.')
dh90SlotPhysicalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 8), PhysAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotPhysicalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotPhysicalAddress.setDescription('A read-write variable for the physical address to allow devices to be added to the hub remotely. Writing this variable as part of a remote add device routine will cause the new physical address to be accessable in the corresponding ifPhysAddress variable in ifTable.')
dh90SlotNumberOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotNumberOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotNumberOfPorts.setDescription('The number of ports on this module. Returns 8 for DECserver90L and DECrepeater90T, 6 for DECrepeater90C.')
dh90SlotPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotPassword.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotPassword.setDescription('Password used to enable privileged operations on the DECserver90L and access to the bridge. Reads to this variable will return a null string.')
dh90SlotNewPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotNewPassword.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotNewPassword.setDescription('Setting this variable causes the agent to set a new password on the terminal server using the TSNewPassword value as the new password and TSPassword as the old password. Power on the terminal server must be cycled within a minute for the change to take effect. Reads to this variable will return a null string.')
dh90SlotPolling = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90SlotPolling.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotPolling.setDescription("The current polling status of the module. If the DECagent 90 is polling this device, a get of this variable will return 'on', otherwise 'off' is returned. Setting this variable to 'off' causes the agent to stop polling the device in this slot. Setting this variable to 'on' causes the agent to start polling the device in the specified slot. If a device does not repond to a poll, an moduleDown enterprise specific trap is generated.")
dh90SlotPrimarySpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotPrimarySpecific.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotPrimarySpecific.setDescription('A reference to the Bridge { experimental 14 }, the Character-like { experimental 19 } or the { drpt90 } repeater portion of this MIB definition. If the module realizes some other function, the object identifier nullSpecific OBJECT IDENTIFIER ::= { 0 0 } is returned.')
dh90SlotSecondarySpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 5, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dh90SlotSecondarySpecific.setStatus('mandatory')
if mibBuilder.loadTexts: dh90SlotSecondarySpecific.setDescription('A reference to the RS232-like { experimental 20 } MIB definition, if dh90ModulePrimarySpecific identifies the Character-like MIB. Otherwise, the object identifier nullSpecific OBJECT IDENTIFIER ::= { 0 0 } is returned.')
dh90TrapAddressTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 6), )
if mibBuilder.loadTexts: dh90TrapAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: dh90TrapAddressTable.setDescription('A table of IP Addresses to which this device will send traps.')
dh90TrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 6, 1), ).setIndexNames((0, "DH90-MIB", "dh90TrapAddress"))
if mibBuilder.loadTexts: dh90TrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dh90TrapEntry.setDescription('Each entry contains an IP Address to which all SNMP Traps will be sent by this community.')
dh90TrapAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 1, 6, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dh90TrapAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dh90TrapAddress.setDescription('An IP Address to which all SNMP traps generated by this device will be sent. Setting a instance to a value of zero will delete the row in the table.')
da90FlashErasures = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: da90FlashErasures.setStatus('mandatory')
if mibBuilder.loadTexts: da90FlashErasures.setDescription('The number of times the flash memory on this DECagent 90 has been erased. This number is the total of erasures for all segments of flash.')
da90Maintenance = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ready", 1), ("unused", 2), ("reset", 3), ("resetToFactory", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90Maintenance.setStatus('mandatory')
if mibBuilder.loadTexts: da90Maintenance.setDescription("A control variable to reset the counters on a DECagent 90. In response to a get-request or a get-next-request, the agent always returns 'ready'. Setting the value to 'reset' causes the entire module to be reset. Setting the value to 'resetToFactory' causes the entire device to be reset to the original factory settings.")
da90CommunityNumber = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: da90CommunityNumber.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityNumber.setDescription('Number of community string-pair entries in da90HubCommStrsTable.')
da90CommunityTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4), )
if mibBuilder.loadTexts: da90CommunityTable.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityTable.setDescription('A table of community string pairs for client hubs.')
da90CommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1), ).setIndexNames((0, "DH90-MIB", "da90CommunityIndex"))
if mibBuilder.loadTexts: da90CommunityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityEntry.setDescription('Contains a pair of community strings, one specifying a read-only profile, the other a read-write profile.')
da90CommunityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90CommunityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityIndex.setDescription(' Index into hub community string pair table, identifies the community being accessed ')
da90CommunityType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("invalid", 2), ("active", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90CommunityType.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityType.setDescription('Identifies whether the current community information in the DENMA is active for this row in the community table. Setting to invalid frees the NVRAM used to store the community information (destroys the slot table and port tables for this community).')
da90CommunityROString = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90CommunityROString.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityROString.setDescription("Community string, with a read-only profile, used to access a da90's client Hub. All community strings in the read-only set must be unique. Setting such a community string to a pre-existing value returns a status of BadValue. Reading this variable with any community string other than the agent's community string will return a zero length string.")
da90CommunityRWString = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90CommunityRWString.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityRWString.setDescription("Community string, with a read-write profile, used to access a da90's client Hub. All community strings in the read-only set must be unique. Setting such a community string to a pre-existing value returns a status of BadValue. Reading this variable with any community string other than the agent's read-write community string will return a zero length string.")
da90CommunityTrapString = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 2, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: da90CommunityTrapString.setStatus('mandatory')
if mibBuilder.loadTexts: da90CommunityTrapString.setDescription("Community string sent with traps generated due to events caused by this community. The trap community strings do not have to be unique. This variable is read using the agent's community string.")
ds90LNumberModules = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LNumberModules.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LNumberModules.setDescription('Number of DECserver 90L Modules represented in the ds90LModuleTable.')
ds90LModuleTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2), )
if mibBuilder.loadTexts: ds90LModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LModuleTable.setDescription('A table of DECserver 90L modules installed in the group. The number of entries is given in ds90LModuleNumber.')
ds90LModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1), ).setIndexNames((0, "DH90-MIB", "ds90LSlotIndex"))
if mibBuilder.loadTexts: ds90LModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LModuleEntry.setDescription('Contains objects defining characteristics of DECserver 90L modules in the group ')
ds90LSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSlotIndex.setDescription('The slot index value which addresses the dh90SlotTable for this module.')
ds90LDot3StatsDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LDot3StatsDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LDot3StatsDeferredTransmissions.setDescription('A count of frames for which the first transmission attempt on a particular interface is delayed because the medium is busy. The count represented by an instance of this object does not include frames involved in collisions.')
ds90LDot3StatsSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LDot3StatsSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LDot3StatsSingleCollisionFrames.setDescription('A count of successfully transmitted frames on a particular interface for which transmission is inhibited by exactly one collision. (If DS90L is implementing the MIB-II if group, the following also applies: A frame that is counted by an instance of this object is also counted by the corresponding instance of either the ifOutUcastPkts or ifOutNUcastPkts object and is not counted by the corresponding instance of the ds90LDot3StatsMultipleCollisionFrames object.)')
ds90LDot3StatsMultipleCollsionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LDot3StatsMultipleCollsionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LDot3StatsMultipleCollsionFrames.setDescription('A count of successfully transmitted frames on a particular interface for which transmission is inhibited by more than one collision. (If DS90L is implementing the MIB-II if group, the following also applies: A frame that is counted by an instance of this object is also counted by the corresponding instance of either the ifOutUcastPkts or ifOutNUcastPkts object and is not counted by the corresponding instance of the ds90LDot3StatsSingleCollisionFrames object.)')
ds90LEnetDataOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LEnetDataOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LEnetDataOverruns.setDescription('A count of the number of frames arriving at the DS90L lost due to data overrun since it last reinitialized or zeroed counters.')
ds90LLatCircMsgsIns = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircMsgsIns.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircMsgsIns.setDescription('A count of the number of LAT circuit messages received by this DS90L since it last reinitialized or zeroed counters.')
ds90LLatCircMsgsOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircMsgsOuts.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircMsgsOuts.setDescription('A count of the number of LAT circuit messages transmitted by this DS90L since it last reinitialized or zeroed counters.')
ds90LLatSessSolicitAccepts = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatSessSolicitAccepts.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatSessSolicitAccepts.setDescription('A count of the number of LAT Solicits accepted by this DS90L since it last reinitialized or zeroed counters.')
ds90LLatSessSolicitRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatSessSolicitRejects.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatSessSolicitRejects.setDescription('A count of the number of LAT Solicits rejected by this DS90L since it last reinitialized or zeroed counters.')
ds90LLatCircDuplsMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircDuplsMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircDuplsMsgs.setDescription('A count of the number of duplicate LAT messages the DS90L LAT implementation has discarded since it last reinitialized or zeroed counters.')
ds90LLatCircMsgRetransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircMsgRetransmits.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircMsgRetransmits.setDescription('A count of the total number of LAT circuit messages this DS90L has retransmitted since it last reinitialized or zeroed counters.')
ds90LLatSessIllegalSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatSessIllegalSlots.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatSessIllegalSlots.setDescription('A count of the number of illegal LAT slots the DS90L has received on all LAT sessions since it last reinitialized or zeroed counters.')
ds90LIllegalMulticastRcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LIllegalMulticastRcvs.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LIllegalMulticastRcvs.setDescription('This counts the number of illegal multicast LAT messages received on this DECserver 90L since it last reinitialized or zeroed counters.')
ds90LLatCircKeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircKeepAlive.setDescription('This defines the number of seconds the LAT circuits provider waits between transmitting LAT circuit layer keep-alive messages. Writing to this object is equivalent to issuing the CHANGE SERVER KEEPALIVE TIMER command via the user interface.')
ds90LLatCircRetransmitLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 120))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircRetransmitLimit.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircRetransmitLimit.setDescription('This object defines the maximum number of LAT circuit message retransmissions the server will attempt before declaring the circuit failed. Writing to this object is equivalent to issuing the CHANGE SERVER RETRANSMIT LIMIT command via the user interface.')
ds90LLatCircInvalidMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LLatCircInvalidMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LLatCircInvalidMsgs.setDescription("This counts the number of invalid LAT messages received on its entry's LAT circuit since the DECserver90L last reinitialized or zeroed counters.")
ds90LAuthorizeMode = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LAuthorizeMode.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LAuthorizeMode.setDescription('Setting this value to enable causes the SET A,password command to be sent to the DECserver 90. The module will enter authorized mode IF the power is cycled on the module within one minute. The password used will be the current value of dh90ModulePassword. Setting this variable to disable results in authorized mode being cleared')
ds90LMaintenance = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ready", 1), ("zeroCounters", 2), ("reset", 3), ("resetToFactory", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LMaintenance.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LMaintenance.setDescription("A control variable to reset the counters on a DECserver 90L. In response to a get-request or a get-next-request, the agent always returns 'ready'. Setting the value to 'zeroCounters' causes the if, LAT and dh90SlotCounterTime counters to be cleared. Setting the value to 'reset' causes the entire module to be reset, any users and circuits will be disconnected. Setting the value to 'resetToFactory' causes the entire device to be reset to the original factory settings. Passwords, port names and printer speeds will be cleared.")
ds90LPrompt = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPrompt.setDescription("A DECserver 90L+ (PLUS) variable. Contains the prompt displayed when a session is local to the PLUS version of the terminal server. The default value is '->'. This variable is not present if the server is a DECserver 90L.")
ds90LPortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3), )
if mibBuilder.loadTexts: ds90LPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortTable.setDescription('Table of port specific variables on this DECserver90L.')
ds90LPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortIndex.setDescription('The value of charPortIndex for this port.')
ds90LPortRemoteModification = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortRemoteModification.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortRemoteModification.setDescription('Enables and disables remote modification of of the port by the host system.')
ds90LPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("terminal", 1), ("printer", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortType.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortType.setDescription('Selects the type of device connected to the port.')
ds90LPortBreak = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortBreak.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortBreak.setDescription('Determines if the port responds to local or remote break.')
ds90LPortTest = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortTest.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortTest.setDescription('Setting this variable to enable places the port into loopback mode. Loopback mode can be used to verify that a port is receiving and sending characters.')
ds90LPortAutoConfigure = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortAutoConfigure.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortAutoConfigure.setDescription('A DECserver 90L+ (PLUS) variable. Enables or disables the Autoconfiguration of the port, the ability of the port to autobaud. Disabling autoconfiguration also causes the speed and characteristics of the port to be stored in non-volatile memory on the server. The variable is not present if the server is a DECserver 90L.')
ds90LPortOnDemandLoading = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds90LPortOnDemandLoading.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortOnDemandLoading.setDescription('A DECserver 90L+ (PLUS) variable. Enables or disables on demand loading of fonts. The variable is not present if the server is a DECserver 90L.')
ds90LSessionTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4), )
if mibBuilder.loadTexts: ds90LSessionTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionTable.setDescription('The list of all LAT sessions active on this DECserver90L.')
ds90LPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 3, 1), ).setIndexNames((0, "DH90-MIB", "ds90LPortIndex"))
if mibBuilder.loadTexts: ds90LPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LPortEntry.setDescription('A single LAT session instance this DS90L currently provides.')
ds90LSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1), ).setIndexNames((0, "DH90-MIB", "ds90LSessionPort"), (0, "DH90-MIB", "ds90LSessionIndex"))
if mibBuilder.loadTexts: ds90LSessionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionEntry.setDescription('A single LAT session instance this DS90L currently provides.')
ds90LSessionPort = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSessionPort.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionPort.setDescription('The value of charPortIndex for the port to which this session belongs.')
ds90LSessionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSessionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionIndex.setDescription('The session index in the context of the port, a non-zero positive integer. Will be 1 for the DECserver90L, 4 for DECserver 90L+.')
ds90LSessionRemoteNode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSessionRemoteNode.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionRemoteNode.setDescription('The name of the remote node providing the service for this session.')
ds90LSessionService = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSessionService.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionService.setDescription('The service to which this session is connected.')
ds90LSessionRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 3, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds90LSessionRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: ds90LSessionRemotePortId.setDescription('The name of the port at the remote node providing the connection, for instance LAT121.')
drpt90PortTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1), )
if mibBuilder.loadTexts: drpt90PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortTable.setDescription('A list of port entries. The index for a repeater port is given by (slot number*100) + port number The number of ports is given by dh90SlotTable.dh90SlotEntry. dh90SlotNumberOfPorts.')
drpt90PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1), ).setIndexNames((0, "DH90-MIB", "drpt90PortIndex"))
if mibBuilder.loadTexts: drpt90PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortEntry.setDescription('A collection of objects containing information for a given interface.')
drpt90PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortIndex.setDescription('Identifies the module and port. The value of this object is given by: (slot number*100) + port number')
drpt90PortName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: drpt90PortName.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortName.setDescription('The text description of the port given by management')
drpt90PortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: drpt90PortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortAdminStatus.setDescription('The desired state of the port.')
drpt90PortState = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("autoPartitioned", 2), ("managementPartitioned", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortState.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortState.setDescription('The state of the port. Unknown(1) is returned when the port state cannot be determined. AutoPartitioned(2) indicates that the repeater has disabled the port automatically, ManagementPartitioned(3) indicates that the port has been disabled remotely, and active(4) indicates that the port is operational.')
drpt90PortType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("twistedPair", 2), ("thinWire", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortType.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortType.setDescription('The Physical Medium type of the port')
drpt90PortPartitionCount = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortPartitionCount.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortPartitionCount.setDescription('The number of times this port has partitioned. This value is only significant if drpt90PortStatus is not unknown(1).')
drpt90PortAutoPartitionReason = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("notPartitioned", 0), ("managementPartitioned", 1), ("excessiveLength", 2), ("excessiveLengthAndMgmtPart", 3), ("excessiveCollisions", 4), ("excessiveCollisionsAndMgmtPart", 5), ("jabber", 6), ("jabberAndMgmtPart", 7), ("nocarrierLoopback", 8), ("nocarrierLoopbackAndMgmtPart", 9), ("transmitCarrierDropout", 10), ("transmitCarrierDropoutAndMgmtPart", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortAutoPartitionReason.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortAutoPartitionReason.setDescription('Errors currently detected on the port.')
drpt90PortJamBits = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("jb96", 2), ("jb128", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortJamBits.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortJamBits.setDescription('The number of jam bits being used on the port segment.')
drpt90PortAddrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 2), )
if mibBuilder.loadTexts: drpt90PortAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortAddrTable.setDescription('A list of MAC addresses paired with the repeater port on which they have been seen.')
drpt90PortAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 2, 1), ).setIndexNames((0, "DH90-MIB", "drpt90PortPhyAddr"))
if mibBuilder.loadTexts: drpt90PortAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortAddrEntry.setDescription('A MAC addresses and the repeater port on which it resides.')
drpt90PortPhyAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 2, 1, 1), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortPhyAddr.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortPhyAddr.setDescription('A MAC address seen on this port')
drpt90PortAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1608))).setMaxAccess("readonly")
if mibBuilder.loadTexts: drpt90PortAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: drpt90PortAddrIndex.setDescription('Identifies the module and port. The value of this object the same as drpt90PortIndex and is given by: (slot number*100) + port number')
dbSysChar = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 1))
dbSysStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 2))
dbSysRomVersion = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbSysRomVersion.setStatus('mandatory')
if mibBuilder.loadTexts: dbSysRomVersion.setDescription('The version number of the software stored in ROM.')
dbSysInitSwitch = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("reset", 2), ("resetToFactory", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dbSysInitSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: dbSysInitSwitch.setDescription("This object allows the management action of initializing a device and forcing it to run selftest. It can also be used to reset all information added to the device's NVRAM. When read, it returns a value of other(1). When set to a value of 'reset', the bridge will empty the forwarding data base and start relearning. When set to 'resetToFactory', the bridge will empty the forwarding data base, reset spanning tree and clear all protocol filters and password.")
dbSysDeviceState = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("init", 1), ("operate", 2), ("broken", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbSysDeviceState.setStatus('mandatory')
if mibBuilder.loadTexts: dbSysDeviceState.setDescription('The operational state of the device.')
dbSysNvramFailed = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbSysNvramFailed.setStatus('mandatory')
if mibBuilder.loadTexts: dbSysNvramFailed.setDescription('A flag, that, when set to True, indicates that the NVRAM failed selftest following the last initialization of the device. Values set to variables maintained on the bridge will not be preserved over a power cycle of the bridge.')
dbIfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2, 1), )
if mibBuilder.loadTexts: dbIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: dbIfTable.setDescription('A list of interface entries. The number of entries is given by ifNumber, defined in [2].')
dbIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2, 1, 1), ).setIndexNames((0, "DH90-MIB", "dbIfIndex"))
if mibBuilder.loadTexts: dbIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dbIfEntry.setDescription('A collection of objects containing information for a given interface.')
dbIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dbIfIndex.setDescription('Identifies the Interface. The value of this the same object is as the ifIndex, defined in [2], for this interface.')
dbIfBadFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbIfBadFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: dbIfBadFramesReceived.setDescription('Number of frames received with a bad frame check sequence or the device received a frame loss indication from the hardware on the interface.')
dbIfTransmitFramesError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dbIfTransmitFramesError.setStatus('mandatory')
if mibBuilder.loadTexts: dbIfTransmitFramesError.setDescription('Number of frames that were transmitted with an error on the line.')
db90Char = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1))
db90Stat = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2))
db90Coun = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 3))
db90Span = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4))
db90PortInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5))
db90ProtoFilt = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6))
db90LB100SpanningTreeVer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90LB100SpanningTreeVer.setStatus('mandatory')
if mibBuilder.loadTexts: db90LB100SpanningTreeVer.setDescription('The version number of the Spanning Tree algorithm used by the bridge when in the LAN Bridge 100 Spanning Tree mode.')
db90802SpanningTreeVer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90802SpanningTreeVer.setStatus('mandatory')
if mibBuilder.loadTexts: db90802SpanningTreeVer.setDescription('The version number of the Spanning Tree algorithm used by the bridge when in the 802.1d Spanning Tree mode.')
db90MaxForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90MaxForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90MaxForwardingDBEntries.setDescription('The maximum number of address entries that the bridge can store in its volatile memory.')
db90MaxNVForwardingDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90MaxNVForwardingDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90MaxNVForwardingDBEntries.setDescription('The maximum number of permanent address entries that the bridge can store in its NVRAM.')
db90MaxProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90MaxProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90MaxProtocolDBEntries.setDescription('The maximum number of protocol entries that the bridge can store in its protocol database. These entries control the handling of frames based on their Ethernet PT, IEEE 802.2 DSAP or IEEE 802 SNAP Protocol ID.')
db90MaxNVProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90MaxNVProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90MaxNVProtocolDBEntries.setDescription('The maximum number of protocol entries that the bridge can store in its nonvolatile memory. These are retained after a power-down.')
db90CurrProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90CurrProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90CurrProtocolDBEntries.setDescription("The number of protocol entries that are stored in the bridge's protocol database. These control the handling of frames based on their Ethernet protocol type, IEEE 802.2 DSAP, or 802 SNAP Protocol ID.")
db90CurrNVProtocolDBEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90CurrNVProtocolDBEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90CurrNVProtocolDBEntries.setDescription("The number of protocol entries in the bridge's NVRAM. These are retained after a power loss.")
db90MgmtHeardPort = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("backbone", 1), ("workgroup", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90MgmtHeardPort.setStatus('mandatory')
if mibBuilder.loadTexts: db90MgmtHeardPort.setDescription('The port on which this command was received.')
db90LB100BeingPolled = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90LB100BeingPolled.setStatus('mandatory')
if mibBuilder.loadTexts: db90LB100BeingPolled.setDescription('The address of the LAN Bridge 100 mode bridge that sent this bridge into the LAN Bridge 100 Spanning Tree mode. If this bridge is the Root, this object indicates the bridge that will be polled periodically to determine if it is still necessary to stay in this Spanning Tree mode.')
db90TimeSinceLastHello = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90TimeSinceLastHello.setStatus('mandatory')
if mibBuilder.loadTexts: db90TimeSinceLastHello.setDescription('The number of seconds since the bridge last sent a Hello message.')
db90HubManagement = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90HubManagement.setStatus('mandatory')
if mibBuilder.loadTexts: db90HubManagement.setDescription('Indicates whether the bridge is managing the hub (i.e., is capable of managing repeaters inserted in the hub).')
db90CurrFdbEntries = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90CurrFdbEntries.setStatus('mandatory')
if mibBuilder.loadTexts: db90CurrFdbEntries.setDescription('The number of entries currently active in the DECbridge 90 forwarding data base, or one more than the value of db90MaxForwardingDBEntries if the bridge has exceededd the size of the forwarding data base hardware.')
db90SpanningTreeModeChanges = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90SpanningTreeModeChanges.setStatus('mandatory')
if mibBuilder.loadTexts: db90SpanningTreeModeChanges.setDescription('The number of times that the bridge switched from the 802.1d Spanning Tree mode to the LB100 Spanning Tree mode.')
db90BestRootAge = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90BestRootAge.setStatus('mandatory')
if mibBuilder.loadTexts: db90BestRootAge.setDescription('The age, in hundredths of seconds, of the Hello message that established the best root.')
db90TopologyChangeFlag = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90TopologyChangeFlag.setStatus('mandatory')
if mibBuilder.loadTexts: db90TopologyChangeFlag.setDescription('A flag that indicates whether a Topology Change is currently in effect on the extended LAN.')
db90TellParentFlag = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90TellParentFlag.setStatus('mandatory')
if mibBuilder.loadTexts: db90TellParentFlag.setDescription('A flag that indicates if the bridge is attempting to propagate a topology change towards the Root.')
db90ForwardingDBShortAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90ForwardingDBShortAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: db90ForwardingDBShortAgingTime.setDescription('The number of seconds that the bridge keeps learned entries active while a topology change is in effect.')
db90BadHelloLimit = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90BadHelloLimit.setStatus('mandatory')
if mibBuilder.loadTexts: db90BadHelloLimit.setDescription('The number of hello intervals during which the bridge receives one or more bad hellos on a line, before the bridge performs a test on the link. A bad Hello message is one that contains inferior information that is received on a port on which this bridge is Designated.')
db90BadHelloResetTimer = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90BadHelloResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: db90BadHelloResetTimer.setDescription('The number of Hello intervals without bad Hellos that the bridge will wait before it resets its bad Hello count to zero.')
db90NoFrameInterval = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90NoFrameInterval.setStatus('mandatory')
if mibBuilder.loadTexts: db90NoFrameInterval.setDescription('The The number of seconds of inactivity on a line that will cause the bridge to run a test on that line. The bridge considers a line to be inactive if it does not receive any frames on that line.')
db90LB100PollTime = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90LB100PollTime.setStatus('mandatory')
if mibBuilder.loadTexts: db90LB100PollTime.setDescription('The number of seconds that a Root bridge in LAN Bridge 100 mode waits between polling the LAN Bridge 100 that is keeping it in this mode. This polling is done to determine whether the LB100 is still present on the extended LAN.')
db90LB100ResponseTimeout = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90LB100ResponseTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: db90LB100ResponseTimeout.setDescription('The number of seconds that a Root in LAN Bridge 100 Spanning Tree mode will wait for a response from the LAN Bridge 100 which is keeping it in this mode, before which it will assume that the LB100 is no longer on the extended LAN.')
db90LB100SpanningTreeCompat = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 4, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autoSelect", 1), ("ieee802", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90LB100SpanningTreeCompat.setStatus('mandatory')
if mibBuilder.loadTexts: db90LB100SpanningTreeCompat.setDescription('A switch that controls the Spanning Tree mode used by the bridge. If in Auto-Select mode, the bridge will go into 802 Spanning Tree mode by default, but will switch to LB100 mode as soon as a LB100 is detected. In 802 Spanning Tree mode, the bridge will stay in 802 mode.')
db90IfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 1), )
if mibBuilder.loadTexts: db90IfTable.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfTable.setDescription('A list of interface entries. The number of entries is given by ifNumber, defined in [2].')
db90IfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 1, 1), ).setIndexNames((0, "DH90-MIB", "db90IfIndex"))
if mibBuilder.loadTexts: db90IfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEntry.setDescription('A collection of objects containing information for a given interface.')
db90IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in [2], for this interface.')
db90IfDeviceFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfDeviceFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfDeviceFramesReceived.setDescription('The number of frames addressed to the bridge itself that were received on this line.')
db90IfBadHelloLimitExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfBadHelloLimitExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfBadHelloLimitExceeded.setDescription('The number of times that the Bad Hellos on the line exceeded the Bad Hello limit.')
db90IfEtherTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2), )
if mibBuilder.loadTexts: db90IfEtherTable.setStatus('optional')
if mibBuilder.loadTexts: db90IfEtherTable.setDescription('A list of interface entries for an Ethernet port.')
db90IfEtherEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2, 1), ).setIndexNames((0, "DH90-MIB", "db90IfIndex"))
if mibBuilder.loadTexts: db90IfEtherEntry.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEtherEntry.setDescription('A collection of objects containing information for a given interface.')
db90IfEthIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfEthIndex.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEthIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in [2], for this interface.')
db90IfEthFramingError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfEthFramingError.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEthFramingError.setDescription('The number of times that a frame received on the line contained both a noninteger multiple of 8 bits and a CRC error.')
db90IfEthCarrierLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfEthCarrierLoss.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEthCarrierLoss.setDescription('The number of times that the bridge detected a loss of the carrier signal while transmitting a frame on the line.')
db90IfEthCollisionLimitExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfEthCollisionLimitExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfEthCollisionLimitExceeded.setDescription('The number of times that the bridge failed to transmit a frame on this line after 16 attempts, the collision limit.')
db90IfSpanTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3), )
if mibBuilder.loadTexts: db90IfSpanTable.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpanTable.setDescription('A list of interface entries for a port.')
db90IfSpanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1), ).setIndexNames((0, "DH90-MIB", "db90IfIndex"))
if mibBuilder.loadTexts: db90IfSpanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpanEntry.setDescription('A collection of objects containing information for a given interface.')
db90IfSpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 17))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfSpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpIndex.setDescription('Identifies the Interface. The value of this object is the same as the ifIndex, defined in [2], for this interface.')
db90IfSpDesigRootAge = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfSpDesigRootAge.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpDesigRootAge.setDescription('The age, in hundreths of seconds, of the last Hello message received from the designated bridge on the line.')
db90IfSpForwardDelayTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfSpForwardDelayTimer.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpForwardDelayTimer.setDescription('The time remaining, in hundreths of seconds, before the bridge will leave the Learning State of Preforwarding, and enter the Forwarding State.')
db90IfSpBadHelloCount = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfSpBadHelloCount.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpBadHelloCount.setDescription('The number of Hello intervals during which at least one Bad Hello was received.')
db90IfSpTopologyChangeAckFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 5, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90IfSpTopologyChangeAckFlag.setStatus('mandatory')
if mibBuilder.loadTexts: db90IfSpTopologyChangeAckFlag.setDescription('A flag that indicates whether a topology change notification received on a link that we are designated on needs to be acknowledged.')
db90ProtoFilterOther = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: db90ProtoFilterOther.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterOther.setDescription('Action taken by the bridge on Ethernet protocol types or the 5-byte SNAP PIDs other than those specified in the db90ProtoTable. This value defaults to forward(1) and is modified only if a protocol with db90filterEntry.db90FilterStatus of forward(1) is entered into the table.')
db90ProtoFilterTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2), )
if mibBuilder.loadTexts: db90ProtoFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterTable.setDescription('A table that contains filtering information about Ethernet protocol types and 5 byte SNAP PIDs for the DECbridge 90.')
db90ProtoFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1), ).setIndexNames((0, "DH90-MIB", "db90ProtoFilterProtocol"))
if mibBuilder.loadTexts: db90ProtoFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterEntry.setDescription('A table that contains filtering characteristics for Ethernet protocol types and 5 byte SNAP PIDs for the DECbridge 90.')
db90ProtoFilterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90ProtoFilterProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterProtocol.setDescription("The protocol type or SNAP PID in a frame to which this entry's filtering information applies. The length is 2 for Ethernet protocol types and 5 for SNAP PID.")
db90ProtoFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("invalid", 2), ("ethernet", 3), ("snap-sap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90ProtoFilterType.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterType.setDescription('The type of this entry. unknown(1) specifies that this protocol filter is unused. invalid(2) deletes the filter. ethernet(3) or snap-sap(4) defines the size of db90ProtoFilterProtocol.')
db90ProtoFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forward", 1), ("filter", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90ProtoFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterStatus.setDescription('Action taken by bridge when it sees this ethernet protocol type or SNAP PID in a received frame. Note that this value must be identical to db90ProtoFilterOther unless db90ProtoFilterMulticastFlag is multicastOnly(2) or there are no other entries with db90ProtoFilterMulticastFlag=allFrames(1).')
db90ProtoFilterMulticastFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allFrames", 1), ("multicastOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90ProtoFilterMulticastFlag.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterMulticastFlag.setDescription('Identifies whether or not filtering is based on the multicast bit in the MAC destination address. If allFrames(1), then filtering is performed as per db90ProtoFilterStatus. For multicastOnly(2), multicast frames for this protocol are always filtered and unicast frames are always forwarded; this is true regardless of the value of db90ProtoFilterOther.')
db90ProtoFilterPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 3, 5, 3, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("backbone", 1), ("workGroup", 2), ("allPorts", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: db90ProtoFilterPortMask.setStatus('mandatory')
if mibBuilder.loadTexts: db90ProtoFilterPortMask.setDescription('Must be allPorts(3) unless db90ProtoFilterMulticastFlag is multicastOnly, in which case any specification is valid.')
mibBuilder.exportSymbols("DH90-MIB", da90=da90, db90BestRootAge=db90BestRootAge, db90ProtoFilterMulticastFlag=db90ProtoFilterMulticastFlag, dh90SlotPrimarySpecific=dh90SlotPrimarySpecific, dh90SlotEntry=dh90SlotEntry, ds90LNumberModules=ds90LNumberModules, dec=dec, ds90LDot3StatsSingleCollisionFrames=ds90LDot3StatsSingleCollisionFrames, db90SpanningTreeModeChanges=db90SpanningTreeModeChanges, db90LB100SpanningTreeCompat=db90LB100SpanningTreeCompat, da90FlashErasures=da90FlashErasures, db90IfEthFramingError=db90IfEthFramingError, da90CommunityROString=da90CommunityROString, db90TimeSinceLastHello=db90TimeSinceLastHello, drpt90PortAddrIndex=drpt90PortAddrIndex, dh90SlotIndex=dh90SlotIndex, ds90LModuleTable=ds90LModuleTable, ds90LLatCircMsgsOuts=ds90LLatCircMsgsOuts, db90ForwardingDBShortAgingTime=db90ForwardingDBShortAgingTime, ds90L=ds90L, dbIfIndex=dbIfIndex, da90Maintenance=da90Maintenance, dh90SlotIfBase=dh90SlotIfBase, drpt90PortType=drpt90PortType, db90ProtoFilterStatus=db90ProtoFilterStatus, db90ProtoFilterProtocol=db90ProtoFilterProtocol, drpt90PortPartitionCount=drpt90PortPartitionCount, dbIfEntry=dbIfEntry, dh90SlotTable=dh90SlotTable, ds90LPortType=ds90LPortType, drpt90PortState=drpt90PortState, ds90LLatCircMsgsIns=ds90LLatCircMsgsIns, db90IfEtherTable=db90IfEtherTable, ds90LSlotIndex=ds90LSlotIndex, db90IfBadHelloLimitExceeded=db90IfBadHelloLimitExceeded, db90NoFrameInterval=db90NoFrameInterval, drpt90PortTable=drpt90PortTable, ds90LMaintenance=ds90LMaintenance, dbSysRomVersion=dbSysRomVersion, db90LB100BeingPolled=db90LB100BeingPolled, drpt90PortName=drpt90PortName, db90HubManagement=db90HubManagement, dh90SlotModuleVersion=dh90SlotModuleVersion, drpt90PortEntry=drpt90PortEntry, ds90LPortTable=ds90LPortTable, db90Char=db90Char, db90ProtoFilterTable=db90ProtoFilterTable, db90IfTable=db90IfTable, dh90NumberSlots=dh90NumberSlots, db90IfEthCollisionLimitExceeded=db90IfEthCollisionLimitExceeded, dh90SlotModuleName=dh90SlotModuleName, ema=ema, da90CommunityType=da90CommunityType, db90MaxNVForwardingDBEntries=db90MaxNVForwardingDBEntries, db90IfSpTopologyChangeAckFlag=db90IfSpTopologyChangeAckFlag, drpt90=drpt90, db90IfSpanTable=db90IfSpanTable, ds90LPortRemoteModification=ds90LPortRemoteModification, dh90TrapAddress=dh90TrapAddress, db90IfSpForwardDelayTimer=db90IfSpForwardDelayTimer, dbIfTable=dbIfTable, db90LB100PollTime=db90LB100PollTime, dbIfTransmitFramesError=dbIfTransmitFramesError, ds90LModuleEntry=ds90LModuleEntry, db90BadHelloResetTimer=db90BadHelloResetTimer, dbSysDeviceState=dbSysDeviceState, da90CommunityRWString=da90CommunityRWString, db90IfEntry=db90IfEntry, ds90LLatCircInvalidMsgs=ds90LLatCircInvalidMsgs, db90ProtoFilterPortMask=db90ProtoFilterPortMask, da90CommunityTrapString=da90CommunityTrapString, ds90LLatSessSolicitAccepts=ds90LLatSessSolicitAccepts, decExp=decExp, dh90Type=dh90Type, db90CurrFdbEntries=db90CurrFdbEntries, dh90SlotPolling=dh90SlotPolling, db90IfSpIndex=db90IfSpIndex, db90Stat=db90Stat, db90ProtoFilterOther=db90ProtoFilterOther, ds90LPortBreak=ds90LPortBreak, db90MaxProtocolDBEntries=db90MaxProtocolDBEntries, db90LB100ResponseTimeout=db90LB100ResponseTimeout, db90ext=db90ext, db90IfEthCarrierLoss=db90IfEthCarrierLoss, ds90LLatCircRetransmitLimit=ds90LLatCircRetransmitLimit, ds90LSessionTable=ds90LSessionTable, ds90LSessionEntry=ds90LSessionEntry, drpt90PortAdminStatus=drpt90PortAdminStatus, db90system=db90system, dh90LastChange=dh90LastChange, ds90LAuthorizeMode=ds90LAuthorizeMode, dbSysInitSwitch=dbSysInitSwitch, db90interfaces=db90interfaces, ds90LLatSessIllegalSlots=ds90LLatSessIllegalSlots, dbSysChar=dbSysChar, drpt90PortPhyAddr=drpt90PortPhyAddr, ds90LPortTest=ds90LPortTest, db90IfSpanEntry=db90IfSpanEntry, ds90LIllegalMulticastRcvs=ds90LIllegalMulticastRcvs, drpt90PortAddrTable=drpt90PortAddrTable, ds90LPortEntry=ds90LPortEntry, db90CurrNVProtocolDBEntries=db90CurrNVProtocolDBEntries, ds90LEnetDataOverruns=ds90LEnetDataOverruns, db90TellParentFlag=db90TellParentFlag, db90PortInterfaces=db90PortInterfaces, db90802SpanningTreeVer=db90802SpanningTreeVer, dh90SlotNewPassword=dh90SlotNewPassword, db90ProtoFilt=db90ProtoFilt, dh90SlotModuleType=dh90SlotModuleType, ds90LDot3StatsDeferredTransmissions=ds90LDot3StatsDeferredTransmissions, db90IfDeviceFramesReceived=db90IfDeviceFramesReceived, ds90LPortOnDemandLoading=ds90LPortOnDemandLoading, ds90LLatCircDuplsMsgs=ds90LLatCircDuplsMsgs, db90Span=db90Span, db90CurrProtocolDBEntries=db90CurrProtocolDBEntries, ds90LSessionRemotePortId=ds90LSessionRemotePortId, dbSysNvramFailed=dbSysNvramFailed, da90CommunityTable=da90CommunityTable, dh90SlotPassword=dh90SlotPassword, ds90LSessionService=ds90LSessionService, db90bridge=db90bridge, dh90SlotNumberOfPorts=dh90SlotNumberOfPorts, drpt90PortIndex=drpt90PortIndex, da90CommunityNumber=da90CommunityNumber, ds90LLatCircMsgRetransmits=ds90LLatCircMsgRetransmits, drpt90PortJamBits=drpt90PortJamBits, dh90=dh90, ds90LLatCircKeepAlive=ds90LLatCircKeepAlive, db90ProtoFilterType=db90ProtoFilterType, ds90LDot3StatsMultipleCollsionFrames=ds90LDot3StatsMultipleCollsionFrames, db90LB100SpanningTreeVer=db90LB100SpanningTreeVer, dh90SlotCounterTime=dh90SlotCounterTime, dh90TrapEntry=dh90TrapEntry, db90ProtoFilterEntry=db90ProtoFilterEntry, db90MaxNVProtocolDBEntries=db90MaxNVProtocolDBEntries, ds90LLatSessSolicitRejects=ds90LLatSessSolicitRejects, dh90TrapAddressTable=dh90TrapAddressTable, dh90SlotIfNumber=dh90SlotIfNumber, dh90SlotPhysicalAddress=dh90SlotPhysicalAddress, decMIBextension=decMIBextension, drpt90PortAutoPartitionReason=drpt90PortAutoPartitionReason, db90MaxForwardingDBEntries=db90MaxForwardingDBEntries, db90IfEtherEntry=db90IfEtherEntry, ds90LPortIndex=ds90LPortIndex, db90BadHelloLimit=db90BadHelloLimit, ds90LSessionIndex=ds90LSessionIndex, ds90LSessionPort=ds90LSessionPort, dh90SlotSecondarySpecific=dh90SlotSecondarySpecific, dbIfBadFramesReceived=dbIfBadFramesReceived, ds90LPrompt=ds90LPrompt, db90IfIndex=db90IfIndex, ds90LSessionRemoteNode=ds90LSessionRemoteNode, db90Coun=db90Coun, drpt90PortAddrEntry=drpt90PortAddrEntry, ds90LPortAutoConfigure=ds90LPortAutoConfigure, da90CommunityIndex=da90CommunityIndex, dh90Backplane=dh90Backplane, db90MgmtHeardPort=db90MgmtHeardPort, db90IfEthIndex=db90IfEthIndex, db90IfSpBadHelloCount=db90IfSpBadHelloCount, db90TopologyChangeFlag=db90TopologyChangeFlag, db90IfSpDesigRootAge=db90IfSpDesigRootAge, dbSysStatus=dbSysStatus, da90CommunityEntry=da90CommunityEntry)

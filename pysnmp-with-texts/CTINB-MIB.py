#
# PySNMP MIB module CTINB-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTINB-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:29:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ctINBinfo, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctINBinfo")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, ObjectIdentity, MibIdentifier, IpAddress, Integer32, Gauge32, Counter32, iso, Unsigned32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, TimeTicks, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "ObjectIdentity", "MibIdentifier", "IpAddress", "Integer32", "Gauge32", "Counter32", "iso", "Unsigned32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "TimeTicks", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
inbMonarchSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1))
inbMonarchSystemTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1), )
if mibBuilder.loadTexts: inbMonarchSystemTable.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchSystemTable.setDescription('')
inbMonarchSystemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1), ).setIndexNames((0, "CTINB-MIB", "inbMonarchINB"))
if mibBuilder.loadTexts: inbMonarchSystemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchSystemEntry.setDescription('')
inbMonarchSystemINB = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbA", 1), ("inbB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchSystemINB.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchSystemINB.setDescription("Two physical INB's may exist on a module. This object distinquishes which INB, INB-A or INB-B.")
inbMonarchStatusTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchStatusTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchStatusTimeStamp.setDescription('This object represents the value of sysUptime when the Monarch last changed.')
inbMonarchBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchBandwidth.setDescription('The bandwidth of this INB in Megabits.')
inbMonarchTDMSlotMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("userPolicy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inbMonarchTDMSlotMode.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTDMSlotMode.setDescription('The automatic TDM mode overides any preset TDM allocation. All boards get an equal number of pre-allocated TDM slots, adding up to 100% of total INB bandwidth, and have Round Robin enabled. The automatic mode will, in effect, provide each board with a 1/(number of boards) minimum guarantee INB bandwidth. The userPolicy mode will have the per board policy enforced. Each board will have a level of service (TDM slots, Round Robin arbitration from the inbMonarchTable) associated with it to take effect when this object is set to user_policy. Newly inserted boards will default to Round Robin and share the remaining fixed INB bandwidth (inbMonarchTDMSlotTotal - inbMonarchTDMSlotActual).')
inbMonarchTDMSlotTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchTDMSlotTotal.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTDMSlotTotal.setDescription('This object represents the total possible number of INB backplane TDM slots.')
inbMonarchSystemTDMSlotActual = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchSystemTDMSlotActual.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchSystemTDMSlotActual.setDescription('This object represents the total number of allocated INB backplane TDM slots. This is the sum of all instances of inbMonarchTDMSlotRequest in userPolicy mode. In automatic mode this number would represent the number of inserted boards.')
inbMonarchTDMSlotbandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchTDMSlotbandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTDMSlotbandwidth.setDescription('This object represents the bandwidth in bits that each slot represents on the backplane.')
inbMonarch = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2))
inbMonarchTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1), )
if mibBuilder.loadTexts: inbMonarchTable.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTable.setDescription('')
inbMonarchEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1), ).setIndexNames((0, "CTINB-MIB", "inbMonarchSlot"), (0, "CTINB-MIB", "inbMonarchINB"))
if mibBuilder.loadTexts: inbMonarchEntry.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchEntry.setDescription('')
inbMonarchSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchSlot.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchSlot.setDescription('The slot number containing this module.')
inbMonarchINB = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbA", 1), ("inbB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchINB.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchINB.setDescription('Two physical INB interfaces may exist on a module. This object distinquishes which INB, INB-A or INB-B.')
inbMonarchStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standBy", 1), ("sysUndefined", 2), ("operational", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchStatus.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchStatus.setDescription('Application state of the monarch application on this module. Standby - indicates this module is not the monarch but can be. SysUndefined - indicates this module can not be monarch. Operational - says this module is the monarch. ')
inbMonarchLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchLinkStatus.setDescription('This object describes the state of the backplane. LinkUp is when this INB detects the clock on the backplane. LinkDown is when no backplane clock has been detected.')
inbMonarchLinkCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchLinkCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchLinkCapacity.setDescription('The bandwidth capacity of this board in Megabytes.')
inbMonarchTDMSlotRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inbMonarchTDMSlotRequest.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTDMSlotRequest.setDescription('This object is the number of fixed TDM slots requested for this board . NOTE: new request will take effect the next time the inbMonarchTDMSlotMode object is set to userPolicy. NOTE: this value has no meaning when the inbMonarchTDMSlotMode is automatic.')
inbMonarchTDMSlotActual = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: inbMonarchTDMSlotActual.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchTDMSlotActual.setDescription('This object is the actual number of fixed TDM slots given to this board. In automatic mode, this value is the total number of slots divided by the number of inserted boards, in userPolicy mode, this reflects the inbMonarchTDMSlotRequest value at the last time the chassis entered userPolicy mode.')
inbMonarchRoundRobinControl = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbMonarchRoundRobinControl.setStatus('mandatory')
if mibBuilder.loadTexts: inbMonarchRoundRobinControl.setDescription('This object enables or disable this INB the ability to participate in the Round Robin arbitration phase.')
inbStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3))
inbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1), )
if mibBuilder.loadTexts: inbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsTable.setDescription('')
inbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1), ).setIndexNames((0, "CTINB-MIB", "inbStatsSlot"), (0, "CTINB-MIB", "inbStatsINB"))
if mibBuilder.loadTexts: inbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsEntry.setDescription('')
inbStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsSlot.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsSlot.setDescription('The slot number containing this module.')
inbStatsINB = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbA", 1), ("inbB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsINB.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsINB.setDescription('Two physical INB interfaces may exist on a module. This object distinquishes which INB, INB-A or INB-B.')
inbStatsIfindex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsIfindex.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsIfindex.setDescription('The interface number of the INB. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifIndex object defined in RFC 1213.')
inbStatsUniCastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsUniCastCells.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsUniCastCells.setDescription('Number of UniCast INB cells received from the backplane.')
inbStatsMultiCastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsMultiCastCells.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsMultiCastCells.setDescription('Number of multi-cast INB cells received from the backplane.')
inbStatsBroadCastCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsBroadCastCells.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsBroadCastCells.setDescription('Number of broadcast INB cells received from the backplane.')
inbStatsXmitCells = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsXmitCells.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsXmitCells.setDescription('Number of INB cells transmitted to the backplane.')
inbStatsRecvSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsRecvSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsRecvSeqErrs.setDescription('Number of pkts with sequence errors received from the backplane.')
inbStatsRecvChksumErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsRecvChksumErrs.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsRecvChksumErrs.setDescription('Number of pkts with checksum errors received from the backplane.')
inbStatsxmitToFps = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsxmitToFps.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsxmitToFps.setDescription('Number of transmit errors to FPS.')
inbStatsToFpsDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsToFpsDrops.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsToFpsDrops.setDescription('INBC receive fifo full count. This represents the number of cells that were not forwarded to the FPS.')
inbStatsFromInbErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsFromInbErrs.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsFromInbErrs.setDescription('Number of INB receive errors from the backplane. This includes FPSC xmit errors(inbStatsxmitToFps), INBC receive sequence errors (inbStatsRecvSeqErrs) and INBC checksum errors(inbStatsRecvChksumErrs).')
inbStatsToINBDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsToINBDrops.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsToINBDrops.setDescription('Number of FPSC recv frame drop count. This represents the number of frames that were not sent out on the INB backplane.')
inbStatsToInbErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 12, 1, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: inbStatsToInbErrs.setStatus('mandatory')
if mibBuilder.loadTexts: inbStatsToInbErrs.setDescription('Number of INB backplane transmit errors. This includes FPSC receive timeout errors')
mibBuilder.exportSymbols("CTINB-MIB", inbMonarchSystem=inbMonarchSystem, inbMonarchSystemTDMSlotActual=inbMonarchSystemTDMSlotActual, inbMonarchTDMSlotbandwidth=inbMonarchTDMSlotbandwidth, inbStats=inbStats, inbStatsSlot=inbStatsSlot, inbMonarchEntry=inbMonarchEntry, inbStatsToINBDrops=inbStatsToINBDrops, inbMonarchStatusTimeStamp=inbMonarchStatusTimeStamp, inbMonarchINB=inbMonarchINB, inbMonarchTDMSlotMode=inbMonarchTDMSlotMode, inbStatsFromInbErrs=inbStatsFromInbErrs, inbMonarchTDMSlotActual=inbMonarchTDMSlotActual, inbStatsRecvSeqErrs=inbStatsRecvSeqErrs, inbStatsRecvChksumErrs=inbStatsRecvChksumErrs, inbMonarch=inbMonarch, inbStatsxmitToFps=inbStatsxmitToFps, inbMonarchSlot=inbMonarchSlot, inbStatsINB=inbStatsINB, inbStatsUniCastCells=inbStatsUniCastCells, inbStatsIfindex=inbStatsIfindex, inbMonarchTDMSlotRequest=inbMonarchTDMSlotRequest, inbStatsTable=inbStatsTable, inbStatsToFpsDrops=inbStatsToFpsDrops, inbMonarchSystemTable=inbMonarchSystemTable, inbMonarchTDMSlotTotal=inbMonarchTDMSlotTotal, inbStatsBroadCastCells=inbStatsBroadCastCells, inbMonarchRoundRobinControl=inbMonarchRoundRobinControl, inbStatsToInbErrs=inbStatsToInbErrs, inbMonarchStatus=inbMonarchStatus, inbMonarchLinkStatus=inbMonarchLinkStatus, inbStatsEntry=inbStatsEntry, inbStatsMultiCastCells=inbStatsMultiCastCells, inbStatsXmitCells=inbStatsXmitCells, inbMonarchTable=inbMonarchTable, inbMonarchSystemINB=inbMonarchSystemINB, inbMonarchLinkCapacity=inbMonarchLinkCapacity, inbMonarchBandwidth=inbMonarchBandwidth, inbMonarchSystemEntry=inbMonarchSystemEntry)

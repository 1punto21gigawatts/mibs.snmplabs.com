#
# PySNMP MIB module CLJ8550-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CLJ8550-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:25:06 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Integer32, Counter64, iso, MibIdentifier, NotificationType, Bits, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Unsigned32, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Integer32", "Counter64", "iso", "MibIdentifier", "NotificationType", "Bits", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Unsigned32", "Counter32", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
dm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2))
class DisplayString(OctetString):
    pass

device = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1))
settings_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1)).setLabel("settings-system")
status_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2)).setLabel("status-system")
background_message = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37)).setLabel("background-message")
background_message1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 1)).setLabel("background-message1")
background_message2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 2)).setLabel("background-message2")
id = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4))
simm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1))
simm1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1))
simm2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2))
simm3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 3))
simm4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 4))
simm5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 5))
simm6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 6))
simm7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 7))
simm8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 8))
mio = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3))
mio1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1))
mio2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 2))
phd = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5))
phd1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 1))
phd2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2))
phd3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 3))
phd4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 4))
phd5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 5))
phd6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 6))
test = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5))
job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6))
settings_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1)).setLabel("settings-job")
active_print_jobs = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2)).setLabel("active-print-jobs")
job_being_parsed = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1)).setLabel("job-being-parsed")
job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5)).setLabel("job-info")
job_info_attribute = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23)).setLabel("job-info-attribute")
held_job = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7)).setLabel("held-job")
held_job_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1)).setLabel("held-job-info")
held_job_control = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2)).setLabel("held-job-control")
file_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10)).setLabel("file-system")
settings_file_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1)).setLabel("settings-file-system")
status_file_system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2)).setLabel("status-file-system")
file_systems = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3)).setLabel("file-systems")
file_system2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 2)).setLabel("file-system2")
errorlog = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11))
error1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1))
error2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2))
error3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3))
error4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4))
error5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5))
error6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6))
error7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7))
error8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8))
error9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9))
error10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10))
error11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11))
error12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12))
error13 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13))
error14 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14))
error15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15))
error16 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16))
error17 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17))
error18 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18))
error19 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19))
error20 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20))
error21 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21))
error22 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22))
error23 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23))
error24 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24))
error25 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25))
error26 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26))
error27 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27))
error28 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28))
error29 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29))
error30 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30))
error31 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31))
error32 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32))
error33 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33))
error34 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34))
error35 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35))
error36 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36))
error37 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37))
error38 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38))
error39 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39))
error40 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40))
error41 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41))
error42 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42))
error43 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43))
error44 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44))
error45 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45))
error46 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46))
error47 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47))
error48 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48))
error49 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49))
error50 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50))
remote_procedure_call = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13)).setLabel("remote-procedure-call")
settings_rpc = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 1)).setLabel("settings-rpc")
status_rpc = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2)).setLabel("status-rpc")
rpc_services = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3)).setLabel("rpc-services")
nfs_server = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2)).setLabel("nfs-server")
settings_nfs_server = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 1)).setLabel("settings-nfs-server")
status_nfs_server = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 2)).setLabel("status-nfs-server")
rpc_bind = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3)).setLabel("rpc-bind")
settings_rpc_bind = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3, 1)).setLabel("settings-rpc-bind")
status_rpc_bind = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3, 2)).setLabel("status-rpc-bind")
xport_interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 14)).setLabel("xport-interface")
status_xip = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 14, 2)).setLabel("status-xip")
source_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2)).setLabel("source-subsystem")
io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1))
settings_io = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1)).setLabel("settings-io")
ports = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3))
port1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1))
processing_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3)).setLabel("processing-subsystem")
pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3))
settings_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1)).setLabel("settings-pdl")
status_pdl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2)).setLabel("status-pdl")
pdl_pcl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3)).setLabel("pdl-pcl")
pdl_postscript = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4)).setLabel("pdl-postscript")
pjl = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5))
jetsend_proc_sub = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8)).setLabel("jetsend-proc-sub")
settings_jetsend = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 1)).setLabel("settings-jetsend")
jetsend_contact = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 3)).setLabel("jetsend-contact")
settings_jetsend_contact = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 3, 1)).setLabel("settings-jetsend-contact")
destination_subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4)).setLabel("destination-subsystem")
print_engine = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1)).setLabel("print-engine")
status_prt_eng = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2)).setLabel("status-prt-eng")
intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3))
settings_intray = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1)).setLabel("settings-intray")
intrays = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3))
intray1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1))
intray2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2))
intray3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3))
intray4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 4))
intray5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 5))
outbin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4))
settings_outbin = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 1)).setLabel("settings-outbin")
outbins = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3))
outbin1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1))
outbin2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2))
outbin3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3))
outbin4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4))
outbin5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5))
outbin6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 6))
outbin7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 7))
outbin8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 8))
outbin9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 9))
outbin10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 10))
outbin11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 11))
marking_agent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 5)).setLabel("marking-agent")
settings_marking_agent = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 5, 1)).setLabel("settings-marking-agent")
imaging = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6))
ph = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7))
ph_devices = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3)).setLabel("ph-devices")
ph2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 2))
ph3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 3))
print_media = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8)).setLabel("print-media")
settings_print_media = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 1)).setLabel("settings-print-media")
media_info = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3)).setLabel("media-info")
media1 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1))
media2 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2))
media3 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3))
media4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4))
media5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5))
media6 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6))
media7 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7))
media8 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8))
media9 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9))
media10 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10))
media11 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11))
media12 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12))
media13 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13))
media14 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14))
media15 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15))
tables = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7))
channel_table = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2)).setLabel("channel-table")
channel_entry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1)).setLabel("channel-entry")
resource_manager = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12)).setLabel("resource-manager")
mass_storage_resources = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3)).setLabel("mass-storage-resources")
hrm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3))
hrDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3))
hrDiskStorageTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6))
hrDiskStorageEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6, 1))
hrPartitionTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7))
hrPartitionEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1))
hrFSTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8))
hrFSEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1))
hrStorage = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2))
hrStorageTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3))
hrStorageEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1))
hrDeviceTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2))
hrDeviceEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1))
hrPrinterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5))
hrPrinterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1))
channel = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6))
channelTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3))
channelEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1))
print_engine_test = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 9)).setLabel("print-engine-test")
printmib = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2))
prtGeneral = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5))
prtGeneralTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1))
prtGeneralEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1))
prtCover = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6))
prtCoverTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1))
prtCoverEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1))
prtLocalization = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7))
prtLocalizationTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1))
prtLocalizationEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1))
prtStorageRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2))
prtStorageRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1))
prtDeviceRefTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3))
prtDeviceRefEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1))
prtInput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8))
prtInputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2))
prtInputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1))
prtOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9))
prtOutputTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2))
prtOutputEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1))
prtMarker = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10))
prtMarkerTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2))
prtMarkerEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1))
prtMarkerSupplies = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11))
prtMarkerSuppliesTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1))
prtMarkerSuppliesEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1))
prtMediaPath = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13))
prtMediaPathTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4))
prtMediaPathEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1))
prtChannel = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14))
prtChannelTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1))
prtChannelEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1))
prtInterpreter = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15))
prtInterpreterTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1))
prtInterpreterEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1))
prtConsoleDisplayBuffer = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16))
prtConsoleDisplayBufferTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5))
prtConsoleDisplayBufferEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1))
prtConsoleLights = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17))
prtConsoleLightTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6))
prtConsoleLightEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1))
prtAlert = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18))
prtAlertTable = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1))
prtAlertEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1))
energy_star = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 1), Integer32()).setLabel("energy-star").setMaxAccess("readwrite")
if mibBuilder.loadTexts: energy_star.setStatus('optional')
if mibBuilder.loadTexts: energy_star.setDescription('Returns or changes the Energy Star sleep value. If the value is greater than zero, then the device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. A value of zero means Energy Star is disabled and the device will not go to sleep based on print engine idle time. The value must be non-negative. Additional information: Returns or changes the Energy Star sleep value. The device will go into energy saving sleep mode after the print engine has been idle for the number of seconds specified by this object. Color LaserJet8550 supports values of 10, 1800, 3600, 10800, 28800. Setting to an unsupported value causes the printer to substitute a value (listed below) and to return <noError> status. The values for normal operation are as follow: >=0 and <= 15 snap to 10 >= 16 and <= 2699 snap to 1800 (30 minutes) >= 2700 and <= 5399 snap to 3600 (60 minutes) >= 5400 and <= 16199 snap to 10800 (180 minutes) >= 16200 snap to 28800 (480 minutes) ')
sleep_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eFalse", 1), ("eTrue", 2)))).setLabel("sleep-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: sleep_mode.setStatus('optional')
if mibBuilder.loadTexts: sleep_mode.setDescription("Returns eTrue if the device is in energy saving sleep mode, otherwise returns eFalse. Setting SLEEP-MODE to eFalse causes the device to wake up, if it is in sleep mode. Setting SLEEP-MODE to eTrue causes the device to go into sleep mode. Additional information: Setting SLEEP-MODE to eTrue causes the device to go into sleep mode. Setting this object to eTrue while printer is awake will not change the printer's current state and will return <genErr> status. Setting this object to eTrue while printer is already in the Sleep Mode will not change the printer's current state and will return <noError> status. Setting this object to eFalse while the printer is asleep causes the device to wake up. Setting eFalse while printer is already awake will not change the printer's current state and will return <noError> status.")
on_off_line = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("eOnline", 1), ("eOffline", 2), ("eOfflineAtEndOfJob", 3)))).setLabel("on-off-line").setMaxAccess("readwrite")
if mibBuilder.loadTexts: on_off_line.setStatus('optional')
if mibBuilder.loadTexts: on_off_line.setDescription("To bring the PDL processing sub-system on or off line. If the device is a printer, then the printer does not process print job data when the printer is off line. PML communication persists. Additional information: When the printer is in the Offline state, printing will stop as soon as possible (no more sheets of media are pulled from input trays). All I/O communication continues (no change from the Online state). Setting to eOnline has the following affect: Printer will immediately go to or remain in the Online state; <noError> status is returned. If the printer's current state is Offline with a pending error condition that prevents the printer from going to the Online state, the printer will remain in the Offline state; <genErr> status is returned. Setting to eOffline has the following affect: Printer will immediately go to or remain in the Offline state; <noError> status is returned. If pages are being printed, those pages will complete with the printer in the Offline state. Setting to eOfflineAtEndOfJob has the following affect: If not in a job or already in the Offline state, the printer will immediately go to or remain in the Offline state; <noError> status is returned. If printing and the current state is Online, the printer will remain in the Online state, with the value of this object as eOfflineAtEndOfJob, until the end of the job; <noError> status is returned. At the end of the job, the printer goes to the Offline state and the value of this object becomes eOffline. During the eOffine state, the printer will still rip and process jobs. Setting this object to eOffline or eOnline before the end of the job causes the action for that value to be taken immediately.")
pysmi_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eInitiateAction", 1)))).setLabel("continue").setMaxAccess("writeonly")
if mibBuilder.loadTexts: pysmi_continue.setStatus('optional')
if mibBuilder.loadTexts: pysmi_continue.setDescription("A device can support a class of errors called continuable errors. When a continuable error is encountered, the device requires a continue event to occur before the device will continue operation. One continue event is setting the CONTINUE object to eInitiateAction. Devices can support other continue events, like auto-continue. A continue event causes the continuable error to be acknowledged, thus allowing the device to continue. Each device needs to list the continuable errors. If the device doesn't currently have an unacknowledged continuable error, the response will contain <genErr>. Additional information: Since Color LaserJet8550 does not have a CONTINUE key, the GO key is used to perform the continue operation at the control panel.")
auto_continue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eOn", 2)))).setLabel("auto-continue").setMaxAccess("readonly")
if mibBuilder.loadTexts: auto_continue.setStatus('optional')
if mibBuilder.loadTexts: auto_continue.setDescription('Indicates if the device will automatically continue after encountering a continuable error. If AUTO- CONTINUE is set to eOn, the device will automatically generate continue event to acknowledge continuable errors. If AUTO-CONTINUE is set to eOff, then some other continue event will have to acknowledge the continuable error. Additional information: Indicates if the device will automatically continue after encountering a continuable error. If AUTO-CONTINUE is set to eOn (AUTO-CONTINUE is always on for Color LaserJet8550), the device will automatically generate continue event to acknowledge continuable errors.')
job_input_auto_continue_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 3600))).setLabel("job-input-auto-continue-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_timeout.setDescription('The number of seconds the device waits after a job related continuable error occurs before automatically continuing. An example job related continuable error is the job requesting a media size that is not available. After the timeout expires, the device will continue processing the job as if a continue event occurred, such as the front panel continue key being pressed. If the value is -1, the device does not automatically continue after a job related continuable error occurs. If the value is 0, the device immediately continues. If the value is greater than 0, the value represents the timeout value in seconds. Additional information: This object is used only for media requests (size and/or name). Color LaserJet8550 supports any value in the range of -1 to 3600. Setting to a value outside of that range causes the printer to substitute a value (listed below) and to return <noError> status. The values are as follow: <-1 snaps to -1 >3600 snaps to 3600 (60 minutes) The action that occurs when this timeout expires is explained by JOB-INPUT-AUTO-CONTINUE-MODE. It is not the same as the CONTINUE object being set to eInitiateAction or the Go key being pressed on the control panel. See the CONTINUE object description for information on the actions that occur for those conditions.')
job_input_auto_continue_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 36), OctetString()).setLabel("job-input-auto-continue-mode").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_input_auto_continue_mode.setStatus('optional')
if mibBuilder.loadTexts: job_input_auto_continue_mode.setDescription('Returns or sets the device behavior when the desired media is not currently available. cCancelJob - The device cancels the job. The device POS should explain what happens if this item is not the only item in the collection. cAutoMediaSizeOverride - The device is allowed to substitute a different size media. cAutoMediaNameOverride - The device is allowed to substitute a different media name. cUSMediaSizeOverride The device is allowed to substitute US media sizes (letter, etc.) for ISO media sizes (A4, etc.). cISOMediaSizeOverride The device is allowed to substitute ISO media sizes (A4, etc.) for US media sizes (letter, etc.). Additional information: This object applies to all media requests, including Manual Feed Requests. This object describes the action that is performed when the JOB-INPUT-AUTO-CONTINUE-TIMEOUT expires. The action performed by the CONTINUE object being set to eInitiateAction or the Go key being pressed on the control panel may cause different actions. See the CONTINUE object description for information on the actions that occur for those conditions.')
background_status_msg_line1_part1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setLabel("background-status-msg-line1-part1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: background_status_msg_line1_part1.setStatus('optional')
if mibBuilder.loadTexts: background_status_msg_line1_part1.setDescription("The string displayed on the device's front panel in place of the printer's built-in background status string. An example built-in background status string is '00 READY'. Additional information: The display size for the Color LaserJet8550 printer is 2 by 16. The value of this object is displayed on the first line and the value of BACKGROUND-STATUS-MSG-LINE2-PART1 is displayed on the second line of the display. Each object must be set independently. If line 2 has been set, and the next message to be displayed only requires line 1, BACKGROUND-STATUS-MSG-LINE2-PART1 must be set to the null string to clear it. This object allows a message to be displayed when it is the highest priority message waiting to be displayed. Setting this object does not guarantee the message will be displayed; and reading it returns the value last written, not the currently displayed message. The priority assigned for displaying this message is one lower than the PJL RDYMSG. To clear the message, write a null string to both this object and BACKGROUND-STATUS-MSG-LINE2-PART1. While the object prtConsoleLocalization controls the localization and symbol set usage of printer generated messages, this object's message is displayed using the symbol set (note: The default symbol set is Roman-8 for HP - EFI may vary) specified with the string. The default symbol set is Roman-8; additional legal symbol sets are ISOLatin5, ISOLatin2, HalfWidthKatakana, and ISOLatinCyrillic. When either BACKGROUND-STATUS-MSG-LINE1-PART1 or BACKGROUND-STATUS-MSG-LINE2-PART1 contains a non-null value, both will be displayed.")
background_status_msg_line2_part1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 37, 2, 1), DisplayString()).setLabel("background-status-msg-line2-part1").setMaxAccess("readwrite")
if mibBuilder.loadTexts: background_status_msg_line2_part1.setStatus('optional')
if mibBuilder.loadTexts: background_status_msg_line2_part1.setDescription("The string displayed on the device's front panel in place of the printer's built-in background status string. An example built-in background status string is '00 READY'. Additional information: See BACKGROUND-STATUS-MSG-LINE1-PART1")
error_log_clear = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eClearErrorLog", 1)))).setLabel("error-log-clear").setMaxAccess("writeonly")
if mibBuilder.loadTexts: error_log_clear.setStatus('optional')
if mibBuilder.loadTexts: error_log_clear.setDescription('Setting this object clears all the entries in the error log sub-tree.')
job_output_auto_continue_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 3600))).setLabel("job-output-auto-continue-timeout").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_output_auto_continue_timeout.setStatus('optional')
if mibBuilder.loadTexts: job_output_auto_continue_timeout.setDescription('Returns or sets the time that the printer will wait after an output bin becomes full and the printer is trying to deliver a sheet of media to that output bin. When the timeout expires, the job is processed according to the OUTBINn-OVERRIDE-MODE. A value of -1 indicates that the printer will wait for a continue event. A non- negative value is the number of seconds to wait. Additional information: Returns the time that the printer will wait after an output bin becomes full and the printer is trying to deliver a sheet of media to that output bin. A value of -1 indicates that the printer will wait for a continue event.')
collated_originals_support = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 42), OctetString()).setLabel("collated-originals-support").setMaxAccess("readonly")
if mibBuilder.loadTexts: collated_originals_support.setStatus('optional')
if mibBuilder.loadTexts: collated_originals_support.setDescription("Indicates that the printer can create multiple, collated 'originals' of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or 'mopies'. This is the base functionality required by the other collection items. cProofAndHold - The printer saves a copy of the job while printing the first mopy. Later, this held job can be released and the rest of the mopies will print. cSecurityPrint - The printer spools the job and holds the job until the user releases the job by entering a password at the printer's control panel. cAutoHighlight - The printer prints the job a number of times with a mail distribution list prepended to each job. A different mailing address is highlighted on each mopy. cCollatedAtSpeed - The printer can create multiple collated copies where all copies after the original are printed at engine speed. Additional information: Indicates that the printer can create multiple, collated originals of a job and shows the level of support for this capability. cCollatedOriginals - The printer can create multiple collated originals, or mopies. This is the base functionality required by the other collection items. None of them are supported by Color LaserJet8550. Without disk, this object will not exist. This will be set at boot-up initialization. If the disk fails, in any way, then the disk error functionality will handle the situation. Note: Proof and print is not supported via PML.")
localization_languages_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 52), DisplayString()).setLabel("localization-languages-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: localization_languages_supported.setStatus('optional')
if mibBuilder.loadTexts: localization_languages_supported.setDescription('The list of languages supported by the device. The languages are primarily, but not limited to, two character codes from ISO 639, each separated by a comma character. Additional information: This string will always be in the Roman-8 character set. See prtLocalizationLanguage for details about each language value.')
localization_countries_supported = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 2, 53), DisplayString()).setLabel("localization-countries-supported").setMaxAccess("readonly")
if mibBuilder.loadTexts: localization_countries_supported.setStatus('optional')
if mibBuilder.loadTexts: localization_countries_supported.setDescription('The list of countries supported by the device. The countries are primarily, but not limited to, two character codes from ISO 3166, each separated by a comma character. Additional information: ')
model_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 1), DisplayString()).setLabel("model-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_number.setStatus('optional')
if mibBuilder.loadTexts: model_number.setDescription('Identifies the device model number as listed in the HP corporate price list (e.g. C2121A for DeskJet 500C). The string is as specific as possible. Products should note in POS if the model number on the CPL changes but the device reports the previous model number. If the model number changes based on the installed options, the POS should indicate if only the base model number is returned, or if the device senses the installed options and returns the correct model number. If possible, encode the model number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: The value of this object does not change based on the installed options.')
model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 2), DisplayString()).setLabel("model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: model_name.setStatus('optional')
if mibBuilder.loadTexts: model_name.setDescription("Identifies the device model name (e.g. ''DeskJet 1200C''). The string is as specific as possible. Capitalization and spacing should match family naming conventions. Products should note in POS if the model name on the HP corporate price list changes but the device reports the previous device name. If the model name changes based on the installed options, the POS should indicate if only the base model name is returned, or if the device senses the installed options and returns the correct model name. If possible, encode the model name in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: The value of this object does not change based on the installed options. Since the value of this object is frequently used in displaying a list of printers, it is kept relatively short in case systems have limited width for their display area.")
serial_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 3), DisplayString()).setLabel("serial-number").setMaxAccess("readonly")
if mibBuilder.loadTexts: serial_number.setStatus('optional')
if mibBuilder.loadTexts: serial_number.setDescription('Identifies the serial number for the device. If the SERIAL-NUMBER object is set by the user, then setting the object does not need to be protected. If the SERIAL-NUMBER object is set at the factory, then the SERVICE-PASSWORD object must be set correctly before the SERIAL-NUMBER object is writable. If this is a writable object, the POS should indicate the maximum supported string length. If possible, encode the serial number in a symbol set (like Roman-8) that matches the ASCII character set and limit the characters used to ASCII characters. Additional information: This value is affected by NVRAM resets, it is set to the default value of S4601LXXXXX, when a NVRAM init is done. This object is read-only so the SERVICE-PASSWORD object is not used.')
device_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 10), DisplayString()).setLabel("device-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_name.setStatus('optional')
if mibBuilder.loadTexts: device_name.setDescription('User defined device name. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 32 characters. If the user entered string is too long, the device will store the first 32 characters and will return the <noError> status.')
device_location = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 11), DisplayString()).setLabel("device-location").setMaxAccess("readwrite")
if mibBuilder.loadTexts: device_location.setStatus('optional')
if mibBuilder.loadTexts: device_location.setDescription('User defined device location. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 16 characters. If the user entered string is too long, the device will store the first 16 characters and will return the <noError> status. This object is saved in NVRAM.')
asset_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 3, 12), DisplayString()).setLabel("asset-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: asset_number.setStatus('optional')
if mibBuilder.loadTexts: asset_number.setDescription('User defined asset number. The POS should indicate the maximum supported string length. If the user entered string is too long, the device will store as much as possible and will return the <noError>. Additional information: The maximum supported string length is 8 characters. If the user entered string is too long, the device will store the first 8 characters and will return the <noError> status. This object is saved in NVRAM.')
simm1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_type.setStatus('optional')
if mibBuilder.loadTexts: simm1_type.setDescription("Returns an indication of the type of option installed in SIMM slot 1. eEmpty means the device did not detect any option installed in the interface slot. eUnknown means the device doesn't recognize the installed option. eUnSupported means the device recognizes the installed option, but does not support the option. eReadOnlyMemory means the installed option contains ROM Ics. eVolatileRandomAccessMemory means the installed option contains RAM ICs that loose data when the power is turned off. eNonVolatileRandomAccessMemory means that the installed option contains RAM ICs that do not loose data when the power is turned off. eFlashMemory means that the installed option contains a type of non-volatile RAM that needs to be erased before it can be written. eDiskDrive means the installed option contains a disk drive. eRamRom means the installed option contains both volatile random access memory and read only memory. eInputPHD means the installed option is an input paper handling device. eOutputPHD means the installed option is an output paper handling device. eIOCard means the installed option is an I/O card. Additional information: Returns an indication of the type of option installed in SIMM slot 1. eEmpty means the device did not detect any option installed in the interface slot. eUnknown means the device doesn't recognize the installed option. eUnSupported means the device recognizes the installed option, but does not support the option. eReadOnlyMemory means the installed option contains ROMICs. eVolatileRandomAccessMemory means the installed option contains RAM ICs that loose data when the power is turned off.")
simm1_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 1, 5), Integer32()).setLabel("simm1-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm1_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm1_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 1. The capacity is dependent on the type of option, as indicated by the SIMM1-TYPE object. This object has no meaning if the installed option type is eUnknown or eReadOnlyMemory. This object contains the size, in bytes, if the installed option type is eVolatileRandomAccessMemory, eNonVolatileRandomAccessMemory, eFlashMemory, or eDiskDrive. If the type of the installed option is eRamRom, this object contains the size, in bytes, of the random access memory. If the type of the installed option is eInputPHD, the capacity indicates the number of input trays supported by the installed option. If the type of the installed option is eOutputPHD, the capacity indicates the number of output bins supported by the installed option. If the type of the installed option is eIOCard, the capacity indicates the number of logical I/O ports supported by the I/O card. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM1-TYPE type is eVolatileRandomAccessMemory.')
simm2_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm2-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm2_type.setStatus('optional')
if mibBuilder.loadTexts: simm2_type.setDescription('Returns an indication of the type of option installed in SIMM slot 2. See SIMM1-TYPE for a description.')
simm2_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 2, 5), Integer32()).setLabel("simm2-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm2_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm2_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 2. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM2-TYPE type is eVolatileRandomAccessMemory.')
simm3_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm3-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm3_type.setStatus('optional')
if mibBuilder.loadTexts: simm3_type.setDescription('Returns an indication of the type of option installed in SIMM slot 3. See SIMM1-TYPE for a description.')
simm3_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 3, 5), Integer32()).setLabel("simm3-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm3_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm3_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 3. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM3-TYPE type is eVolatileRandomAccessMemory.')
simm4_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm4-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm4_type.setStatus('optional')
if mibBuilder.loadTexts: simm4_type.setDescription('Returns an indication of the type of option installed in SIMM slot 4. See SIMM1-TYPE for a description.')
simm4_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 4, 5), Integer32()).setLabel("simm4-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm4_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm4_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 4. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM4-TYPE type is eVolatileRandomAccessMemory.')
simm5_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm5-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm5_type.setStatus('optional')
if mibBuilder.loadTexts: simm5_type.setDescription('Returns an indication of the type of option installed in SIMM slot 5. See SIMM1-TYPE for a description.')
simm5_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 5, 5), Integer32()).setLabel("simm5-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm5_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm5_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 5. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM5-TYPE type is eVolatileRandomAccessMemory.')
simm6_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 6, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm6-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm6_type.setStatus('optional')
if mibBuilder.loadTexts: simm6_type.setDescription('Returns an indication of the type of option installed in SIMM slot 6. See SIMM1-TYPE for a description.')
simm6_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 6, 5), Integer32()).setLabel("simm6-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm6_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm6_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 6. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM6-TYPE type is eVolatileRandomAccessMemory.')
simm7_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm7-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm7_type.setStatus('optional')
if mibBuilder.loadTexts: simm7_type.setDescription('Returns an indication of the type of option installed in SIMM slot 7. See SIMM1-TYPE for a description.')
simm7_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 7, 5), Integer32()).setLabel("simm7-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm7_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm7_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 7. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM7-TYPE type is eVolatileRandomAccessMemory.')
simm8_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eReadOnlyMemory", 4), ("eVolatileRandomAccessMemory", 5)))).setLabel("simm8-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm8_type.setStatus('optional')
if mibBuilder.loadTexts: simm8_type.setDescription('Returns an indication of the type of option installed in SIMM slot 8. See SIMM1-TYPE for a description.')
simm8_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 1, 8, 5), Integer32()).setLabel("simm8-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: simm8_capacity.setStatus('optional')
if mibBuilder.loadTexts: simm8_capacity.setDescription('Returns an indication of the capacity of the SIMM installed in SIMM slot 8. See SIMM1-CAPACITY for a description. Additional information: Returns an indication of the capacity of the installed option in bytes. This object is not supported unless the SIMM8-TYPE type is eVolatileRandomAccessMemory.')
mio1_model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 2), DisplayString()).setLabel("mio1-model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_model_name.setStatus('optional')
if mibBuilder.loadTexts: mio1_model_name.setDescription('Returns product information identifying the I/O card. Example: XXXX')
mio1_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 3), DisplayString()).setLabel("mio1-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: mio1_manufacturing_info.setDescription('Returns information describing the manufacture of the I/O card installed in MIO/EIO slot 1. May include serial number and firmware revision. Additional information: The format of the string returned is determined by the manufacturer of the MIO card. There is no standard for content of the string. If no card is installed, a null string is returned.')
mio1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 12))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eDiskDrive", 8), ("eIOCard", 12)))).setLabel("mio1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio1_type.setStatus('optional')
if mibBuilder.loadTexts: mio1_type.setDescription('Returns an indication of the type of option installed in MIO/EIO slot 1. See SIMM1-TYPE for an explanation of the enumerations. Additional information: Returns an indication of the type of option installed in MIO/EIO slot 1. See SIMM1-TYPE for explanation of eEmpty, eUnknown, and eUnSupported. eDiskDrive means the installed option contains a disk drive. eIOCard means the installed option is an I/O card.')
mio2_model_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 2, 2), DisplayString()).setLabel("mio2-model-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio2_model_name.setStatus('optional')
if mibBuilder.loadTexts: mio2_model_name.setDescription('Returns product information identifying the I/O card. Example: XXXX')
mio2_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 2, 3), DisplayString()).setLabel("mio2-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio2_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: mio2_manufacturing_info.setDescription('Returns information describing the manufacture of the I/O card installed in MIO/EIO slot 2. May include serial number and firmware revision. Additional information: The format of the string returned is determined by the manufacturer of the MIO card. There is no standard for content of the string. If no card is installed, a null string is returned.')
mio2_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 3, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 8, 12))).clone(namedValues=NamedValues(("eEmpty", 1), ("eUnknown", 2), ("eUnSupported", 3), ("eDiskDrive", 8), ("eIOCard", 12)))).setLabel("mio2-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: mio2_type.setStatus('optional')
if mibBuilder.loadTexts: mio2_type.setDescription('Returns an indication of the type of option installed in MIO/EIO slot 2. See SIMM1-TYPE for an explanation of the enumerations. Additional information: Returns an indication of the type of option installed in MIO/EIO slot 2. See MIO1-TYPE for an explanation of the enumerations.')
phd1_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eEmpty", 1)))).setLabel("phd1-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd1_type.setStatus('optional')
if mibBuilder.loadTexts: phd1_type.setDescription("Returns an indication of the type of option installed as PHD 1. See SIMM1-TYPE for an explanation of the enumerations. Additional information: Color LaserJet8550 doesn't support envelope feeder but software reserves PHD1 for envelope feeder. All other PHD1 objects are removed.")
phd2_model = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 1), DisplayString()).setLabel("phd2-model").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_model.setStatus('optional')
if mibBuilder.loadTexts: phd2_model.setDescription('Returns product information identifying PHD device 2. Additional information: If at least one (1) external paper handling device is attached to the printer, then this object will exist. Not applicable if the value of PHD2-TYPE is eEmpty. Returns product information about the first paper handling device in the device chain.')
phd2_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 2), DisplayString()).setLabel("phd2-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: phd2_manufacturing_info.setDescription('Returns information describing the manufacture of PHD 2. May include serial number and firmware revision. Additional information: If at least one (1) external paper handling device is attached to the printer, then this object will exist. Not applicable if the value of PHD2-TYPE is eEmpty. This object returns the name of the manufacturer of the first paper handling device.')
phd2_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 11))).clone(namedValues=NamedValues(("eEmpty", 1), ("eInputPHD", 10), ("eOutputPHD", 11)))).setLabel("phd2-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_type.setStatus('optional')
if mibBuilder.loadTexts: phd2_type.setDescription('Returns an indication of the type of option installed in PHD interface 2. See SIMM1-TYPE for an explanation of the enumerations. Additional information: External paper handling devices are connected to the printer in a daisy-chained fashion. PHD2 refers to the first device that is connected. Returns eEmpty if no paper handling devices are installed. If the HCI is attached, the value will be eInputPHD. If the HCO is the first connected device, the value will be eOutputPHD.')
phd2_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 2, 4), Integer32()).setLabel("phd2-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_capacity.setStatus('optional')
if mibBuilder.loadTexts: phd2_capacity.setDescription('Returns an indication of the capacity of the installed option. See SIMM1-CAPACITY for an explanation of the meaning of the value of this object. Additional information: If at least one (1) external paper handling device (EPHD) is attached to the printer, then this object will exist. Not applicable if the value of PHD2-TYPE is eEmpty. This object returns the number of input trays or output bins, depending the device type (see PHD2-TYPE) for the first EPHD in the device chain.')
phd3_model = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 3, 1), DisplayString()).setLabel("phd3-model").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd3_model.setStatus('optional')
if mibBuilder.loadTexts: phd3_model.setDescription('Returns product information identifying PHD device 3. Additional information: If at least two (2) external paper handling devices are attached to the printer, then this object will exist. Not applicable if the value of PHD3-TYPE is eEmpty.')
phd3_manufacturing_info = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 3, 2), DisplayString()).setLabel("phd3-manufacturing-info").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd3_manufacturing_info.setStatus('optional')
if mibBuilder.loadTexts: phd3_manufacturing_info.setDescription('Returns information describing the manufacture of PHD 3. May include serial number and firmware revision. Additional information: If at least two (2) external paper handling devices are attached to the printer, then this object will exist. Not applicable if the value of PHD3-TYPE is eEmpty. This object returns the name of the manufacturer of the second paper handling device.')
phd3_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 11))).clone(namedValues=NamedValues(("eEmpty", 1), ("eInputPHD", 10), ("eOutputPHD", 11)))).setLabel("phd3-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd3_type.setStatus('optional')
if mibBuilder.loadTexts: phd3_type.setDescription('Returns an indication of the type of option installed in PHD interface 3. See SIMM1-TYPE for an explanation of the enumerations. Additional information: External paper handling devices are connected to the printer in a daisy-chained fashion. PHD3 refers to the second device that is connected. Returns eEmpty if no paper handling devices are installed. If the HCI is attached, the value will be eInputPHD. If the HCO is the second connected device, the value will be eOutputPHD.')
phd3_capacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 3, 4), Integer32()).setLabel("phd3-capacity").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd3_capacity.setStatus('optional')
if mibBuilder.loadTexts: phd3_capacity.setDescription('Returns an indication of the capacity of the installed option. See SIMM1-CAPACITY for an explanation of the meaning of the value of this object. Additional information: If at least two (2) external paper handling devices (EPHD) are attached to the printer, then this object will exist. Not applicable if the value of PHD3-TYPE is eEmpty. This object returns the number of input trays or output bins, depending the device type (see PHD3-TYPE) for the second EPHD in the device chain.')
phd4_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eEmpty", 1)))).setLabel("phd4-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd4_type.setStatus('optional')
if mibBuilder.loadTexts: phd4_type.setDescription('Returns an indication of the type of option installed in PHD interface 4. See SIMM1-TYPE for an explanation of the enumerations. Additional information: External paper handling devices are connected to the printer in a daisy-chained fashion. PHD4 refers to the third device that is connected. Returns the type of the third party device in this chain, otherwise, eEmpty if only tow paper handling devices are installed. At introduction, there is no planned configuration that would cause the value of this object to be anything other than eEmpty.')
phd5_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eEmpty", 1)))).setLabel("phd5-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd5_type.setStatus('optional')
if mibBuilder.loadTexts: phd5_type.setDescription('Returns an indication of the type of option installed in PHD interface 5. See SIMM1-TYPE for an explanation of the enumerations. Additional information: External paper handling devices are connected to the printer in a daisy-chained fashion. PHD5 refers to the forth device that is connected. Returns eEmpty if only four paper handling devices are installed. At introduction, there is no planned configuration that would cause the value of this object to be anything other than eEmpty.')
phd6_type = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 4, 5, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eEmpty", 1)))).setLabel("phd6-type").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd6_type.setStatus('optional')
if mibBuilder.loadTexts: phd6_type.setDescription('Returns an indication of the type of option installed in PHD interface 6. See SIMM1-TYPE for an explanation of the enumerations. Additional information: External paper handling devices are connected to the printer in a daisy-chained fashion. PHD6 refers to the fifth device that is connected. Returns eEmpty if only four paper handling devices are installed. At introduction, there is no planned configuration that would cause the value of this object to be anything other than eEmpty.')
self_test = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("eNotInASelfTest", 1), ("eNonDestructiveSelfTest", 4)))).setLabel("self-test").setMaxAccess("readwrite")
if mibBuilder.loadTexts: self_test.setStatus('optional')
if mibBuilder.loadTexts: self_test.setDescription("Writing this object allows a device self test to be started. Reading this object provides an indication what self-test is currently executing, if any. Actual self-test operation is device specific. A self test may not be allowed at any arbitrary time. If the device supports the requested self test, but can not start the execution of the self test when requested, the device will respond with <genErr>. If a non-destructive self test is being started, the device will generate a response before the self test is completed. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: The eNonDestructiveSelfTest performs limited testing on the printer and its attached paper handling devices. After the self-test is complete a configuration page is printed. The recommended way to cause a configuration page to be printed is to use the PRINT-INTERNAL-PAGE object. A continuous self test cannot be started or terminated using this OID. When the printer is idle, setting this object to eNonDestructiveSelfTest results in a status of <noError> and a value of eNonDestructiveSelfTest being returned. If the printer is not idle (whether printing an external job, printing an internal page or running self test), a status of <genErr> status will be returned with a value of eNotInASelfTest. When the printer is idle, setting this object to eNonDestructiveSelfTest causes some internal testing, the page to be formatted and put in the printer's print queue. Before the page is in the print queue, a get on this object will return eNonDestructiveSelfTest Attempting to set this object before the page has completed being formatted and printed will cause <genErr> status to be returned with a value of eNotInASelfTest. After the page is in the queue, a get on this object will return a value of eNotInASelfTest. Setting this object to eNonDestructiveSelfTest before the first page has completed results in a status of <genErr> status with a value of eNotInASelfTest. Likewise, if the PRINT-INTERNAL-PAGE object is set to a valid value and that page has not printed when this object is set to eNonDestructiveSelfTest, a status of <genErr> status with a value of eNotInASelfTest will be returned until the internal page has printed.")
print_internal_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 7, 8, 9, 350, 450, 1000))).clone(namedValues=NamedValues(("eNotPrintingAnInternalPage", 1), ("ePrintingAnUnknownInternalPage", 2), ("eDeviceDemoPage1ConfigurationPage", 3), ("eDeviceDemoPage2", 4), ("eDeviceDemoPage5ErrorLog", 7), ("eDeviceDemoPage6FileSystemDirectoryListing", 8), ("eDeviceDemoPage7MenuMap", 9), ("ePCLFontList1", 350), ("ePostScriptFontList1", 450), ("eMarkingAgentTestPattern", 1000)))).setLabel("print-internal-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: print_internal_page.setStatus('optional')
if mibBuilder.loadTexts: print_internal_page.setDescription("Writing this object to a value other than eNotPrintingAnInternalPage causes the device to attempt to print an internally generated page. Reading this object provides an indication what internally generated page is currently being printed, if any. The actual page is device specific. Some devices may support continuously printing an internally generated page. Setting this object to eNotPrintingAnInternalPage terminates continuously printing internally generated pages. An internally generated page may not be allowed to be printed at any arbitrary time; under what conditions it will succeed or fail is device specific. If the device supports the requested page, but can not start printing the page when requested, the device will respond with <genErr>. RECOMMENDATION: If the device is ready (i.e. the NOT- READY-PRINTER object does not contain any items, except maybe being off-line) and is idle (i.e. the NOT-IDLE object does not contain any items), this request should always succeed. This provides a mechanism for driver writers to always determine if the action will succeed or not. Additional information: PCL and PS config. pages for Color LaserJet8550 are the same. Only 1 page for info on both PCL and PS. PCL and PS font lists are different. eDeviceDemoPage2 is the printer demo page. ePCLFontList1 is the PCL typeface list. eDeviceDemoPage5ErrorLog is the printer's error log. Color LaserJet8550 does not support continuously printing a demo page. The value eDeviceDemoPage6FileSystemDirectoryListing can only be set when the disk option is installed. When this object is set to a valid value and the printer is idle, the status returned is <noError> and the value returned is ePrintingAnUnknownInternalPage. If the printer is not idle (whether printing an external job, printing an internal page or executing a self test), a status of <genErr> status will be returned with a value of eNotPrintingAnInternalPage. Setting this object to a valid value causes the desired page to be formatted and put in the printer's print queue. While the page is being formatted a get on this object will return the value ePrintingAnUnknownInternalPage, if the time to format the page is long enough (it is currently estimated that the time to format some pages is as short as one millisecond). Attempting to set this object before the page has completed being formatted and printed will cause <genErr> status to be returned with a value of eNotPrintingAnInternalPage. After the page is in the queue, a get on this object will return a value of eNotPrintingAnInternalPage. Setting this object to cause another page to be printed before the first page has completed results in a status of <genErr> status with a value of eNotPrintingAnInternalPage. Likewise, if the SELF-TEST object is set to eNonDestructiveSelfTest and that page has not printed when this object is set to print a page, a status of <genErr> status with a value of eNotPrintingAnInternalPage will be returned until the self test page has printed.")
cancel_job = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setLabel("cancel-job").setMaxAccess("writeonly")
if mibBuilder.loadTexts: cancel_job.setStatus('optional')
if mibBuilder.loadTexts: cancel_job.setDescription("Cancels the print job whose ID matches the value written to the CANCEL-JOB object. The host first learns the job ID using the CURRENT-JOB-PARSING-ID command. If the printer has completely processed the job, the printer responds with <badValue>. If the value of the CURRENT-JOB-PARSING-ID is smaller than the value written to the CANCEL-JOB object, then the printer responds with <badValue>. When read, returns the value of the last job ID what was canceled, or -1 to indicate no job has been canceled. Additional information: If the value written matches the ID of a job that is currently being canceled (for any reason), the printer responds with <noError>. Color LaserJet8550 uses job ID's in the range of 0..32767. Because the ID number can wrap to zero, CURRENT-JOB-PARSING-ID may be smaller than the value written to this object; when this occurs, no error will result as long as the ID is for a currently processing job.")
job_info_change_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("job-info-change-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_change_id.setStatus('optional')
if mibBuilder.loadTexts: job_info_change_id.setDescription('Returns the current value of an object in the job-info sub-tree whose value has changed. Define the object identifier for the object whose value has changed as job-info.required-field.optional-field.job-id. job-info represents the OID prefix of all objects in the job-info sub-tree. Required-field represents the OID field value that follows the job-info prefix. Since some objects in the job-info sub-tree have two OID fields between the job-info prefix and the job-id, the optional-field represents the OID field between the required-field and the job-id field, if present. Using this definition, the format for the JOB-INFO-CHANGE-ID binary value can be described as follows: Bytes 0-3 : required-field Bytes 4-7 : optional-field, or all zeros if there is no optional field Bytes 8-11: Job ID. Bytes 12-n : The value of the object job-info. required-field.optional-field.job-id. All multi-byte values stored in Motorola (big-endian) format, where the most significant byte occurs first. Additional information: Color LaserJet8550 will use this object to report changes of the job-info-pages-printed and job-info-state objects. The required-field (bytes - through 3) will designate whether the change to be reported involuves the pages printed (13) or job state (15). The optionl-field (bytes4 through 7) will always be zeroes. The value- field (bytes 12 through 15) will contain the new value for pages printed or job state cast to a 32-byt integer.')
hold_job_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 1, 10), Integer32()).setLabel("hold-job-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: hold_job_timeout.setStatus('optional')
if mibBuilder.loadTexts: hold_job_timeout.setDescription('The time, in minutes, that the printer will wait before automatically deleting a held job. This allows the printer to automatically clean up jobs that have been forgotten (held but never released). Additional information: This only applies to temporary held jobs, i.e., HOLD=ON or PROOF. This is a global timer that only affects the jobs that are sent after it is set. A value of 0 means never delete the jobs. Setting it to an unsupported value causes the printer to substitute a value (listed below) and to return <noError> status. Color LaserJet8550 supports values of 0, 60, 240, 1440, and 10080 The values are as follows: <=0 snap to 0 (disabled) >=1 and <=150 snap to 60 (60 minutes) >=151 and <=840 snap to 240 (4 hours) >=841 and <=2880 snap to 1440 (1 day) >=2881 snap to 10080 (1 week)')
current_job_parsing_id = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setLabel("current-job-parsing-id").setMaxAccess("readonly")
if mibBuilder.loadTexts: current_job_parsing_id.setStatus('optional')
if mibBuilder.loadTexts: current_job_parsing_id.setDescription('Contains the printer assigned job identification for the job currently being processed by the processing PDL sub- system. The job ID is a monotonically increasing number. The job ID may be reset to zero at power-up and may roll over to zero after reaching some maximum value. Additional information: A value of -1 is returned when the printer is not parsing a job. When data for a new job is detected, this object is updated (the job may or may not turn out to be a Null Job); however, the trap does not occur until the printer determines that it is not a Null Job (a trapped value will differ from the previous value name or job attribute, causes no pages to be printed, by one or more). Some JOB-INFO- objects are created when the first data bytes are received. If the printer determines that the job is a Null Job, the JOB-INFO- objects related to the Null Job are deleted. Color LaserJet8550 retains the JOB-INFO- objects for the 24 most recent jobs that are not Null Jobs.')
job_info_name1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 1), DisplayString()).setLabel("job-info-name1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name1.setStatus('optional')
if mibBuilder.loadTexts: job_info_name1.setDescription("Contains the first part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: The job name is the string specified by the NAME= parameter of the @PJL JOB command which allows a maximum of 80 characters. The first 40 characters are in this object and the second 40 are in JOB-INFO-NAME2. The symbol set is Roman-8. When jobs are nested, the value assigned to this object is the name provided by the most recent @PJL JOB NAME= command. If no name is provided, a null string is returned. ")
job_info_name2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 2), DisplayString()).setLabel("job-info-name2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_name2.setStatus('optional')
if mibBuilder.loadTexts: job_info_name2.setDescription("Contains the second part of this print job's name. The last OID field for this dynamic object contains the job ID. Additional information: See JOB-INFO-NAME1.")
job_info_stage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 10), OctetString()).setLabel("job-info-stage").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_stage.setStatus('optional')
if mibBuilder.loadTexts: job_info_stage.setDescription('Indicates what printer sub-systems are currently processing this print job. The last OID field for this dynamic object contains the job ID. cSourceSubsystem - some of the job is in the printer I/O subsystem. cProcessingSubsystem - some of the job is in the printer imaging processing subsystem. cDestinationSubsystem - some of the job is being printed. Additional information: For Color LaserJet8550 cSourceSubsystem and cProcessingSubsystem will always be set and cleared together. A non-printing job will never set cDestinationSubsystem. When a page is ready to be printed (the intermediate has been built), cDestinationSubsystem will be set even if a page of a previous job is currently being printed. cDestinationSubsystem remains set until the last page of the job has reached an output bin. If a page requires extensive processing and allows all the previous pages of a job to complete printing cDestinationSubsystem will remain set until the last page of the job is closed.')
job_info_io_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 11), Integer32()).setLabel("job-info-io-source").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_io_source.setStatus('optional')
if mibBuilder.loadTexts: job_info_io_source.setDescription('Indicates which I/O source, the print job was received over. The value maps to port numbering scheme supported in the DEVICE/SOURCE-SUBSYSTEM/IO/PORTS sub-tree.')
job_info_pages_processed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 12), Integer32()).setLabel("job-info-pages-processed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_processed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_processed.setDescription('Indicates the number of pages processed by the processing subsystem. If neither the cSourceSubsystem or the cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages processed for this job. The last OID field for this dynamic object contains the job ID. Additional information: This object is incremented by one when a page is processed, regardless of the number of pages that are printed as a result of the single page processed. In other words, it does not matter how many identical copies of a page are printed, or no pages may be printed if operating in silent run mode, this count is incremented only once. A page is considered processed when all of the input data has been processed for a page (the intermediate has been produced); the image of the page is not necessarily completely formed.')
job_info_pages_printed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 13), Integer32()).setLabel("job-info-pages-printed").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_printed.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_printed.setDescription('Indicates the number of pages printed by the destination subsystem. If non of the cSourceSubsystem, cProcessingSubsystem or cDestinationSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the total number of pages printed for this job. This value may increase by two each time for duplex jobs. The last OID field for this dynamic object contains the job ID. Additional information: Indicates the number of pages printed (i.e., the page has reached the output tray) by the destination subsystem. If multiple copies of a page are printed, each copy is counted individually. Duplexed pages count as 2 pages.')
job_info_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 14), Integer32()).setLabel("job-info-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_size.setStatus('optional')
if mibBuilder.loadTexts: job_info_size.setDescription('Indicates the number of bytes of data processed by the processing subsystem. If neither of the cSourceSubsystem or cProcessingSubsystem items are in the associated JOB-INFO-STAGE object, then this object contains the size of this job, in bytes. The last OID field for this dynamic object contains the job ID. Additional information: This count may be incremented by values other than one as blocks of data are processed; blocks of data (which may be as large as 2K bytes) will be processed in a varying amount of time. When a job completes, this count may not be the same as the total number of bytes sent to the printer since some data before or after the job may be considered to be outside the job. Also, for ill-formed PostScript jobs (ones that do not use the ENTER LANGUAGE command) will be reported as having approximately 256 extra bytes due to the way the language switching is accomplished.')
job_info_state = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 9, 10, 11))).clone(namedValues=NamedValues(("eAborted", 3), ("eWaitingForResources", 4), ("ePrinted", 5), ("eRetained", 6), ("eTerminating", 7), ("ePaused", 9), ("eCancelled", 10), ("eProcessing", 11)))).setLabel("job-info-state").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_state.setStatus('optional')
if mibBuilder.loadTexts: job_info_state.setDescription('Indicates the state of the job. The last OID field for this dynamic object contains the job ID. eAborted - the print job was aborted. eWaitingForResources - the print job requires resources that are not currently available. Example resources that can cause the job to wait include the print engine or PDL processor being unavailable. The print engine could be unavailable due to paper out, paper jam, staple out, stapler jam, marking agent low, output bin full, etc. The PDL processor could be unavailable due to an off-line condition. Each printer specific object specification should state which conditions cause a job to be waiting for resources and also state which objects can be retrieved by an application to determine the exact cause of a resource being unavailable. ePrinted - the job has printed. The related JOB-INFO- OUTCOME object indicates if any problems were encountered while the job was processed. eRetained - the job can be reprinted. eTerminating - the job was aborted or cancelled and is currently is terminating. eInterrupted - the job has been interrupted. The job can be continued. ePaused - the job has been paused. The job can be continuted. eCancelled - the job has been cancelled. eProcessing - the job is currently being printed normally. Additional information: Indicates the state of the job. The last OID field for this dynamic object contains the job ID eAborted - the print job was aborted. eWaitingForResources - the print job requires resources that are not currently available. Example resources that can cause the job to wait include the print engine or PDL processor being unavailable due to paper out, paper jam, marking agent low, output bin full, etc. The PDL processor could be unavailable due to an off-line condition. ePrinted - the job has printed. The related JOB-INFO-OUTCOME object indicates if any problms were encountered while the job was precessed. eRetained - the job can be reprinted. eTerminating - the job was aborted or cancelled and is currently is terminating. ePaused - the job has been paused. The job can be continued. eCancelled - the job has been cancelled. eProcessing - the job is currently being printed normally.')
job_info_outcome = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("eOk", 3), ("eWarningsEncountered", 4), ("eErrorsEncountered", 5)))).setLabel("job-info-outcome").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outcome.setStatus('optional')
if mibBuilder.loadTexts: job_info_outcome.setDescription('Indicates if any warning or error conditions were encountered while processing the assoicated job. The last OID field for this dynamic object contains the job ID.')
job_info_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 20), OctetString()).setLabel("job-info-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_outbins_used.setDescription("Indicates which output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: The bins designated by this collection include the printer's own output bins as well as the 'logical output bins' associated with any attached external paper handling devices. (The mapping of the physical output bins of an external paper handling device to its 'logical output bins' depends on the usage mode of the device. For instance, in 'mailbox mode', there is one-to-one correspondence of 'logical output bins' to physical bins, whereas in 'stacker mode', one 'logical output bin' may map to several physical bins.) If a bin is used as an overflow bin, then its bit will be set as well. cOutbin1 is the top/face-down bin. cOutbin2 is the left/face-up bin. ")
job_info_physical_outbins_used = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 22), OctetString()).setLabel("job-info-physical-outbins-used").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_physical_outbins_used.setStatus('optional')
if mibBuilder.loadTexts: job_info_physical_outbins_used.setDescription("Indicates which physical output bins this job has delivered printed pages to. The last OID field for this dynamic object contains the job ID. Additional information: Bits in this object are set only if printed pages were delivered to an external paper handling device. This object is supported regardless of whether or not an external device is installed. The bits set map to the device's bins in a device specific manner. If the device does not report to the formatter which bins are used, then no bits will be set. For the HCO, the bins map to the bits as follows: cOutbin1--Face-up bin cOutbin2--Bin1 cOutbin3--Bin2 cOutbin4--Bin3 cOutbin5--Bin4 cOutbin6--Bin5 cOutbin7--Bin6 cOutbin8--Bin7 cOutbin9--Bin8 cOutbin10--Bin9 ")
job_info_attr_1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-1").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_1.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_1.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. Attribute objects are saved sequentially, starting with 1, after the start of a job. If more attributes are set than there are objects to store them, the excess JOBATTR values are ignored. If the corresponding SET JOBATTR= command has not been received when a get is done for this object, a status of <noSuchName> will be returned.')
job_info_attr_2 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-2").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_2.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_2.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_3 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-3").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_3.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_3.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_4 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-4").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_4.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_4.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_5 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-5").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_5.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_5.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_6 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-6").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_6.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_6.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_7 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-7").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_7.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_7.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_8 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-8").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_8.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_8.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_9 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-9").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_9.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_9.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_10 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-10").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_10.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_10.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_11 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-11").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_11.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_11.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_12 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-12").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_12.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_12.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_13 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-13").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_13.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_13.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_14 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-14").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_14.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_14.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_15 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-15").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_15.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_15.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_16 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-16").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_16.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_16.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_17 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-17").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_17.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_17.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_18 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-18").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_18.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_18.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_19 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-19").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_19.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_19.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_20 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-20").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_20.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_20.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_21 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 21), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-21").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_21.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_21.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_22 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-22").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_22.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_22.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_23 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-23").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_23.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_23.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_24 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-24").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_24.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_24.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_25 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-25").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_25.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_25.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_26 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-26").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_26.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_26.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_27 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-27").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_27.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_27.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_28 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-28").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_28.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_28.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_29 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-29").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_29.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_29.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_30 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-30").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_30.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_30.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_31 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-31").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_31.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_31.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_attr_32 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 23, 32), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setLabel("job-info-attr-32").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_attr_32.setStatus('optional')
if mibBuilder.loadTexts: job_info_attr_32.setDescription('Returns the value that was set in PJL via the SET JOBATTR= command. See JOB-INFO-ATTR-1 for details.')
job_info_requested_originals = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 24), Integer32()).setLabel("job-info-requested-originals").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_requested_originals.setStatus('optional')
if mibBuilder.loadTexts: job_info_requested_originals.setDescription('The number of requested collated copies. The value was supplied with the job via PJL QTY variable, the PostScript Collate and NumCopies entries in the page device dictionary, or via some other mechansim.')
job_info_page_count_current_original = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 25), Integer32()).setLabel("job-info-page-count-current-original").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_page_count_current_original.setStatus('optional')
if mibBuilder.loadTexts: job_info_page_count_current_original.setDescription('The page number being printed within the current copy of a collated multi-copy job. This value changes when the job-info-pages-printed changes. The job-info-pages- printed indicates the total number of pages printed in the job, while this object indicates the number of pages printed for this copy of a collated multi-copy job.')
job_info_pages_in_original = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 26), Integer32()).setLabel("job-info-pages-in-original").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_pages_in_original.setStatus('optional')
if mibBuilder.loadTexts: job_info_pages_in_original.setDescription('Number of pages in a single copy of a collated multi- copy job.')
job_info_printed_originals = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 5, 27), Integer32()).setLabel("job-info-printed-originals").setMaxAccess("readonly")
if mibBuilder.loadTexts: job_info_printed_originals.setStatus('optional')
if mibBuilder.loadTexts: job_info_printed_originals.setDescription('Number of collated copies completely printed and delivered to the output bin at time of query. Additional information: Number of collated copies completly printed at time of query.')
held_job_user_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("held-job-user-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_user_name.setStatus('optional')
if mibBuilder.loadTexts: held_job_user_name.setDescription('User name that is obtained by the driver through some internal method or from user input. Additional information: The following is a general description for all the JOB-MANAGEMENT objects described below. These object describe the attributes of the dynamic list containing all the stored jobs on the disk available for printing or deleting via the job-management feature. The jobs on this list are not deleted from the disk unless explicitly specified by the user. A print job may be specified for retention by PJL commands in the data stream. Following is a list of the PJL commands (i.e. these comments describe the PJL implementation and in some cases do not reflect the PML implementation.): @PJL SET HOLD=OFF|ON|PROOF|STORE|PRINT GENERAL DESCRIPTION: This variable specifies the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. OFF: The job is printed but not retained on disk after printing. This is the default value. ON: This setting may be thought of as free proof-and-hold. The requested number of copies will be printed and the job will be temporarily stored on disk. The job will then be available for printing additional copies through the control panel and through PML. There will be a limit to the number of these temporary jobs that may be stored, and when the limit is exceeded the oldest job will be removed from the disk. PROOF: One copy of the job is printed and remaining copies are stored on disk. The job is then available to select for printing via the control panel menus or PML. The job will be deleted from the disk when the disk space is needed for another proof and hold job but only after the additional copies have been printed. It will also be deleted when the user sends down another proof and hold job with the same job name, or the user explicitly deletes the job. STORE: The job is not printed immediately but is retained on disk. The job is available to select for printing via the control panel DEFAULT VALUE: OFF The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET USERNAME=<80 bytes> GENERAL DESCRIPTION: Eighty-character user name that is obtained by the driver through some internal method or from user input. If the job stream does not contain a USERNAME the default value will be NO USER NAME. The driver is responsible for determining the size of the printers control panel and sending a string of appropriate length. DEFAULT VALUE: NO USER NAME The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and, INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET JOBNAME=<80 bytes> GENERAL DESCRIPTION: Eighty-character job name that may be generated by the driver or obtained from user input. This value may be used in conjunction with the USERNAME to select a job from the front panel. If the job stream does not contain a JOBNAME, the printer will assume no job name; each subsequent job that is sent down by the same user would replace the users last job on disk. The driver is responsible for determining the size of the printers control panel and sending a string of appropriate length. NOTE: The limit of 80 bytes is a PJL limit. The limit for PML will be 40 bytes. DEFAULT VALUE: NULL STRING The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET HOLDTYPE=PUBLIC|PRIVATE GENERAL DESCRIPTION: This variable specifies the privacy level of the job. PUBLIC: The job does not require a PIN in order to be released for printing. This is the default value. PRIVATE: The job requires a PIN in order to be released for printing. The PIN is specified by the HOLDKEY variable. If the HOLDTYPE is set to PRIVATE, a HOLDKEY value must be specified. If no HOLDKEY is specified, the job will be considered PUBLIC. DEFAULT VALUE: PUBLIC The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. @PJL SET HOLDKEY=4 digits, 0000...9999 GENERAL DESCRIPTION: A 4-digit string, each digit 0-9, that is specified in the job stream and then required to be entered in order to release the job for printing. If a HOLDTYPE is PRIVATE, a HOLDKEY value must be specified. If no HOLDKEY value is specified, a job will be considered PUBLIC. DEFAULT VALUE: NULL STRING The value will be stored in RAM only, not in NVRAM. The legal PJL commands are SET and INQUIRE. DEFAULT is not allowed. The variable will appear in the PJL INFO VARIABLES list. The format for the OID is as follows: 3.4.1.6.x.y <-----> | | | | \\ / | job-id in the system / \\ PML_JOB_MGNT_ROOT_OID \\ job attribute 1..6 x values are 1..6: 1) user-name: user name that is obtained by the driver through some internal method or from user input. 2) job-name: job name may be generated by the driver or obtained from user input. 3) hold: indicates the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. There are 4 options: OFF: The job is printed but not retained on the disk. ON: The job is printed and stored temporarily on the disk. STORE: The job is not printed but stored on the disk. PROOF: One copy of the job is printed and the remaining copies are stored on the disk. 4) holdtype: The variable specifies the security level of the job. PUBLIC: The job does not require a PIN in order to release the job for printing. PRIVATE: The job requires a PIN in order to be released for printing. 5) quantity: number of copies to print. Valid values are 0..999. 6) pin: A 4 digit string, each digit is 0-9, that is specified in the job stream and then required to be entered in order to release the job for printing. y : an unsigned 15 bit number which uniquely identifies the job. The job id for the job remains the same for the job until it is deleted from the held jobs list. For example, the OID below is asking for the user name of the job whose id is 3. The application would issue: OID get 3.4.1.6.1.3 For example, the <getnext> OID values sequence is as follows: OID returned OID getnext 3.4.1.6 3.4.1.6.1.1 getnext 3.4.1.6.1.1 3.4.1.6.1.2 getnext 3.4.1.6.2.1 3.4.1.6.2.2 ... getnext 3.4.1.6.1.6 3.4.1.6.1.7 getnext 3.4.1.6.2.1 3.4.1.6.2.2 getnext 3.4.1.6.5.2828 3.4.1.6.6.1 NOTE: for example above, job id 2828 is the last job in the list of held jobs. ... Also supported is <getnext> on the job attributes: OID returned OID getnext 3.4.1.6.1 3.4.1.6.1.1 getnext 3.4.1.6.6 3.4.1.6.6.1')
held_job_job_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setLabel("held-job-job-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_job_name.setStatus('optional')
if mibBuilder.loadTexts: held_job_job_name.setDescription('The job name may be generated by the driver or obtained from user input. Additional information: The job name may be generated by the driver or obtained from user input.')
held_job_retention = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("eHoldOff", 1), ("eHoldOn", 2), ("eHoldStore", 3), ("eHoldProof", 4)))).setLabel("held-job-retention").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_retention.setStatus('optional')
if mibBuilder.loadTexts: held_job_retention.setDescription('Indicates the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. There are 4 options: OFF: The job is printed but not retained on the disk. ON: The job is printed and stored temporarily on the disk. PROOF: One copy of the job is printed and the remaining copies are stored on the disk. STORE: The job is not printed but stored on the disk. Additional information: Indicates the retention classification of the job. The values indicate whether the job is printed immediately and/or stored. There are 4 options: OFF: The job is printed but not retained on the disk. ON: The job is printed and stored temporarily on the disk. PROOF: One copy of the job is printed and the remaining copies are stored on the disk. STORE: The job is not printed but stored on the disk.')
held_job_security = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eHoldTypePublic", 1), ("eHoldTypePrivate", 2)))).setLabel("held-job-security").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_security.setStatus('optional')
if mibBuilder.loadTexts: held_job_security.setDescription('The variable specifies the security level of the job. PUBLIC: The job does not require a PIN in order to release the job for printing. PRIVATE: The job requires a PIN in order to be released for printing. Additional information: The variable specifies the security level of the job. PUBLIC: The job does not require a PIN in order to release the job for printing. PRIVATE:The job requires a PIN in order to be released for printing.')
held_job_quantity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setLabel("held-job-quantity").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_quantity.setStatus('optional')
if mibBuilder.loadTexts: held_job_quantity.setDescription('Number of copies to print. Additional information: Number of copies to print.')
held_job_pin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 4))).setLabel("held-job-pin").setMaxAccess("readonly")
if mibBuilder.loadTexts: held_job_pin.setStatus('optional')
if mibBuilder.loadTexts: held_job_pin.setDescription('A string that is specified in the job stream and then required to be entered in order to release the job for printing. PIN stands for Personal Identification Number. Additional information: Must be a 4 digit string, each digit must be 0..9 or a null string if there is no pin.')
held_job_print = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setLabel("held-job-print").setMaxAccess("writeonly")
if mibBuilder.loadTexts: held_job_print.setStatus('optional')
if mibBuilder.loadTexts: held_job_print.setDescription('Instructs the printer to schedule the specified held job for printing with the specified number of copies. The job-id is used to identify which job to print. A held job can also be printed from the control panel. Additional information: Bytes 0-3 is the job id of the job to print. Bytes 4-7 is the number of copies to print.')
held_job_delete = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32768))).setLabel("held-job-delete").setMaxAccess("writeonly")
if mibBuilder.loadTexts: held_job_delete.setStatus('optional')
if mibBuilder.loadTexts: held_job_delete.setDescription('Instructs the printer to delete the specified held job from the list. The job-id is used to identify which job to delete. A held job can also be deleted from the control panel. Additional information: ')
held_job_set_queue_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 50))).setLabel("held-job-set-queue-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: held_job_set_queue_size.setStatus('optional')
if mibBuilder.loadTexts: held_job_set_queue_size.setDescription('Sets the maximum number of jobs which can be stored in the held job list. Additional information: Sets the size of the temporary job lists queue.')
held_job_enable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 6, 7, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eDisabled", 1), ("eEnabled", 2)))).setLabel("held-job-enable").setMaxAccess("readwrite")
if mibBuilder.loadTexts: held_job_enable.setStatus('optional')
if mibBuilder.loadTexts: held_job_enable.setDescription('Enables or disables Job Retention (Job Hold). The valid values are eDisabled and eEnabled. (Specifying an invalid mode causes an <badValue> error to be returned.) When eDisabled is specified all Job Retention (Hold, Proof, Store, PIN Printing) is disabled. When eEnabled is specified, the Job Retention characteristics of a given job are defined by the PJL variable SET HOLD. Additional information: When disabled, currently held jobs are not removed, but must be explicitly removed through the Control Panel or the PML object HELD-JOB-DELETE.')
file_system_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 1), Integer32()).setLabel("file-system-memory").setMaxAccess("readwrite")
if mibBuilder.loadTexts: file_system_memory.setStatus('optional')
if mibBuilder.loadTexts: file_system_memory.setDescription('The amount of memory, in bytes, used by the file system to buffer file data. Additional information: Reports the amount of memeory, in bytes, reserved for use by the file system. Returns status if attempting to access this object and there is no storage device is installed. The values remain constant across reboots. Possible values: FILE-SYSTEM-MAX-OPEN-FILES 32 512 EIO DISK 69916 198556.')
file_system_max_open_files = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 512))).setLabel("file-system-max-open-files").setMaxAccess("readwrite")
if mibBuilder.loadTexts: file_system_max_open_files.setStatus('optional')
if mibBuilder.loadTexts: file_system_max_open_files.setDescription('The number of open files allowed at one time. Opening a file when the maximum number of files are currently open will fail. Additional information: Indicates the number of open files a personality (e.g. PCL or PostScript) is guaranteed to be able to open before the file system runs out of file handles. After writing this object, the printer must be rebooted (powercycled) before the change takes effect. This object supports any value between 32 - 512 inclusive. If a value less then 32 then it snaps to 32 if greater than 512 it snaps to 512. The factory default value is depentdent on the amount of installed RAM. The default value of 32 is when Memory <= 4MB, 128 is if the memory is > 4MB. Performing a cold reset sets this object back to the factory default value. Returns status if attempting to access this object and there is no storage device is installed.')
file_system_statistic_read_open = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 1), Integer32()).setLabel("file-system-statistic-read-open").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_read_open.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_read_open.setDescription('The number of times the file system has received requests to open a file for reading. Opening a file for both reading and writing will cause this value to change. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device installed. This value is increamented when a file is opened.')
file_system_statistic_write_open = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 2), Integer32()).setLabel("file-system-statistic-write-open").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_write_open.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_write_open.setDescription('The number of times the file system has received requests to open a file for writing. Opening a file for both reading and writing will cause this value to change. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device installed. This value is increamented when a file is opened.')
file_system_statistic_successful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 3), Integer32()).setLabel("file-system-statistic-successful").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_successful.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_successful.setDescription('A counter indicating the number of file system requests that completed successfully. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device installed.')
file_system_statistic_unsuccessful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 4), Integer32()).setLabel("file-system-statistic-unsuccessful").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_unsuccessful.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_unsuccessful.setDescription('A counter indicating the number of file system requests that completed unsuccessfully. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device is installed.')
file_system_statistic_current_memory_usage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 5), Integer32()).setLabel("file-system-statistic-current-memory-usage").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_current_memory_usage.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_current_memory_usage.setDescription('A value indicating the number of bytes of RAM currently used by the file system firmware. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device is installed. This will vary depending on the number and size of msss storage devices installed.')
file_system_statistic_max_memory_usage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 2, 6), Integer32()).setLabel("file-system-statistic-max-memory-usage").setMaxAccess("readonly")
if mibBuilder.loadTexts: file_system_statistic_max_memory_usage.setStatus('optional')
if mibBuilder.loadTexts: file_system_statistic_max_memory_usage.setDescription('A value indicating the maximum number of bytes of RAM used by the file system firmware. The POS should state if the value is reset to zero after a power cycle. Additional information: Resets to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device is installed.')
file_system2_initialize_volume = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 10, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eNotInitializing", 1), ("eInitializing", 2)))).setLabel("file-system2-initialize-volume").setMaxAccess("writeonly")
if mibBuilder.loadTexts: file_system2_initialize_volume.setStatus('optional')
if mibBuilder.loadTexts: file_system2_initialize_volume.setDescription('Setting this object to eInitializing causes file system 2 to be initialized. Reading this object indicates if the file system is currently being initialized. Additional information: The hrDeviceIndex value for the mass storage device is the same value that is used to index into the FILE-SYSTEM sub-tree. Since this product supports only one storage device, and since hrDeviceIndex for the mass storage devices will start at 2 if the mass storage device is installed, the FILE-SYSTEM2-INITIALIZE-VOLUME object will be the object that allows the mass storage device to be installed.')
error1_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 1), Integer32()).setLabel("error1-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error1_time_stamp.setDescription("Contains some sort of time stamp indicating when error 1 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: In Color LaserJet8550 this item contains the engine page count when the error occurred. A value of zero means 'no error'. See ERROR1-CODE for an explanation of the order used for storing errors.")
error1_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 1, 2), Integer32()).setLabel("error1-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error1_code.setStatus('optional')
if mibBuilder.loadTexts: error1_code.setDescription("Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: Contains a device specific error code. A value of zero means 'no error'. See the Color LaserJet8550 Control Panel ERS for specific code information. The error number is returned in the upper 16 bits. If it is 68,69,79, or 80, then the sub code is returned in the lower 16 bits (eg. 68 0019, where the subcode is already a hexadecimal value). If the error number is any other number, then the 1st sub code (XX) will be in bits 15-8 and the 2nd sub code (YY) will be in bits 7-0 (eg. 55.04.02) where XX=04 and YY=02). Example: If the error is 68 001A, then the value returned will be 4456474. To break it down: 4456474 = 0x0044001A The upper 16 bits: 0x0044 = 68 The lower 16 bits: 0x001A = 001A Which is the error: 68 001A Example: If the error is 55.04.241, then the error code will be 3605745. To break it down: 3605745 = 0x003704F1 The upper 16 bits: 0x0037 = 55 The upper byte of the lower 16 bits: 0x04 = 04 The lower byte of the lower 16 bits: 0xF1 = 241 Which is the error: 55.04.241 ERROR1- is the oldest error in the log. Errors are added until ERROR50- is reached. If more errors occur, ERROR1- is replaced by moving all error entries down one position and adding the newest error as ERROR50-")
error2_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 1), Integer32()).setLabel("error2-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error2_time_stamp.setDescription('Contains some sort of time stamp indicating when error 2 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error2_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 2, 2), Integer32()).setLabel("error2-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error2_code.setStatus('optional')
if mibBuilder.loadTexts: error2_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error3_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 1), Integer32()).setLabel("error3-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error3_time_stamp.setDescription('Contains some sort of time stamp indicating when error 3 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error3_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 3, 2), Integer32()).setLabel("error3-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error3_code.setStatus('optional')
if mibBuilder.loadTexts: error3_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error4_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 1), Integer32()).setLabel("error4-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error4_time_stamp.setDescription('Contains some sort of time stamp indicating when error 4 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error4_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 4, 2), Integer32()).setLabel("error4-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error4_code.setStatus('optional')
if mibBuilder.loadTexts: error4_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error5_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 1), Integer32()).setLabel("error5-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error5_time_stamp.setDescription('Contains some sort of time stamp indicating when error 5 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error5_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 5, 2), Integer32()).setLabel("error5-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error5_code.setStatus('optional')
if mibBuilder.loadTexts: error5_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error6_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 1), Integer32()).setLabel("error6-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error6_time_stamp.setDescription('Contains some sort of time stamp indicating when error 6 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error6_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 6, 2), Integer32()).setLabel("error6-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error6_code.setStatus('optional')
if mibBuilder.loadTexts: error6_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error7_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 1), Integer32()).setLabel("error7-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error7_time_stamp.setDescription('Contains some sort of time stamp indicating when error 7 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error7_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 7, 2), Integer32()).setLabel("error7-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error7_code.setStatus('optional')
if mibBuilder.loadTexts: error7_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error8_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 1), Integer32()).setLabel("error8-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error8_time_stamp.setDescription('Contains some sort of time stamp indicating when error 8 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error8_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 8, 2), Integer32()).setLabel("error8-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error8_code.setStatus('optional')
if mibBuilder.loadTexts: error8_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error9_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 1), Integer32()).setLabel("error9-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error9_time_stamp.setDescription('Contains some sort of time stamp indicating when error 9 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error9_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 9, 2), Integer32()).setLabel("error9-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error9_code.setStatus('optional')
if mibBuilder.loadTexts: error9_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error10_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 1), Integer32()).setLabel("error10-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error10_time_stamp.setDescription('Contains some sort of time stamp indicating when error 10 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error10_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 10, 2), Integer32()).setLabel("error10-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error10_code.setStatus('optional')
if mibBuilder.loadTexts: error10_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error11_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11, 1), Integer32()).setLabel("error11-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error11_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error11_time_stamp.setDescription('Contains some sort of time stamp indicating when error 11 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error11_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 11, 2), Integer32()).setLabel("error11-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error11_code.setStatus('optional')
if mibBuilder.loadTexts: error11_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error12_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12, 1), Integer32()).setLabel("error12-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error12_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error12_time_stamp.setDescription('Contains some sort of time stamp indicating when error 12 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error12_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 12, 2), Integer32()).setLabel("error12-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error12_code.setStatus('optional')
if mibBuilder.loadTexts: error12_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error13_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13, 1), Integer32()).setLabel("error13-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error13_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error13_time_stamp.setDescription('Contains some sort of time stamp indicating when error 13 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error13_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 13, 2), Integer32()).setLabel("error13-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error13_code.setStatus('optional')
if mibBuilder.loadTexts: error13_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error14_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14, 1), Integer32()).setLabel("error14-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error14_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error14_time_stamp.setDescription('Contains some sort of time stamp indicating when error 14 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error14_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 14, 2), Integer32()).setLabel("error14-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error14_code.setStatus('optional')
if mibBuilder.loadTexts: error14_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error15_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15, 1), Integer32()).setLabel("error15-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error15_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error15_time_stamp.setDescription('Contains some sort of time stamp indicating when error 15 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error15_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 15, 2), Integer32()).setLabel("error15-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error15_code.setStatus('optional')
if mibBuilder.loadTexts: error15_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error16_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16, 1), Integer32()).setLabel("error16-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error16_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error16_time_stamp.setDescription('Contains some sort of time stamp indicating when error 16 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error16_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 16, 2), Integer32()).setLabel("error16-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error16_code.setStatus('optional')
if mibBuilder.loadTexts: error16_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error17_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17, 1), Integer32()).setLabel("error17-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error17_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error17_time_stamp.setDescription('Contains some sort of time stamp indicating when error 17 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error17_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 17, 2), Integer32()).setLabel("error17-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error17_code.setStatus('optional')
if mibBuilder.loadTexts: error17_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error18_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18, 1), Integer32()).setLabel("error18-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error18_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error18_time_stamp.setDescription('Contains some sort of time stamp indicating when error 18 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error18_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 18, 2), Integer32()).setLabel("error18-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error18_code.setStatus('optional')
if mibBuilder.loadTexts: error18_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error19_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19, 1), Integer32()).setLabel("error19-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error19_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error19_time_stamp.setDescription('Contains some sort of time stamp indicating when error 19 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error19_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 19, 2), Integer32()).setLabel("error19-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error19_code.setStatus('optional')
if mibBuilder.loadTexts: error19_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error20_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20, 1), Integer32()).setLabel("error20-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error20_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error20_time_stamp.setDescription('Contains some sort of time stamp indicating when error 20 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error20_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 20, 2), Integer32()).setLabel("error20-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error20_code.setStatus('optional')
if mibBuilder.loadTexts: error20_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error21_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21, 1), Integer32()).setLabel("error21-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error21_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error21_time_stamp.setDescription('Contains some sort of time stamp indicating when error 21 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error21_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 21, 2), Integer32()).setLabel("error21-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error21_code.setStatus('optional')
if mibBuilder.loadTexts: error21_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error22_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22, 1), Integer32()).setLabel("error22-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error22_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error22_time_stamp.setDescription('Contains some sort of time stamp indicating when error 22 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error22_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 22, 2), Integer32()).setLabel("error22-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error22_code.setStatus('optional')
if mibBuilder.loadTexts: error22_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error23_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23, 1), Integer32()).setLabel("error23-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error23_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error23_time_stamp.setDescription('Contains some sort of time stamp indicating when error 23 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error23_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 23, 2), Integer32()).setLabel("error23-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error23_code.setStatus('optional')
if mibBuilder.loadTexts: error23_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error24_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24, 1), Integer32()).setLabel("error24-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error24_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error24_time_stamp.setDescription('Contains some sort of time stamp indicating when error 24 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error24_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 24, 2), Integer32()).setLabel("error24-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error24_code.setStatus('optional')
if mibBuilder.loadTexts: error24_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error25_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25, 1), Integer32()).setLabel("error25-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error25_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error25_time_stamp.setDescription('Contains some sort of time stamp indicating when error 25 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error25_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 25, 2), Integer32()).setLabel("error25-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error25_code.setStatus('optional')
if mibBuilder.loadTexts: error25_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error26_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26, 1), Integer32()).setLabel("error26-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error26_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error26_time_stamp.setDescription('Contains some sort of time stamp indicating when error 26 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error26_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 26, 2), Integer32()).setLabel("error26-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error26_code.setStatus('optional')
if mibBuilder.loadTexts: error26_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error27_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27, 1), Integer32()).setLabel("error27-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error27_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error27_time_stamp.setDescription('Contains some sort of time stamp indicating when error 27 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error27_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 27, 2), Integer32()).setLabel("error27-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error27_code.setStatus('optional')
if mibBuilder.loadTexts: error27_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error28_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28, 1), Integer32()).setLabel("error28-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error28_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error28_time_stamp.setDescription('Contains some sort of time stamp indicating when error 28 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error28_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 28, 2), Integer32()).setLabel("error28-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error28_code.setStatus('optional')
if mibBuilder.loadTexts: error28_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error29_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29, 1), Integer32()).setLabel("error29-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error29_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error29_time_stamp.setDescription('Contains some sort of time stamp indicating when error 29 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error29_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 29, 2), Integer32()).setLabel("error29-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error29_code.setStatus('optional')
if mibBuilder.loadTexts: error29_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error30_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30, 1), Integer32()).setLabel("error30-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error30_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error30_time_stamp.setDescription('Contains some sort of time stamp indicating when error 30 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error30_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 30, 2), Integer32()).setLabel("error30-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error30_code.setStatus('optional')
if mibBuilder.loadTexts: error30_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error31_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31, 1), Integer32()).setLabel("error31-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error31_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error31_time_stamp.setDescription('Contains some sort of time stamp indicating when error 31 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error31_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 31, 2), Integer32()).setLabel("error31-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error31_code.setStatus('optional')
if mibBuilder.loadTexts: error31_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error32_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32, 1), Integer32()).setLabel("error32-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error32_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error32_time_stamp.setDescription('Contains some sort of time stamp indicating when error 32 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error32_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 32, 2), Integer32()).setLabel("error32-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error32_code.setStatus('optional')
if mibBuilder.loadTexts: error32_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error33_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33, 1), Integer32()).setLabel("error33-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error33_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error33_time_stamp.setDescription('Contains some sort of time stamp indicating when error 33 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error33_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 33, 2), Integer32()).setLabel("error33-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error33_code.setStatus('optional')
if mibBuilder.loadTexts: error33_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error34_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34, 1), Integer32()).setLabel("error34-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error34_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error34_time_stamp.setDescription('Contains some sort of time stamp indicating when error 34 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error34_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 34, 2), Integer32()).setLabel("error34-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error34_code.setStatus('optional')
if mibBuilder.loadTexts: error34_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error35_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35, 1), Integer32()).setLabel("error35-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error35_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error35_time_stamp.setDescription('Contains some sort of time stamp indicating when error 35 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error35_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 35, 2), Integer32()).setLabel("error35-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error35_code.setStatus('optional')
if mibBuilder.loadTexts: error35_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error36_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36, 1), Integer32()).setLabel("error36-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error36_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error36_time_stamp.setDescription('Contains some sort of time stamp indicating when error 36 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error36_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 36, 2), Integer32()).setLabel("error36-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error36_code.setStatus('optional')
if mibBuilder.loadTexts: error36_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error37_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37, 1), Integer32()).setLabel("error37-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error37_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error37_time_stamp.setDescription('Contains some sort of time stamp indicating when error 37 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error37_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 37, 2), Integer32()).setLabel("error37-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error37_code.setStatus('optional')
if mibBuilder.loadTexts: error37_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error38_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38, 1), Integer32()).setLabel("error38-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error38_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error38_time_stamp.setDescription('Contains some sort of time stamp indicating when error 38 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error38_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 38, 2), Integer32()).setLabel("error38-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error38_code.setStatus('optional')
if mibBuilder.loadTexts: error38_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error39_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39, 1), Integer32()).setLabel("error39-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error39_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error39_time_stamp.setDescription('Contains some sort of time stamp indicating when error 39 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error39_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 39, 2), Integer32()).setLabel("error39-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error39_code.setStatus('optional')
if mibBuilder.loadTexts: error39_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error40_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40, 1), Integer32()).setLabel("error40-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error40_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error40_time_stamp.setDescription('Contains some sort of time stamp indicating when error 40 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error40_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 40, 2), Integer32()).setLabel("error40-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error40_code.setStatus('optional')
if mibBuilder.loadTexts: error40_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error41_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41, 1), Integer32()).setLabel("error41-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error41_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error41_time_stamp.setDescription('Contains some sort of time stamp indicating when error 41 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error41_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 41, 2), Integer32()).setLabel("error41-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error41_code.setStatus('optional')
if mibBuilder.loadTexts: error41_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error42_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42, 1), Integer32()).setLabel("error42-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error42_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error42_time_stamp.setDescription('Contains some sort of time stamp indicating when error 42 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error42_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 42, 2), Integer32()).setLabel("error42-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error42_code.setStatus('optional')
if mibBuilder.loadTexts: error42_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error43_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43, 1), Integer32()).setLabel("error43-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error43_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error43_time_stamp.setDescription('Contains some sort of time stamp indicating when error 43 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error43_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 43, 2), Integer32()).setLabel("error43-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error43_code.setStatus('optional')
if mibBuilder.loadTexts: error43_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error44_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44, 1), Integer32()).setLabel("error44-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error44_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error44_time_stamp.setDescription('Contains some sort of time stamp indicating when error 44 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error44_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 44, 2), Integer32()).setLabel("error44-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error44_code.setStatus('optional')
if mibBuilder.loadTexts: error44_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error45_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45, 1), Integer32()).setLabel("error45-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error45_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error45_time_stamp.setDescription('Contains some sort of time stamp indicating when error 45 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error45_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 45, 2), Integer32()).setLabel("error45-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error45_code.setStatus('optional')
if mibBuilder.loadTexts: error45_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error46_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46, 1), Integer32()).setLabel("error46-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error46_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error46_time_stamp.setDescription('Contains some sort of time stamp indicating when error 46 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error46_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 46, 2), Integer32()).setLabel("error46-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error46_code.setStatus('optional')
if mibBuilder.loadTexts: error46_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error47_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47, 1), Integer32()).setLabel("error47-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error47_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error47_time_stamp.setDescription('Contains some sort of time stamp indicating when error 47 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error47_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 47, 2), Integer32()).setLabel("error47-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error47_code.setStatus('optional')
if mibBuilder.loadTexts: error47_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error48_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48, 1), Integer32()).setLabel("error48-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error48_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error48_time_stamp.setDescription('Contains some sort of time stamp indicating when error 48 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error48_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 48, 2), Integer32()).setLabel("error48-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error48_code.setStatus('optional')
if mibBuilder.loadTexts: error48_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error49_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49, 1), Integer32()).setLabel("error49-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error49_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error49_time_stamp.setDescription('Contains some sort of time stamp indicating when error 49 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error49_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 49, 2), Integer32()).setLabel("error49-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error49_code.setStatus('optional')
if mibBuilder.loadTexts: error49_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
error50_time_stamp = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50, 1), Integer32()).setLabel("error50-time-stamp").setMaxAccess("readonly")
if mibBuilder.loadTexts: error50_time_stamp.setStatus('optional')
if mibBuilder.loadTexts: error50_time_stamp.setDescription('Contains some sort of time stamp indicating when error 50 occurred. Example time stamps include the actual time the error occurred (in seconds since Jan. 1, 1970), and the total engine page count. The device POS documents the meaning of the time stamp. Additional information: See ERROR1-TIME-STAMP.')
error50_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 11, 50, 2), Integer32()).setLabel("error50-code").setMaxAccess("readonly")
if mibBuilder.loadTexts: error50_code.setStatus('optional')
if mibBuilder.loadTexts: error50_code.setDescription('Contains a device specific error code. Each device POS should list what errors are logged to the error log and the meaning of each supported error code value. Additional information: See ERROR1-CODE.')
rpc_test_return_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 1, 1), OctetString()).setLabel("rpc-test-return-code").setMaxAccess("writeonly")
if mibBuilder.loadTexts: rpc_test_return_code.setStatus('optional')
if mibBuilder.loadTexts: rpc_test_return_code.setDescription("This test object that will not be supported in any released product. Setting this object allows the next RPC call return code to be specified. The POS will specify the binary format. Additional information: The format of the binary data is a one of three formats. The first format is no binary data, which indicates the next RPC reply should not be modified. The other two formats are described in RFC 1057 and encoded using XDR (i.e.e, the value is the data used to instead of the actual RPC reply). The second format is when reply_stat is MSG_ACCEPTED and accept_stat is something other than SUCCESS. The third format is when reply_stat is MSG_DENIED. Notice that all RPC replies that do not contain any 'results' are supported.")
rpc_bind_protocol_address = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 1, 2), OctetString()).setLabel("rpc-bind-protocol-address").setMaxAccess("readwrite")
if mibBuilder.loadTexts: rpc_bind_protocol_address.setStatus('optional')
if mibBuilder.loadTexts: rpc_bind_protocol_address.setDescription('Array of Berkeley sockets style protocol addresses used to bind RPC to a communications protocol family. Setting an instance of this array object to a zero length binary value disables the transport protocol indicated by that instance. All multi-bytes fields are in network (or big-endian) order. Bytes 1 and 2 indicate the transport protocol. Some of the transport protocol mapping information can be found in RFC 1010 Assigned Numbers. A list of interesting transport protocol number mappings include: Protocol | Number ---------+------- UDP/IP | 17 IPX | 1000 MLC | 4660 Bytes 3 and 4 indicate the address family. The address family uses the same mapping as the BSD sockets address family. A list of interesting address family mappings include: Address Family | Number ---------------+------- Internet | 2 NetWare | 6 MLC | 22136 The format the fifth and following bytes is dependent on the address family. For the Internet address family, bytes 5 and 6 contain the port number, bytes 7 through 10 contain the IP address, and the following eight bytes are unused. For NetWare, bytes 5 through 8 are the network number, bytes 9 through 14 are the node number, and bytes 15 and 16 are the socket number. Additional information: The length of the binary value is zero if the instance of an object in the rpc-bind-protocol-address array is not in use. An unfortuante side effect of the implementation is initializing the mass storage device sets this object back to the factory default value. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
rpc_statistic_successful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2, 1), Integer32()).setLabel("rpc-statistic-successful").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_statistic_successful.setStatus('optional')
if mibBuilder.loadTexts: rpc_statistic_successful.setDescription('A counter indicating the number of RPC requests that completed successfully (reply_data stat is SUCCESS). The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
rpc_statistic_unsuccessful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2, 2), Integer32()).setLabel("rpc-statistic-unsuccessful").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_statistic_unsuccessful.setStatus('optional')
if mibBuilder.loadTexts: rpc_statistic_unsuccessful.setDescription('A counter indicating the number of RPC requests that completed unsuccessfully (reply_data stat is not SUCCESS). The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
rpc_bound_protocol_address = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 2, 3), OctetString()).setLabel("rpc-bound-protocol-address").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_bound_protocol_address.setStatus('optional')
if mibBuilder.loadTexts: rpc_bound_protocol_address.setDescription('An array of Berkeley sockets style protocol addresses that the NFS service has been bound to successful. The format is that same as the array of RPC-BIND-PROTOCOL- ADDRESS of objects. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
nfs_server_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 1, 1), Integer32()).setLabel("nfs-server-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: nfs_server_memory.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_memory.setDescription('The amount of memory, in bytes, used by the Network File System server to buffer file data. Additional information: Roports the amount of memoyr, in bytes, reserved for use by the NFS server. An unfortunate side effect of the implementation is initializing the mass storage device sets this object back to the factory default value. Also includes the memory used by other firmware components in addition to the NFS server. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
nfs_server_read_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 1500))).setLabel("nfs-server-read-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: nfs_server_read_size.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_read_size.setDescription('The maximum amount of data transferred in one NFS server read data call. Additional information: An unfortunate side effect of the implementation is initializing the mass storage device sets this object back to the factory default value. Returns status if attempting to access this object and there is no storage device is installed. Rebooting causes this value to reset to factory default. Value < 256 snaps to 256 value > 1500 snaps to 1500.')
nfs_server_write_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 1500))).setLabel("nfs-server-write-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: nfs_server_write_size.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_write_size.setDescription('The maximum amount of data transferred in one NFS server write data call. Additional information: An unfortunate side effect of the implementation is initializing the mass storage device sets this object bact to the factory default value. Returns status if attempting to access this object and there is no storage device installed.')
nfs_server_test_return_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 1, 4), OctetString()).setLabel("nfs-server-test-return-code").setMaxAccess("writeonly")
if mibBuilder.loadTexts: nfs_server_test_return_code.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_test_return_code.setDescription('This test object that will not be supported in any released product. Setting this object allows the next NFS call return code to be specified. The POS will specify the binary format. Additional information: A three byte binary value. The first byte indicates what procedure is being effected by this set. value | function ------+------------------ 1 | GetAttr 2 | SetAttr 3 | reserved 4 | Lookup 5 | reserved 6 | Read 7 | reserved 8 | Write 9 | Create 10 | Remove 11 | Rename 12 | reserved 13 | reserved 14 | MkDir 15 | RmDir 16 | ReadDir 17 | StatFS The second byte is the stat value returned by the next call to procedure specified by the value of the first byte. The second byte can not be zero. Refer to RFC 1094 for a list of stat values. The third byte indicates which call to the specified file system routine will fail. A value of one means the first call will fail. A value of two means the second call will fail, and so on. Writing this boject causes any previous write to this boject to be invalidated.')
nfs_server_statistic_successful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 2, 1), Integer32()).setLabel("nfs-server-statistic-successful").setMaxAccess("readonly")
if mibBuilder.loadTexts: nfs_server_statistic_successful.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_statistic_successful.setDescription('A counter indicating the number of NFS requests that completed without error. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device installed.')
nfs_server_statistic_unsuccessful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 2, 2), Integer32()).setLabel("nfs-server-statistic-unsuccessful").setMaxAccess("readonly")
if mibBuilder.loadTexts: nfs_server_statistic_unsuccessful.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_statistic_unsuccessful.setDescription('A counter indicating the number of NFS requests that completed with an NFS status other than NFS_OK (0). The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device installed.')
nfs_server_statistic_current_memory_usage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 2, 4), Integer32()).setLabel("nfs-server-statistic-current-memory-usage").setMaxAccess("readonly")
if mibBuilder.loadTexts: nfs_server_statistic_current_memory_usage.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_statistic_current_memory_usage.setDescription('A value indicating the number of bytes of RAM currently used by the NFS firmware. Additional information: Resets to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device is installed.')
nfs_server_statistic_max_memory_usage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 2, 2, 5), Integer32()).setLabel("nfs-server-statistic-max-memory-usage").setMaxAccess("readonly")
if mibBuilder.loadTexts: nfs_server_statistic_max_memory_usage.setStatus('optional')
if mibBuilder.loadTexts: nfs_server_statistic_max_memory_usage.setDescription('A value indicating the maximum number of bytes of RAM used by the NFS firmware. The POS should state if the value is reset to zero after a power cycle. Additional information: Resets to the factory default value after a power cycle. Returns status if attempting to access this object and there is no storage device is installed.')
rpc_bind_test_return_code = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3, 1, 1), OctetString()).setLabel("rpc-bind-test-return-code").setMaxAccess("writeonly")
if mibBuilder.loadTexts: rpc_bind_test_return_code.setStatus('optional')
if mibBuilder.loadTexts: rpc_bind_test_return_code.setDescription('This test object that will not be supported in any released product. Setting this object allows the next RPC bind call return code to be specified. The POS will specify the binary format. Additional information: A one byte value. value | meaning ------+----------------------- 1 | Next GetPort or GetAddr will receive port 0 | (indicating the service is not supported). 2 | Next Dump will receive an empty table.')
rpc_bind_statistic_successful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3, 2, 1), Integer32()).setLabel("rpc-bind-statistic-successful").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_bind_statistic_successful.setStatus('optional')
if mibBuilder.loadTexts: rpc_bind_statistic_successful.setDescription('A counter indicating the number of RPC bind (RPC program number 100000, version 2) requests that completed successfully. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
rpc_bind_statistic_unsuccessful = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 13, 3, 3, 2, 2), Integer32()).setLabel("rpc-bind-statistic-unsuccessful").setMaxAccess("readonly")
if mibBuilder.loadTexts: rpc_bind_statistic_unsuccessful.setStatus('optional')
if mibBuilder.loadTexts: rpc_bind_statistic_unsuccessful.setDescription('A counter indicating the number of RPC bind (RPC program number 100000, version 2) requests that completed unsuccessfully. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
xip_statistic_processed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 14, 2, 1), Integer32()).setLabel("xip-statistic-processed").setMaxAccess("readonly")
if mibBuilder.loadTexts: xip_statistic_processed.setStatus('optional')
if mibBuilder.loadTexts: xip_statistic_processed.setDescription('A counter indicating the number of XIP requests that were processed. The POS should state if a power cycle causes the counter is be reset to zero. Additional information: The number of XIP datagrams that have been received by the XIP service. Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
xip_statistic_data_in_dropped = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 14, 2, 2), Integer32()).setLabel("xip-statistic-data-in-dropped").setMaxAccess("readonly")
if mibBuilder.loadTexts: xip_statistic_data_in_dropped.setStatus('optional')
if mibBuilder.loadTexts: xip_statistic_data_in_dropped.setDescription('A counter indicating the number of XIP data in datagrams that were dropped (typically due to the printer being flooded with XIP requests ). The POS should state if a power cycle causes the counter is be reset to zero. Additional information: Reset to the factory default value after a power cycle. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
io_timeout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 300))).setLabel("io-timeout").setMaxAccess("readwrite")
if mibBuilder.loadTexts: io_timeout.setStatus('optional')
if mibBuilder.loadTexts: io_timeout.setDescription('The amount of time, in seconds, to wait for more print job data to be received before an I/O timeout occurs. The I/O channel being timed is the I/O channel that received the data associated with the current print job. If an I/O timeout occurs, the PDL processing sub-system assumes all the data associated with the current print job has been received, and processes the end of job in an PDL specific manner. The POS specifies the supported values. Additional information: If an I/O timeout occurs, the PDL processing sub-system will consider it an end of job condition only if there is data from another I/O subsystem waiting to be processed. The suppurted values are 5 to 300 seconds and the step size is 10 seconds. Setting to a value outside the supported range returns <badValue> status and the value will be snapped to the nearest supported value.')
io_switch = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eYes", 1)))).setLabel("io-switch").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_switch.setStatus('optional')
if mibBuilder.loadTexts: io_switch.setDescription('Indicates if the device will switch between I/O channels when a job boundary is encountered and print job data is available on another I/O channel.')
io_buffering = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eAuto", 3)))).setLabel("io-buffering").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_buffering.setStatus('optional')
if mibBuilder.loadTexts: io_buffering.setDescription('Returns or controls the manner in which the device performs I/O data buffering. I/O data buffering allows additional print job data to be buffered by the I/O sub- system in an effort to allow the computer sending the data to perform other tasks and to keep the PDL processing sub-system busy. eOff, I/O buffering is disabled. When eOn, I/O buffering is enabled and the IO-BUFFER-SIZE object controls the amount of memory set aside for I/O buffer. When eAuto, I/O buffering is enabled and the I/O buffer size is determined automatically by the device and the IO-BUFFER-SIZE object is not used. Additional information: When eAuto, I/O buffering is enabled and the I/O buffer size is determined automatically by the device and the IO-BUFFER-SIZE object is not used.')
io_buffer_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 6), Integer32()).setLabel("io-buffer-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: io_buffer_size.setStatus('optional')
if mibBuilder.loadTexts: io_buffer_size.setDescription('Returns or configures the amount of memory, in bytes, dedicated to I/O print job data buffering. Attempting to set to an unsupported value causes the device to use the closest supported value. Each device POS should document the list of supported values. Additional information: When IO-BUFFERING is eAuto, the printer determines the value of this object. Reading this object when IO-BUFFERING is eAuto will return the value that is currently being used by the printer. The minimum value is 10240; the maximum value is the current value of this object plus the value of MAXIMUM-IO-BUFFERING-MEMORY. Supported values are multiples of 10240 for values less or equal to 97280 and multiples of 102400 for values greater than 97280. ')
maximum_io_buffering_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 1, 7), Integer32()).setLabel("maximum-io-buffering-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: maximum_io_buffering_memory.setStatus('optional')
if mibBuilder.loadTexts: maximum_io_buffering_memory.setDescription("This object's name is misleading. Returns the maximum amount of additional memory, in bytes, that can be dedicated to buffering print job data. Additional information: Memory for I/O Buffering is allocated in increments of 102400 bytes. Therefore, for each 1M (1048576 bytes) of memory added to the printer, 1024000 bytes are made available to resource saving (and I/O buffering) and 24576 bytes are retained until an additional 102400 byte block can be made available. The value reported by this object is always rounded down to the nearest multiple of 102400.")
port1_parallel_speed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eFast", 2)))).setLabel("port1-parallel-speed").setMaxAccess("readonly")
if mibBuilder.loadTexts: port1_parallel_speed.setStatus('optional')
if mibBuilder.loadTexts: port1_parallel_speed.setDescription('Returns or changes the maximum parallel I/O port speed, for port 1. This object is only supported if this port is a parallel port. An eSlow setting causes a 10 us busy pulse per received byte of data. An eFast setting causes a 1.5 us busy pulse per received byte of data. In rare cases, setting this value to eFast can cause the parallel port to no longer transfer data reliably. Additional information: Returns the maximum parallel I/O port speed, for port 1. This object is only supported if this port is a parallel port. An eFast setting causes a 1.5 us busy pulse per received byte of data. In rare cases, eFast can cause the parallel port to no longer transfer data reliably. ')
port1_parallel_bidirectionality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eBidirectional", 2)))).setLabel("port1-parallel-bidirectionality").setMaxAccess("readonly")
if mibBuilder.loadTexts: port1_parallel_bidirectionality.setStatus('optional')
if mibBuilder.loadTexts: port1_parallel_bidirectionality.setDescription("Returns or changes whether the parallel I/O port supports bidirectional communication for port 1. This object is only supported if this port is a parallel port. Additional information: Color LaserJet8550 will always be bi-directional. Thus, having this object here doesn't mean much... A get on this object returns the current mode for the parallel port.")
default_copies = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999))).setLabel("default-copies").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_copies.setStatus('optional')
if mibBuilder.loadTexts: default_copies.setDescription('Returns or changes default copies. Default copies is the default values used by the PDL to control the number of copies of each page in the print job that are printed. The print job can override this value. The list of supported values should be documented in the device POS. Additional information: The supported values are 1 through 999. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: <1 snaps to 1 >999 snaps to 999')
resource_saving = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eAuto", 3)))).setLabel("resource-saving").setMaxAccess("readonly")
if mibBuilder.loadTexts: resource_saving.setStatus('optional')
if mibBuilder.loadTexts: resource_saving.setDescription("Returns or changes PDL resource saving. Resource saving stores a PDL's permanent soft resources, like fonts, even when another PDL is active. Resource saving is also called environment saving. When eOff, resource saving is disabled. When ON, resource saving is enabled and memory is set aside for each PDL based on that PDL's resource saving memory size object, to store that PDL's permanent soft resources. When eAuto, resource saving is enabled and memory space for each installed PDL is determined automatically. The device POS should document what values are legal when only one PDL is installed. Additional information: Color LaserJet8550 only supports eAuto. Thus memory space for each installed PDL is determined automatically.")
maximum_resource_saving_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 7), Integer32()).setLabel("maximum-resource-saving-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: maximum_resource_saving_memory.setStatus('optional')
if mibBuilder.loadTexts: maximum_resource_saving_memory.setDescription("This object's name is misleading. This object returns the maximum amount of additional memory, in bytes, that can be dedicated to holding PDL permanent soft resources. Additional information: Base memory for Color LaserJet8550 is 32MB. Memories for PostScript and PCL are 3MB and 4MB respectively. However, for every 8MB increment, 0.5MB is added to each PDL. (((64 * 8) - 32) / 8) / 0.5 = 30MB. Thus, total memories for PostScript and PCL are 33MB and 34MB respectively.")
default_vertical_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 8), Integer32()).setLabel("default-vertical-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vertical_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_vertical_black_resolution.setDescription('Returns or changes the value of the default vertical black resolution. The units are dots per inch. Additional information: In Color LaserJet8550 changing this OID also causes DEFAULT-HORIZONTAL-BLACK-RESOLUTION to change. DEFAULT-HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported value is 600. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. < 300 snap to 600 >= 300 snap to 600')
default_horizontal_black_resolution = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 9), Integer32()).setLabel("default-horizontal-black-resolution").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_horizontal_black_resolution.setStatus('optional')
if mibBuilder.loadTexts: default_horizontal_black_resolution.setDescription('Returns or changes the value of the default horizontal black resolution. The units are dots per inch. Additional information: In Color LaserJet8550 changing this OID also causes DEFAULT- VERTICAL-BLACK RESOLUTION to change. DEFAULT- HORIZONTAL-BLACK-RESOLUTION and DEFAULT-VERTICAL-BLACK-RESOLUTION must always be the same. The supported value is 600. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: < 300 snap to 600 >= 300 snap to 600')
default_page_protect = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("eAuto", 3)))).setLabel("default-page-protect").setMaxAccess("readonly")
if mibBuilder.loadTexts: default_page_protect.setStatus('optional')
if mibBuilder.loadTexts: default_page_protect.setDescription("Returns or changes the default page protection behavior. If eOff, the device does not reserve memory for holding the entire raster form of a processed page. If eOn, then memory is reserved. If eAuto, the device determines the amount of memory to reserve. Additional information: In eAuto, the device determines the amount of memory to reserve. Color LaserJet8550 doesn't need to support this object. Thus, this object being here does not convey much meaning.")
default_lines_per_page = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 11), Integer32()).setLabel("default-lines-per-page").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_lines_per_page.setStatus('optional')
if mibBuilder.loadTexts: default_lines_per_page.setDescription('Returns or changes the default number of lines per page. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return the <noError>. Additional information: The supported values in Color LaserJet8550 are 5 to 128. Setting to an unsupported value causes the the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: <5 snaps to 5 >128 snaps to 128')
default_vmi = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 12), Integer32()).setLabel("default-vmi").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_vmi.setStatus('optional')
if mibBuilder.loadTexts: default_vmi.setDescription('Returns or changes the default vertical motion index. The unit of measure for VMI is centipoints per line. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>.')
default_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11, 25, 26, 27, 45, 46, 72, 80, 81, 90, 91, 100))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eJISB5", 45), ("eJISB4", 46), ("eJapanesePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100)))).setLabel("default-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_size.setStatus('optional')
if mibBuilder.loadTexts: default_media_size.setDescription("This indicates the default media size. A write of an unsupported value causes an <badValue>. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document.")
cold_reset_media_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 26))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eISOandJISA4", 26)))).setLabel("cold-reset-media-size").setMaxAccess("readwrite")
if mibBuilder.loadTexts: cold_reset_media_size.setStatus('optional')
if mibBuilder.loadTexts: cold_reset_media_size.setDescription('Returns or sets the media size that is used as the DEFAULT-MEDIA-SIZE when a cold reset occurs.')
default_media_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 1, 22), DisplayString()).setLabel("default-media-name").setMaxAccess("readwrite")
if mibBuilder.loadTexts: default_media_name.setStatus('optional')
if mibBuilder.loadTexts: default_media_name.setDescription('Returns or sets the media name that is used until the media name is changed by a print job command. Additional information: This string must be one of the MEDIAn-NAME objects.')
form_feed_needed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eFalse", 1)))).setLabel("form-feed-needed").setMaxAccess("readonly")
if mibBuilder.loadTexts: form_feed_needed.setStatus('optional')
if mibBuilder.loadTexts: form_feed_needed.setDescription('Indicates if the PDL processing sub-system has made marks on the current page and the source subsystem has been idle for a device specific amount of time. Additional information: This object in Color LaserJet8550 will never go to true.')
pcl_resource_saving_memory_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 2), Integer32()).setLabel("pcl-resource-saving-memory-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setStatus('optional')
if mibBuilder.loadTexts: pcl_resource_saving_memory_size.setDescription('Returns or changes the amount of resource saving memory set aside to hold permanent soft PCL resources. Additional information: The value returned by this object is the amount of Resource Saving memory currently dedicated to PCL. If a value is received that is between 1 and 409599, it will be snapped to 409600 and a status of <noError> returned. If an unsupported value greater than 409600 is received, it will be snapped down to the nearest 102400 value and a status of <noError> returned.')
pcl_total_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 5), Integer32()).setLabel("pcl-total-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: pcl_total_page_count.setStatus('optional')
if mibBuilder.loadTexts: pcl_total_page_count.setDescription('Total number of PCL pages printed by the device. Additional information: In Color LaserJet8550 the PCL page count is kept in NVRAM however the NVRAM value is only updated every 10 pages. NOTE: The value returned by this OID will be incremented every page but if power is lost between NVRAM updates, up to 9 pages of the page count may be lost. The page count counter will be reset to zero after 16,777,215 (2^24-1) pages. The page count is incremented when a sheet of media is pulled from an input tray. A duplex printed sheet will cause this counter to be incremented by two.')
pcl_default_font_height = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 13), Integer32()).setLabel("pcl-default-font-height").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_height.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_height.setDescription("Returns or changes the default PCL height. Height is an approximate measure of the body of the type in centipoints. A centipoint is 1/7200 inch. Height applies only to proportional fonts. Point size, in points, can be converted to font height, in centipoints, by multiplying the point size by 100. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: Supported values range from 400 to 99975, in increments of 25 units. Setting to an unsupported value causes the printer to substitute in a snap value and to return <noError> status. The snap values are as follow: <=400 snaps to 400 >=99975 snaps to 99975 Unsupported values in the range 400 to 99975 snaps DOWN to the previous supported value (i.e 25293 snaps to 25275 or 75038 snaps to 75025).")
pcl_default_font_source = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 13))).clone(namedValues=NamedValues(("eInternal", 1), ("ePermanentSoft", 2), ("eRomSimm1", 10), ("eRomSimm2", 11), ("eRomSimm3", 12), ("eRomSimm4", 13)))).setLabel("pcl-default-font-source").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_source.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_source.setDescription('Returns or changes the value of the default font source variable in NVRAM.')
pcl_default_font_number = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 999))).setLabel("pcl-default-font-number").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_number.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_number.setDescription('Returns or changes the value of the default font number variable in NVRAM. Writing an unsupported value causes the printer to generate an <badValue>.')
pcl_default_font_width = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 3, 16), Integer32()).setLabel("pcl-default-font-width").setMaxAccess("readwrite")
if mibBuilder.loadTexts: pcl_default_font_width.setStatus('optional')
if mibBuilder.loadTexts: pcl_default_font_width.setDescription("Returns or changes the default PCL font width. Width is expressed as the width of a character in centipoints. A centipoint is 1/7200 inch. Width applies only to fixed space fonts. Pitch, in character per inch, can be converted to font width, in centipoints, by dividing 7200 by the pitch. The POS indicates the supported values. An unsupported value causes the printer to use the closest supported value, causing the printer to return <noError>. ''Closest'' means the smallest absolute difference. Additional information: Setting to an unsupported value causes the printer to substitute in a snap value (listed below) and to return <noError> status. The snap values are as follow: <=44 snaps to 44 >=9999 snaps to 9999")
postscript_resource_saving_memory_size = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 2), Integer32()).setLabel("postscript-resource-saving-memory-size").setMaxAccess("readonly")
if mibBuilder.loadTexts: postscript_resource_saving_memory_size.setStatus('optional')
if mibBuilder.loadTexts: postscript_resource_saving_memory_size.setDescription('Returns or changes the amount of resource saving memory set aside to hold permanent soft PostScript resources. Additional information: The value returned by this object is the amount of Resource Saving memory currently dedicated to PostScript. If a value is received that is between 1 and 409599, it will be snapped to 409600 and a status of <noError> returned. If an unsupported value greater than 409600 is received, it will be snapped down to the nearest 102400 value and a status of <noError> returned.')
postscript_total_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 5), Integer32()).setLabel("postscript-total-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: postscript_total_page_count.setStatus('optional')
if mibBuilder.loadTexts: postscript_total_page_count.setDescription('Total number of PostScript pages printed by the device. Additional information: In Color LaserJet8550 the count is kept in NVRAM however the NVRAM value is only updated every 10 sheets. NOTE: The value returned by this OID will be incremented every sheet but if power is lost between NVRAM updates up to 9 sheets of the count may be lost. The counter will be reset to zero after 16,777,215 (2^24-1) pages. ')
postscript_print_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("postscript-print-errors").setMaxAccess("readwrite")
if mibBuilder.loadTexts: postscript_print_errors.setStatus('optional')
if mibBuilder.loadTexts: postscript_print_errors.setDescription('Returns or changes the value of the print PostScript errors setting. If eOn, PostScript prints an error page showing the error encountered and the stack at the time of the error.')
postscript_jam_recovery = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 3, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eOn", 2)))).setLabel("postscript-jam-recovery").setMaxAccess("readonly")
if mibBuilder.loadTexts: postscript_jam_recovery.setStatus('optional')
if mibBuilder.loadTexts: postscript_jam_recovery.setDescription('Returns or changes the PostScript jam recovery setting. If eOn, then the device will reprint PostScript pages, if those pages jam. Additional information: Returns the Postscript jam recovery setting. If eOn, then the device will reprint PostScript pages, if those pages jam.')
pjl_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 5, 1), Integer32()).setLabel("pjl-password").setMaxAccess("readonly")
if mibBuilder.loadTexts: pjl_password.setStatus('optional')
if mibBuilder.loadTexts: pjl_password.setDescription('Returns PJL password, if the password is not set (zero). If the password is set, then attempting to retrieve the password causes an <genErr> to occur and will return the <NullValue>.')
jetsend_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eOff", 1), ("eOn", 2)))).setLabel("jetsend-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: jetsend_mode.setStatus('optional')
if mibBuilder.loadTexts: jetsend_mode.setDescription('Enables or disables the JetSend processing sub-system. Additional information: Enables or disables the JetSend processing subsystem. The valid values are eOff and eOn. (Specifying an invalid mode causes an <badValue> error to be returned.)')
jetsend_contact_password = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 3, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("jetsend-contact-password").setMaxAccess("writeonly")
if mibBuilder.loadTexts: jetsend_contact_password.setStatus('optional')
if mibBuilder.loadTexts: jetsend_contact_password.setDescription("A C structure containing the following fields: typedef struct { ubyte old_password[8]; ubyte new_password[8];/ } jetsend_change_contact_password_t; where ubyte is an unsigned byte (0-255). Additional information: Controls access to the JetSend processing subsystem. Password absence/presence determines whether the device will allow a session to be established. The following C data structure contains the relevant fields (described in subsequent paragraphs): typedef struct { unsigned char old_password[8]; unsigned char new_password[8]; } Whenever the password is disabled (i.e., is zero-filled for its entire length), the device is indicating its willingness to allow session establishment. Whenever the password is enabled (i.e., has one or more non-zero-filled values), the device is controlling session establishment -- all in-progress JetSend sessions must supply a matching password or the device will reject the in-progress session. To disable the password, specify the matching password via the 'old_password' field and zero-fill the 'new_password' field. To enable the password for the first time, zero-fill the 'old_password' field and specify the new password via the 'new_password' field (the new password should not be zero-filled; otherwise, the password will remain disabled). To enable or change the password thereafter, specify the matching password via the 'old_password' field and specify the new password via the 'new_password' field (the new desired password should not be zero-filled; otherwise, the password will be disabled). To determine if the password is enabled, zero-fill both the 'old_password' and 'new_password' fields. If an error occurs, the password is enabled; otherwise, the password is disabled. (Specifying either an 'old_password' or 'new_password' fields greater than eight (8) bytes causes the error <badValue> to be returned.)")
jetsend_contact_ip_address_security = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 3, 8, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("jetsend-contact-ip-address-security").setMaxAccess("writeonly")
if mibBuilder.loadTexts: jetsend_contact_ip_address_security.setStatus('optional')
if mibBuilder.loadTexts: jetsend_contact_ip_address_security.setDescription("A C structure containing the following fields: typedef struct { ubyte reserved[3]; ubyte command; /* command: 0 to 1 */ ubyte password[8]; ubyte IPAddress[4]; } jetsend_contact_ip_address_security_t; where ubyte is an unsigned byte (0-255). The defined values defined for command are: When command is 0: IPAddress is 0: device is locked, no one can contact it IPAddress is > 0: only that address is allowed to contact the device When command is 1: IPAddress is 0: any device can contact it IPAddress is > 0: any device matching this mask can contact it. If the result of logically anding the mask value supplied in the IPAddress field with the sending device's IP address matches the result of logically anding the mask value supplied in the IPAddress field with this device's IP address, then JetSend will allow the session to be established. Additional information: Controls the device or class of device(s) which may communicate with the JetSend processing subsystem. The following C data structure contains the relevant fields (described in subsequent paragraphs): typedef struct { unsigned char reserved[3]; unsigned char command; unsigned char password[8]; unsigned char IPAddress[4]; } The 'reserved' field is not used and should remain zero-filled. The 'command' field interpretation differs based on its value: 0 = Accept session(s) only from the specific device whose IP address matches the specified IP address; all other session request(s) from non-matching device(s) are rejected. 1 = Accept session(s) only from the specific device(s) whose IP address(es) conform to the mask specified in the 'IPAddress' field; all other session request(s) from device(s) with non-matching submask(s) are rejected. (If the result of logically AND'ing the mask value supplied in the 'IPAddress' field with the sending device's IP address matches the result of logically AND'ing the mask value supplied in the 'IPAddress' field with this device's IP address, then JetSend will allow session establishment. Password absence/presence determines whether the device will allow the caller to alter the IP address security. If the password is disabled, the caller may set the 'command' and 'IPAddress' fields directly. If the password is enabled, the caller may (re-)set the 'command' and 'IPAddress' fields only after specifying the matching 'password' field. (Refer to the aforementioned 'JETSEND-CONTACT-PASSWORD' object ID.) (Specifying either an invalid 'command' field value or a 'password' field greater than eight (8) bytes or an 'IPAddress' field greater than four (4) bytes causes the error <badValue> to be returned.)")
total_color_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967296))).setLabel("total-color-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: total_color_page_count.setStatus('optional')
if mibBuilder.loadTexts: total_color_page_count.setDescription('Total number of color pages printed by the device. Additional information: Any page with one or more color pixels is counted as a color page. Pages that only contain black marks are not counted by this object. The counter will roll over to zero after 4,294,967,296 pages. Each side of a duplexed sheet of media will be counted independently based on the criteria listed above.')
duplex_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 2, 22), Integer32()).setLabel("duplex-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: duplex_page_count.setStatus('optional')
if mibBuilder.loadTexts: duplex_page_count.setDescription('Total number of sheets of media that have been duplex printed. A sheet is counted if it travels through the duplex page path, regardless of whether or not marks are made on the page. The POS will indicate if the value is kept in NVRAM. Additional information: In Color LaserJet8550 the count is kept in NVRAM however the NVRAM value is only updated every 10 sheets. NOTE: The value returned by this OID will be incremented every sheet but if power is lost between NVRAM updates up to 9 sheets of the count may be lost. The counter will be reset to zero after 16,777,215 (2^24-1) pages. ')
mp_tray = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("eCassette", 2), ("eFirst", 3)))).setLabel("mp-tray").setMaxAccess("readwrite")
if mibBuilder.loadTexts: mp_tray.setStatus('optional')
if mibBuilder.loadTexts: mp_tray.setDescription("Returns or changes the value of the multi-purpose (MP) tray configuration variable. The MP tray can be configured to operate as an additional input tray (eCassette), a manual feed slot (eManual), or in a manner compatible with the LaserJet III manual feed slot (eFirst). If configured for eFirst, if media is present in the MP tray, that media is used (assuming the size matches and the print job didn't specify another tray) until the MP tray is empty.")
custom_paper_dim_unit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("eTenThousandthsOfInches", 3), ("eMicrometers", 4)))).setLabel("custom-paper-dim-unit").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_dim_unit.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_dim_unit.setDescription("The units of measure used to specify the width and height of the printer's custom paper. The unit of measure of eTenThousandthsOfInches is 0.0001 inches. Additional information: The only valid values for this object are eTenThousandthsOfInches (3), and eMicrometers (4). The data for this object is stored in NVRAM.")
custom_paper_feed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 8), Integer32()).setLabel("custom-paper-feed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_feed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_feed_dim.setDescription("Sets the printer's custom paper dimension in the feed direction (direction parallel to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range for Color LaserJet8550 is 75000 to 177000 if CUSTOM-PAPER-DIM-UNIT is eTenthousandthoOfInches or 190500 to 449580 if CUSTOM-APPER-DIM-UNIT is eMicrometers. Attempts to set this object outside the valid range will result in a return value of <badValue>. The data for this object is stored in NVRAM.")
custom_paper_xfeed_dim = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 1, 9), Integer32()).setLabel("custom-paper-xfeed-dim").setMaxAccess("readwrite")
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setStatus('optional')
if mibBuilder.loadTexts: custom_paper_xfeed_dim.setDescription("Sets the printer's custom paper dimension in the cross- feed direction (direction ninety degrees relative to the direction of paper feeding). The value for this object is specified in micrometers or tenthousandths of an inch, depending upon the value of CUSTOM-PAPER-DIM-UNIT. The valid range is engine-dependent and should be documented in the POS for each product. Additional information: The valid range for Color LaserJet8550 is 36700 to 117000 if CUSTOM-PAPER-DIM-UNIT is eTenthousandthoOfInches or 93218 to 297180 if CUSTOM-APPER-DIM-UNIT is eMicrometers. Attempts to set this object outside the valid range will result in a return value of <badValue>. The data for this object is stored in NVRAM.")
tray1_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 11, 25, 26, 27, 45, 46, 72, 80, 81, 90, 91, 100, 101))).clone(namedValues=NamedValues(("eUSExecutive", 1), ("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eISOandJISA5", 25), ("eISOandJISA4", 26), ("eISOandJISA3", 27), ("eJISB5", 45), ("eJISB4", 46), ("eJapansePostcardDouble", 72), ("eMonarch", 80), ("eCommercial10", 81), ("eInternationalDL", 90), ("eInternationalC5", 91), ("eInternationalB5", 100), ("eCustom", 101)))).setLabel("tray1-media-size-loaded").setMaxAccess("readwrite")
if mibBuilder.loadTexts: tray1_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray1_media_size_loaded.setDescription("Returns the media size that is currently configuredconfigured in tray #1. This object can be set to indicate the media size currently loaded, if the printer supports input trays that can not sense the media size. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: Returns the media size that is currently configured in tray #1. This object can be set to indicate the media size currently loaded, if the printer supports input trays that cannot sense the media size. Complete list of supported media sizes along with their dimensions are listed in the 'Media Size Table' near the end of this document. This tray is built in and therefore, always installed.")
tray1_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 1, 12), Integer32()).setLabel("tray1-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray1_phd.setStatus('optional')
if mibBuilder.loadTexts: tray1_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray.')
tray2_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 26, 46))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eUSLegal", 3), ("eISOandJISA4", 26), ("eJISB4", 46)))).setLabel("tray2-media-size-loaded").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray2_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray2_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #2. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: If the tray drawer is open, a get on this object will cause a status of <genErr> to be returned. If the tray is empty, the size that the tray is configured for will be returned.")
tray2_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 2, 12), Integer32()).setLabel("tray2-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray2_phd.setStatus('optional')
if mibBuilder.loadTexts: tray2_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray.')
tray3_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 11, 27, 26, 46))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eISOandJISA3", 27), ("eISOandJISA4", 26), ("eJISB4", 46)))).setLabel("tray3-media-size-loaded").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray3_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray3_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #3. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: The Media Size Table does not exist in this document.")
tray3_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 3, 12), Integer32()).setLabel("tray3-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray3_phd.setStatus('optional')
if mibBuilder.loadTexts: tray3_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray.')
tray4_media_size_loaded = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 11, 27, 26, 46))).clone(namedValues=NamedValues(("eUSLetter", 2), ("eUSLegal", 3), ("eLedger", 11), ("eISOandJISA3", 27), ("eISOandJISA4", 26), ("eJISB4", 46)))).setLabel("tray4-media-size-loaded").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray4_media_size_loaded.setStatus('optional')
if mibBuilder.loadTexts: tray4_media_size_loaded.setDescription("Returns the media size that is currently configured in tray #4. Complete list of supported media sizes along with their dimensions are listed in the ''Media Size Table'' near the end of this document. Additional information: The Media Size Table does not exist in this document. Attempting to access this object when the tray is not installed will result in an ErrorUnknownObjectIdentifier response from the printer.")
tray4_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 4, 12), Integer32()).setLabel("tray4-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray4_phd.setStatus('optional')
if mibBuilder.loadTexts: tray4_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray.')
tray5_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 3, 3, 5, 12), Integer32()).setLabel("tray5-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: tray5_phd.setStatus('optional')
if mibBuilder.loadTexts: tray5_phd.setDescription('Provides the number of the Paper Handling Device that contains this input tray.')
overflow_bin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 1, 4), Integer32()).setLabel("overflow-bin").setMaxAccess("readonly")
if mibBuilder.loadTexts: overflow_bin.setStatus('optional')
if mibBuilder.loadTexts: overflow_bin.setDescription('Returns or sets the bin that will be used for additional sheets of media when the current bin is full and printing is allowed to continue. Additional information: If this object is set to zero, overflowing to another bin is not allowed.')
outbin1_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 1, 9), OctetString()).setLabel("outbin1-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin1_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin1_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: If cCancelJob is set, the current print job will be cancelled regardless of other item settings. If cOutbinFullOverride is set and this bin is the designated overflow bin (OVERFLOW-BIN = 1), then the bit is ignored. This object describes the action that is performed when the JOB-OUTPUT-AUTO-CONTINUE-TIMEOUT expires. If no bits are set, no override action is taken (the printer will continue to wait). The action performed by the CONTINUE object being set to eInitiateAction or the GO key being pressed on the control panel may cause different actions. See the CONTINUE object description for information on the actions that occur for those conditions.')
outbin2_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 2, 9), OctetString()).setLabel("outbin2-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin2_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin2_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin3_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 9), OctetString()).setLabel("outbin3-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin3_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin3_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin3_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 3, 11), Integer32()).setLabel("outbin3-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin3_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin3_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin4_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 9), OctetString()).setLabel("outbin4-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin4_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin4_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin4_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 4, 11), Integer32()).setLabel("outbin4-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin4_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin4_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin5_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 9), OctetString()).setLabel("outbin5-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin5_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin5_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin5_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 5, 11), Integer32()).setLabel("outbin5-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin5_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin5_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin6_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 6, 9), OctetString()).setLabel("outbin6-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin6_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin6_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin6_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 6, 11), Integer32()).setLabel("outbin6-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin6_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin6_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin7_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 7, 9), OctetString()).setLabel("outbin7-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin7_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin7_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin7_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 7, 11), Integer32()).setLabel("outbin7-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin7_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin7_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin8_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 8, 9), OctetString()).setLabel("outbin8-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin8_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin8_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin8_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 8, 11), Integer32()).setLabel("outbin8-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin8_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin8_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin9_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 9, 9), OctetString()).setLabel("outbin9-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin9_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin9_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin9_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 9, 11), Integer32()).setLabel("outbin9-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin9_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin9_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin10_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 10, 9), OctetString()).setLabel("outbin10-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin10_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin10_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin10_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 10, 11), Integer32()).setLabel("outbin10-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin10_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin10_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
outbin11_override_mode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 11, 9), OctetString()).setLabel("outbin11-override-mode").setMaxAccess("readwrite")
if mibBuilder.loadTexts: outbin11_override_mode.setStatus('optional')
if mibBuilder.loadTexts: outbin11_override_mode.setDescription('Returns or sets the device behavior when this output bin condition causes printing to stop. cCancelJob - The device cancels the job. cOutbinFullOverride - The device sends subsequent media to the overflow bin. cOutbinAttentionOverride - The device ignores the attention condition and continues printing. cBinderAttentionOverride - The device ignores the binder attention condition and continues printing. Additional information: See OUTBIN1-OVERRIDE-MODE.')
outbin11_phd = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 4, 3, 11, 11), Integer32()).setLabel("outbin11-phd").setMaxAccess("readonly")
if mibBuilder.loadTexts: outbin11_phd.setStatus('optional')
if mibBuilder.loadTexts: outbin11_phd.setDescription('Provides the number of the Paper Handling Device that contains this output bin.')
low_marking_agent_processing = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eStop", 1), ("eCont", 2)))).setLabel("low-marking-agent-processing").setMaxAccess("readwrite")
if mibBuilder.loadTexts: low_marking_agent_processing.setStatus('optional')
if mibBuilder.loadTexts: low_marking_agent_processing.setDescription('Returns or changes how the device processes a low marking agent event. If eCont, then the device continues to print. If eStop, then the device stops until a continue event occurs.')
default_ret = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("eOff", 1)))).setLabel("default-ret").setMaxAccess("readonly")
if mibBuilder.loadTexts: default_ret.setStatus('optional')
if mibBuilder.loadTexts: default_ret.setDescription("Returns or changes the Resolution Enhancement Technology setting. Devices that only support eOff and on should map all other values to on and always return the same non-eOff value to indicate on. The list of supported values should be documented in the device POS. Additional information: Color LaserJet8550 doesn't have RET.")
default_print_quality = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 6, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 100))).setLabel("default-print-quality").setMaxAccess("readonly")
if mibBuilder.loadTexts: default_print_quality.setStatus('optional')
if mibBuilder.loadTexts: default_print_quality.setDescription('Returns or sets the default print quality. A value of zero has the lowest print quality. A value of 100 has the highest print quality. Each POS should document what values in the 0 to 100 range are supported. Additional information: In Color LaserJet8550, the supported value is 100. A value of 100 corresponds to ECONOMODE=OFF.')
phd2_device_specific_command = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 2, 2), OctetString()).setLabel("phd2-device-specific-command").setMaxAccess("writeonly")
if mibBuilder.loadTexts: phd2_device_specific_command.setStatus('optional')
if mibBuilder.loadTexts: phd2_device_specific_command.setDescription('This object is used to send device-specific data to the paper handling device. The meaning of the device- specific command is dependent on the paper handling device and must be specified in the POS. If the paper handling device does not accept the command, then an <badValue> will be returned. If the device accepts the command, it may still be processing the command after the response has been returned. Depending on the device, the application may need to query PHDx-DEVICE-MEMORY to see when the command has completed. Additional information: If at least one (1) external paper handling device is attached to the printer, then this object will exist. Not applicable if the value of PHD2-TYPE is eEmpty. Since it will usually take longer to send this command to the device than PML allows for <set> operations, this object will have a return value that does not necessarily match the value currently received by the first device.')
phd2_device_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 2, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("phd2-device-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd2_device_memory.setStatus('optional')
if mibBuilder.loadTexts: phd2_device_memory.setDescription("This object is used to read the current values stored in shared memory available from the paper handling device. Additional information: If at least one external paper handling devices are attached to the printer, then this object will exist. Not applicable if the value of PHD2-TYPE is eEmpty. This object returns the current memory stored in the printer's NVRAM (non-volatile RAM) for the first paper handling device. Currently, the printer allocates 16 bytes for each device.")
phd3_device_specific_command = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 3, 2), OctetString()).setLabel("phd3-device-specific-command").setMaxAccess("writeonly")
if mibBuilder.loadTexts: phd3_device_specific_command.setStatus('optional')
if mibBuilder.loadTexts: phd3_device_specific_command.setDescription('This object is used to send device-specific data to the paper handling device. The meaning of the device- specific command is dependent on the paper handling device and must be specified in the POS. If the paper handling device does not accept the command, then an <badValue> will be returned. If the device accepts the command, it may still be processing the command after the response has been returned. Depending on the device, the application may need to query PHDx-DEVICE-MEMORY to see when the command has completed. Additional information: If at least two (2) external paper handling devices are attached to the printer, then this object will exist. Not applicable if the value of PHD3-TYPE is eEmpty. Since it will usually take longer to send this command to the device than PML allows for <Set> operations, this object will have a return value that does not necessarily match the value currently received by the second device.')
phd3_device_memory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 7, 3, 3, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setLabel("phd3-device-memory").setMaxAccess("readonly")
if mibBuilder.loadTexts: phd3_device_memory.setStatus('optional')
if mibBuilder.loadTexts: phd3_device_memory.setDescription("This object is used to read the current values stored in shared memory available from the paper handling device. Additional information: If at least two external paper handling devices are attached to the printer, then this object will exist. Not applicable if the value of PHD3-TYPE is eEmpty. This object returns the current memory stored in the printer's NVRAM (non-volatile RAM) for the second paper handling device. Currently, the printer allocates 16 bytes for each device.")
media_names_available = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 1, 1), OctetString()).setLabel("media-names-available").setMaxAccess("readwrite")
if mibBuilder.loadTexts: media_names_available.setStatus('optional')
if mibBuilder.loadTexts: media_names_available.setDescription('The value of this object controls which of the MEDIAx- NAME objects are supported. If a bit is set to zero, then attempting to get or set the corresponding MEDIAx- NAME objects will return <noSuchName>. Additional information: Setting a bit to one will cause the corresponding MEDIAn- objects to be available (attempting to access an unavailable object will return <noSuchName>). MEDIA1- objects are always present in Color LaserJet8550, as this is the default media. If this object is set to a value that does not include cMediaName1Available, that bit will be set and a status of <noError> will be returned.')
media1_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 1), DisplayString()).setLabel("media1-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_name.setStatus('optional')
if mibBuilder.loadTexts: media1_name.setDescription('Media 1 name. Additional information: The symbol set for this string is Roman-8.')
media1_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 2), DisplayString()).setLabel("media1-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_short_name.setStatus('optional')
if mibBuilder.loadTexts: media1_short_name.setDescription("Length restricted version of the media name 1. The length restriction is required to allow the media name to be displayed on the device's control panel. The device POS must state the maximum number of characters allowed. If the device also has a limitation on what characters in a character set can be used (e.g. only uppercase characters allowed), the POS should also state character restrictions. Additional information: The Maximum supported string length is 9 characters. If the user entered string is too long, the device will store the first 9 characters and will return the <noError> status.")
media1_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 1, 3), Integer32()).setLabel("media1-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media1_page_count.setStatus('optional')
if mibBuilder.loadTexts: media1_page_count.setDescription('Number of sheets of media 1 that have been printed. The device POS should state whether this value is lost across a power cycle or kept in NVRAM. Additional information: In Color LaserJet8550 the media page count saved in NVRAM after every 10 pages. The maximum value is 4,294,967,295 which will never be reached in normal operation. The page count is incremented when a sheet of media is pulled from an input tray. A duplex printed sheet will cause this counter to be incremented by one.')
media2_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 1), DisplayString()).setLabel("media2-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_name.setStatus('optional')
if mibBuilder.loadTexts: media2_name.setDescription('Media 2 name. Additional information: See MEDIA1-NAME.')
media2_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 2), DisplayString()).setLabel("media2-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_short_name.setStatus('optional')
if mibBuilder.loadTexts: media2_short_name.setDescription('Length restricted version of the media name 2. See MEDIA1-SHORT-NAME for details.')
media2_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 2, 3), Integer32()).setLabel("media2-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media2_page_count.setStatus('optional')
if mibBuilder.loadTexts: media2_page_count.setDescription('Number of sheets of media 2 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media3_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 1), DisplayString()).setLabel("media3-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_name.setStatus('optional')
if mibBuilder.loadTexts: media3_name.setDescription('Media 3 name. Additional information: See MEDIA1-NAME.')
media3_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 2), DisplayString()).setLabel("media3-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_short_name.setStatus('optional')
if mibBuilder.loadTexts: media3_short_name.setDescription('Length restricted version of the media name 3. See MEDIA1-SHORT-NAME for details.')
media3_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 3, 3), Integer32()).setLabel("media3-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media3_page_count.setStatus('optional')
if mibBuilder.loadTexts: media3_page_count.setDescription('Number of sheets of media 3 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media4_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 1), DisplayString()).setLabel("media4-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_name.setStatus('optional')
if mibBuilder.loadTexts: media4_name.setDescription('Media 4 name. Additional information: See MEDIA1-NAME.')
media4_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 2), DisplayString()).setLabel("media4-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_short_name.setStatus('optional')
if mibBuilder.loadTexts: media4_short_name.setDescription('Length restricted version of the media name 4. See MEDIA1-SHORT-NAME for details.')
media4_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 4, 3), Integer32()).setLabel("media4-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media4_page_count.setStatus('optional')
if mibBuilder.loadTexts: media4_page_count.setDescription('Number of sheets of media 4 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media5_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 1), DisplayString()).setLabel("media5-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_name.setStatus('optional')
if mibBuilder.loadTexts: media5_name.setDescription('Media 5 name. Additional information: See MEDIA1-NAME.')
media5_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 2), DisplayString()).setLabel("media5-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_short_name.setStatus('optional')
if mibBuilder.loadTexts: media5_short_name.setDescription('Length restricted version of the media name 5. See MEDIA1-SHORT-NAME for details.')
media5_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 5, 3), Integer32()).setLabel("media5-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media5_page_count.setStatus('optional')
if mibBuilder.loadTexts: media5_page_count.setDescription('Number of sheets of media 5 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media6_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 1), DisplayString()).setLabel("media6-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_name.setStatus('optional')
if mibBuilder.loadTexts: media6_name.setDescription('Media 6 name. Additional information: See MEDIA1-NAME.')
media6_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 2), DisplayString()).setLabel("media6-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_short_name.setStatus('optional')
if mibBuilder.loadTexts: media6_short_name.setDescription('Length restricted version of the media name 6. See MEDIA1-SHORT-NAME for details.')
media6_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 6, 3), Integer32()).setLabel("media6-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media6_page_count.setStatus('optional')
if mibBuilder.loadTexts: media6_page_count.setDescription('Number of sheets of media 6 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media7_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 1), DisplayString()).setLabel("media7-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_name.setStatus('optional')
if mibBuilder.loadTexts: media7_name.setDescription('Media 7 name. Additional information: See MEDIA1-NAME.')
media7_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 2), DisplayString()).setLabel("media7-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_short_name.setStatus('optional')
if mibBuilder.loadTexts: media7_short_name.setDescription('Length restricted version of the media name 7. See MEDIA1-SHORT-NAME for details.')
media7_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 7, 3), Integer32()).setLabel("media7-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media7_page_count.setStatus('optional')
if mibBuilder.loadTexts: media7_page_count.setDescription('Number of sheets of media 7 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media8_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 1), DisplayString()).setLabel("media8-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_name.setStatus('optional')
if mibBuilder.loadTexts: media8_name.setDescription('Media 8 name. Additional information: See MEDIA1-NAME.')
media8_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 2), DisplayString()).setLabel("media8-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_short_name.setStatus('optional')
if mibBuilder.loadTexts: media8_short_name.setDescription('Length restricted version of the media name 8. See MEDIA1-SHORT-NAME for details.')
media8_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 8, 3), Integer32()).setLabel("media8-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media8_page_count.setStatus('optional')
if mibBuilder.loadTexts: media8_page_count.setDescription('Number of sheets of media 8 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media9_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 1), DisplayString()).setLabel("media9-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_name.setStatus('optional')
if mibBuilder.loadTexts: media9_name.setDescription('Media 9 name. Additional information: See MEDIA1-NAME.')
media9_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 2), DisplayString()).setLabel("media9-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_short_name.setStatus('optional')
if mibBuilder.loadTexts: media9_short_name.setDescription('Length restricted version of the media name 9. See MEDIA1-SHORT-NAME for details.')
media9_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 9, 3), Integer32()).setLabel("media9-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media9_page_count.setStatus('optional')
if mibBuilder.loadTexts: media9_page_count.setDescription('Number of sheets of media 9 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media10_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 1), DisplayString()).setLabel("media10-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_name.setStatus('optional')
if mibBuilder.loadTexts: media10_name.setDescription('Media 10 name. Additional information: See MEDIA1-NAME.')
media10_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 2), DisplayString()).setLabel("media10-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_short_name.setStatus('optional')
if mibBuilder.loadTexts: media10_short_name.setDescription('Length restricted version of the media name 10. See MEDIA1-SHORT-NAME for details.')
media10_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 10, 3), Integer32()).setLabel("media10-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media10_page_count.setStatus('optional')
if mibBuilder.loadTexts: media10_page_count.setDescription('Number of sheets of media 10 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media11_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 1), DisplayString()).setLabel("media11-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_name.setStatus('optional')
if mibBuilder.loadTexts: media11_name.setDescription('Media 11 name. Additional information: See MEDIA1-NAME.')
media11_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 2), DisplayString()).setLabel("media11-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_short_name.setStatus('optional')
if mibBuilder.loadTexts: media11_short_name.setDescription('Length restricted version of the media name 11. See MEDIA1-SHORT-NAME for details.')
media11_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 11, 3), Integer32()).setLabel("media11-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media11_page_count.setStatus('optional')
if mibBuilder.loadTexts: media11_page_count.setDescription('Number of sheets of media 11 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media12_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 1), DisplayString()).setLabel("media12-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_name.setStatus('optional')
if mibBuilder.loadTexts: media12_name.setDescription('Media 12 name. Additional information: See MEDIA1-NAME.')
media12_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 2), DisplayString()).setLabel("media12-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_short_name.setStatus('optional')
if mibBuilder.loadTexts: media12_short_name.setDescription('Length restricted version of the media name 12. See MEDIA1-SHORT-NAME for details.')
media12_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 12, 3), Integer32()).setLabel("media12-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media12_page_count.setStatus('optional')
if mibBuilder.loadTexts: media12_page_count.setDescription('Number of sheets of media 12 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media13_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 1), DisplayString()).setLabel("media13-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_name.setStatus('optional')
if mibBuilder.loadTexts: media13_name.setDescription('Media 13 name. Additional information: See MEDIA1-NAME.')
media13_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 2), DisplayString()).setLabel("media13-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_short_name.setStatus('optional')
if mibBuilder.loadTexts: media13_short_name.setDescription('Length restricted version of the media name 13. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media13_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 13, 3), Integer32()).setLabel("media13-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media13_page_count.setStatus('optional')
if mibBuilder.loadTexts: media13_page_count.setDescription('Number of sheets of media 13 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media14_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 1), DisplayString()).setLabel("media14-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_name.setStatus('optional')
if mibBuilder.loadTexts: media14_name.setDescription('Media 14 name. Additional information: See MEDIA1-NAME.')
media14_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 2), DisplayString()).setLabel("media14-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_short_name.setStatus('optional')
if mibBuilder.loadTexts: media14_short_name.setDescription('Length restricted version of the media name 14. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media14_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 14, 3), Integer32()).setLabel("media14-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media14_page_count.setStatus('optional')
if mibBuilder.loadTexts: media14_page_count.setDescription('Number of sheets of media 14 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
media15_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 1), DisplayString()).setLabel("media15-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_name.setStatus('optional')
if mibBuilder.loadTexts: media15_name.setDescription('Media 15 name. Additional information: See MEDIA1-NAME.')
media15_short_name = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 2), DisplayString()).setLabel("media15-short-name").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_short_name.setStatus('optional')
if mibBuilder.loadTexts: media15_short_name.setDescription('Length restricted version of the media name 15. See MEDIA1-SHORT-NAME for details. Additional information: See MEDIA1-SHORT-NAME.')
media15_page_count = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 8, 3, 15, 3), Integer32()).setLabel("media15-page-count").setMaxAccess("readonly")
if mibBuilder.loadTexts: media15_page_count.setStatus('optional')
if mibBuilder.loadTexts: media15_page_count.setDescription('Number of sheets of media 15 that have been printed. See MEDIA1-PAGE-COUNT for details. Additional information: See MEDIA1-PAGE-COUNT.')
channel_bytes_sent = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 2), Integer32()).setLabel("channel-bytes-sent").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_sent.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_sent.setDescription('The low order 31 bits of the number of bytes sent from the printer to the host on this logical channel.')
channel_bytes_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 3), Integer32()).setLabel("channel-bytes-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_bytes_received.setStatus('optional')
if mibBuilder.loadTexts: channel_bytes_received.setDescription('The low order 31 bits of the number of bytes received by the printer from the host on this logical channel.')
channel_io_errors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 4), Integer32()).setLabel("channel-io-errors").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_io_errors.setStatus('optional')
if mibBuilder.loadTexts: channel_io_errors.setDescription('The low order 31 bits of the number of I/O errors which have occured on this logical channel.')
channel_jobs_received = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 5), Integer32()).setLabel("channel-jobs-received").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_jobs_received.setStatus('optional')
if mibBuilder.loadTexts: channel_jobs_received.setDescription('The low order 31 bits of the number of print jobs which have been received on this logical channel.')
channel_mio = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 7, 2, 1, 6), Integer32()).setLabel("channel-mio").setMaxAccess("readonly")
if mibBuilder.loadTexts: channel_mio.setStatus('optional')
if mibBuilder.loadTexts: channel_mio.setDescription("The number of the MIO card associated with this logical channel. If this logical channel is not associated with an MIO card a zero is returned. The value returned for each logical channel is the MIO card's physical slot number. The list of supported values should be documented in the device POS. Additional information: The value returned will be zero for channel one. If an MIOA card is installed, channels 3..18 will return a value of one or two and, if an MIOB card is installed, 19-34 will return a value of one or two, but not the same as channels 3..18. When two MIO cards are installed, the value returned by any channel 3..34 may change after the printer is power cycled.")
mass_storage_resource_change_counter = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3, 1), Integer32()).setLabel("mass-storage-resource-change-counter").setMaxAccess("readonly")
if mibBuilder.loadTexts: mass_storage_resource_change_counter.setStatus('optional')
if mibBuilder.loadTexts: mass_storage_resource_change_counter.setDescription('A counter which changes when a mass storage based resource has been added or deleted. Additional information: The value of this counter changes each time the MASS-STORAGE-RESOURCE-CHANGED object is set to eTrue. The value also changes when the mass storage device is initialized. However, the value does not change when a mass storage device is removed and a different mass storage device is installed. Performing a cold reset sets this object back to the factory default value. Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
mass_storage_resource_changed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 1, 12, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eTrue", 2)))).setLabel("mass-storage-resource-changed").setMaxAccess("writeonly")
if mibBuilder.loadTexts: mass_storage_resource_changed.setStatus('optional')
if mibBuilder.loadTexts: mass_storage_resource_changed.setDescription('Setting to eTrue causes MASS-STORAGE-RESOURCE-CHANGE- COUNTER to be incremented. Additional information: Returns <noSuchName> status if attempting to access this object and there is no storage device is installed.')
hrdiskstorageaccess = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eHreadWrite", 1), ("eHreadOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrdiskstorageaccess.setStatus('mandatory')
if mibBuilder.loadTexts: hrdiskstorageaccess.setDescription('An indication if this long-term storage device is readable and writable or only readable. This should reflect the media type, any write-protect mechanism, and any device configuration that affects the entire device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object can be set to write protect the mass storage device, even though the host resources MIB documents the object as read-only. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrdiskstoragemedia = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("eHother", 1), ("eHhardDisk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdiskstoragemedia.setStatus('mandatory')
if mibBuilder.loadTexts: hrdiskstoragemedia.setDescription('An indication of the type of media used in this long-term storage device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrdiskstorageremoveble = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eHfalse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdiskstorageremoveble.setStatus('mandatory')
if mibBuilder.loadTexts: hrdiskstorageremoveble.setDescription('Denotes whether or not the disk media may be removed from the drive. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrdiskstoragecapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdiskstoragecapacity.setStatus('mandatory')
if mibBuilder.loadTexts: hrdiskstoragecapacity.setDescription('The total size for this long-term storage device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The capacity is in Kbytes. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrpartitionindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrpartitionindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrpartitionindex.setDescription('A unique value for each partition on this long- term storage device. The value for each long-term storage device must remain constant at least from one re-initialization of the agent to the next re- initialization. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The first and second index indicates the hrDeviceIndex for this mass storage device. The value of this object is the same as the second index. The printer only supports one partition per mass storage device. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrpartitionlabel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrpartitionlabel.setStatus('mandatory')
if mibBuilder.loadTexts: hrpartitionlabel.setDescription('A textual description of this partition. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The MS-DOS volume label. The volume label is not writable. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed. This object is not settable and returns the empty string if the mass storage device has not been initialized.')
hrpartitionid = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrpartitionid.setStatus('mandatory')
if mibBuilder.loadTexts: hrpartitionid.setDescription('A descriptor which uniquely represents this partition to the responsible operating system. On some systems, this might take on a binary representation. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The value returned is the ASCII string version of the hrDeviceIndex for this mass storage device. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrpartitionsize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrpartitionsize.setStatus('mandatory')
if mibBuilder.loadTexts: hrpartitionsize.setDescription('The size of this partition. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The capacity is in Kbytes. Returns the same value as hrDiskStorageCapacity. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrpartitionfsindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrpartitionfsindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrpartitionfsindex.setDescription('The index of the file system mounted on this partition. If no file system is mounted on this partition, then this value shall be zero. Note that multiple partitions may point to one file system, denoting that that file system resides on those partitions. Multiple file systems may not reside on one partition. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Indicates if the mass storage device has been initialized. Returns zero if the mass storage device is not initialized, otherwise the value matches the hrDeviceIndex value for this mass storage device. The value indicates the hrFileSystemTable index for the file system stored on this partition. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed.')
hrfsindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfsindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsindex.setDescription('A unique value for each file system local to this host. The value for each file system must remain constant at least from one re-initialization of the agent to the next re-initialization. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The index is assigned by the person controlling the printer object definition. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfsmountpoint = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfsmountpoint.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsmountpoint.setDescription('The path name of the root of this file system. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfsremotemountpoint = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfsremotemountpoint.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsremotemountpoint.setDescription('A description of the name and/or address of the server that this file system is mounted from. This may also include parameters such as the mount point on the remote file system. If this is not a remote file system, this string should have a length of zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. This printer does not support remote file system mounting. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfstype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfstype.setStatus('mandatory')
if mibBuilder.loadTexts: hrfstype.setDescription('The value of this object identifies the type of this file system. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfsaccess = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eHreadWrite", 1), ("eHreadOnly", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hrfsaccess.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsaccess.setDescription('An indication if this file system is logically configured by the operating system to be readable and writable or only readable. This does not represent any local access-control policy, except one that is applied to the file system as a whole. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Returns the same value as hrDiskStorageAccess. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfsbootable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("eHfalse", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfsbootable.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsbootable.setDescription('A flag indicating whether this file system is bootable. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfsstorageindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfsstorageindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrfsstorageindex.setDescription('The index of the hrStorageEntry that represents information about this file system. If there is no such information available, then this value shall be zero. The relevant storage entry will be useful in tracking the percent usage of this file system and diagnosing errors that may occur when it runs out of space. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The value indicates the hrStorageTable index for this mass storage device. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.')
hrfslastfullbackupdate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfslastfullbackupdate.setStatus('mandatory')
if mibBuilder.loadTexts: hrfslastfullbackupdate.setDescription("The last date at which this complete file system was copied to another storage device for backup. This information is useful for ensuring that backups are being performed regularly. If this information is not known, then this variable shall have the value corresponding to January 1, year 0000, 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The default value is the value defined to represent an unknown time of January 1, year 0000, 00:00:00.0. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.")
hrfslastpartialbackupdate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 8, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrfslastpartialbackupdate.setStatus('mandatory')
if mibBuilder.loadTexts: hrfslastpartialbackupdate.setDescription("The last date at which a portion of this file system was copied to another storage device for backup. This information is useful for ensuring that backups are being performed regularly. If this information is not known, then this variable shall have the value corresponding to January 1, year 0000, 00:00:00.0, which is encoded as (hex)'00 00 01 01 00 00 00 00'. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Constant. The default value is the value defined to represent an unknown time of January 1, year 0000, 00:00:00.0. Returns <noSuchName> status if attempting to perform a Get on this OID with no mass storage device installed or if the file system has not been initialized.")
hrmemorysize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrmemorysize.setStatus('mandatory')
if mibBuilder.loadTexts: hrmemorysize.setDescription('The amount of physical main memory contained by the host. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The unit of measure for this object is 1024 bytes. The default value assumes the base printer with no additional memory.')
hrstorageindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageindex.setDescription('A unique value for each logical storage area contained by the host. Refer to RFC 1514, Host Resources MIB, for more details.')
hrstoragetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragetype.setDescription('The type of storage represented by this entry. Refer to RFC 1514, Host Resources MIB, for more details.')
hrstoragedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragedescr.setDescription('A description of the type and instance of the storage described by this entry. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is not localized.')
hrstorageallocationunits = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationunits.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationunits.setDescription('The size, in bytes, of the data objects allocated from this pool. If this entry is monitoring sectors, blocks, buffers, or packets, for example, this number will commonly be greater than one. Otherwise this number will typically be one. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Unit is one byte. The size, in bytes, of the data objects allocated from this pool. If this entry is monitoring sectors, blocks, buffers, or packets, for example, this number will commonly be greater than one. Otherwise this number will typically be one.')
hrstoragesize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstoragesize.setStatus('mandatory')
if mibBuilder.loadTexts: hrstoragesize.setDescription('The size of the storage represented by this entry, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Total formatter RAM. Color LaserJet8550 has 0 byte of memory soldered on the formatter.')
hrstorageused = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageused.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageused.setDescription('The amount of the storage represented by this entry that is allocated, in units of hrStorageAllocationUnits. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object returns the amount of memory in use by the printer at the current time. This object should not be used when creating a print job for the device because the amount of memory in use will likely be different when the printer processes the print job.')
hrstorageallocationfailures = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 2, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrstorageallocationfailures.setStatus('mandatory')
if mibBuilder.loadTexts: hrstorageallocationfailures.setDescription('The number of requests for storage represented by this entry that could not be honored due to not enough storage. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is set to zero at power on and when any reset is done via prtGeneralReset. This object is incremented whenever the printer is short on memory or out of memory/job cleared.')
hrdeviceindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceindex.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceindex.setDescription('A unique value for each device contained by the host. The value for each device must remain constant at least from one re-initialization of the agent to the next re-initialization. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The entry in the Device Table which describes the printer. ')
hrdevicetype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicetype.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicetype.setDescription("An indication of the type of device. If this value is `hrDeviceProcessor { hrDeviceTypes 3 }' then an entry exists in the hrProcessorTable which corresponds to this device. If this value is `hrDeviceNetwork { hrDeviceTypes 4 }', then an entry exists in the hrNetworkTable which corresponds to this device. If this value is `hrDevicePrinter { hrDeviceTypes 5 }', then an entry exists in the hrPrinterTable which corresponds to this device. If this value is `hrDeviceDiskStorage { hrDeviceTypes 6 }', then an entry exists in the hrDiskStorageTable which corresponds to this device. Refer to RFC 1514, Host Resources MIB, for more details.")
hrdevicedescr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicedescr.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicedescr.setDescription("A textual description of this device, including the device's manufacturer and revision, and optionally, its serial number. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This object is not localized.")
hrdeviceid = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceid.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceid.setDescription('The product ID for this device. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The complete OID reported by this object is: .1.3.6.1.4.1.11.2.3.9.1.2.10')
hrdevicestatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 5))).clone(namedValues=NamedValues(("eHrunning", 2), ("eHwarning", 3), ("eHdown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdevicestatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrdevicestatus.setDescription("The current operational state of the device described by this row of the table. A value unknown(1) indicates that the current state of the device is unknown. running(2) indicates that the device is up and running and that no unusual error conditions are known. The warning(3) state indicates that agent has been informed of an unusual error condition by the operational software (e.g., a disk device driver) but that the device is still 'operational'. An example would be high number of soft errors on a disk. A value of testing(4), indicates that the device is not available for use because it is in the testing state. The state of down(5) is used only when the agent has been informed that the device is not available for any use. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHrunning -- Printer ready to print or is printing. May be in power save mode. eHwarning -- A condition exists that needs attention but it is not currently preventing printing. A non-critical alert is active. eHdown -- Printer is not printing due to an error condition. A critical alert is active, human interaction is needed to bring the printer to a ready state.")
hrdeviceerrors = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrdeviceerrors.setStatus('mandatory')
if mibBuilder.loadTexts: hrdeviceerrors.setDescription('The number of errors detected on this device. It should be noted that as this object has a SYNTAX of Counter, that it does not have a defined initial value. However, it is recommended that this object be initialized to zero. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: This is the number of critical alerts that have been entered into the alert table since the device was powered on. The maximum value for this object is 2^32-1.')
hrprinterstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("eHother", 1), ("eHidle", 3), ("eHprinting", 4), ("eHwarmup", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterstatus.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterstatus.setDescription("The current status of this printer device. When in the idle(1), printing(2), or warmup(3) state, the corresponding hrDeviceStatus should be running(2) or warning(3). When in the unknown state, the corresponding hrDeviceStatus should be unknown(1). Refer to RFC 1514, Host Resources MIB, for more details. Additional information: The printer's condition is mapped as follows: eHother -- The printer is offline or a critical alert is active. eHidle -- The printer is not doing any of the items listed below for eHprinting status. eHprinting -- The printer is processing PJL or PDL data, or processeing a control panel request, or printing images. eHwarmup -- If hrDeviceStatus is eHdown, then the printer is currently offline but is resolving the condition that caused it be offline. It will be online when it is ready to print. If hrDeviceStatus is eHrunning, then the printer was in power save mode and is now becoming ready to print.")
hrprinterdetectederrorstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 3, 3, 5, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setStatus('mandatory')
if mibBuilder.loadTexts: hrprinterdetectederrorstate.setDescription("This object represents any error conditions detected by the printer. The error conditions are encoded as bits in an octet string, with the following definitions: Condition Bit # hrDeviceStatus lowPaper 0 warning(3) noPaper 1 down(5) lowToner 2 warning(3) noToner 3 down(5) doorOpen 4 down(5) jammed 5 down(5) offline 6 down(5) serviceRequested 7 warning(3) If multiple conditions are currently detected and the hrDeviceStatus would not otherwise be unknown(1) or testing(4), the hrDeviceStatus shall correspond to the worst state of those indicated, where down(5) is worse than warning(3) which is worse than running(2). Bits are numbered starting with the most significant bit of the first byte being bit 0, the least significant bit of the first byte being bit 7, the most significant bit of the second byte being bit 8, and so on. A one bit encodes that the condition was detected, while a zero bit encodes that the condition was not detected. This object is useful for alerting an operator to specific warning or error conditions that may occur, especially those requiring human intervention. Refer to RFC 1514, Host Resources MIB, for more details. Additional information: Color LaserJet8550 reports error conditions as follows: lowPaper -- A tray is empty, but the media to be loaded is not currently needed. hrDeviceStatus = eHwarning; hrPrinterStatus = eHidle or eHprinting; a non-critical alert is active. noPaper -- A tray is empty and must be filled for printing to continue. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; a non-critical alert is active. lowToner -- Toner is almost gone. The quality of printed pages will begin to deteriorate until the toner is completely gone. hrDeviceStatus = eHwarning; hrPrinterStatus = eHidle or eHprinting; a non-critical alert is active. noToner -- Toner Low 2 or no cartridge installed. CoverOpen -- A Cover is open. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; a non-critical alert is active. jammed -- A jam condition is preventing printing. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; a critical alert is active. offline -- Printer is offline. hrDeviceStatus = eHdown; hrPrinterStatus = eHother; a critical alert is active. serviceRequested -- Any status or error condition not listed above. If the condition prevents printing, the 'offline' bit is also set and the hrDeviceStatus and hrPrinterStatus listed for offline above are returned. hrDeviceStatus = eHwarning; hrPrinterStatus = eHidle or eHprinting; a non-critical alert is active.")
channelnumberofchannels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 1), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelnumberofchannels.setStatus('optional')
if mibBuilder.loadTexts: channelnumberofchannels.setDescription('An indication of how many print data channels the I/O card supports. Additional information: This object is used by the MIO card to tell the peripheral firmware how many logical channels will be used by the card. This object can only be set once per physical channel. If an attempt is made to set it a subsequent time it is ignored and an return code of <genErr> is returned. If new firmware is dynamically downloaded to the IO card card, and if that firmware uses more logical channels, it is necessary to reset the printer.')
channelprinteralert = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelprinteralert.setStatus('optional')
if mibBuilder.loadTexts: channelprinteralert.setDescription("Identifies the values of prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup, prtAlertGroupIndex, prtAlertLocation, and prtAlertCode for the latest critical evnet in the prtAlertTable. The binary string is defined as following: ------------------------------------------------------ Field | Filed | Description Offset | Length | ------------------------------------------------------ 0 | 4 | the value of prtAlertIndex 4 | 4 | the value of prtAlertSeverityLevel 8 | 4 | the value of prtAlertGroup 12 | 4 | the value of prtAlertGroupIndex 16 | 4 | the value of prtAlertLocation 20 | 4 | the value of prtAlertCode ------------------------------------------------------ Each field is in Big Endian style. Additional information: This object is used to pass alert information from the peripheral to the MIO card. The standard printer MIB contains the following description: printerAlert TRAP-TYPE ENTERPRISE printerV1Alert VARIABLES { prtAlertIndex, prtAlertSeverityLevel, prtAlertGroup, prtAlertGroupIndex, prtAlertLocation, prtAlertCode } DESCRIPTION 'This trap is sent whenever a critical event is added to the prtAlertTable.' In order to provide this information in the trap packet, the MIO card enables traps on channelPrinterAlert. When a critical alert is generated the peripheral fills the appropriate value into this object and sends it to the card. This object is a structure which contains 24 bytes of data. The structure is: struct structAlertInfo { sint32 prtAlertIndex; sint32 prtAlertSeverityLevel; sint32 prtAlertGroup; sint32 prtAlertGroupIndex; sint32 prtAlertLocation; sint32 prtAlertCode; } thisAlertData;")
channeltype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 8, 9, 10, 11, 15, 38))).clone(namedValues=NamedValues(("eChOther", 1), ("eChAppleTalkPAP", 7), ("eChLPDServer", 8), ("eChNetwareRPrinter", 9), ("eChNetwarePServer", 10), ("eChPort9100", 11), ("eChDLCLLCPort", 15), ("eChBidirPortTCP", 38)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channeltype.setStatus('optional')
if mibBuilder.loadTexts: channeltype.setDescription('Identifies the type of MIO print data channel. Additional information: This object is for use by the I/O card only. After telling the peripheral how many logical channels will be used, the MIO card tells the printer the type of each of the channels. The type information is passed using the channelType object. Values are then saved by the peripheral and reported when users request the value of prtChannelType.')
channelprotocolversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1, 3), OctetString()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelprotocolversion.setStatus('optional')
if mibBuilder.loadTexts: channelprotocolversion.setDescription('The version of the protocol used on this MIO print data channel. Additional information: This object is for use by the I/O card only. After telling the peripheral how many logical channels will be used, the MIO card tells the printer the protocol version of each of the channels. The protocol version information is passed using the channelProtocolVersion object. Values are then saved by the peripheral and reported when users request the value of prtChannelProtocolVersion.')
channelstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("eChOther", 1), ("eChPrintDataAccecped", 3), ("eChNoDataAccepted", 4)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelstate.setStatus('optional')
if mibBuilder.loadTexts: channelstate.setDescription('The state of this print data channel. The value determines whether control information and print data is allowed through this channel or not. Additional information: This object is for use by the I/O card only. After telling the peripheral how many logical channels will be used, the MIO card tells the printer the state of each of the channels. The state can change from time to time. The state information is passed using the channelState object. Values are saved by the peripheral and reported when users request the value of prtChannelState.')
channelifindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1, 5), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelifindex.setStatus('optional')
if mibBuilder.loadTexts: channelifindex.setDescription('The value of ifIndex which corresponds to this channel. Additional information: This object is for use by the I/O card only. After telling the peripheral how many logical channels will be used, the MIO card tells the printer the value of the IfIndex for each channel. The IfIndex is used as part of MIB-II. The values are saved by the peripheral and reported when users request the value of prtChannelIfIndex.')
channelstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 6, 3, 1, 6), Integer32()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: channelstatus.setStatus('optional')
if mibBuilder.loadTexts: channelstatus.setDescription("Sub-unit status is reported in the entries of the principle table in the Group that represents the sub- unit. For sub-units that report a status, there is a status column in the table and the value of this column is always an integer formed in the following way. The SubUnitStatus is an integer that is the sum of 5 distinct values, Availability, Non-Critical, Critical, On-line, and Transitioning. These values are: Availability value Available and Idle 0 000'b Available and Standby 2 010'b Available and Active 4 100'b Available and Busy 6 110'b Unavailable and OnRequest 1 001'b Unavailable because Broken 3 011'b Unknown 5 101'b Non-Critical No Non-Critical Alerts 0 Non-Critical Alerts 8 Critical No Critical Alerts 0 Critical Alerts 16 On-Line Intended state is On-Line 0 Intended state is Off-Line 32 Transitioning At intended state 0 Transitioning to intended state 64 Additional information: This object is for use by the I/O card only. After telling the peripheral how many logical channels will be used, the MIO card tells the printer the status of each of the channels. The status can change from time to time. The status information is passed using the channelStatus object. Values are saved by the peripheral and reported when users request the value of prtChannelStatus.")
pe_test_button_press = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 1, 4, 1, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("eButton1Pressed", 1), ("eButton2Pressed", 2), ("eButton3Pressed", 3), ("eButton4Pressed", 4), ("eButton5Pressed", 5), ("eButton6Pressed", 6), ("eButton7Pressed", 7), ("eButton8Pressed", 8), ("eButton9Pressed", 9), ("eButton10Pressed", 10)))).setLabel("pe-test-button-press").setMaxAccess("writeonly")
if mibBuilder.loadTexts: pe_test_button_press.setStatus('optional')
if mibBuilder.loadTexts: pe_test_button_press.setDescription("OBSOLETE! Use CONTROL-PANEL-BUTTON-PRESS instead. Writing this object simulates pressing a front panel button. The mapping of a value to a device's front panel button is device specific. For example, in the LaserJet 5Si product, the mapping is: eButton1Pressed - Online eButton2Pressed - Menu eButton3Pressed - Item eButton4Pressed - Plus eButton5Pressed - Select This object should not be in the print engine test sub- tree, but the implementing engineer made up an OID, instead of getting one assigned. Please don't do that!")
prtgeneralconfigchanges = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralconfigchanges.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralconfigchanges.setDescription("Counts configuration changes that change the capabilities of a printer, such as the addition/deletion of input/output bins, the addition/deletion of interpreters, or changes in media size. Such changes will often affect the capability of the printer to service certain types of print jobs. Management applications may cache infrequently changed configuration information about sub-units on the printer. This object should be incremented whenever the agent wishes such applications to invalidate that cache and re-download all of this configuration information, thereby signaling a change in the printer's configuration. For example, if an input tray that contained paper of different dimensions was added, this counter would be incremented. As an additional example, this counter would not be incremented when an input tray is removed or the level of an input device changes. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This is a 32 bit counter (unsigned). When it reaches its maximum value, it will roll to zero.")
prtgeneralcurrentlocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 11))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentlocalization.setDescription('The value of the prtLocalizationIndex corresponding to the current language, country, and character set to be used for localized string values that are identified as being dependent on the value of this object. Note that this object does not apply to localized strings in the prtConsole group or to any object that is not explicitly identified as being localized according to prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML LOCALIZATION-LANGUAGE. The value of this object is saved in NVRAM.')
prtgeneralreset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6))).clone(namedValues=NamedValues(("ePnotResetting", 3), ("ePpowerCycleReset", 4), ("ePresetToNVRAM", 5), ("ePresetToFactoryDefaults", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralreset.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralreset.setDescription("Setting this value to `powerCycleReset', `resetToNVRAM', or `resetToFactoryDefaults' will result in the resetting of the printer. When read, this object will always have the value `notResetting(3)', and a SET of the value `notResetting' shall have no effect on the printer. Some of the defined values are optional. However, every implementation must support at least the values `notResetting' and 'resetToNVRAM'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML USER-NVRAM-RESET and POWER-ON-RESET. All resets follow the same sequence of events except that a a value of ePresetToFactoryDefaults first makes a call to reset the NVRAM to factory defaults. Then, the following sequence of events occur: 1. A delay is initiated while a reply is returned to the requestor indicating OK. 2. The printer goes off-line. 3. The control panel is disabled. 4. The paper path is flushed. 5. The printer is reset per the request. The printer will respond to PML requests up to this point in time. Setting this object to ePpowerCycleReset causes Color LaserJet8550 to perform its power on initialization routines. I/O cards are reset (NVRAM on the cards is not changed; all I/O buffers are flushed). The tests normally run at power on time are executed. Setting this object to ePresetToNVRAM causes the printer to reset itself to its power on state without doing its normal power on testing. The I/O cards are not reset and I/O buffers remain intact. Setting this object to ePresetToFactoryDefaults causes the same action as a Cold Reset operation performed at the control panel (except power on testing is not performed). The I/O cards are not reset and I/O buffers remain intact.")
prtgeneralcurrentoperator = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralcurrentoperator.setDescription("The name of the person who is responsible for operating this printer. It is suggested that this string include information that would enable other humans to reach the operator, such as a phone number. As a convention to facilitate automatic notification of the operator by the agent or the network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers may also include ASCII comma characters(hex 2C) that are used to indicate a two-second pause during the dialing sequence. If either the phone, fax, or email information is not available, then a line should not be included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML SYSTEM-CONTACT. The maximum supported string length is 32 characters. If the user entered string is too long, the device will store as much as possible and will return the <noError> status. This object is saved in NVRAM.")
prtgeneralserviceperson = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtgeneralserviceperson.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralserviceperson.setDescription("The name of the person responsible for servicing this printer. It is suggested that this string include information that would enable other humans to reach the service person, such as a phone number. As a convention to facilitate automatic notification of the service person by the agent or a network management station, the phone number, fax number or email address should be placed on a separate line starting with ASCII LF (hex 0x0A) and the ASCII text string (without the quotes): 'phone: ', 'fax: ', and 'email: ', respectively. Phone numbers may contain digits, whitespace and parentheses, which shall be ignored. Phone numbers can also include one or more ASCII comma characters(hex 2C) to indicate a two-second pause during the dialing sequence. If either the phone,fax, or email information is not available, then a line should not included for this information. NOTE: For interoperability purposes, it is advisable to use email addresses formatted according to RFC 822 requirements. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML SYSTEM-CONTACT. The maximum supported string length is 32 characters. If the user entered string is too long, the device will store as much as possible and will return the <noError> status. This object is saved in NVRAM.")
prtinputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtinputdefaultindex.setDescription("The value of prtInputIndex corresponding to the default input sub-unit: that is, this object selects the default source of input media. This value shall be -1 if there is no default input subunit specified for the printer as a whole. In this case, the actual default input subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The default input tray is determined by the printer based on DEFAULT-MEDIA-SIZE and DEFAULT-MEDIA-NAME. If multiple trays have qualifying media, tray 1 is selected first, then the non-empty tray with the highest capacity is selected; trays of equal capacity are selected by lower tray number. Trays 1-3 refer to the printer's trays that are so labeled. Tray 4 is the first tray of the first external input paper handling device.")
prtoutputdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtoutputdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtoutputdefaultindex.setDescription('The value of prtOutputIndex corresponding to the default output sub-unit; that is, this object selects the default output destination. This value shall be -1 if there is no default output subunit specified for the printer as a whole. In this case, the actual default output subunit may be specified by means outside the scope of this MIB, such as by each interpreter in a printer with multiple interpreters. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkerdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerdefaultindex.setDescription('The value of prtMarkerIndex corresponding to the default marker sub-unit; that is, this object selects the default marker. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmediapathdefaultindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtmediapathdefaultindex.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdefaultindex.setDescription('The value of prtMediaPathIndex corresponding to the default media path; that is, the selection of the default media path. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtconsolelocalization = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtconsolelocalization.setStatus('optional')
if mibBuilder.loadTexts: prtconsolelocalization.setDescription('The value of the prtLocalizationIndex corresponding to the language, country, and character set to be used for the console. This localization applies both to the actual display on the console as well as the encoding of these console objects in management operations. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML LOCALIZATION-LANGUAGE. The value of this object is saved in NVRAM. If a localized string is currently being displayed on the control panel by the device, changing this object will cause the displayed string to be changed to its new value. If this object is changed while the printer is processing a page that contains localized strings has started, the results are undefined.')
prtconsolenumberofdisplaylines = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaylines.setDescription("The number of lines on the printer's physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML DISPLAY-NUMBER-OF-ROWS. The printer has two physical lines on the display, however, in many cases up to eight seperate lines of text may be displayed by alternating pairs of lines every three seconds. Thus the display really has eight logical lines for displaying messages. This object will return the number of logical display lines supported by the printer.")
prtconsolenumberofdisplaychars = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setStatus('optional')
if mibBuilder.loadTexts: prtconsolenumberofdisplaychars.setDescription('The number of characters per line displayed on the physical display. This value is 0 if there are no lines on the physical display or if there is no physical display Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML DISPLAY-COLUMN-SIZE.')
prtconsoledisable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6))).clone(namedValues=NamedValues(("ePoperatorConsoleEnabled", 3), ("ePoperatorConsoleDisabled", 4), ("ePoperatorConsoleEnabledLevel1", 5), ("ePoperatorConsoleEnabledLevel2", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtconsoledisable.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisable.setDescription("If the object prtConsoleDisable has value 'operatorConsoleDisabled' then input is not accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabled' then input is accepted from the operator console. If the object prtConsoleDisable has the value 'operatorConsoleEnabledLevel1','operatorConsoleEnabledLevel2' or 'operatorConsoleEnabledLevel3' then limited input is accepted from the operator console; the limitations are product specific, however, the limitations are generally less restrictive for operatorConsoleEnabledLevel1 than for operatorConsoleEnabledLeve2, which is less restrictive than operatorConsoleEnabledLevel3. The value of the prtConsoleDisable object is a type-2 enumeration. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML CONTROL-PANEL-LOCK. If the object prtConsoleDisable has value 'ePoperatorConsoleDisabled' then manual input is not accepted from the operator console. If the object prtConsoleDisable has the value 'ePoperatorConsoleEnabled' then manual input is accepted from the operator console. The following menus are locked with these corresponding values: ePoperatorConsoleEnabled (no locking) ePoperatorConsoleEnabledLevel1 (minimal locking) RESETS MENU CONFIGURATION MENU I/O MENU CALIBRATION MENU ePoperatorConsoleEnabledLevel2 (moderate locking) PAPER HANDLING MENU menus in level 1 ePoperatorConsoleDisabled (maximum locking) PRINTING MENU INFORMATION MENU Job Cancel menus in Levels 1 and 2.")
prtgeneralbannerpage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5))).clone(namedValues=NamedValues(("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtgeneralbannerpage.setStatus('optional')
if mibBuilder.loadTexts: prtgeneralbannerpage.setDescription('Used to enable or disable printing banner pages at the beginning of jobs. This is a master switch which applies to all jobs, regardless of interpreter. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtcoverdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverdescription.setStatus('optional')
if mibBuilder.loadTexts: prtcoverdescription.setDescription('The manufacturer provided cover sub-mechanism name in the localization specified by prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtcoverstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePCoverOpen", 3), ("ePCoverClosed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtcoverstatus.setStatus('optional')
if mibBuilder.loadTexts: prtcoverstatus.setDescription('The status of this cover sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML NOT-READY-DOOR-OPEN.')
prtlocalizationlanguage = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationlanguage.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationlanguage.setDescription('A two character language code from ISO 639. Examples en, gb, ca, fr, de. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The languages supported by Color LaserJet8550 are English, French, German, Italian, Spanish, Swedish, Danish, Norwegian, Dutch, Finnish, and Portuguese.')
prtlocalizationcountry = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcountry.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcountry.setDescription('A two character country code from ISO 3166, a blank string (two space characters) shall indicate that the country is not defined. Examples: US, FR, DE, ... Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The languages supported by Color LaserJet8550 (and corresponding country) are English (United States), French (France), German (Germany), Italian (Italy), Spanish (Spain), Swedish (Sweden), Danish (Denmark), Norwegian (Norway), Dutch (Netherlands), Finnish (Finland), Portuguese (Portugal), Turkish (Turkey), Polish (Poland), Russian (Russia), Czech (Czechoslovakia), Hungarian (Hungary).')
prtlocalizationcharacterset = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2004))).clone(namedValues=NamedValues(("ePcsHPRoman8", 2004)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtlocalizationcharacterset.setStatus('optional')
if mibBuilder.loadTexts: prtlocalizationcharacterset.setDescription('The coded character set used for this localization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtstoragerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtstoragerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtstoragerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this storageEntry is associated with. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtdevicerefindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 5, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtdevicerefindex.setStatus('optional')
if mibBuilder.loadTexts: prtdevicerefindex.setDescription('The value of the hrDeviceIndex of the printer device that this deviceEntry is associated with. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePsheetFeedAutoRemovableTray", 3), ("ePsheetFeedAutoNonRemovableTray", 4), ("ePsheetFeedManual", 5), ("ePcontinuousRoll", 6), ("ePcontinuousFanFold", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputtype.setStatus('optional')
if mibBuilder.loadTexts: prtinputtype.setDescription('The type of technology (discriminated primarily according to feeder mechanism type) employed by the input sub-unit. Note, the Optional Input Class provides for a descriptor field to further qualify the other choice. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Tray 1 is the multi-purpose tray and is always present. Tray 1 can operate in manual feed mode and supports both sheets and envelopes. its type is ePsheetFeedAutoNonRemovableTray. Color LaserJet8550 base model does not support tray 2. Trays 2 (8550 N and up) and 3 are the drawers and, although they are usually not removed from the printer, the printer cannot distinguish the open and removed conditions. Therefore, when they are open, they are considered to be removed and, for this object, they are considered to be of type ePsheetFeedAutoRemovableTray. Tray 4 is the high capacity input device. .')
prtinputdimunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdimunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputdimunit.setDescription('The unit of measurement for use calculating and relaying dimensional values for this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinputmediadimfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The feed direction is the direction in which the media is fed on this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: For trays 2 (8550 N and up), 3 and 4 (which can reliably sense this value) the objects behave exactly the same as prtInputMediaDimFeedDirChosen. Attempting to set this object for trays 2, 3 and 4 will cause <noSuchName> to be returned. The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared.')
prtinputmediadimxfeeddirdeclared = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirdeclared.setDescription('This object provides the value of the declared dimension, in the cross feed direction, of the media that is (or, if empty, was or will be) in this input sub-unit. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (prtInputDimUnit). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests. Otherwise, the value may be changed. The value (-1) means other and specifically means that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: For trays 2 (8550 N and up), 3 and 4 (which can reliably sense this value) the objects behave exactly the same as prtInputMediaDimXFeedDirChosen. Attempting to set this object for trays 2, 3 and 4 will cause <noSuchName> to be returned. The default values assume the trays are configured for letter size paper. For tray 1 the value is the dimension for the media size currently declared.')
prtinputmediadimfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. Feed dimension measurements are taken relative to the feed direction associated with that sub-unit and are in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The objects for trays 2 (8550 N and up), 3 and 4 reflect the configuration of the corresponding drawers. When the drawer is open, a value of -2 is returned. The default values assume the trays are configured for letter size paper. The object for trays 1 returns the value of the media size for which the tray is currently configured.')
prtinputmediadimxfeeddirchosen = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setStatus('optional')
if mibBuilder.loadTexts: prtinputmediadimxfeeddirchosen.setDescription('The printer will act as if media of the chosen dimension (in the cross feed direction) is present in this input source. Note that this value will be used even if the input tray is empty. The cross feed direction is ninety degrees relative to the feed direction associated with this sub-unit. This dimension is measured in input sub-unit dimensional units (MediaUnit). If the printer supports the declared dimension, the granted dimension is the same as the declared dimension. If not, the granted dimension is set to the closest dimension that the printer supports when the declared dimension is set. The value (-1) means other and specifically indicates that this sub-unit places no restriction on this parameter. The value (-2) indicates unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The objects for trays 2 (8550 N and up), 3 and 4 reflect the configuration of the corresponding drawers. When the drawer is open, a value of -2 is returned. The default values assume the trays are configured for letter size paper. The object for trays 1 returns the value of the media size for which the tray is currently configured.')
prtinputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 8, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePsheets", 8), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtinputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: A sheet is a single piece of 20 pound paper. ')
prtinputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtinputmaxcapacity.setDescription('The maximum capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value reflects claimed capacity. If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML TRAYn-MAXIMUM-CAPACITY. Color LaserJet8550 base model does not support tray 2. The max capacity of the Matterhorn HCI is 1000.')
prtinputcurrentlevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputcurrentlevel.setStatus('optional')
if mibBuilder.loadTexts: prtinputcurrentlevel.setDescription('The current capacity of the input sub-unit in input sub-unit capacity units (PrtCapacityUnitTC). If this input sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Contol Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that at least one unit remains. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: For trays 1, Color LaserJet8550 can only detect empty/not empty trays. It returns -3 for not empty and 0 for empty. For trays 2 (8550 N and up) and 3, Color LaserJet8550 can detect approximately the amount of media. The value returned is based on the amount detected as follows: 0 - empty 1 - 1-110 sheets 50 - 50-260 sheets 200 - 200-490 sheets 430 - 430 sheets or more For tray 4, Color LaserJet8550 can detect approximately the amount of media. The value returned is based on the amount detected as follows: 0 - empty 1 - 1 sheet to 25% of capacity 500 - 26% to 50% of capacity 1000 - 51% to 75% of capacity 1500 - 76% to 100% of capacity If the tray drawer is open, a value of -2 (unknown) will be returned.')
prtinputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtinputstatus.setDescription('The current status of this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML STATUS-TRAY-MISSING and STATUS-TRAY-EMPTY. See SubUnitStatus in RFC1759 Printer MIB for details on values reported by this object. Color LaserJet8550 will not include values Available and Standby (2), Available and Active (4) or Unknown (5).')
prtinputmedianame = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinputmedianame.setStatus('optional')
if mibBuilder.loadTexts: prtinputmedianame.setDescription("A description of the media contained in this input sub-unit; This description is intended for display to a human operator. This description is not processed by the printer. It is used to provide information not expressible in terms of the other media attributes (e.g. prtInputMediaDimFeedDirChosen, prtInputMediaDimXFeedDirChosen, prtInputMediaWeight, prtInputMediaType). An example would be `legal tender bond paper'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML TRAYn-MEDIA-NAME. If set to a string other than one contained by a MEDIAn-NAME object, a status of <badValue> is returned.")
prtinputname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputname.setStatus('optional')
if mibBuilder.loadTexts: prtinputname.setDescription('The name assigned to this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML TRAYn-NAME.')
prtinputvendorname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputvendorname.setStatus('optional')
if mibBuilder.loadTexts: prtinputvendorname.setDescription('The vendor name of this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinputmodel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputmodel.setStatus('optional')
if mibBuilder.loadTexts: prtinputmodel.setDescription('The model name of this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML objects PHDn-MODEL. Color LaserJet8550 base model does not support tray 2.')
prtinputversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputversion.setStatus('optional')
if mibBuilder.loadTexts: prtinputversion.setDescription('The version of this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML objects PHDn-MANUFACTURING-INFO. Color LaserJet8550 base model does not support tray 2.')
prtinputserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtinputserialnumber.setDescription('The serial number assigned to this input sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinputdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinputdescription.setDescription('A free-form text description of this input sub-unit in the localization specified by prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinputsecurity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinputsecurity.setStatus('optional')
if mibBuilder.loadTexts: prtinputsecurity.setDescription('Indicates if this input sub-unit has some security associated with it. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: No security mechanism provided.')
prtoutputtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePremovableBin", 3), ("ePunRemovableBin", 4), ("ePcontinuousRollDevice", 5), ("ePmailBox", 6), ("ePcontinousFanFold", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputtype.setStatus('optional')
if mibBuilder.loadTexts: prtoutputtype.setDescription('The type of technology supported by this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtoutputcapacityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 8, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePsheets", 8), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputcapacityunit.setStatus('optional')
if mibBuilder.loadTexts: prtoutputcapacityunit.setDescription('The unit of measurement for use in calculating and relaying capacity values for this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: A sheet is a single piece of 20 pound paper.')
prtoutputmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputmaxcapacity.setDescription('The maximum capacity of this output sub-unit in output sub-unit capacity units (PrtCapacityUnitTC). There is no convention associated with the media itself so this value essentially reflects claimed capacity. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be changed by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML OUTBINn-MAXIMUM-CAPACITY. Output sub-unit 2 is not supported if any output paper handling device is attached. The capacity of sub-unit 4 depends on the mode of operation. The capcities are as follows: Stacker: 3000 letter papers (sub-units 5-11 do not exist) Job Separator: 250 (sub-units 5-11 do not exist) Stapler: 125 (sub-units 5 - 11 do not exist) Mailbox: 250 (this is the default mode)')
prtoutputremainingcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputremainingcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputremainingcapacity.setDescription("The remaining capacity of the possible output sub-unit capacity in output sub-unit capacity units (PrtCapacityUnitTC) of this output sub-unit. If this output sub-unit can reliably sense this value, the value is sensed by the printer and may not be modified by management requests; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. The value (-3) means that the printer knows that there remains capacity for at least one unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML NOT-READY-OUTBIN-FULL and STATUS-OUTBIN-FULL. The values reported for output sub-unit 1 (face-down, top bin) will be either (-3) if it is not full or (0) if it is full. Output sub-unit 2 (face-up, left side bin) does not have any sensing, so it will always report unknown (-2). The first output sub-unit (3) of the HCO reports either (62) if it is not full, (125) when empty, or (0) if it is full. In mailbox mode, the HCO sub-units (4-11) will report (250) when empty, (125) when there's room for <250 sheets and (0) when full. In stacker and job separator modes all bins are treated as a single output bin so sub-unit 4 will report (2000) when all bins are empty. A value of (0) is reported when the topmost bin is full (stacker mode) or when a bins is full (separator mode). When the stacker or separator has started filling, the value reported is based on the number of bins that are empty, partially filled and full. A percentage is calculated based on the status of each bin. Each full bin counts 1, each not empty/not full bin counts 0.5 and each empty bin counts 0. The result is mapped to an estimate of the remaining capacity as follows (percent full is included here for completeness, since that is how the HCO reports it to the printer): 0.0 2000 (100%) 0.5 1900 ( 90%) 1.0 1800 ( 85%) 1.5 1700 ( 80%) 2.0 1500 ( 75%) 2.5 1400 ( 65%) 3.0 1300 ( 60%) 3.5 1200 ( 55%) 4.0 1000 ( 50%) 4.5 900 ( 40%) 5.0 800 ( 35%) 5.5 700 ( 30%) 6.0 500 ( 25%) 6.5 400 ( 15%) 7.0 300 ( 10%) 7.5 200 ( 5%) 8.0 0 ( 0%) Note: Due to HCO mechanism limitations, the value reported may not always be accurate (the bin status is detected only when the media delivery head is moved to or past a physical bin). Also, for stacker mode a bin is considered full as long as any bin above it is not empty. Default values assume all sub-units are empty and the HCO is in mailbox mode.")
prtoutputstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputstatus.setStatus('optional')
if mibBuilder.loadTexts: prtoutputstatus.setDescription('The current status of this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML NOT-READY-OUTBIN-MISSING and STATUS-OUTBIN-MISSING. The default values assume all bins are empty. See SubUnitStatus in RFC1759 Printer MIB for details on values reported by this object. Color LaserJet8550 will not include values Available and Standby (2), Available and Active (4), Unknown (5) or Transitioning to intended state (64).')
prtoutputname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 19))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtoutputname.setStatus('optional')
if mibBuilder.loadTexts: prtoutputname.setDescription('The name assigned to this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML OUTBINn-NAME. The characters must be in the range 20H to 7FH except 5C. When this string is displayed on the control panel the Roman-8 symbol set is used. The object for bin 2 is not available when the HCO is attached.')
prtoutputvendorname = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputvendorname.setStatus('optional')
if mibBuilder.loadTexts: prtoutputvendorname.setDescription('The vendor name of this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: ')
prtoutputmodel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputmodel.setStatus('optional')
if mibBuilder.loadTexts: prtoutputmodel.setDescription('The name assigned to this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The value returned by this object depends on the current mode of the device. The possible values are as follows: MULTIBIN MAILBOX C4785A MULTIBIN STACKER C4785A MULTIBIN SEPARATOR C4785A STAPLER MODULE C3766A.')
prtoutputversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputversion.setStatus('optional')
if mibBuilder.loadTexts: prtoutputversion.setDescription('The version of this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Returns device-specific information about the configuration of the output bin. May include information about the type of processing that can be done to media sent to this bin; processing includes but is not limited to binding, punching, folding and sealing. Format of this object is specified by the output device documentation.')
prtoutputserialnumber = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputserialnumber.setStatus('optional')
if mibBuilder.loadTexts: prtoutputserialnumber.setDescription('The serial number assigned to this output sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtoutputdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputdescription.setStatus('optional')
if mibBuilder.loadTexts: prtoutputdescription.setDescription(' A free-form text description of this output sub-unit in the localization specified by prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtoutputsecurity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputsecurity.setStatus('optional')
if mibBuilder.loadTexts: prtoutputsecurity.setDescription('Indicates if this output sub-unit has some security associated with it and if that security is enabled or not. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: No security mechanism provided.')
prtoutputstackingorder = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("ePunknown", 2), ("ePfirstToLast", 3), ("ePlastToFirst", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputstackingorder.setStatus('optional')
if mibBuilder.loadTexts: prtoutputstackingorder.setDescription("The current state of the stacking order for the associated output sub-unit. `FirstToLast' means that as pages are output the front of the next page is placed against the back of the previous page. `LasttoFirst' means that as pages are output the back of the next page is placed against the front of the previous page. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML OUTBINn-STACK-ORDER.")
prtoutputpagedeliveryorientation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePfaceUp", 3), ("ePfaceDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputpagedeliveryorientation.setStatus('optional')
if mibBuilder.loadTexts: prtoutputpagedeliveryorientation.setDescription("The reading surface that will be `up' when pages are delivered to the associated output sub-unit. Values are faceUp and faceDown. (Note: interpretation of these values is in general context-dependent based on locale; presentation of these values to an end-user should be normalized to the expectations of the user). Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.")
prtoutputbursting = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputbursting.setStatus('optional')
if mibBuilder.loadTexts: prtoutputbursting.setDescription('This object indicates that the outputting sub-unit supports bursting, and if so, whether the feature is enabled. Bursting is the process by which continuous media is separated into individual sheets, typically by bursting along pre-formed perforations. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Bursting is not supported. For the base, outbins 1 and 2 are supported. In stacker/stapler mode, outbins 1, 3, and 4 are supported. In MBM mode, outbins 1, 3 - 11 are supported.')
prtoutputdecollating = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputdecollating.setStatus('optional')
if mibBuilder.loadTexts: prtoutputdecollating.setDescription('This object indicates that the output supports supports decollating, and if so, whether the feature is enabled. Decollating is the process by which the individual parts within a multi-part form are separated and sorted into separate stacks for each part. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Decollating is not supported.')
prtoutputpagecollated = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputpagecollated.setStatus('optional')
if mibBuilder.loadTexts: prtoutputpagecollated.setDescription('This object indicates that the output sub-unit supports page collation, and if so, whether the feature is enabled. See glossary for definition of how this document defines collation. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtoutputoffsetstacking = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 9, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePon", 3), ("ePoff", 4), ("ePnotPresent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtoutputoffsetstacking.setStatus('optional')
if mibBuilder.loadTexts: prtoutputoffsetstacking.setDescription('This object indicates that the output supports supports offset stacking, and if so, whether the feature is enabled. See glossary for how Offset Stacking is defined by this document. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkermarktech = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePelectrophotographicLED", 3), ("ePelectrophotographicLaser", 4), ("ePelectrophotographicOther", 5), ("ePimpactMovingHeadDotMatrix9pin", 6), ("ePimpactMovingHeadDotMatrix24pin", 7), ("ePimpactMovingHeadDotMatrixOther", 8), ("ePimpactMovingHeadFullyFormed", 9), ("ePimpactBand", 10), ("ePimpactOther", 11), ("ePinkjetAqueous", 12), ("ePinkjetSolid", 13), ("ePinkjetOther", 14), ("ePpen", 15), ("ePthermalTransfer", 16), ("ePthermalSensitive", 17), ("ePthermalDiffusion", 18), ("ePthermalOther", 19), ("ePelectroerosion", 20), ("ePelectrostatic", 21), ("ePphotographicMicrofiche", 22), ("ePphotographicImagesetter", 23), ("ePphotographicOther", 24), ("ePionDeposition", 25), ("ePeBeam", 26), ("ePtypesetter", 27)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkermarktech.setStatus('optional')
if mibBuilder.loadTexts: prtmarkermarktech.setDescription('The type of marking technology used for this marking sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkercounterunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 11, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePcharacters", 5), ("ePlines", 6), ("ePimpressions", 7), ("ePsheets", 8), ("ePdotRow", 9), ("ePhours", 11), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkercounterunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkercounterunit.setDescription('The unit that will be used by the printer when reporting counter values for this marking sub-unit. The time units of measure are provided for a device like a strip recorder that does not or cannot track the physical dimensions of the media and does not use characters, lines or sheets. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkerlifecount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerlifecount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerlifecount.setDescription('The count of the number of units of measure counted during the life of printer using units of measure as specified by prtMarkerCounterUnit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML TOTAL-ENGINE-PAGE-COUNT. In Color LaserJet8550 it is kept in NVRAM however the NVRAM value is only updated every 10 impressions. NOTE: The value returned by this OID will be incremented every page but if power is lost between NVRAM updates, up to 9 impressions of the page count may be lost. The counter will be reset to zero after 16,777,215 ( 2^24-1) pages. The page count is incremented when a sheet of media is pulled from an input tray. A duplex printed sheet will cause this counter to be incremented by two.')
prtmarkerpoweroncount = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerpoweroncount.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerpoweroncount.setDescription('The count of the number of units of measure counted since the equipment was most recently powered on using units of measure as specified by prtMarkerCounterUnit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkerprocesscolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerprocesscolorants.setDescription('The number of process colors supported by this marker. A process color of 1 implies monochrome. The value of this object and prtMarkerSpotColorants cannot both be 0. The value of prtMarkerProcessColorants must be 0 or greater. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Color LaserJet8550 has four process colorants: Black, Cyan, Magenta, and Yellow.')
prtmarkerspotcolorants = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerspotcolorants.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerspotcolorants.setDescription('The number of spot colors supported by this marker. The value of this object and prtMarkerProcessColorants cannot both be 0. Must be 0 or greater. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkeraddressabilityunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityunit.setDescription("The unit of measure of distances, as applied to the marker's resolution. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.")
prtmarkeraddressabilityfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityfeeddir.setDescription("The maximum number of addressable marking positions in the feed direction per 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Use this object to specify resolution. Color LaserJet8550 only supports 600 dpi.")
prtmarkeraddressabilityxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmarkeraddressabilityxfeeddir.setDescription("The maximum number of addressable marking positions in the cross feed direction in 10000 units of measure specified by prtMarkerAddressabilityUnit. A value of (-1) implies 'other' or 'infinite' while a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Use this object to specify resolution. Color LaserJet8550 only supports 600 dpi.")
prtmarkernorthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkernorthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkernorthmargin.setDescription('The margin, in units identified by prtMarkerAddressabilityUnit, from the leading edge of the medium as the medium flows through the marking engine with the side to be imaged facing the observer. The leading edge is the North edge and the other edges are defined by the normal compass layout of directions with the compass facing the observer. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersouthmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersouthmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersouthmargin.setDescription('The margin from the South edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkerwestmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerwestmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerwestmargin.setDescription('The margin from the West edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkereastmargin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkereastmargin.setStatus('optional')
if mibBuilder.loadTexts: prtmarkereastmargin.setDescription('The margin from the East edge (see prtMarkerNorthMargin) of the medium in units identified by prtMarkerAddressabilityUnit. Printing within the area bounded by all four margins is guaranteed for all interpreters. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkerstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 10, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkerstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmarkerstatus.setDescription('The current status of this marker sub-unit. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML NOT-READY-DESTINATION-PRINT-ENGINE and STATUS-DESTINATION-PRINT-ENGINE. The default value assumes no malfunctions. See SubUnitStatus in RFC1759 Printer MIB for details on values reported by this object. Color LaserJet8550 will not include values Available and Active (4) or Unknown (5).')
prtmarkersuppliesmarkerindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmarkerindex.setDescription('The value of prtMarkerIndex corresponding to the marking sub-unit with which this marker supply sub-unit is associated. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliescolorantindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliescolorantindex.setDescription('The value of prtMarkerColorantIndex corresponding to the colorant with which this marker supply sub-unit is associated. This value shall be 0 if there is no colorant table. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliesclass = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePsupplyThatIsConsumed", 3), ("ePreceptacleThatIsFilled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesclass.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesclass.setDescription('Indicates whether this supply entity represents a supply that is consumed or a receptacle that is filled. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliestype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePtoner", 3), ("ePwasteToner", 4), ("ePink", 5), ("ePinkCartridge", 6), ("ePinkRibbon", 7), ("ePwasteInk", 8), ("ePopc", 9), ("ePdeveloper", 10), ("ePfuserOil", 11), ("ePsolidWax", 12), ("ePribbonWax", 13), ("ePwasteWax", 14), ("ePfuser", 15), ("ePcoronaWire", 16), ("ePfuserOilWick", 17), ("ePcleanerUnit", 18), ("ePfuserCleaningPad", 19), ("ePtransferUnit", 20), ("ePtonerCartridge", 21), ("ePfuserOiler", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliestype.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliestype.setDescription('The type of this supply. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliesdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesdescription.setDescription('The description of this supply container/receptacle in the localization specified by prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliessupplyunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 7, 8, 12, 11, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4), ("ePimpressions", 7), ("ePsheets", 8), ("ePthousandthsOfOunces", 12), ("ePhours", 11), ("ePtenthsOfGrams", 13), ("ePhundrethsOfFluidOunces", 14), ("ePtenthsOfMilliliters", 15), ("ePfeet", 16), ("ePmeters", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliessupplyunit.setDescription('Unit of measure of this marker supply container/receptacle. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersuppliesmaxcapacity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersuppliesmaxcapacity.setDescription('The maximum capacity of this supply container/receptacle expressed in prtMarkerSuppliesSupplyUnit. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmarkersupplieslevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 11, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmarkersupplieslevel.setStatus('optional')
if mibBuilder.loadTexts: prtmarkersupplieslevel.setDescription("The current level if this supply is a container; the remaining space if this supply is a receptacle. If this supply container/receptacle can reliably sense this value, the value is reported by the printer and is read-only; otherwise, the value may be written (by a Remote Control Panel or a Management Application). The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. The value (-2) means unknown. A value of (-3) means that the printer knows that there is some supply/remaining space, respectively. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Color LaserJet8550 detects two states for the toner: Between the 'LOW' and 'LOW 2' thresholds will be reported as -2. At the 'LOW 2' threshold will be reported as 0. The other consumables will report -2. For Matterhorn, at printer initialization, all consumables will default to -2. This value will not change since Matterhorn cannot track consumables.")
prtmediapathmaxspeedprintunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 16, 17))).clone(namedValues=NamedValues(("ePtenThousandthsOfInchesPerHour", 3), ("ePmicrometersPerHour", 4), ("ePcharactersPerHour", 5), ("ePlinesPerHour", 6), ("ePimpressionsPerHour", 7), ("ePsheetsPerHour", 8), ("ePdotRowPerHour", 9), ("ePfeetPerHour", 16), ("ePmetersPerHour", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeedprintunit.setDescription('The unit of measure used in specifying the speed of all media paths in the printer. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmediapathmediasizeunit = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePtenThousandthsOfInches", 3), ("ePmicrometers", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmediasizeunit.setDescription('The units of measure of media size for use in calculating and relaying dimensional values for all media paths in the printer. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmediapathmaxspeed = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxspeed.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxspeed.setDescription("The maximum printing speed of this media path expressed in prtMediaPathMaxSpeedUnit's. A value of (-1) implies 'other'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML PRINT-ENGINE-PERFORMANCE. The page size for this performance is 8.5x11.")
prtmediapathmaxmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediafeeddir.setDescription("The maximum physical media size in the feed direction of this media path expressed in units of measure specified by PrtMediaPathMediaSizeUnit. A value of (-1) implies 'unlimited', a value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 185000 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 469900 if prtMediaPathMediaSizeUnit is ePmicrometers.")
prtmediapathmaxmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathmaxmediaxfeeddir.setDescription("The maximum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. It is 120000 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 304800 if prtMediaPathMediaSizeUnit is ePmicrometers.")
prtmediapathminmediafeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediafeeddir.setDescription("The minimum physical media size in the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. For the simplex paper path it is 74803 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 189999 if prtMediaPathMediaSizeUnit is ePmicrometers. For the duplex paper path it is 82677 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 210000 if prtMediaPathMediaSizeUnit is ePmicrometers. This sizes correspond to a custom paper length for simplex, A5 paper length for duplex ( Note: The simallest paper size for simplex must be fed portrait).")
prtmediapathminmediaxfeeddir = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathminmediaxfeeddir.setDescription("The minimum physical media size across the feed direction of this media path expressed in units of measure specified by prtMediaPathMediaSizeUnit. A value of (-2) implies 'unknown'. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The value returned by this object depends on the value of prtMediaPathMediaSizeUnit. For the simplex paper path, it is 38740 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 98400 if prtMediaPathMediaSizeUnit is ePmicrometers. For the duplex paper path it is 58267 if prtMediaPathMediaSizeUnit is ePtenThousandthsOfInches or 148000 if prtMediaPathMediaSizeUnit is ePmicrometers. This size corresponds to a custom paper width for the simplex, A5 paper width for duplex.")
prtmediapathtype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("ePlongEdgeBindingDuplex", 3), ("ePshortEdgeBindingDuplex", 4), ("ePsimplex", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathtype.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathtype.setDescription('The type of the media path for this media path. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML DUPLEX-INSTALLED.')
prtmediapathdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathdescription.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathdescription.setDescription('The manufacturer-provided description of this media path in the localization specified by prtGeneralCurrentLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtmediapathstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 13, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtmediapathstatus.setStatus('optional')
if mibBuilder.loadTexts: prtmediapathstatus.setDescription('The current status of this media path. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The default values assume the printer is idle. See SubUnitStatus in RFC1759 Printer MIB for details on values reported by this object. Color LaserJet8550 will not include values Available and Standby (2), Available and Active (4), Unknown (5), Non-CriticalAlerts (8) or Transitioning to intended state (64).')
prtchanneltype = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 7, 10, 15, 38))).clone(namedValues=NamedValues(("ePother", 1), ("ePchIEEE1284Port", 5), ("ePchAppleTalkPAP", 7), ("ePchNetwarePServer", 10), ("ePchDLCLLCPort", 15), ("ePchBidirPortTCP", 38)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchanneltype.setStatus('optional')
if mibBuilder.loadTexts: prtchanneltype.setDescription('The type of this print data channel. This object provides the linkage to ChannelType-specific groups that may (conceptually) extend the prtChannelTable with additional details about that channel. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This object, in conjunction with prtChannelProtocolVersion, replaces the PML object PORTn-DESCRIPTION. MIO-based channels provide their own values. There are 34 channel types for Color LaserJet8550; first two being parallel, 3 - 18 are for the first card, and 19 - 34 are for the second card. If a card wants to use all 16 channels at a given time, it can. But a card could use less than 16 channels at a given time.')
prtchannelprotocolversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelprotocolversion.setStatus('optional')
if mibBuilder.loadTexts: prtchannelprotocolversion.setDescription('The version of the protocol used on this channel. The format used for version numbering depends on prtChannelType. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This object, in conjunction with prtChannelType, replaces the PML object PORTn-DESCRIPTION. MIO-based channels provide their own values. The channel 1 value includes (separated by semi colons) different aspects of the spec: electrical;logical; and physical connector.')
prtchannelcurrentjobcntllangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelcurrentjobcntllangindex.setDescription("The value of prtInterpreterIndex corresponding to the Control Language Interpreter for this channel. This interpreter defines the syntax used for control functions, such as querying or changing environment variables and identifying job boundaries (e.g. PJL, PostScript, NPAP). Must be 1 or greater. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This object points to the PJL language. It is read-only because PJL (2) is the printer's only job control language. It is the same for all channels.")
prtchanneldefaultpagedesclangindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setStatus('optional')
if mibBuilder.loadTexts: prtchanneldefaultpagedesclangindex.setDescription('The value of prtInterpreterIndex corresponding to the Page Description Language Interpreter for this channel. This interpreter defines the default Page Description Language interpreter to be used for the print data unless the Control Language is used to select a specific interpreter (e.g., PCL, PostScript Language, auto-sense). Must be 1 or greater. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML DEFAULT-PDL. The default points to the automatic language switcher. If this object is changed for one channel, all channels will be changed.')
prtchannelstate = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("ePother", 1), ("ePprintDataAccepted", 3), ("ePnoDataAccepted", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstate.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstate.setDescription("The state of this print data channel. The value determines whether control information and print data is allowed through this channel or not. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: MIO-based channels provide their own values for this object. The base-printer's port always reports a value of ePprintDataAccepted. If the printer is offline, that is detected by reading the Host Resources General Printer Status objects, not by reading this object.")
prtchannelifindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelifindex.setStatus('optional')
if mibBuilder.loadTexts: prtchannelifindex.setDescription('The value of ifIndex (in the ifTable; see the interface section of MIB-2/RFC 1213) which corresponds to this channel. When more than one row of the ifTable is relevant, this is the index of the row representing the topmost layer in the interface hierarchy. A value of zero indicates that no interface is associated with this channel. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: MIO-based channels provide their own values for this object.')
prtchannelstatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 14, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtchannelstatus.setStatus('optional')
if mibBuilder.loadTexts: prtchannelstatus.setDescription("The current status of the channel. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: See SubUnitStatus in RFC1759 Printer MIB for details on values reported by this object. MIO-based channels provide their own values for this object. Status for Color LaserJet8550's parallel port will not include values Available and Standby (2), Available and Active (4), Non-Critical Alerts (8) or Transitioning to intended state (64).")
prtinterpreterlangfamily = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 5, 6, 37))).clone(namedValues=NamedValues(("ePlangPCL", 3), ("ePlangPJL", 5), ("ePlangPS", 6), ("ePlangAutomatic", 37)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangfamily.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangfamily.setDescription('The family name of a Page Description Language (PDL) or control language which this interpreter in the printer can interpret or emulate. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PCL-NAME and FW-ROM-DATECODE ( sort of). Also provides a place to supply PJL information and overall ROM information ( by using the language switcher as a separate language).')
prtinterpreterlanglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlanglevel.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlanglevel.setDescription("The level of the language which this interpreter is interpreting or emulating. This might contain a value like '5e' for an interpreter which is emulating level 5e of the PCL language. It might contain '2' for an interpreter which is emulating level 2 of the PostScript language. Similarly it might contain '2' for an interpreter which is emulating level 2 of the HPGL language. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.")
prtinterpreterlangversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterlangversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterlangversion.setDescription('The date code or version of the language which this interpreter is interpreting or emulating. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This is a date code determined by the firmware build engineer. The value of these objects will change from build to build and the final value will be determined at some later date. At that time the default values will be changed to reflect the final value.')
prtinterpreterdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdescription.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdescription.setDescription('A string to identify this interpreter in the localization specified by prtGeneralCurrentLocalization as opposed to the language which is being interpreted. It is anticipated that this string will allow manufacturers to unambiguously identify their interpreters. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: None of these strings are localized.')
prtinterpreterversion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterversion.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterversion.setDescription('The date code, version number, or other product specific information tied to this interpreter. This value is associated with the interpreter, rather than with the version of the language which is being interpreted or emulated. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Same as prtInterpreterLangVersion.')
prtinterpreterdefaultorientation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePportrait", 3), ("ePlandscape", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultorientation.setDescription('The current orientation default for this interpreter. This value may be overridden for a particular job (e.g., by a command in the input data stream). Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML DEFAULT-ORIENTATION. Setting this object for one interpreter will change it for all installed interpreters. The automatic language switching and PJL interpreters ignore the value of this object. The value for PCL is either ePportrait or ePlandscape; attempting to set it to a different value will cause <badValue> to be returned.')
prtinterpreterfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterfeedaddressability.setDescription('The maximum interpreter addressability in the feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityFeedDir ) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinterpreterxfeedaddressability = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterxfeedaddressability.setDescription('The maximum interpreter addressability in the cross feed direction in 10000 prtMarkerAddressabilityUnits (see prtMarkerAddressabilityXFeedDir) for this interpreter. The value (-1) means other and specifically indicates that the sub-unit places no restrictions on this parameter. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtinterpreterdefaultcharsetin = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 8, 12, 15, 2004))).clone(namedValues=NamedValues(("ePcsISOLatin2", 5), ("ePcsISOLatinCyrillic", 8), ("ePcsISOLatin5", 12), ("ePcsHalfWidthKatakana", 15), ("ePcsHPRoman8", 2004)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetin.setDescription('The default coded character set for input octets encountered outside a context in which the Page Description Language established the interpretation of the octets. (Input octets are presented to the interpreter through a path defined in the channel group.) This value shall be (2) if there is no default. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: This object refers to PCL symbol set.')
prtinterpreterdefaultcharsetout = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 2004, 2005))).clone(namedValues=NamedValues(("ePcsNoDefault", 2), ("ePcsASCII", 3), ("ePcsHPRoman8", 2004), ("ePcsAdobeStandardEncoding", 2005)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setStatus('optional')
if mibBuilder.loadTexts: prtinterpreterdefaultcharsetout.setDescription("The default character set for data coming from this interpreter through the printer's output channel (i.e. the 'backchannel'). This value shall be (2) if there is no default. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: ")
prtinterpretertwoway = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 15, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("ePyes", 3), ("ePno", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtinterpretertwoway.setStatus('optional')
if mibBuilder.loadTexts: prtinterpretertwoway.setDescription('Indicates whether or not this interpreter returns information back to the host. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtconsoledisplaybuffertext = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 16, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledisplaybuffertext.setDescription("The content of a line in the logical display buffer of the operator's console of the printer. When a write operation occurs, normally a critical message, to one of the LineText strings, the agent should make that line displayable if a physical display is present. Writing a zero length string clears the line. It is an implementation-specific matter as to whether the agent allows a line to be overwritten before it has been cleared. Printer generated strings shall be in the localization specified by prtConsoleLocalization. Management Application generated strings should be localized by the Management Application. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: Replaces PML STATUS-MSG-LINE1-PART1 and STATUS-MSG-LINE2-PART1. The ojbects BACKGROUND-STATUS-MSG-LINE1-PART1 and BACKGROUND-STATUS-MSG-LINE2-PART1 should be used to write messages to the control panel display. prtConsoleDisplayBufferText[1..8] maps to logical line [1..8] of the display. Unused lines on the control pannel should retrun NULL.")
prtconsoleontime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleontime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleontime.setDescription("This object, in conjunction with prtConsoleOffTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: There are three control panel LED's: Ready ( index 1), Data ( index 2) and Attention ( index 3). The Ready and Data led flash at the rate of 500 milliseconds on followed by 500 milliseconds off. The Attention led flashes at the rate of 250 milliseconds on followed by 250 milliseconds off. See 'ERS: Color LaserJet8550 Control Panel' for a complete description of LED behavior.")
prtconsoleofftime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoleofftime.setStatus('optional')
if mibBuilder.loadTexts: prtconsoleofftime.setDescription("This object, in conjunction with prtConsoleOnTime, defines the current status of the light. If both prtConsoleOnTime and prtConsoleOffTime are non-zero, the lamp is blinking and the values presented define the on time and off time, respectively, in milliseconds. If prtConsoleOnTime is zero and prtConsoleOffTime is non-zero, the lamp is off. If prtConsoleOffTime is zero and prtConsoleOnTime is non-zero, the lamp is on. If both values are zero the status of the lamp is undefined. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: There are three control panel LED's: Ready( index 1), Data ( index 2) and Attention ( index 3). The Ready and Data led flash at the rate of 500 milliseconds on followed by 500 milliseconds off. The Attention led flashes at the rate of 250 milliseconds on followed by 250 milliseconds off. See 'ERS: Color LaserJet8550 Control Panel' for a complete description of LED behavior.")
prtconsolecolor = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePwhite", 3), ("ePred", 4), ("ePgreen", 5), ("ePblue", 6), ("ePcyan", 7), ("ePmagenta", 8), ("ePyellow", 9), ("ePorange", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsolecolor.setStatus('optional')
if mibBuilder.loadTexts: prtconsolecolor.setDescription('The color of this light. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtconsoledescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 17, 6, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtconsoledescription.setStatus('optional')
if mibBuilder.loadTexts: prtconsoledescription.setDescription('The vendor description or label of this light in the localization specified by prtConsoleLocalization. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB.')
prtalertseveritylevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("ePother", 1), ("ePcriticalBinaryChangeEvent", 3), ("ePwarningUnaryChangeEvent", 4), ("ePwarningBinaryChangeEvent", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertseveritylevel.setStatus('optional')
if mibBuilder.loadTexts: prtalertseveritylevel.setDescription('The level of severity of this alert table entry. The printer determines the severity level assigned to each entry into the table. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.')
prtalerttraininglevel = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ePother", 1), ("ePuntrained", 3), ("ePtrained", 4), ("ePfieldService", 5), ("ePmanagement", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalerttraininglevel.setStatus('optional')
if mibBuilder.loadTexts: prtalerttraininglevel.setDescription('See textual convention PrtAlertTrainingLevelTC Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries. The value of this object depends on the alert condition as follows: ePuntrained: Paper out. ePtrained: Toner out. ePfieldService: Marker failure. ePmanagement: Configuration change.')
prtalertgroup = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("ePother", 1), ("ePhostResourcesMIBStorageTable", 3), ("ePhostResourcesMIBDeviceTable", 4), ("ePgeneralPrinter", 5), ("ePcover", 6), ("ePlocalization", 7), ("ePinput", 8), ("ePoutput", 9), ("ePmarker", 10), ("ePmarkerSupplies", 11), ("ePmarkerColorant", 12), ("ePmediaPath", 13), ("ePchannel", 14), ("ePinterpreter", 15), ("ePconsoleDisplayBuffer", 16), ("ePconsoleLights", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroup.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroup.setDescription('The type of sub-unit within the printer model that this alert is related. Input, output, and markers are examples of printer model groups, i.e., examples of types of sub-units. Wherever possible, these enumerations match the sub-identifier that identifies the relevant table in the printmib. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.')
prtalertgroupindex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertgroupindex.setStatus('optional')
if mibBuilder.loadTexts: prtalertgroupindex.setDescription('An index of the row within the principle table in the group identified by prtAlertGroup that represents the sub-unit of the printer that caused this alert. The combination of the prtAlertGroup and the prtAlertGroupIndex defines exactly which printer sub-unit caused the alert.; for example, Input #3, Output #2, and Marker #1. Every object in this MIB is indexed with hrDeviceIndex and optionally, another index variable. If this other index variable is present in the table that generated the alert, it will be used as the value for this object. Otherwise, this value shall be -1. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.')
prtalertlocation = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertlocation.setStatus('optional')
if mibBuilder.loadTexts: prtalertlocation.setDescription('The sub-unit location that is defined by the printer manufacturer to further refine the location of this alert within the designated sub-unit. The location is used in conjunction with the Group and GroupIndex values; for example, there is an alert in Input #2 at location number 7. The value (-2) indicates unknown Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.')
prtalertcode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 501, 502, 503, 504, 505, 506, 507, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 901, 902, 903, 904, 1001, 1002, 1003, 1004, 1005, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1301, 1302, 1303, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1509, 1801))).clone(namedValues=NamedValues(("ePother", 1), ("ePunknown", 2), ("ePcoverOpened", 3), ("ePcoverClosed", 4), ("ePinterlockOpened", 5), ("ePinterlockClosed", 6), ("ePconfigurationChanged", 7), ("ePjammed", 8), ("ePsubunitMissing", 9), ("ePsubunitLifeAlmostOver", 10), ("ePsubunitLifeOver", 11), ("ePsubunitAlmostEmpty", 12), ("ePsubunitEmpty", 13), ("ePsubunitAlmostFull", 14), ("ePsubunitFull", 15), ("ePsubunitNearLimit", 16), ("ePsubunitAtLimit", 17), ("ePsubunitOpened", 18), ("ePsubunitClosed", 19), ("ePsubunitTurnedOn", 20), ("ePsubunitTurnedOff", 21), ("ePsubunitOffline", 22), ("ePsubunitPowerSaver", 23), ("ePsubunitWarmingUp", 24), ("ePsubunitAdded", 25), ("ePsubunitRemoved", 26), ("ePsubunitRecousrceAdded", 27), ("ePsubunitResourceRemoved", 28), ("ePsubunitRecoverableFailure", 29), ("ePsubunitUnrecoverableFailure", 30), ("ePsubunitRecoverableStorageError", 31), ("ePsubunitUnrecoverableStorageError", 32), ("ePsubunitMotorFailure", 33), ("ePsubunitMemoryExhausted", 34), ("ePcoverOpened", 501), ("ePcoverClosed", 502), ("ePpoweredUp", 503), ("ePpoweredDown", 504), ("ePprinterNMSReset", 505), ("ePprinterManualReset", 506), ("ePprinterReadyToPrint", 507), ("ePinputMediaTrayMissing", 801), ("ePinputMediaSizeChanged", 802), ("ePinputMediaWeightChanged", 803), ("ePinputMediaTypeChanged", 804), ("ePinputMediaColorChanged", 805), ("ePinputMediaFormPartsChange", 806), ("ePinputMediaSupplyLow", 807), ("ePinputMediaSupplyEmpty", 808), ("ePinputMediaChangeRequest", 809), ("ePinputManualInputRequest", 810), ("ePinputTrayPositionFailure", 811), ("ePinputTrayElevationFailure", 812), ("ePinputCannotFeedSizeSelected", 813), ("ePoutputMediaTrayMissing", 901), ("ePoutputMediaTrayAlmostFull", 902), ("ePoutputMediaTrayFull", 903), ("ePoutputMailboxSelectFailure", 904), ("ePmarkerFuserUnderTemperature", 1001), ("ePmarkerFuserOverTemperature", 1002), ("ePmarkerFuserTimingFailure", 1003), ("ePmarkerFuserThermistorFailure", 1004), ("ePmarkerAdjustingPrintQuality", 1005), ("ePmarkerTonerEmpty", 1101), ("ePmarkerInkEmpty", 1102), ("ePmarkerPrintRibbonEmpty", 1103), ("ePmarkerTonerAlmostEmpty", 1104), ("ePmarkerInkAlmostEmpty", 1105), ("ePmarkerPrintRibbonAlmostEmpty", 1106), ("ePmarkerWasteTonerReceptacleAlmostFull", 1107), ("ePmarkerWasteInkReceptacleAlmostFull", 1108), ("ePmarkerWasteTonerReceptacleFull", 1109), ("ePmarkerWasteInkReceptacleFull", 1110), ("ePmarkerOpcLifeAlmostOver", 1111), ("ePmarkerOpcLifeOver", 1112), ("ePmarkerDeveloperAlmostEmpty", 1113), ("ePmarkerDeveloperEmpty", 1114), ("ePmarkerTonerCartridgeMissing", 1115), ("ePmediaPathMediaTrayMissing", 1301), ("ePmediaPathMediaTrayAlmostFull", 1302), ("ePmediaPathMediaTrayFull", 1303), ("ePinterpreterMemoryIncreased", 1501), ("ePinterpreterMemoryDecreased", 1502), ("ePinterpreterCartridgeAdded", 1503), ("ePinterpreterCartridgeDeleted", 1504), ("ePinterpreterResourceAdded", 1505), ("ePinterpreterResourceDeleted", 1506), ("ePinterpreterResourceUnavailable", 1507), ("ePinterpreterComplexPageEncountered", 1509), ("ePalertRemovalOfBinaryChangeEntry", 1801)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertcode.setStatus('optional')
if mibBuilder.loadTexts: prtalertcode.setDescription('See associated textual convention PrtAlertCodeTC Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.')
prtalertdescription = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 9, 4, 2, 2, 18, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: prtalertdescription.setStatus('optional')
if mibBuilder.loadTexts: prtalertdescription.setDescription("A description of this alert entry in the localization specified by prtGeneralCurrentLocalization. The description is provided by the printer to further elaborate on the enumerated alert or provide information in the case where the code is classified as `other' or `unknown'. The printer is required to return a description string but the string may be a null string. Refer to Printer Management Standards web page, http://www.pwg.org, for more details in the original format of the Standard Printer MIB. Additional information: The alert table in Color LaserJet8550 will hold up to 233 entries.")
mibBuilder.exportSymbols("CLJ8550-MIB", simm1_capacity=simm1_capacity, error24=error24, outbin9_override_mode=outbin9_override_mode, error24_time_stamp=error24_time_stamp, prtAlert=prtAlert, held_job_delete=held_job_delete, asset_number=asset_number, channel_entry=channel_entry, error38_time_stamp=error38_time_stamp, error47_time_stamp=error47_time_stamp, job_info_attr_14=job_info_attr_14, error43_time_stamp=error43_time_stamp, error44_time_stamp=error44_time_stamp, media11_page_count=media11_page_count, held_job_control=held_job_control, simm1_type=simm1_type, prtMarker=prtMarker, error19=error19, simm5_type=simm5_type, intray3=intray3, prtchanneltype=prtchanneltype, error10=error10, tray5_phd=tray5_phd, status_prt_eng=status_prt_eng, id=id, hrdevicedescr=hrdevicedescr, settings_marking_agent=settings_marking_agent, error41_time_stamp=error41_time_stamp, prtconsolenumberofdisplaychars=prtconsolenumberofdisplaychars, error6_time_stamp=error6_time_stamp, media7_page_count=media7_page_count, outbin4=outbin4, nfs_server_test_return_code=nfs_server_test_return_code, prtmarkerdefaultindex=prtmarkerdefaultindex, prtinterpreterlanglevel=prtinterpreterlanglevel, hrPrinterTable=hrPrinterTable, channelprotocolversion=channelprotocolversion, error35=error35, hrstorageused=hrstorageused, media8=media8, error18=error18, media6=media6, prtalertseveritylevel=prtalertseveritylevel, prtchannelcurrentjobcntllangindex=prtchannelcurrentjobcntllangindex, prtChannelEntry=prtChannelEntry, job_info_outcome=job_info_outcome, prtalertcode=prtalertcode, media8_name=media8_name, held_job_retention=held_job_retention, settings_file_system=settings_file_system, hrPartitionEntry=hrPartitionEntry, prtConsoleDisplayBufferTable=prtConsoleDisplayBufferTable, outbin5=outbin5, prtchannelprotocolversion=prtchannelprotocolversion, media9_page_count=media9_page_count, error42_code=error42_code, maximum_resource_saving_memory=maximum_resource_saving_memory, job_info_attr_24=job_info_attr_24, tray2_phd=tray2_phd, file_system_statistic_current_memory_usage=file_system_statistic_current_memory_usage, prtgeneralconfigchanges=prtgeneralconfigchanges, io_timeout=io_timeout, prtGeneralTable=prtGeneralTable, DisplayString=DisplayString, job_info_requested_originals=job_info_requested_originals, simm2_type=simm2_type, error3_time_stamp=error3_time_stamp, error3_code=error3_code, media3_name=media3_name, prtmediapathmaxspeedprintunit=prtmediapathmaxspeedprintunit, prtchannelifindex=prtchannelifindex, error1=error1, media2_name=media2_name, error22_time_stamp=error22_time_stamp, phd3_device_specific_command=phd3_device_specific_command, job_info_attr_19=job_info_attr_19, settings_io=settings_io, error47=error47, custom_paper_dim_unit=custom_paper_dim_unit, hrfsaccess=hrfsaccess, pcl_resource_saving_memory_size=pcl_resource_saving_memory_size, error27=error27, hrfslastpartialbackupdate=hrfslastpartialbackupdate, media_info=media_info, hrm=hrm, job_info_attr_12=job_info_attr_12, file_system_statistic_max_memory_usage=file_system_statistic_max_memory_usage, form_feed_needed=form_feed_needed, file_system_statistic_read_open=file_system_statistic_read_open, hrstorageindex=hrstorageindex, remote_procedure_call=remote_procedure_call, held_job_quantity=held_job_quantity, media13_short_name=media13_short_name, hrdeviceerrors=hrdeviceerrors, source_subsystem=source_subsystem, error41_code=error41_code, job_info_size=job_info_size, prtMediaPathTable=prtMediaPathTable, error23_code=error23_code, prtoutputmodel=prtoutputmodel, error8_time_stamp=error8_time_stamp, media2_page_count=media2_page_count, mass_storage_resources=mass_storage_resources, error5_time_stamp=error5_time_stamp, mio1_manufacturing_info=mio1_manufacturing_info, prtlocalizationcountry=prtlocalizationcountry, prtinputmediadimfeeddirdeclared=prtinputmediadimfeeddirdeclared, prtmediapathstatus=prtmediapathstatus, prtgeneralcurrentlocalization=prtgeneralcurrentlocalization, prtmarkerwestmargin=prtmarkerwestmargin, prtmarkernorthmargin=prtmarkernorthmargin, prtDeviceRefEntry=prtDeviceRefEntry, energy_star=energy_star, job_info_page_count_current_original=job_info_page_count_current_original, pjl=pjl, intray5=intray5, media15_short_name=media15_short_name, job_info_attr_26=job_info_attr_26, outbin11=outbin11, channelprinteralert=channelprinteralert, prtmarkeraddressabilityxfeeddir=prtmarkeraddressabilityxfeeddir, prtMarkerEntry=prtMarkerEntry, prtinputmediadimfeeddirchosen=prtinputmediadimfeeddirchosen, prtConsoleDisplayBuffer=prtConsoleDisplayBuffer, simm5_capacity=simm5_capacity, job_info_physical_outbins_used=job_info_physical_outbins_used, prtalertgroupindex=prtalertgroupindex, error43_code=error43_code, error27_time_stamp=error27_time_stamp, job=job, prtconsolenumberofdisplaylines=prtconsolenumberofdisplaylines, prtmarkersuppliesdescription=prtmarkersuppliesdescription, error22_code=error22_code, duplex_page_count=duplex_page_count, status_pdl=status_pdl, error37_code=error37_code, tray3_media_size_loaded=tray3_media_size_loaded, file_system_memory=file_system_memory, prtinputmodel=prtinputmodel, job_input_auto_continue_mode=job_input_auto_continue_mode, prtChannelTable=prtChannelTable, serial_number=serial_number, error5_code=error5_code, error16_time_stamp=error16_time_stamp, error30_code=error30_code, nfs_server_statistic_successful=nfs_server_statistic_successful, job_info_io_source=job_info_io_source, error8_code=error8_code, error9=error9, error1_code=error1_code, error12_code=error12_code, hrstoragedescr=hrstoragedescr, media10=media10, hrdeviceid=hrdeviceid, prtmarkersuppliessupplyunit=prtmarkersuppliessupplyunit, active_print_jobs=active_print_jobs, settings_pdl=settings_pdl, prtdevicerefindex=prtdevicerefindex, media15_page_count=media15_page_count, error14=error14, settings_system=settings_system, error45_code=error45_code, settings_print_media=settings_print_media, outbin=outbin, media14_page_count=media14_page_count, nfs_server_memory=nfs_server_memory, error9_time_stamp=error9_time_stamp, phd3_type=phd3_type, port1_parallel_speed=port1_parallel_speed, device_name=device_name, prtgeneralcurrentoperator=prtgeneralcurrentoperator, media9_short_name=media9_short_name, channelstate=channelstate, mio2_manufacturing_info=mio2_manufacturing_info, media10_short_name=media10_short_name, pcl_default_font_source=pcl_default_font_source, job_info_attr_27=job_info_attr_27, error11=error11, channelifindex=channelifindex, prtLocalizationEntry=prtLocalizationEntry, job_info_pages_printed=job_info_pages_printed, error10_time_stamp=error10_time_stamp, error11_code=error11_code, jetsend_contact_password=jetsend_contact_password, channel_bytes_received=channel_bytes_received, media12_page_count=media12_page_count, file_system_statistic_unsuccessful=file_system_statistic_unsuccessful, error14_time_stamp=error14_time_stamp, tables=tables, prtmarkerpoweroncount=prtmarkerpoweroncount, pcl_total_page_count=pcl_total_page_count, simm5=simm5, media6_name=media6_name, outbin3_phd=outbin3_phd, error34_code=error34_code, outbin6_phd=outbin6_phd, nfs_server_statistic_max_memory_usage=nfs_server_statistic_max_memory_usage, error29_code=error29_code, simm8_capacity=simm8_capacity, prtInputTable=prtInputTable, default_horizontal_black_resolution=default_horizontal_black_resolution, error37_time_stamp=error37_time_stamp, prtmediapathdescription=prtmediapathdescription, error26_time_stamp=error26_time_stamp, error5=error5, error17=error17, low_marking_agent_processing=low_marking_agent_processing, prtinterpreterlangversion=prtinterpreterlangversion, error46=error46, error25_time_stamp=error25_time_stamp, rpc_statistic_successful=rpc_statistic_successful, postscript_print_errors=postscript_print_errors, settings_jetsend_contact=settings_jetsend_contact, prtInput=prtInput, pdl_pcl=pdl_pcl, error45_time_stamp=error45_time_stamp, prtoutputbursting=prtoutputbursting, prtmarkersuppliesclass=prtmarkersuppliesclass, intrays=intrays, rpc_bind_statistic_unsuccessful=rpc_bind_statistic_unsuccessful, media14=media14, rpc_bind=rpc_bind, printmib=printmib, held_job_print=held_job_print, prtconsoleofftime=prtconsoleofftime, error35_code=error35_code, pdl_postscript=pdl_postscript, job_output_auto_continue_timeout=job_output_auto_continue_timeout, port1_parallel_bidirectionality=port1_parallel_bidirectionality, outbin1=outbin1, prtgeneralreset=prtgeneralreset, error39_code=error39_code, media6_short_name=media6_short_name, job_info_attr_17=job_info_attr_17, mio=mio, error49_code=error49_code, error19_time_stamp=error19_time_stamp, hrDeviceTable=hrDeviceTable, prtchannelstatus=prtchannelstatus, jetsend_proc_sub=jetsend_proc_sub, job_info_attr_9=job_info_attr_9, status_rpc_bind=status_rpc_bind, io_buffer_size=io_buffer_size, prtConsoleLights=prtConsoleLights, rpc_test_return_code=rpc_test_return_code, status_rpc=status_rpc, custom_paper_xfeed_dim=custom_paper_xfeed_dim, postscript_total_page_count=postscript_total_page_count, prtConsoleLightEntry=prtConsoleLightEntry, intray=intray, simm6_capacity=simm6_capacity, prtInterpreterTable=prtInterpreterTable, xport_interface=xport_interface, job_info_attr_10=job_info_attr_10)
mibBuilder.exportSymbols("CLJ8550-MIB", job_info_attr_21=job_info_attr_21, prtlocalizationlanguage=prtlocalizationlanguage, prtoutputserialnumber=prtoutputserialnumber, job_info_attr_30=job_info_attr_30, error1_time_stamp=error1_time_stamp, job_info_state=job_info_state, job_info_attr_22=job_info_attr_22, error49_time_stamp=error49_time_stamp, pcl_default_font_number=pcl_default_font_number, media8_short_name=media8_short_name, job_info_attr_7=job_info_attr_7, prtAlertTable=prtAlertTable, error2=error2, job_info_attr_3=job_info_attr_3, error23=error23, intray4=intray4, settings_rpc=settings_rpc, prtcoverstatus=prtcoverstatus, error44_code=error44_code, job_info_name1=job_info_name1, error25_code=error25_code, postscript_jam_recovery=postscript_jam_recovery, status_xip=status_xip, hrFSTable=hrFSTable, job_info_attr_5=job_info_attr_5, error29=error29, outbin9=outbin9, job_info_change_id=job_info_change_id, nfs_server=nfs_server, prtConsoleLightTable=prtConsoleLightTable, error28_time_stamp=error28_time_stamp, prtmarkersuppliescolorantindex=prtmarkersuppliescolorantindex, prtalertlocation=prtalertlocation, prtinputsecurity=prtinputsecurity, error41=error41, outbin2=outbin2, error10_code=error10_code, prtInterpreterEntry=prtInterpreterEntry, default_ret=default_ret, mass_storage_resource_changed=mass_storage_resource_changed, hrfstype=hrfstype, prtinterpreterfeedaddressability=prtinterpreterfeedaddressability, job_info_attr_8=job_info_attr_8, hrfsstorageindex=hrfsstorageindex, prtInputEntry=prtInputEntry, jetsend_contact=jetsend_contact, hold_job_timeout=hold_job_timeout, job_info_attr_32=job_info_attr_32, error30=error30, prtMediaPathEntry=prtMediaPathEntry, media1_name=media1_name, error4=error4, media10_page_count=media10_page_count, file_system_statistic_successful=file_system_statistic_successful, outbin4_phd=outbin4_phd, prtmediapathtype=prtmediapathtype, prtmediapathmediasizeunit=prtmediapathmediasizeunit, prtmarkerstatus=prtmarkerstatus, error50_time_stamp=error50_time_stamp, error12_time_stamp=error12_time_stamp, prtmarkermarktech=prtmarkermarktech, media4=media4, phd5_type=phd5_type, phd2_type=phd2_type, error26_code=error26_code, settings_jetsend=settings_jetsend, media1_short_name=media1_short_name, hrDevice=hrDevice, media5_short_name=media5_short_name, prtoutputdefaultindex=prtoutputdefaultindex, prtchannelstate=prtchannelstate, error37=error37, outbin3=outbin3, default_lines_per_page=default_lines_per_page, hrdevicetype=hrdevicetype, prtoutputoffsetstacking=prtoutputoffsetstacking, held_job_enable=held_job_enable, error2_code=error2_code, simm2=simm2, simm2_capacity=simm2_capacity, job_info_attr_20=job_info_attr_20, rpc_bind_protocol_address=rpc_bind_protocol_address, outbin1_override_mode=outbin1_override_mode, default_media_size=default_media_size, phd2=phd2, error34_time_stamp=error34_time_stamp, hrfsremotemountpoint=hrfsremotemountpoint, marking_agent=marking_agent, error21_code=error21_code, prtDeviceRefTable=prtDeviceRefTable, hrstoragetype=hrstoragetype, error8=error8, error13=error13, job_info_attr_18=job_info_attr_18, prtalerttraininglevel=prtalerttraininglevel, io=io, processing_subsystem=processing_subsystem, outbin7=outbin7, job_info_attr_23=job_info_attr_23, error46_time_stamp=error46_time_stamp, held_job_info=held_job_info, file_system=file_system, prtLocalizationTable=prtLocalizationTable, media5_name=media5_name, hrpartitionid=hrpartitionid, hrdeviceindex=hrdeviceindex, job_info_outbins_used=job_info_outbins_used, background_message2=background_message2, job_info_stage=job_info_stage, settings_job=settings_job, hrPrinterEntry=hrPrinterEntry, prtMarkerSuppliesEntry=prtMarkerSuppliesEntry, channel_bytes_sent=channel_bytes_sent, pe_test_button_press=pe_test_button_press, prtconsoledisplaybuffertext=prtconsoledisplaybuffertext, error39=error39, error15_code=error15_code, outbin5_phd=outbin5_phd, prtInterpreter=prtInterpreter, resource_manager=resource_manager, tray4_media_size_loaded=tray4_media_size_loaded, job_info_name2=job_info_name2, mp_tray=mp_tray, job_info_attribute=job_info_attribute, simm8_type=simm8_type, media11_name=media11_name, error40_time_stamp=error40_time_stamp, nfs_server_write_size=nfs_server_write_size, outbin8_phd=outbin8_phd, prtGeneralEntry=prtGeneralEntry, prtAlertEntry=prtAlertEntry, error24_code=error24_code, phd2_manufacturing_info=phd2_manufacturing_info, error32_code=error32_code, media2=media2, phd6=phd6, prtoutputpagecollated=prtoutputpagecollated, hrDeviceEntry=hrDeviceEntry, intray1=intray1, on_off_line=on_off_line, default_print_quality=default_print_quality, simm8=simm8, rpc_bound_protocol_address=rpc_bound_protocol_address, outbin9_phd=outbin9_phd, media6_page_count=media6_page_count, prtmarkerspotcolorants=prtmarkerspotcolorants, error29_time_stamp=error29_time_stamp, media12=media12, channel_jobs_received=channel_jobs_received, prtinterpreterdescription=prtinterpreterdescription, prtinterpreterdefaultorientation=prtinterpreterdefaultorientation, postscript_resource_saving_memory_size=postscript_resource_saving_memory_size, held_job_user_name=held_job_user_name, job_info_attr_6=job_info_attr_6, default_media_name=default_media_name, prtinterpretertwoway=prtinterpretertwoway, outbin10=outbin10, prtinterpreterdefaultcharsetin=prtinterpreterdefaultcharsetin, error21=error21, total_color_page_count=total_color_page_count, prtconsoledisable=prtconsoledisable, prtstoragerefindex=prtstoragerefindex, media2_short_name=media2_short_name, maximum_io_buffering_memory=maximum_io_buffering_memory, error19_code=error19_code, error28=error28, error26=error26, mio2=mio2, file_systems=file_systems, error9_code=error9_code, self_test=self_test, media5_page_count=media5_page_count, media_names_available=media_names_available, prtinterpreterdefaultcharsetout=prtinterpreterdefaultcharsetout, nfs_server_statistic_current_memory_usage=nfs_server_statistic_current_memory_usage, prtmediapathmaxmediaxfeeddir=prtmediapathmaxmediaxfeeddir, settings_rpc_bind=settings_rpc_bind, error47_code=error47_code, prtmarkerprocesscolorants=prtmarkerprocesscolorants, prtinterpreterversion=prtinterpreterversion, error11_time_stamp=error11_time_stamp, prtChannel=prtChannel, phd4_type=phd4_type, file_system_statistic_write_open=file_system_statistic_write_open, hrdiskstorageremoveble=hrdiskstorageremoveble, job_info_attr_4=job_info_attr_4, prtoutputdescription=prtoutputdescription, channelTable=channelTable, channelstatus=channelstatus, hrdevicestatus=hrdevicestatus, ph2=ph2, phd2_capacity=phd2_capacity, phd3_model=phd3_model, simm7_type=simm7_type, error40=error40, hrDiskStorageTable=hrDiskStorageTable, dm=dm, job_info_attr_2=job_info_attr_2, media11=media11, prtOutput=prtOutput, phd3_capacity=phd3_capacity, job_info_attr_29=job_info_attr_29, error21_time_stamp=error21_time_stamp, ph3=ph3, error12=error12, pdl=pdl, error18_code=error18_code, hrstoragesize=hrstoragesize, simm4=simm4, error35_time_stamp=error35_time_stamp, job_input_auto_continue_timeout=job_input_auto_continue_timeout, channel_table=channel_table, rpc_bind_test_return_code=rpc_bind_test_return_code, collated_originals_support=collated_originals_support, outbin10_phd=outbin10_phd, error4_code=error4_code, background_status_msg_line1_part1=background_status_msg_line1_part1, simm3=simm3, hrStorageTable=hrStorageTable, simm6_type=simm6_type, job_info_attr_28=job_info_attr_28, media8_page_count=media8_page_count, hrfsindex=hrfsindex, media14_short_name=media14_short_name, overflow_bin=overflow_bin, imaging=imaging, hrpartitionlabel=hrpartitionlabel, destination_subsystem=destination_subsystem, hrpartitionfsindex=hrpartitionfsindex, job_info_attr_13=job_info_attr_13, prtoutputstatus=prtoutputstatus, error31_time_stamp=error31_time_stamp, error49=error49, ph_devices=ph_devices, error27_code=error27_code, error_log_clear=error_log_clear, phd1_type=phd1_type, tray2_media_size_loaded=tray2_media_size_loaded, media7_short_name=media7_short_name, background_message=background_message, held_job_security=held_job_security, prtmarkersuppliesmarkerindex=prtmarkersuppliesmarkerindex, phd3_manufacturing_info=phd3_manufacturing_info, outbins=outbins, localization_countries_supported=localization_countries_supported, phd2_model=phd2_model, prtinputmaxcapacity=prtinputmaxcapacity, error39_time_stamp=error39_time_stamp, outbin7_phd=outbin7_phd, prtMediaPath=prtMediaPath, simm3_type=simm3_type, file_system2_initialize_volume=file_system2_initialize_volume, error20_time_stamp=error20_time_stamp, outbin11_override_mode=outbin11_override_mode)
mibBuilder.exportSymbols("CLJ8550-MIB", tray4_phd=tray4_phd, simm3_capacity=simm3_capacity, job_info_pages_in_original=job_info_pages_in_original, outbin11_phd=outbin11_phd, error16_code=error16_code, background_message1=background_message1, simm1=simm1, media9=media9, io_switch=io_switch, job_info_pages_processed=job_info_pages_processed, port1=port1, pjl_password=pjl_password, phd3=phd3, prtGeneral=prtGeneral, prtinputmediadimxfeeddirchosen=prtinputmediadimxfeeddirchosen, error7_code=error7_code, error50=error50, media9_name=media9_name, prtOutputEntry=prtOutputEntry, default_copies=default_copies, outbin6=outbin6, print_media=print_media, prtmarkersuppliestype=prtmarkersuppliestype, settings_nfs_server=settings_nfs_server, sleep_mode=sleep_mode, prtconsolelocalization=prtconsolelocalization, simm7_capacity=simm7_capacity, job_info_attr_1=job_info_attr_1, error50_code=error50_code, device=device, background_status_msg_line2_part1=background_status_msg_line2_part1, simm7=simm7, error15_time_stamp=error15_time_stamp, file_system_max_open_files=file_system_max_open_files, phd2_device_memory=phd2_device_memory, io_buffering=io_buffering, hrprinterstatus=hrprinterstatus, prtalertdescription=prtalertdescription, media12_name=media12_name, outbin8=outbin8, settings_intray=settings_intray, hrdiskstoragecapacity=hrdiskstoragecapacity, file_system2=file_system2, status_file_system=status_file_system, prtinputmediadimxfeeddirdeclared=prtinputmediadimxfeeddirdeclared, hrStorageEntry=hrStorageEntry, error30_time_stamp=error30_time_stamp, outbin3_override_mode=outbin3_override_mode, error33=error33, prtalertgroup=prtalertgroup, hrprinterdetectederrorstate=hrprinterdetectederrorstate, prtmediapathdefaultindex=prtmediapathdefaultindex, held_job=held_job, prtinterpreterlangfamily=prtinterpreterlangfamily, system=system, media12_short_name=media12_short_name, prtoutputmaxcapacity=prtoutputmaxcapacity, prtoutputremainingcapacity=prtoutputremainingcapacity, prtinputdefaultindex=prtinputdefaultindex, channelEntry=channelEntry, hrdiskstoragemedia=hrdiskstoragemedia, status_system=status_system, channel_mio=channel_mio, nfs_server_statistic_unsuccessful=nfs_server_statistic_unsuccessful, error34=error34, error4_time_stamp=error4_time_stamp, error20=error20, error48_code=error48_code, media15_name=media15_name, job_info_attr_25=job_info_attr_25, mio1=mio1, error14_code=error14_code, simm4_capacity=simm4_capacity, error31_code=error31_code, media14_name=media14_name, prtoutputstackingorder=prtoutputstackingorder, hrPartitionTable=hrPartitionTable, cancel_job=cancel_job, prtlocalizationcharacterset=prtlocalizationcharacterset, job_being_parsed=job_being_parsed, error48_time_stamp=error48_time_stamp, error43=error43, prtmarkeraddressabilityunit=prtmarkeraddressabilityunit, error17_code=error17_code, held_job_job_name=held_job_job_name, hrstorageallocationunits=hrstorageallocationunits, errorlog=errorlog, prtinputcapacityunit=prtinputcapacityunit, error6_code=error6_code, jetsend_mode=jetsend_mode, error13_time_stamp=error13_time_stamp, media4_short_name=media4_short_name, prtinputserialnumber=prtinputserialnumber, prtmediapathminmediafeeddir=prtmediapathminmediafeeddir, outbin5_override_mode=outbin5_override_mode, print_internal_page=print_internal_page, device_location=device_location, prtconsoleontime=prtconsoleontime, model_name=model_name, job_info_attr_31=job_info_attr_31, prtoutputdecollating=prtoutputdecollating, intray2=intray2, error17_time_stamp=error17_time_stamp, media13=media13, channel=channel, prtinputname=prtinputname, error48=error48, tray1_phd=tray1_phd, xip_statistic_data_in_dropped=xip_statistic_data_in_dropped, media1_page_count=media1_page_count, error2_time_stamp=error2_time_stamp, media7_name=media7_name, resource_saving=resource_saving, outbin2_override_mode=outbin2_override_mode, error32_time_stamp=error32_time_stamp, media13_name=media13_name, xip_statistic_processed=xip_statistic_processed, prtoutputname=prtoutputname, simm4_type=simm4_type, phd4=phd4, error40_code=error40_code, prtchanneldefaultpagedesclangindex=prtchanneldefaultpagedesclangindex, prtCover=prtCover, error7_time_stamp=error7_time_stamp, error22=error22, prtoutputversion=prtoutputversion, hrStorage=hrStorage, phd5=phd5, error31=error31, prtinputstatus=prtinputstatus, nfs_server_read_size=nfs_server_read_size, hrFSEntry=hrFSEntry, prtmediapathminmediaxfeeddir=prtmediapathminmediaxfeeddir, hrDiskStorageEntry=hrDiskStorageEntry, media3=media3, prtgeneralserviceperson=prtgeneralserviceperson, pcl_default_font_width=pcl_default_font_width, current_job_parsing_id=current_job_parsing_id, prtOutputTable=prtOutputTable, prtinputdescription=prtinputdescription, simm=simm, error46_code=error46_code, prtinputvendorname=prtinputvendorname, test=test, prtinputtype=prtinputtype, error3=error3, media3_page_count=media3_page_count, phd6_type=phd6_type, hrpartitionindex=hrpartitionindex, channelnumberofchannels=channelnumberofchannels, custom_paper_feed_dim=custom_paper_feed_dim, settings_outbin=settings_outbin, job_info_printed_originals=job_info_printed_originals, hrdiskstorageaccess=hrdiskstorageaccess, hrfslastfullbackupdate=hrfslastfullbackupdate, print_engine_test=print_engine_test, tray3_phd=tray3_phd, media4_page_count=media4_page_count, mio1_type=mio1_type, error44=error44, error7=error7, prtmarkereastmargin=prtmarkereastmargin, media1=media1, channeltype=channeltype, prtinputmedianame=prtinputmedianame, hrfsmountpoint=hrfsmountpoint, channel_io_errors=channel_io_errors, hp=hp, outbin10_override_mode=outbin10_override_mode, outbin6_override_mode=outbin6_override_mode, error32=error32, prtgeneralbannerpage=prtgeneralbannerpage, interface=interface, media7=media7, hrpartitionsize=hrpartitionsize, error42=error42, prtStorageRefEntry=prtStorageRefEntry, prtmediapathmaxmediafeeddir=prtmediapathmaxmediafeeddir, error33_time_stamp=error33_time_stamp, error38_code=error38_code, prtMarkerSuppliesTable=prtMarkerSuppliesTable, prtoutputcapacityunit=prtoutputcapacityunit, error45=error45, error6=error6, media11_short_name=media11_short_name, outbin7_override_mode=outbin7_override_mode, phd2_device_specific_command=phd2_device_specific_command, prtinputdimunit=prtinputdimunit, default_vmi=default_vmi, prtCoverTable=prtCoverTable, error23_time_stamp=error23_time_stamp, prtinputversion=prtinputversion, media3_short_name=media3_short_name, rpc_bind_statistic_successful=rpc_bind_statistic_successful, prtinputcurrentlevel=prtinputcurrentlevel, prtoutputvendorname=prtoutputvendorname, prtmarkercounterunit=prtmarkercounterunit, media5=media5, held_job_pin=held_job_pin, error42_time_stamp=error42_time_stamp, error16=error16, mio1_model_name=mio1_model_name, error33_code=error33_code, rpc_services=rpc_services, pysmi_continue=pysmi_continue, pcl_default_font_height=pcl_default_font_height, phd1=phd1, prtMarkerTable=prtMarkerTable, mio2_model_name=mio2_model_name, prtoutputtype=prtoutputtype, job_info=job_info, prtStorageRefTable=prtStorageRefTable, prtoutputsecurity=prtoutputsecurity, ports=ports, phd3_device_memory=phd3_device_memory, default_vertical_black_resolution=default_vertical_black_resolution, prtmarkersuppliesmaxcapacity=prtmarkersuppliesmaxcapacity, prtmarkersouthmargin=prtmarkersouthmargin, error36_code=error36_code, simm6=simm6, rpc_statistic_unsuccessful=rpc_statistic_unsuccessful, error18_time_stamp=error18_time_stamp, prtconsolecolor=prtconsolecolor, localization_languages_supported=localization_languages_supported, status_nfs_server=status_nfs_server, mass_storage_resource_change_counter=mass_storage_resource_change_counter, job_info_attr_16=job_info_attr_16, error36=error36, error38=error38, outbin8_override_mode=outbin8_override_mode, media4_name=media4_name, error13_code=error13_code, media13_page_count=media13_page_count, hrmemorysize=hrmemorysize, prtmarkersupplieslevel=prtmarkersupplieslevel, model_number=model_number, prtoutputpagedeliveryorientation=prtoutputpagedeliveryorientation, tray1_media_size_loaded=tray1_media_size_loaded, prtmarkerlifecount=prtmarkerlifecount, hrstorageallocationfailures=hrstorageallocationfailures, media10_name=media10_name, prtCoverEntry=prtCoverEntry, print_engine=print_engine, held_job_set_queue_size=held_job_set_queue_size, cold_reset_media_size=cold_reset_media_size, prtcoverdescription=prtcoverdescription, auto_continue=auto_continue, error20_code=error20_code, error28_code=error28_code, prtinterpreterxfeedaddressability=prtinterpreterxfeedaddressability, error25=error25, prtconsoledescription=prtconsoledescription, prtmarkeraddressabilityfeeddir=prtmarkeraddressabilityfeeddir, prtmediapathmaxspeed=prtmediapathmaxspeed)
mibBuilder.exportSymbols("CLJ8550-MIB", ph=ph, mio2_type=mio2_type, prtConsoleDisplayBufferEntry=prtConsoleDisplayBufferEntry, media15=media15, outbin4_override_mode=outbin4_override_mode, error36_time_stamp=error36_time_stamp, job_info_attr_15=job_info_attr_15, prtLocalization=prtLocalization, error15=error15, job_info_attr_11=job_info_attr_11, default_page_protect=default_page_protect, jetsend_contact_ip_address_security=jetsend_contact_ip_address_security, hrfsbootable=hrfsbootable, phd=phd, prtMarkerSupplies=prtMarkerSupplies)

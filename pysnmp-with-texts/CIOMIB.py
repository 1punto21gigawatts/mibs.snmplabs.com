#
# PySNMP MIB module CIOMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CIOMIB
# Produced by pysmi-0.3.4 at Wed May  1 11:49:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, NotificationType, Bits, MibIdentifier, ModuleIdentity, iso, IpAddress, enterprises, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Integer32, Unsigned32, Counter32, ObjectIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "NotificationType", "Bits", "MibIdentifier", "ModuleIdentity", "iso", "IpAddress", "enterprises", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Integer32", "Unsigned32", "Counter32", "ObjectIdentity", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
adaptec = MibIdentifier((1, 3, 6, 1, 4, 1, 795))
storagemanagement = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2))
cio2 = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12))
mibRevision = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 1))
storageDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 2))
storageController = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 3))
enclosure = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 4))
busPort = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 5))
aggregatePhysicalExtent = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 6))
aggregateProtectedSpace = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 7))
volumeSet = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 8))
redundancyGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 9))
worldWideIds = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 10))
associations = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 11))
busPortAssociations = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 12))
componentSpareAssociations = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 13))
overallObjectStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 14))
operationalStates = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 15))
statistics = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 16))
trapLogCount = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 17))
trapLog = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 18))
revMajor = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revMajor.setStatus('mandatory')
if mibBuilder.loadTexts: revMajor.setDescription('The major number of the revision of the CIO MIB.')
revMinor = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: revMinor.setStatus('mandatory')
if mibBuilder.loadTexts: revMinor.setDescription('The minor number of the revision of the CIO MIB.')
deviceTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1), )
if mibBuilder.loadTexts: deviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTable.setDescription('A list of storage devices.')
devEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1), ).setIndexNames((0, "CIOMIB", "devIndex"))
if mibBuilder.loadTexts: devEntry.setStatus('mandatory')
if mibBuilder.loadTexts: devEntry.setDescription('A storage device entry.')
devIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devIndex.setStatus('mandatory')
if mibBuilder.loadTexts: devIndex.setDescription('A unique index value for each storage device beginning with 1.')
devType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("rigidDiskDrive", 3), ("flexibleDisketteDrive", 4), ("opticalWriteOnceReadManyDrive", 6), ("magnetoOpticalDrive", 7), ("compactDiskDrive", 8), ("flashDisk", 9), ("cartridgeRigidDiskDrive", 10), ("opticalFloppyDrive", 11), ("tapeDrive", 12), ("solidState", 13), ("mediaChanger", 14), ("digitalVersatileDiskDrive", 15), ("digitalVersatileDiskRAMDrive", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devType.setStatus('mandatory')
if mibBuilder.loadTexts: devType.setDescription('The type of this mass storage device.')
devTypeDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devTypeDescr.setStatus('mandatory')
if mibBuilder.loadTexts: devTypeDescr.setDescription('A longer description of the storage device. For example: 3.5 inch flexible diskette drives using diskettes with a maximum capacity of 1.44MB.')
devSubIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devSubIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: devSubIdentifier.setDescription("The sub-identifier for this storage device (e.g., the device's SCSI logical unit number).")
devMediaBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devMediaBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: devMediaBlockSize.setDescription('The size in bytes of the data blocks used on the storage media. If the media block size is unknown or inconsistent then this value shall be zero.')
devFormattedMediaCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devFormattedMediaCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: devFormattedMediaCapacity.setDescription('The total size in kilobytes of this storage media after it has been formatted.')
devRemovableDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devRemovableDevice.setStatus('mandatory')
if mibBuilder.loadTexts: devRemovableDevice.setDescription('If true, then this storage device is removable (e.g.: PCMCIA device).')
devLoaded = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: devLoaded.setDescription('If true, then the storage device is loaded.')
devRemovableMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devRemovableMedia.setStatus('mandatory')
if mibBuilder.loadTexts: devRemovableMedia.setDescription('If true, then the media in this storage device is removable.')
devMediaLoaded = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devMediaLoaded.setStatus('mandatory')
if mibBuilder.loadTexts: devMediaLoaded.setDescription('If true, the media in this storage device is loaded.')
devCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devCompression.setStatus('mandatory')
if mibBuilder.loadTexts: devCompression.setDescription('If true, the storage device supports compression.')
devEncryption = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devEncryption.setStatus('mandatory')
if mibBuilder.loadTexts: devEncryption.setDescription('If true, the storage device supports encryption.')
ctlrTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1), )
if mibBuilder.loadTexts: ctlrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrTable.setDescription('A list of storage controllers.')
ctlrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1), ).setIndexNames((0, "CIOMIB", "ctlrIndex"))
if mibBuilder.loadTexts: ctlrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrEntry.setDescription('A storage controller entry.')
ctlrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctlrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrIndex.setDescription('A unique index value for each storage controller beginning with 1.')
ctlrDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctlrDescription.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrDescription.setDescription('Name, brand, and hardware revision level of the storage controller.')
ctlrProtectionManagement = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("unprotected", 3), ("protected", 4), ("protectedThroughSCSI3SCC", 5), ("protectedThroughSCSI3SCC2", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctlrProtectionManagement.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrProtectionManagement.setDescription('Indicates whether or not the controller provides redundancy or protection against device failures.')
ctlrBusMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("false", 0), ("true", 1), ("unknown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctlrBusMaster.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrBusMaster.setDescription('If TRUE, then this storage controller is the bus master.')
ctlrSecondsSinceLastPowerUp = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctlrSecondsSinceLastPowerUp.setStatus('mandatory')
if mibBuilder.loadTexts: ctlrSecondsSinceLastPowerUp.setDescription('The number of seconds that have passed since this controller was last powered on.')
enclTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 4, 1), )
if mibBuilder.loadTexts: enclTable.setStatus('mandatory')
if mibBuilder.loadTexts: enclTable.setDescription('A list of enclosures.')
enclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 4, 1, 1), ).setIndexNames((0, "CIOMIB", "enclIndex"))
if mibBuilder.loadTexts: enclEntry.setStatus('mandatory')
if mibBuilder.loadTexts: enclEntry.setDescription('An enclosure entry.')
enclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: enclIndex.setDescription('A unique index value for each enclosure beginning with 1.')
enclType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("decfault", 3), ("safte", 4), ("ses", 5), ("aemi", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclType.setStatus('mandatory')
if mibBuilder.loadTexts: enclType.setDescription('The type of the enclosure.')
enclDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: enclDescription.setStatus('mandatory')
if mibBuilder.loadTexts: enclDescription.setDescription('Description of the enclosure.')
busPortTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1), )
if mibBuilder.loadTexts: busPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: busPortTable.setDescription('A list of bus ports.')
busPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1), ).setIndexNames((0, "CIOMIB", "portIndex"))
if mibBuilder.loadTexts: busPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busPortEntry.setDescription('A bus port entry.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('A unique index value for each bus port beginning with 1.')
portProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("eisa", 3), ("isa", 4), ("pci", 5), ("ata-atapi", 6), ("flexibleDiskette", 7), ("interface1496", 8), ("scsiParallel", 9), ("scsiFibreChannel", 10), ("scsiSerialBusProtocol", 11), ("scsiSerialBusProtocol2", 12), ("scsiSerialStorageArchitecture", 13), ("vesa", 14), ("pcmcia", 15), ("universalSerialBus", 16), ("parallelPort", 17), ("escon", 18), ("diagnostic", 19), ("i2c", 20), ("power", 21), ("hippi", 22), ("multibus", 23), ("vme", 24), ("ipi", 25), ("ieee488", 26), ("rs232", 27), ("ieee802-3-10Base5", 28), ("ieee802-3-10Base2", 29), ("ieee802-3-1Base5", 30), ("ieee802-3-10Broad36", 31), ("ieee802-3-100BaseVG", 32), ("ieee802-5-Tokenring", 33), ("fddi", 34), ("mca", 35)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: portProtocol.setDescription("The protocol describing the electrical characteristics of the Bus Port. If 'Other' is used, then the Protocol Description attribute shall be used.")
portProtocolDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portProtocolDescription.setStatus('mandatory')
if mibBuilder.loadTexts: portProtocolDescription.setDescription('Additional description of the protocol describe above.')
portSignalCharacteristics = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("singleEnded", 3), ("differential", 4), ("lowVoltageDifferential", 5), ("optical", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSignalCharacteristics.setStatus('mandatory')
if mibBuilder.loadTexts: portSignalCharacteristics.setDescription('The electrical characteristics of the Bus Port being described.')
portAddressDescriptor = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAddressDescriptor.setStatus('mandatory')
if mibBuilder.loadTexts: portAddressDescriptor.setDescription('The address descriptor for this bus port. For example the PCI slot and ID.')
portIsochronous = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIsochronous.setStatus('mandatory')
if mibBuilder.loadTexts: portIsochronous.setDescription('Indicates whether or not the bus port supports isochronous transfers.')
portMaximumWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaximumWidth.setStatus('mandatory')
if mibBuilder.loadTexts: portMaximumWidth.setDescription("The maximum width, in bits, of this Bus Port's data path. A value of 1 should be used for serial.")
portMaximumTransferRate = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaximumTransferRate.setStatus('mandatory')
if mibBuilder.loadTexts: portMaximumTransferRate.setDescription('The theoretical maximum transfer rate, in millions of bytes per second, that this Bus Port is capable of achieving under ideal conditions. A value of zero should be used if the transfer rate is less than 1 million bytes per second.')
portMaximumAttachments = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMaximumAttachments.setStatus('mandatory')
if mibBuilder.loadTexts: portMaximumAttachments.setDescription("The maximum number of directly addressable entities supported by this bus port's protocol.")
portConnectorType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("none", 3), ("scsi-A-HighDensityShielded-50pin", 4), ("scsi-A-HighDensityUnshielded-50pin", 5), ("scsi-A-LowDensityShielded-50pin", 6), ("scsi-A-LowDensityUnshielded-50pin", 7), ("scsi-P-HighDensityShielded-68pin", 8), ("scsi-P-HighDensityUnshielded-68pin", 9), ("scsi-SCA-I-80pin", 10), ("scsi-SCA-II-80pin", 11), ("scsi-FibreChannel-DB9-Copper", 12), ("scsi-FibreChannel-Fibre", 13), ("scsi-FibreChannel-SCA-II-40pin", 14), ("scsi-FibreChannel-SCA-II-20pin", 15), ("scsi-FibreChannel-BNC", 16), ("ata-3-5inch-40pin", 17), ("ata-2-5inch-44pin", 18), ("serial-9pin", 19), ("serial-25pin", 20), ("rs232-25pin", 21), ("rs422", 22), ("ieee488", 23), ("aui", 24), ("upt-Category3", 25), ("upt-Category4", 26), ("upt-Category5", 27), ("bnc", 28), ("stp-RJ11", 29), ("stp-RJ45", 30), ("stp-DB9", 31), ("fiberMIC", 32), ("appleAUI", 33), ("pciSlot", 34), ("isaSlot", 35), ("eisaSlot", 36), ("vesaSlot", 37), ("pcmciaSlot", 38), ("pc-CardSlot", 39), ("floppyDiskette5-25inch", 40), ("floppyDiskette3-5inch", 41), ("hssdc-6pin", 42), ("gbicSocket", 43), ("thirteenNinetyFour-6pin", 44), ("scsi-VHDCIshielded-68pin", 45)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConnectorType.setStatus('mandatory')
if mibBuilder.loadTexts: portConnectorType.setDescription("Describes how options (cards, devices, etc.) physically connect to this port bus. If 'Other' is used, then the connector type description attribute shall be used.")
portConnectorTypeDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConnectorTypeDescription.setStatus('mandatory')
if mibBuilder.loadTexts: portConnectorTypeDescription.setDescription('Additional description of the connector described above.')
portConnectorGender = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("female", 3), ("male", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConnectorGender.setStatus('mandatory')
if mibBuilder.loadTexts: portConnectorGender.setDescription('Indicates the gender of the connector described above.')
aggregatePExtentTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 6, 1), )
if mibBuilder.loadTexts: aggregatePExtentTable.setStatus('mandatory')
if mibBuilder.loadTexts: aggregatePExtentTable.setDescription('A list of aggregate physical extent entries.')
aggregatePExtentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 6, 1, 1), ).setIndexNames((0, "CIOMIB", "aggPExtentIndex"))
if mibBuilder.loadTexts: aggregatePExtentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aggregatePExtentEntry.setDescription('An aggregate P Extent entry.')
aggPExtentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggPExtentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aggPExtentIndex.setDescription('A unique index value for each aggregate physical extent beginning with 1.')
aggPExtentBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 6, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggPExtentBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: aggPExtentBlocks.setDescription('The total number of consecutive blocks (including check data blocks) contained in the aggregate p extent. The block size is determined by the storage device associated with this aggregate p extent. Note: If no redundancy group is associated with an aggregate p extent, then this number indicates that the p extent is available.')
aggPExtentCheckDataBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggPExtentCheckDataBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: aggPExtentCheckDataBlocks.setDescription('The number of blocks contained in the aggregate p extent to be used as check data. If the aggregate p extent is available, then this value shall be zero.')
aggregatePsExtentTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 7, 1), )
if mibBuilder.loadTexts: aggregatePsExtentTable.setStatus('mandatory')
if mibBuilder.loadTexts: aggregatePsExtentTable.setDescription('A list of aggregate protected space extents.')
aggregatePsExtentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 7, 1, 1), ).setIndexNames((0, "CIOMIB", "aggPsExtentIndex"))
if mibBuilder.loadTexts: aggregatePsExtentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: aggregatePsExtentEntry.setDescription('An aggregate Ps extent entry.')
aggPsExtentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggPsExtentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: aggPsExtentIndex.setDescription('A unique index value for each aggregate ps extent beginning with 1.')
aggPsExtentBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 7, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aggPsExtentBlocks.setStatus('mandatory')
if mibBuilder.loadTexts: aggPsExtentBlocks.setDescription('The total number of user data blocks that is both located on a single storage device and part or all of a single volume set. The block size is determined by the storage device associated with this aggregate protected space extent. Note: if no volume set is associated with an aggregate protected space extent, then this number indicates the number of blocks that are available.')
volumeSetTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1), )
if mibBuilder.loadTexts: volumeSetTable.setStatus('mandatory')
if mibBuilder.loadTexts: volumeSetTable.setDescription('A list of volume sets.')
volumeSetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1), ).setIndexNames((0, "CIOMIB", "volIndex"))
if mibBuilder.loadTexts: volumeSetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: volumeSetEntry.setDescription('A volume set entry.')
volIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: volIndex.setStatus('mandatory')
if mibBuilder.loadTexts: volIndex.setDescription('A unique index value for each volume set beginning with 1.')
volName = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: volName.setStatus('mandatory')
if mibBuilder.loadTexts: volName.setDescription('The name of the volume set.')
volCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: volCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: volCapacity.setDescription('The total size in Kbytes of the user data space of this volume set.')
volPSExtentStripeLength = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: volPSExtentStripeLength.setStatus('mandatory')
if mibBuilder.loadTexts: volPSExtentStripeLength.setDescription('The number of ps_extents which form a user data stripe. This value shall be zero except when the ps_extent group is used.')
volPSExtentInterleaveDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: volPSExtentInterleaveDepth.setStatus('mandatory')
if mibBuilder.loadTexts: volPSExtentInterleaveDepth.setDescription('The number of ps_extents to stripe as a collective set. This value shall be zero except when the ps_extent group is used.')
redundancyGroupTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 9, 1), )
if mibBuilder.loadTexts: redundancyGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyGroupTable.setDescription('A list of redundancy groups.')
redundancyGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 9, 1, 1), ).setIndexNames((0, "CIOMIB", "redundancyIndex"))
if mibBuilder.loadTexts: redundancyGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyGroupEntry.setDescription('A redundancy group entry.')
redundancyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyIndex.setDescription('A unique index value for each redundancy group beginning with 1.')
redundancyType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 9, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("copy", 3), ("xor", 4), ("p-q", 5), ("s", 6), ("p-s", 7), ("none", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyType.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyType.setDescription('This field specifies the type of redundancy formed.')
worldWideIdTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 10, 1), )
if mibBuilder.loadTexts: worldWideIdTable.setStatus('mandatory')
if mibBuilder.loadTexts: worldWideIdTable.setDescription('A list of worldWideIds.')
worldWideIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 10, 1, 1), ).setIndexNames((0, "CIOMIB", "worldWideIdIndex"))
if mibBuilder.loadTexts: worldWideIdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: worldWideIdEntry.setDescription('An worldWideId entry.')
worldWideIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: worldWideIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: worldWideIdIndex.setDescription('A unique index value for each WorldWideID beginning with 1.')
worldWideIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("none", 3), ("vendorProductSerial", 4), ("ieeeExtendedUniqueIdentifier64bit", 5), ("fc-PH64bitNameIdentifier", 6), ("binary", 7), ("unicode", 8), ("lanMACAddress", 9), ("wanAccessAddress", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: worldWideIdType.setStatus('mandatory')
if mibBuilder.loadTexts: worldWideIdType.setDescription('The type of identifier displayed by the Worldwide Identifier attribute.')
worldWideId = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 10, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: worldWideId.setStatus('mandatory')
if mibBuilder.loadTexts: worldWideId.setDescription('The Worldwide Identifier for this entity.')
associationTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1), )
if mibBuilder.loadTexts: associationTable.setStatus('mandatory')
if mibBuilder.loadTexts: associationTable.setDescription('A list of associations.')
associationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1, 1), ).setIndexNames((0, "CIOMIB", "associationIndex"))
if mibBuilder.loadTexts: associationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: associationEntry.setDescription('An association entry.')
associationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: associationIndex.setDescription('A unique index value for each association beginning with 1.')
associationType = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: associationType.setStatus('mandatory')
if mibBuilder.loadTexts: associationType.setDescription("This field specifies the type of the association. It contains one of the following values: 'Physical Organization', 'Logical Organization', 'Logical to Physical Organization', 'Redundancy Organization', 'Spare Organization', 'Cache', 'FRU', 'Operational State', 'Statistical', 'SubComponent Software', or 'Worldwide Identifier'.")
associationObject1 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associationObject1.setStatus('mandatory')
if mibBuilder.loadTexts: associationObject1.setDescription('The authoritative identifier for the first object referenced.')
associationObject2 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 11, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: associationObject2.setStatus('mandatory')
if mibBuilder.loadTexts: associationObject2.setDescription('The authoritative identifier for the second object referenced.')
busPortAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 12, 1), )
if mibBuilder.loadTexts: busPortAssociationTable.setStatus('mandatory')
if mibBuilder.loadTexts: busPortAssociationTable.setDescription('A list of bus port associations.')
busPortAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 12, 1, 1), ).setIndexNames((0, "CIOMIB", "busPortAssociationIndex"))
if mibBuilder.loadTexts: busPortAssociationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: busPortAssociationEntry.setDescription('A bus port association entry.')
busPortAssociationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busPortAssociationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: busPortAssociationIndex.setDescription('An unique index for each bus port association. This index matches an index in the association table for which bus port association information is available.')
busPortAssociationNegotiatedSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busPortAssociationNegotiatedSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: busPortAssociationNegotiatedSpeed.setDescription('The maximum burst transfer rate, in millions of bytes, which was negotiated between the two associated bus ports.')
busPortAssociationNegotiatedWidth = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 12, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: busPortAssociationNegotiatedWidth.setStatus('mandatory')
if mibBuilder.loadTexts: busPortAssociationNegotiatedWidth.setDescription("The width, in bits, of the bus ports' data path which was negotiated between the two associated bus ports.")
componentSpareAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 13, 1), )
if mibBuilder.loadTexts: componentSpareAssociationTable.setStatus('mandatory')
if mibBuilder.loadTexts: componentSpareAssociationTable.setDescription('A list of component spare associations.')
componentSpareAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 13, 1, 1), ).setIndexNames((0, "CIOMIB", "componentSpareAssociationIndex"))
if mibBuilder.loadTexts: componentSpareAssociationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: componentSpareAssociationEntry.setDescription('A component spare association entry.')
componentSpareAssociationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: componentSpareAssociationIndex.setStatus('mandatory')
if mibBuilder.loadTexts: componentSpareAssociationIndex.setDescription('An unique index for each component spare association. This index matches an index in the association table for which component spare association information is available.')
componentSpareFunctioningState = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("inactiveStandby", 3), ("activeStandby", 4), ("activeStandbyLoadBalances", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: componentSpareFunctioningState.setStatus('mandatory')
if mibBuilder.loadTexts: componentSpareFunctioningState.setDescription('The functioning state of the spares.')
overallStatus = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("okay", 1), ("warning", 2), ("failure", 3), ("unknown", 4), ("other", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: overallStatus.setStatus('mandatory')
if mibBuilder.loadTexts: overallStatus.setDescription('The overall status of objects in the CIO MIB. Will be set to the worst status of any individual object.')
operationalStateTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1), )
if mibBuilder.loadTexts: operationalStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: operationalStateTable.setDescription('A list of operational state information.')
operationalStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1), ).setIndexNames((0, "CIOMIB", "operationalStateIndex"))
if mibBuilder.loadTexts: operationalStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: operationalStateEntry.setDescription('An operational state entry.')
operationalStateIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalStateIndex.setStatus('mandatory')
if mibBuilder.loadTexts: operationalStateIndex.setDescription('A unique index value for each operational state table entry beginning with 1.')
operationalDeviceGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalDeviceGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: operationalDeviceGroupIndex.setDescription('This field present for DMI compatibility - unused in SNMP, always 0.')
operationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("enabled", 3), ("disabled", 4), ("notApplicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalStatus.setStatus('mandatory')
if mibBuilder.loadTexts: operationalStatus.setDescription('The operational status of the object.')
operationalUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("idle", 3), ("active", 4), ("busy", 5), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: operationalUsageState.setDescription('The usage state of the object.')
operationalAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("running", 3), ("warning", 4), ("inTest", 5), ("notApplicable", 6), ("powerOff", 7), ("offLine", 8), ("offDuty", 9), ("degraded", 10), ("notInstalled", 11), ("installError", 12), ("powerSave", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: operationalAvailabilityStatus.setDescription('The availability of the object.')
operationalAdministrativeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("locked", 3), ("unlocked", 4), ("notApplicable", 5), ("shuttingDown", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalAdministrativeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: operationalAdministrativeStatus.setDescription('The administrative state of the object.')
operationalFatalErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalFatalErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: operationalFatalErrorCount.setDescription('The accumulated Fatal or Non-recoverable error count for the object.')
operationalMajorErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalMajorErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: operationalMajorErrorCount.setDescription('The accumulated Major or Critical error count for the object.')
operationalWarningErrorCount = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalWarningErrorCount.setStatus('mandatory')
if mibBuilder.loadTexts: operationalWarningErrorCount.setDescription('The accumulated Warning or Non-critical error count for the object.')
operationalCurrentErrorStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("ok", 3), ("noncritical", 4), ("critical", 5), ("nonrecoverable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalCurrentErrorStatus.setStatus('mandatory')
if mibBuilder.loadTexts: operationalCurrentErrorStatus.setDescription("This attribute presents the current error status for the object. The most critical error status in effect should be presented. I.e. if a part of the object is 'Critical', while other status is 'Non-critical' then the status 'Critical' should be reported.")
operationalPredictedFailureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 15, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("unknown", 2), ("notSupported", 3), ("noFailurePredicted", 4), ("deviceFailurePredicted", 5), ("mediaFailurePredicted", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: operationalPredictedFailureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: operationalPredictedFailureStatus.setDescription('Enumeration describing the current Device Predicted Failure Status (e.g.: the S.M.A.R.T. status of the object).')
statisticsTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1), )
if mibBuilder.loadTexts: statisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsTable.setDescription('A list of statistics.')
statisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1), ).setIndexNames((0, "CIOMIB", "statisticsIndex"))
if mibBuilder.loadTexts: statisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsEntry.setDescription('A statistics entry.')
statisticsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsIndex.setDescription('A unique index value for each statistics table entry beginning with 1.')
statisticsBlocksRead = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsBlocksRead.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsBlocksRead.setDescription('The number of 512 byte blocks read from the object.')
statisticsBlocksWritten = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsBlocksWritten.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsBlocksWritten.setDescription('The number of 512 byte blocks written to the object.')
statisticsReadCommands = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadCommands.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadCommands.setDescription('The number of read commands issued for the object.')
statisticsWriteCommands = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteCommands.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteCommands.setDescription('The number of write commands issued for the object.')
statisticsReadBucket0 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket0.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket0.setDescription('The number of read commands issued, size < 512 bytes.')
statisticsReadBucket1 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket1.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket1.setDescription('The number of read commands issued, 512 bytes <= size < 1K bytes.')
statisticsReadBucket2 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket2.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket2.setDescription('The number of read commands issued, 1K bytes <= size < 2K bytes.')
statisticsReadBucket3 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket3.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket3.setDescription('The number of read commands issued, 2K bytes <= size < 4K bytes.')
statisticsReadBucket4 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket4.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket4.setDescription('The number of read commands issued, 4K bytes <= size < 8K bytes.')
statisticsReadBucket5 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket5.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket5.setDescription('The number of read commands issued, 8K bytes <= size < 16K bytes.')
statisticsReadBucket6 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket6.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket6.setDescription('The number of read commands issued, 16K bytes <= size < 32K bytes.')
statisticsReadBucket7 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket7.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket7.setDescription('The number of read commands issued, 32K bytes <= size < 64K bytes.')
statisticsReadBucket8 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket8.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket8.setDescription('The number of read commands issued, 64K bytes <= size < 128K bytes.')
statisticsReadBucket9 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket9.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket9.setDescription('The number of read commands issued, 128K bytes <= size < 256K bytes.')
statisticsReadBucket10 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket10.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket10.setDescription('The number of read commands issued, 256K bytes <= size < 512K bytes.')
statisticsReadBucket11 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket11.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket11.setDescription('The number of read commands issued, 512K bytes <= size < 1M bytes.')
statisticsReadBucket12 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsReadBucket12.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsReadBucket12.setDescription('The number of read commands issued, size >= 1M bytes.')
statisticsWriteBucket0 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket0.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket0.setDescription('The number of write commands issued, size < 512 bytes.')
statisticsWriteBucket1 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket1.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket1.setDescription('The number of write commands issued, 512 bytes <= size < 1K bytes.')
statisticsWriteBucket2 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket2.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket2.setDescription('The number of write commands issued, 1K bytes <= size < 2K bytes.')
statisticsWriteBucket3 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket3.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket3.setDescription('The number of write commands issued, 2K bytes <= size < 4K bytes.')
statisticsWriteBucket4 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket4.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket4.setDescription('The number of write commands issued, 4K bytes <= size < 8K bytes.')
statisticsWriteBucket5 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket5.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket5.setDescription('The number of write commands issued, 8K bytes <= size < 16K bytes.')
statisticsWriteBucket6 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket6.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket6.setDescription('The number of write commands issued, 16K bytes <= size < 32K bytes.')
statisticsWriteBucket7 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket7.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket7.setDescription('The number of write commands issued, 32K bytes <= size < 64K bytes.')
statisticsWriteBucket8 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket8.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket8.setDescription('The number of write commands issued, 64K bytes <= size < 128K bytes.')
statisticsWriteBucket9 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket9.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket9.setDescription('The number of write commands issued, 128K bytes <= size < 256K bytes.')
statisticsWriteBucket10 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket10.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket10.setDescription('The number of write commands issued, 256K bytes <= size < 512K bytes.')
statisticsWriteBucket11 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket11.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket11.setDescription('The number of write commands issued, 512K bytes <= size < 1M bytes.')
statisticsWriteBucket12 = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 16, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsWriteBucket12.setStatus('mandatory')
if mibBuilder.loadTexts: statisticsWriteBucket12.setDescription('The number of write commands issued, size >= 1M bytes.')
cycTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000))
trapLogNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 17, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLogNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogNumEntries.setDescription('The number entries in the Trap Log.')
trapLogTable = MibTable((1, 3, 6, 1, 4, 1, 795, 2, 12, 18, 1), )
if mibBuilder.loadTexts: trapLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogTable.setDescription('A circular list of trap log entries. The number of entries is given by the value of trapLogCount. Current maximum trap log count is fixed at 125, but should be programmable (via MIB variable and .INI file) in the future.')
trapLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 795, 2, 12, 18, 1, 1), ).setIndexNames((0, "CIOMIB", "trapLogIndex"))
if mibBuilder.loadTexts: trapLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogEntry.setDescription('A trap log entry.')
trapLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 18, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogIndex.setDescription('A unique index value for each trap log table entry beginning with 1.')
trapLogString = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 18, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLogString.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogString.setDescription('A textual string containing the text of the last trap.')
trapLogTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 795, 2, 12, 18, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapLogTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: trapLogTimeStamp.setDescription('The number of seconds which have elapsed between powerup and the trap occurrence.')
cycSeverity = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9001), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("informational", 2), ("warning", 3), ("critical", 4))))
if mibBuilder.loadTexts: cycSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: cycSeverity.setDescription('Severity level of the trap.')
cycObject = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9002), ObjectIdentifier())
if mibBuilder.loadTexts: cycObject.setStatus('mandatory')
if mibBuilder.loadTexts: cycObject.setDescription('The object identifier of the object referred to by the trap.')
cycPhysicalObjectState = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9003), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37))).clone(namedValues=NamedValues(("newlyDiscovered", 1), ("failed", 2), ("recovered", 3), ("changed", 4), ("selfMonitoringWarning", 5), ("selfMonitoringEnabled", 6), ("cacheParametersChanged", 7), ("cacheOn", 8), ("cacheOff", 9), ("deleted", 10), ("batteryReconditionScheduled", 11), ("scheduledBatteryReconditionDeleted", 12), ("batteryChangedGoodToLow", 13), ("batteryChangedLowToGood", 14), ("batteryChangedLowToReconditioning", 15), ("batteryChangedGoodToReconditioning", 16), ("batteryChangedReconditioningToLow", 17), ("batteryChangedReconditioningToGood", 18), ("batteryReconditionCompleted", 19), ("batteryReconditionStarted", 20), ("initializeStarted", 21), ("initializeCompleted", 22), ("initializeFailed", 23), ("initializeAbortedByUser", 24), ("verifyStarted", 25), ("verifyCompleted", 26), ("verifyFailed", 27), ("verifyAbortedByUser", 28), ("batteryOkay", 29), ("batteryDead", 30), ("batteryFailedCharge", 31), ("batteryOvercharged", 32), ("batteryCurrentTooHigh", 33), ("batteryTemperatureTooHigh", 34), ("batteryVoltageTooLow", 35), ("batteryMissing", 36), ("batteryShortCircuit", 37))))
if mibBuilder.loadTexts: cycPhysicalObjectState.setStatus('mandatory')
if mibBuilder.loadTexts: cycPhysicalObjectState.setDescription('New state for the object referred to by the trap.')
cycVolumeSetState = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9004), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28))).clone(namedValues=NamedValues(("unsafeShutdown", 1), ("badBlockRepaired", 2), ("offline", 3), ("offlineMemberFailed", 4), ("online", 5), ("criticalState", 6), ("protectionDisabled", 7), ("protectionEnabled", 8), ("selfMonitoringWarning", 9), ("selfMonitoringEnabled", 10), ("memberMissing", 11), ("dedicatedSpareDeleted", 12), ("dedicatedSpareAdded", 13), ("poolSpareDeleted", 14), ("poolSpareAdded", 15), ("dedicatedSpareUsed", 16), ("poolSpareUsed", 17), ("lastSpareUsed", 18), ("lastSpareDeleted", 19), ("cacheParametersChanged", 20), ("cacheOn", 21), ("cacheOff", 22), ("cacheFlushFailed", 23), ("cacheAllocationFailed", 24), ("arrayAdded", 25), ("arrayDeleted", 26), ("scsiAddressesChangedForMembers", 27), ("nameChanged", 28))))
if mibBuilder.loadTexts: cycVolumeSetState.setStatus('mandatory')
if mibBuilder.loadTexts: cycVolumeSetState.setDescription('New state for the object referred to by the trap.')
cycVolumeSetActivity = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9005), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("reconstruct", 1), ("initialize", 2), ("verify", 3), ("spareTest", 4), ("scheduledReconstruct", 5), ("scheduledInitialize", 6), ("scheduledVerify", 7), ("scheduledSpareTest", 8), ("mirrorBreak", 9), ("mirrorCreate", 10), ("migration", 11), ("expansion", 12))))
if mibBuilder.loadTexts: cycVolumeSetActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cycVolumeSetActivity.setDescription('New activity for the object referred to by the trap.')
cycVolumeSetActivityState = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9006), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("started", 1), ("startedAutofix", 2), ("completed", 3), ("completedWithMiscompares", 4), ("abortedDueToIOError", 5), ("abortedDueToIOErrorWithMiscompares", 6), ("abortedByOperator", 7), ("abortedByOperatorWithMiscompares", 8), ("failed", 9), ("deleted", 10), ("priorityChanged", 11), ("scheduled", 12), ("modified", 13), ("failedToStart", 14), ("abortedNoMemory", 15), ("restarted", 16), ("suspended", 17), ("resumed", 18), ("stopped", 19), ("running", 20), ("aborted", 21))))
if mibBuilder.loadTexts: cycVolumeSetActivityState.setStatus('mandatory')
if mibBuilder.loadTexts: cycVolumeSetActivityState.setDescription('Status of a new activity for the object referred to by the trap.')
cycSpareState = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9007), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("notFunctional", 2))))
if mibBuilder.loadTexts: cycSpareState.setStatus('mandatory')
if mibBuilder.loadTexts: cycSpareState.setDescription('New state for the object referred to by the trap.')
cycEnclosureComponent = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9008), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("cabinet", 1), ("fan", 2), ("powerSupply", 3), ("door", 4), ("speaker", 5), ("temperatureSensor", 6), ("deviceInSlot", 7))))
if mibBuilder.loadTexts: cycEnclosureComponent.setStatus('mandatory')
if mibBuilder.loadTexts: cycEnclosureComponent.setDescription('The part of the enclosure affected by this trap.')
cycEnclosureComponentNumber = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9009), Integer32())
if mibBuilder.loadTexts: cycEnclosureComponentNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cycEnclosureComponentNumber.setDescription('The ordinal number of the part of the enclosure affected by this trap. Numbers ordinarily start at 1, such as Fan 1. A number of 0 refers to all such parts as a single piece. For example, Fan 0 refers to all fans.')
cycEnclosureComponentState = MibScalar((1, 3, 6, 1, 4, 1, 795, 2, 12, 9000, 9010), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("found", 1), ("notResponding", 2), ("operational", 3), ("malfunctioning", 4), ("removed", 5), ("inserted", 6), ("unknownState", 7), ("operationalAndOn", 8), ("operationalAndOff", 9), ("malfunctioningButOn", 10), ("malfunctioningAndOff", 11), ("notPresent", 12), ("present", 13), ("locked", 14), ("unlocked", 15), ("outOfNormalRange", 16), ("inNormalRange", 17), ("runningAtHalfCapacity", 18), ("runningAtMaximumCapacity", 19), ("decreaseToHalfCapacityFailed", 20), ("increaseToMaximumCapacityFailed", 21))))
if mibBuilder.loadTexts: cycEnclosureComponentState.setStatus('mandatory')
if mibBuilder.loadTexts: cycEnclosureComponentState.setDescription('Description of the change in status in the affected enclosure part.')
cycStorageControllerStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,101)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycPhysicalObjectState"))
if mibBuilder.loadTexts: cycStorageControllerStateChange.setDescription('CIO storage controller %d has changed state.')
cycBusPortStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,102)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycPhysicalObjectState"))
if mibBuilder.loadTexts: cycBusPortStateChange.setDescription('CIO bus port %d has changed state.')
cycStorageDeviceStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,103)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycPhysicalObjectState"))
if mibBuilder.loadTexts: cycStorageDeviceStateChange.setDescription('CIO storage device %d has changed state.')
cycVolumeSetStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,104)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycVolumeSetState"))
if mibBuilder.loadTexts: cycVolumeSetStateChange.setDescription('CIO volume set %d has changed state.')
cycVolumeSetActivityChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,105)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycVolumeSetActivity"), ("CIOMIB", "cycVolumeSetActivityState"))
if mibBuilder.loadTexts: cycVolumeSetActivityChange.setDescription('CIO volume set %d has changed activity.')
cycSpareStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,106)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycSpareState"))
if mibBuilder.loadTexts: cycSpareStateChange.setDescription('CIO spare %d has changed state.')
cycEnclosureStateChange = NotificationType((1, 3, 6, 1, 4, 1, 795, 2, 12) + (0,107)).setObjects(("CIOMIB", "cycSeverity"), ("CIOMIB", "cycObject"), ("CIOMIB", "cycEnclosureComponent"), ("CIOMIB", "cycEnclosureComponentNumber"), ("CIOMIB", "cycEnclosureComponentState"))
if mibBuilder.loadTexts: cycEnclosureStateChange.setDescription('A component in CIO enclosure %d has changed state.')
mibBuilder.exportSymbols("CIOMIB", operationalStates=operationalStates, portIsochronous=portIsochronous, componentSpareAssociationEntry=componentSpareAssociationEntry, trapLogTable=trapLogTable, volName=volName, statisticsWriteBucket9=statisticsWriteBucket9, operationalStateIndex=operationalStateIndex, cycVolumeSetStateChange=cycVolumeSetStateChange, aggregatePsExtentEntry=aggregatePsExtentEntry, statisticsWriteBucket3=statisticsWriteBucket3, redundancyGroup=redundancyGroup, ctlrEntry=ctlrEntry, redundancyIndex=redundancyIndex, statisticsWriteBucket8=statisticsWriteBucket8, statisticsWriteBucket1=statisticsWriteBucket1, statisticsReadBucket8=statisticsReadBucket8, portMaximumWidth=portMaximumWidth, statisticsWriteBucket0=statisticsWriteBucket0, cycEnclosureComponentState=cycEnclosureComponentState, associationTable=associationTable, cycSpareState=cycSpareState, associations=associations, statisticsReadBucket7=statisticsReadBucket7, volCapacity=volCapacity, mibRevision=mibRevision, statisticsIndex=statisticsIndex, statisticsReadBucket1=statisticsReadBucket1, statisticsWriteBucket10=statisticsWriteBucket10, deviceTable=deviceTable, enclosure=enclosure, statisticsWriteBucket5=statisticsWriteBucket5, enclEntry=enclEntry, componentSpareAssociationIndex=componentSpareAssociationIndex, statisticsReadBucket10=statisticsReadBucket10, worldWideId=worldWideId, statisticsWriteBucket4=statisticsWriteBucket4, cycStorageDeviceStateChange=cycStorageDeviceStateChange, trapLogString=trapLogString, operationalMajorErrorCount=operationalMajorErrorCount, operationalFatalErrorCount=operationalFatalErrorCount, statisticsWriteBucket12=statisticsWriteBucket12, portAddressDescriptor=portAddressDescriptor, volumeSetTable=volumeSetTable, cycSeverity=cycSeverity, cycVolumeSetActivityChange=cycVolumeSetActivityChange, trapLogTimeStamp=trapLogTimeStamp, ctlrIndex=ctlrIndex, aggPsExtentBlocks=aggPsExtentBlocks, devSubIdentifier=devSubIdentifier, associationObject2=associationObject2, overallStatus=overallStatus, operationalWarningErrorCount=operationalWarningErrorCount, devLoaded=devLoaded, statisticsEntry=statisticsEntry, associationIndex=associationIndex, cycEnclosureComponentNumber=cycEnclosureComponentNumber, statistics=statistics, redundancyGroupTable=redundancyGroupTable, cycVolumeSetActivityState=cycVolumeSetActivityState, aggregatePhysicalExtent=aggregatePhysicalExtent, portMaximumAttachments=portMaximumAttachments, aggregatePExtentEntry=aggregatePExtentEntry, devIndex=devIndex, portIndex=portIndex, trapLogNumEntries=trapLogNumEntries, busPort=busPort, operationalPredictedFailureStatus=operationalPredictedFailureStatus, devEncryption=devEncryption, redundancyType=redundancyType, worldWideIdType=worldWideIdType, portConnectorTypeDescription=portConnectorTypeDescription, devEntry=devEntry, cycObject=cycObject, ctlrBusMaster=ctlrBusMaster, portConnectorGender=portConnectorGender, volIndex=volIndex, statisticsReadBucket12=statisticsReadBucket12, revMajor=revMajor, statisticsWriteBucket7=statisticsWriteBucket7, redundancyGroupEntry=redundancyGroupEntry, statisticsBlocksRead=statisticsBlocksRead, componentSpareAssociations=componentSpareAssociations, busPortAssociations=busPortAssociations, cycVolumeSetState=cycVolumeSetState, enclTable=enclTable, cycVolumeSetActivity=cycVolumeSetActivity, trapLogCount=trapLogCount, devMediaBlockSize=devMediaBlockSize, volumeSet=volumeSet, associationObject1=associationObject1, devTypeDescr=devTypeDescr, aggPExtentBlocks=aggPExtentBlocks, storageDevice=storageDevice, cycPhysicalObjectState=cycPhysicalObjectState, enclType=enclType, operationalStateTable=operationalStateTable, componentSpareFunctioningState=componentSpareFunctioningState, cycBusPortStateChange=cycBusPortStateChange, devRemovableDevice=devRemovableDevice, ctlrTable=ctlrTable, enclIndex=enclIndex, operationalStateEntry=operationalStateEntry, ctlrDescription=ctlrDescription, worldWideIdEntry=worldWideIdEntry, busPortTable=busPortTable, statisticsTable=statisticsTable, statisticsReadBucket3=statisticsReadBucket3, cycSpareStateChange=cycSpareStateChange, operationalDeviceGroupIndex=operationalDeviceGroupIndex, statisticsReadBucket6=statisticsReadBucket6, devCompression=devCompression, portSignalCharacteristics=portSignalCharacteristics, aggregatePsExtentTable=aggregatePsExtentTable, cio2=cio2, trapLogEntry=trapLogEntry, statisticsWriteCommands=statisticsWriteCommands, volPSExtentInterleaveDepth=volPSExtentInterleaveDepth, overallObjectStatus=overallObjectStatus, worldWideIdTable=worldWideIdTable, statisticsReadBucket5=statisticsReadBucket5, aggregateProtectedSpace=aggregateProtectedSpace, statisticsWriteBucket6=statisticsWriteBucket6, aggregatePExtentTable=aggregatePExtentTable, aggPExtentIndex=aggPExtentIndex, ctlrProtectionManagement=ctlrProtectionManagement, portMaximumTransferRate=portMaximumTransferRate, associationEntry=associationEntry, busPortAssociationEntry=busPortAssociationEntry, operationalAdministrativeStatus=operationalAdministrativeStatus, worldWideIds=worldWideIds, volPSExtentStripeLength=volPSExtentStripeLength, adaptec=adaptec, portProtocol=portProtocol, devFormattedMediaCapacity=devFormattedMediaCapacity, revMinor=revMinor, operationalAvailabilityStatus=operationalAvailabilityStatus, operationalCurrentErrorStatus=operationalCurrentErrorStatus, statisticsReadBucket9=statisticsReadBucket9, statisticsReadBucket4=statisticsReadBucket4, statisticsWriteBucket2=statisticsWriteBucket2, cycStorageControllerStateChange=cycStorageControllerStateChange, busPortAssociationNegotiatedWidth=busPortAssociationNegotiatedWidth, statisticsWriteBucket11=statisticsWriteBucket11, cycTraps=cycTraps, busPortEntry=busPortEntry, associationType=associationType, componentSpareAssociationTable=componentSpareAssociationTable, storagemanagement=storagemanagement, trapLogIndex=trapLogIndex, ctlrSecondsSinceLastPowerUp=ctlrSecondsSinceLastPowerUp, cycEnclosureStateChange=cycEnclosureStateChange, statisticsReadBucket0=statisticsReadBucket0, enclDescription=enclDescription, operationalUsageState=operationalUsageState, statisticsReadBucket2=statisticsReadBucket2, devRemovableMedia=devRemovableMedia, busPortAssociationIndex=busPortAssociationIndex, portConnectorType=portConnectorType, aggPExtentCheckDataBlocks=aggPExtentCheckDataBlocks, devMediaLoaded=devMediaLoaded, cycEnclosureComponent=cycEnclosureComponent, trapLog=trapLog, operationalStatus=operationalStatus, volumeSetEntry=volumeSetEntry, busPortAssociationNegotiatedSpeed=busPortAssociationNegotiatedSpeed, statisticsReadCommands=statisticsReadCommands, worldWideIdIndex=worldWideIdIndex, portProtocolDescription=portProtocolDescription, statisticsBlocksWritten=statisticsBlocksWritten, storageController=storageController, aggPsExtentIndex=aggPsExtentIndex, busPortAssociationTable=busPortAssociationTable, statisticsReadBucket11=statisticsReadBucket11, devType=devType)

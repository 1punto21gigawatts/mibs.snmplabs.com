#
# PySNMP MIB module CHECK-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CHECK-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:48:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
zeroDotZero, iso, Integer32, Bits, mib_2, Gauge32, Counter32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, ObjectIdentity, Unsigned32, NotificationType, Counter64, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "zeroDotZero", "iso", "Integer32", "Bits", "mib-2", "Gauge32", "Counter32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "NotificationType", "Counter64", "TimeTicks")
TimeInterval, StorageType, RowStatus, DisplayString, TextualConvention, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TimeInterval", "StorageType", "RowStatus", "DisplayString", "TextualConvention", "TimeStamp")
checkMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 7777))
checkMIB.setRevisions(('2003-12-19 13:13',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: checkMIB.setRevisionsDescriptions(('Initial version',))
if mibBuilder.loadTexts: checkMIB.setLastUpdated('200312191313Z')
if mibBuilder.loadTexts: checkMIB.setOrganization('IETF Distributed Management man Working Group')
if mibBuilder.loadTexts: checkMIB.setContactInfo('Editor: Giorgio Nunzi NEC Europe Ltd. Network Laboratories Kurfuersten-Anlage 36 69221 Heidelberg Germany Tel: +49 6221 90511-39 Email: nunzi@netlab.nec.de')
if mibBuilder.loadTexts: checkMIB.setDescription('This MIB module defines a set of objects that allow to define a health check procedure on a managed node. The health check procedure is performed through a sequence of simple comparison operations on some managed objects against a control value. The result of the health check is accumulated into a single managed object that can be read by a manager to discover the status of the whole set of managed objects instead of retrieving all the single values controlled during the health check procedure. The main purpose of the CHECK-MIB is increasing scalability of network management applications by moving check operations from the management station to managed nodes. There are five groups of managed objects defined by this MIB module: - objects describing capabilities of the CHECK-MIB implementation; - objects controlling the operational status of the health check procedure; - objects defining the checks in the checkResultTable; - objects defining the operations for each of the configured checks in the checkRuleTable; - objects providing information about failed checks.')
class RuleValue(TextualConvention, OctetString):
    description = 'The control value compared with the value of a monitored object. This value encodes all the object types defined by the SMIv2, except the Opaque, with the following rules: - INTEGER, Integer32, Unsigned32, TimeTicks, Counter32, Gauge32: the integer value is encoded with 4 octets in network-byte order; - Counter64: the integer value is encoded with 8 octets in network-byte order; - IpAddress: the address value is encoded with a 4 in network-byte order; - OBJECT IDENTIFIER: each sub-identifier is encoded with 4 octets in network-order and the whole OID is encoded as a sequence of sub-identifiers starting from the top-level; - BITS: all the named bits in the bitstring, commencing with the first bit and proceeding to the last bit, are placed in bits 8 (high order bit) to 1 (low order bit) of the first octet, followed by bits 8 to 1 of each subsequent octet in turn, followed by as many bits as are needed of the final subsequent octet, commencing with bit 8. Remaining bits, if any, of the final octet are set to zero on generation and ignored while performing a check; - OCTET STRING: the string is encoded as it is.'
    status = 'current'
    displayHint = '1x'

class SeverityConfigured(TextualConvention, Unsigned32):
    description = 'The severity value measures the gravity of a failure of a rule or a result. A low value indicates a minor failure, while a high value indicates a sever failure. The scale of the severity is arbitrary chosen by the manager application. This textual convention represents the value of a severity which is configured by the manager.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967293)

class SeverityReturned(TextualConvention, Unsigned32):
    description = "The severity value measures the gravity of a failure of a rule or a result. A low value indicates a minor failure, while a high value indicates a sever failure. The scale of the severity is arbitrary chosen by the manager application. This textual convention represents the value of a severity which is set by the device after the performance of a rule. If the rule has been correctly performed, the value is equal to the severity configured for the rule. If the rule has not been performed because the monitored object couldn't be accessed, then this values is set to 4294967295. If the rule has not been performed due to a lack of resources, then this value is set to 4294967294."
    status = 'current'

checkObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 1))
checkNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 2))
checkConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 3))
checkCapabilities = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 1, 1))
checkCapabMinCheckInterval = MibScalar((1, 3, 6, 1, 2, 1, 7777, 1, 1, 1), TimeTicks()).setUnits('centi-seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: checkCapabMinCheckInterval.setStatus('current')
if mibBuilder.loadTexts: checkCapabMinCheckInterval.setDescription('The minimum interval that can be scheduled between two performances of the same check defined in the checkResultTable using the object checkResultInterval. This value is the minimum value allowed for the object checkResultInterval of the checkResultTable.')
checkCapabMaxResults = MibScalar((1, 3, 6, 1, 2, 1, 7777, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkCapabMaxResults.setStatus('current')
if mibBuilder.loadTexts: checkCapabMaxResults.setDescription('The maximum number of entries supported in the checkResultTable. A value of 0 indicates that there is no fixed limitation. Creating a new row in the checkResultTable with the object checkResultRowStatus after the maximum number of entries supported, leads to a resourceUnavailable error.')
checkCapabMaxRules = MibScalar((1, 3, 6, 1, 2, 1, 7777, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkCapabMaxRules.setStatus('current')
if mibBuilder.loadTexts: checkCapabMaxRules.setDescription('The maximum number of entries supported in the checkRuleTable. A value of 0 indicates that there is no fixed limitation. Creating a new row in the checkRuleTable with the object checkRuleRowStatus after the maximum number of entries supported, leads to a resourceUnavailable error.')
checkControl = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 1, 2))
checkCtrlAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 7777, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("silent", 2), ("down", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: checkCtrlAdminStatus.setStatus('current')
if mibBuilder.loadTexts: checkCtrlAdminStatus.setDescription('The desidered state of the checking engine of the Check MIB implementation. Setting this object to up(1) indicates a request for performing all checks as defined in the checkResultTable and the checkRuleTable performed. Setting this object to silent(2) indicates that all the checks defined in checkResultTable must be performed, but no notification must be sent by the Check MIB implementation. Setting this object to down(3) indicates a request for performing o more tests. When retrieved, the object returns the last value written to it, except after system boot when it returns the value up(1).')
checkCtrlOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 7777, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("silent", 2), ("down", 3), ("flushing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkCtrlOperStatus.setStatus('current')
if mibBuilder.loadTexts: checkCtrlOperStatus.setDescription('The current operational state of the Check MIB implementation. The up(1) state indicates that all checks defined in the checkResultTable and the checkRuleTable are performed. The silent(2) state indicates that all checks are performed as defined in the checkResultTable and the checkRuleTable, but no notification is sent by the Check MIB implementation. The down(3) state indicates that no check is performed. The flushing(4) state indicates that the checkCtrlAdminStatus has been set to down(3) and the managed node is completing the performance of checks that were scheduled before checkCtrlAdminStatus was set to down(3). If the value of checkCtrlAdminStatus does not change again before these checks are completed, then the value of checkCtrlOperStatus will change to down(3) after the checks are completed. After a system re-initialization, the Check MIB implementation starts up with this object set to up(1).')
checkResultTable = MibTable((1, 3, 6, 1, 2, 1, 7777, 1, 3), )
if mibBuilder.loadTexts: checkResultTable.setStatus('current')
if mibBuilder.loadTexts: checkResultTable.setDescription('This table contains the definitions of the checks to be performed by the Check MIB implementation. Each row defines one check and contains the parameters controlling the performance of the check as well as the result of the check. The operations performed by each check are defined as rules in the checkRuleTable.')
checkResultEntry = MibTableRow((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1), ).setIndexNames((0, "CHECK-MIB", "checkResultName"))
if mibBuilder.loadTexts: checkResultEntry.setStatus('current')
if mibBuilder.loadTexts: checkResultEntry.setDescription('An entry defining a check. Each entry is indexed by the string checkResultName, which represents the name of the check. An entry can be created with the object checkResultRowStatus only with the createAndWait operation. A check is never performed if its entry is in the notInService status. Objects in an entry marked as read-create can be modified only when the entry is in notInService status.')
checkResultName = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: checkResultName.setStatus('current')
if mibBuilder.loadTexts: checkResultName.setDescription('A name describing the check. Since the name serves as table index, it must be unique for each row in the table. The name of a check is chosen arbitrary by the manager creating the row in the checkResultTable, but some suggestions are given to offer a common semantic among different managers. The name should give a brief description of the check defined in the row. In particular it is recommended that the name indicates: - the name of the manager who defined the row. - a label describing the check.')
checkResultSeverity = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 2), SeverityReturned()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkResultSeverity.setStatus('current')
if mibBuilder.loadTexts: checkResultSeverity.setDescription('Each time the check defined by this entry (and the corresponding entries of the checkRuleTable) is performed, this object is set to to the maximum value of all checkRuleSeverity objects in corresponding entries of the checkRuleTable for which the check failed. If the check passes for all corresponding rules, then the value of object checkResultSeverity is 0. If the object checkResultInterval contains the value 0, then the check is performed when the value of checkResultSeverity is retrieved by a manager. If the object checkResultInterval contains a value greater than 0, then the check is performed automatically by the managed node and a read access by a manager just returns the value computed at the last scheduled check. Each time object checkResultSeverity is set, the value of object checkResultTime in the corresponding entry is set to the current time, and the value of object checkResultSize is set to the number of corresponding entries in the checkRuleTable for which the check failed. If no check has been performed so far, then the value of this object is 0.')
checkResultSize = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkResultSize.setStatus('current')
if mibBuilder.loadTexts: checkResultSize.setDescription('The number of rules defined in corresponding entries of the checkFailureTable for which the check failed when it was performed last. If no check has been performed so far, then the value of this object is 0.')
checkResultTime = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkResultTime.setStatus('current')
if mibBuilder.loadTexts: checkResultTime.setDescription('A timestamp indicating the time when the last performance of the check defined in this row was completed. If no check has been performed so far, then the value of this object is 0. Note that 0 is a valid timestamp.')
checkResultInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 5), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkResultInterval.setStatus('current')
if mibBuilder.loadTexts: checkResultInterval.setDescription('The interval between two performances of the check defined in this row. When this object is set to a value greater than 0, then the check is performed regularly with the number of centi-seconds indicated by this object between two performances. When this object is successfully set to a value greater than 0, then the check is not performed immediately. The first check is performed after the number of centi-seconds specified by the new value of the object. If a performance is scheduled to start before the previous one has been completed, then the previous check will be completed and the scheduled check will be skipped. If the number of this object is 0, then the check is performed only on request when the value of the object checkResultSeverity is retrieved by a manager. A set operation on this object may lead to an inconsistentValue error in two cases: - if the vale passed is greater than 0 but less than the value of checkCapabMinCheckInterval; - if the value passed is greater than 0 and the check defined in this row includes rules with delta operations.')
checkResultSeverityThreshold = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 6), SeverityConfigured()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkResultSeverityThreshold.setStatus('current')
if mibBuilder.loadTexts: checkResultSeverityThreshold.setDescription('This object serves for sending notifications in case of failures occurred in the check defined in this row. If the value of this object is set to 0, then no notification is sent to the manager even if some rule defined for the check fails. Otherwise, if the performance of a check leads to a value of the object checkResultSeverity that is equal to or greater than the value of the object checkResultSeverityThreshold, then a notification is sent. The notification is an instance of checkResultFailed.')
checkResultStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 7), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkResultStorageType.setStatus('current')
if mibBuilder.loadTexts: checkResultStorageType.setDescription('The value of this object indicates the storage type of this entry in the checkResultTable and of all corresponding entries in the checkRuleTable. The value of this object indicates whether the entries are stored in volatile memory and lost upon reboot or if they are backed up by non-volatile or permanent storage. If checkResultStorageType has the value permanent(4), then all objects whose MAX-ACCESS value is read-write can be modified, but the row cannot be deleted. All the objects in corresponding entries of the checkRuleTable whose MAX-ACCESS is read-create are instead read-only with the exception of the checkRuleRowStatus. Attempts to set this object to permanent(4) will always fail with an inconsistentValue error.')
checkResultRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkResultRowStatus.setStatus('current')
if mibBuilder.loadTexts: checkResultRowStatus.setDescription('This object allows to create and delete rows in the table. The value createAndGo(4) is not allowed and an wrongValue error is returned when attempting to set it. Objects of the same row can be modified only when checkResultRowStatus has the notInService(2) value and set operations on objects of a row in active(1) status result to inconsistentValue. A change of the value of the checkResultRowStatus object is propagated to the checkRuleRowStatus of all the related entries in the checkRuleTable (those indexed by the same checkResultName); if the change of the value of a checkRuleRowStatus object results in an inconsistentValue error, then this error is returned to the manager while setting the value of this checkResultRowStatus. An attempt to set the value of this object to active(1), causes the following actions: - all the related entries in the checkRuleTable become active; if an attempt to activate an entry results in an inconsistentValue error, then this error is returned to the manager and further action is taken; - all the objects of this row become read-only, with the exception of checkResultRowStatus; - if the value of checkResultInterval is greater than 0, then the timer to schedule the performances of the check starts immediately, but the first check will be performed only but after the time specified by checkResultInterval; for rules defining delta operations the values of managed objects to be checked are read immediately, so that delta operations can be computed at the first scheduled check. - if the value of checkResultInterval is equal to 0, then retrieving the value of checkResultSeverity forces the performance of the check. When a row is put in the notInService status, then the following actions are taken: - all the objects of the row marked as read-create can be modified; - all the related entries in the checkRuleTable become notInService; - all scheduled future checks are canceled. - retrieving the value of checkResultSeverity returns always the value computed at the last check. When a row is deleted, then if an alarm was configured, it is removed, and all the related entries in checkRuleTable are deleted (eventually freeing the resources allocated for delta operations defined by those rules). Creating a new row when the table reached the maximum number of entries defined in checkCapabMaxResults results in a resourceUnavailable error.')
checkRuleTable = MibTable((1, 3, 6, 1, 2, 1, 7777, 1, 4), )
if mibBuilder.loadTexts: checkRuleTable.setStatus('current')
if mibBuilder.loadTexts: checkRuleTable.setDescription('This table contains the definitions of the operations performed for checks defined in the checkResultTable. Each row defines an operation on the value of a managed object. The operation consists in a comparison of the value of the managed object with a control value specified in checkRuleValue. The relationship expected between the two values is indicated by checkRuleOperation. It is possible to reference in a single rule either a single instances object or all the instance of a columnar object of a table. For each operation, a severity is set which indicates the gravity of the failure of the comparison operation. The storage type of entries in this table is determined by the value of object checkResultStorageType in the corresponding entry of the checkResultTable.')
checkRuleEntry = MibTableRow((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1), ).setIndexNames((0, "CHECK-MIB", "checkResultName"), (0, "CHECK-MIB", "checkRuleName"))
if mibBuilder.loadTexts: checkRuleEntry.setStatus('current')
if mibBuilder.loadTexts: checkRuleEntry.setDescription('An entry defining a rule for a check defined in the checkResultTable. Each entry is indexed by: 1. the checkResultName of the check which includes the operation defined by the entry; 2. the string checkRuleName, which represents the name of the operation. An entry can be created with the object checkResultRowStatus only with the createAndWait operation. A rule is never considered in the performance of the check defined in the related checkResultEntry, if its entry is in the notInService status. Objects in an entry can be modified only when the entry is in notInService status.')
checkRuleName = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: checkRuleName.setStatus('current')
if mibBuilder.loadTexts: checkRuleName.setDescription('A name describing the rule. Since the name serves as table index coupled with the value of checkResultName, it must be unique per each row in the table inside the scope of checkResultName. The name of a rule is chosen by the manager creating the row, but some suggestions are given to offer a common semantic between different managers. The name should give a brief description of the rule defined in the row. In particular it is recommended that the name indicates the name of the managed object controlled by the rule.')
checkRuleOid = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 3), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkRuleOid.setStatus('current')
if mibBuilder.loadTexts: checkRuleOid.setDescription("The OID indicating the managed object to be checked. The OID must be: - the OID of an instance object: in this case the rule is applied to that object; - the OID of a columnar object (missing of the instance sub-identifier): in this case the rule is applied to all the instances of the columnar object. The validity of the OID is verified when the manager tries to activate the row, following these actions: - the agent should try to read the value of the object referenced by the OID (like a snmp get operation); if the value is read, the OID refers to a valid instance object and the type of the object should be registered inside the agent; - if the object is not available, then the agent should try to read the next object in the lexicographical order (like a snmp get next operation); if the OID returned is a child node of the checkRuleOid, then the latter is assumed to be a columnar object and the type of the object read is stored inside the agent; - if no object could be found or the OID returned is not a leaf of checkRuleOid, then an inconsistentValue error is return to the attempt of activating the row. When setting the OID of a columnar object, at least one instance object must exist at the moment of the activation of the row, so that the validity test of OID passes and the row is activated. If the OID references an instance object that is removed or become inaccessible after the row has been activated, then rule automatically fails with a severity equal to 4294967295. If the OID value references a columnar object and no instance exists after the first performance, then the rule doesn't fail.")
checkRuleValue = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 4), RuleValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkRuleValue.setStatus('current')
if mibBuilder.loadTexts: checkRuleValue.setDescription('The control value compared to the value of the managed object indicated by checkRuleOid. The control value encoded in this object must be consistent with the type of the object referenced by the checkRuleOid. The control value is considered inconsistent if: - the object type is INTEGER, Unsigned32, TimeTicks, Gauge32, Counter32, IpAddress and the size of the checkRuleValue is different from 4; - the object type is Counter64 and the size of the checkRuleValue is different from 8; - the object type is OBJECT IDENTIFIER and the size of the checkRuleValue is not a multiple of 4. The consistency between the control value and the object type is verified when the rule is activated; if the consistency test fails, the attempt to active the row results in an inconsistentValue error.')
checkRuleOperation = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noOperation", 0), ("unequal", 1), ("equal", 2), ("less", 3), ("lessOrEqual", 4), ("greater", 5), ("greaterOrEqual", 6), ("delta", 7))).clone('noOperation')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: checkRuleOperation.setStatus('current')
if mibBuilder.loadTexts: checkRuleOperation.setDescription("The value of this object specifies the comparison operation to be performed between the value of the managed object indicated by checkRuleOid and the value indicated by checkRuleValue. Some operations cannot be applied to all the types of object. If the value of the checkRuleOperation is inconsistent with the type of the object indicated by checkRuleOid, then an attempt to activate the row results in an inconsistentValue error. The value 0 can be configured for all the object types and means that no operation is performed and the rule never fails. When the type of the object indicated by checkRuleOid is IpAddress, BITS, OBJECT IDENTIFIER then only the value equal(2) can be configured. For the IpAddress, the value of the object indicated by checkRuleOid is compared byte by byte with the value of checkRuleValue and the rule doesn't fail if all the bytes are matched. For the OBJECT IDENTIFIER, the rule doesn't fail if checkRuleValue encodes an OID of the same dimension of the value of the object indicated by checkRuleOid and the two OIDs are equal. For the BITS, the rule doesn't fail if the checkRuleValue encodes a bitstring long at least as the number of the named bits and all the named bits are matched with that bitstring. When the type of the object indicated by checkRuleOid is INTEGER, Integer32, Unsigned32, Counter32, Counter64, TimeTicks, Gauge32, all the values from 1 to 6 can be configured. These values define simple mathematical operations: the rule doesn't fail if the the value of the object indicated by checkRuleOid is, respectively, !=, =, <, <=, >, >= than the value of checkRuleValue. A value of of delta(7) can be configured only for Counter32, Counter64, Gauge32; moreover it is permitted only if the check including the rule is performed automatically and thus its value of checkResultInterval greater than 0, otherwise an inconsistentValue error is returned. For a delta operation, each time the rule is performed, the difference between the actual value of the managed object and its value at the last performance is considered and the rule doesn't fail if the difference is <= than the value of the checkRuleValue. If the actual value is less than the previous one, then the difference is augmented with the value 4294967295, like as the managed object reached its maximum value and it has been resetted. Each time the new value of the managed object must be stored by the device in an internal buffer. The buffer must be handled so that when a new managed object is controlled, a new entry is allocated for it. If no more entries are available, then the rule fails with severity 4294967294. If a managed object for which an entry was previously allocated, doesn't exist when a new execution of the delta operation is performed, its entry should be removed. When a new entry is allocated for a new managed object, its value is stored in the entry, but the operation is not computed and the rule doesn't fail; the delta operation is normally computed only from the second time.")
checkRuleSeverity = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 6), SeverityConfigured().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkRuleSeverity.setStatus('current')
if mibBuilder.loadTexts: checkRuleSeverity.setDescription('The severity of a failure of the operation specified by the row for the whole check. A severity of 0 indicates that a failure of the operation is irrelevant.')
checkRuleRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: checkRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: checkRuleRowStatus.setDescription("The control to create and delete rows. It is possible to create new rules only for a check which is already defined in the CHECK-MIB. Creating a new row indexed by a value of checkResultName which doesn't exist already in any row of the checkResultTable results in a inconsistentName error. The value createAndGo(4) is not allowed and an wrongValue error is returned when attempting to set it. Objects of the same row can be modified only when checkRuleRowStatus has the notInService(2) value and set operations on objects of a row in active(1) status result to inconsistentValue. A row in the notInService status is not considered in the performance of the check defined by the related entry in the checkResultTable (the one indexed by the same checkResultName). An attempt to set the value of this object to active(1), causes the following actions: - the validity of the value of checkRuleOid is verified; if it fails, then an inconsistentValue error is returned; - the consistency between the type of the object referenced by checkRuleOid and the value of checkRuleOperation is verified; if it fails, then an inconsistentValue error is returned; - the consistency between the type of the object referenced by checkRuleOid and the value of checkRuleValue is verified; if it fails, then an inconsistentValue error is returned; - if all the tests pass, the row is activated. An attempt to create a new row when the table has reached the maximum number of entries defined in checkCapabMaxRules results in a resourceUnavailable error. An attempt to create a new row in the table with the corresponding entry in the checkResultTable having the storage type permanent(4) results in an inconsistentValue error.")
checkFailureTable = MibTable((1, 3, 6, 1, 2, 1, 7777, 1, 5), )
if mibBuilder.loadTexts: checkFailureTable.setStatus('current')
if mibBuilder.loadTexts: checkFailureTable.setDescription('This table lists all the rules defined in the checkRuleTable, which failed at the last time the check including them has been performed. Entries only describe objects for which the last check failed. Failures in checks before the last one are not indicated.')
checkFailureEntry = MibTableRow((1, 3, 6, 1, 2, 1, 7777, 1, 5, 1), ).setIndexNames((0, "CHECK-MIB", "checkResultName"), (0, "CHECK-MIB", "checkFailureSeverity"), (0, "CHECK-MIB", "checkRuleName"))
if mibBuilder.loadTexts: checkFailureEntry.setStatus('current')
if mibBuilder.loadTexts: checkFailureEntry.setDescription('An entry referencing a failed rule. Each entry is indexed by: 1. the checkResultName of the check including the rule failed; 2. the severity of the rule failed; 3. The checkRuleName of the rule failed. The manager, after having read a value of checkResultSeverity of a check different from 0, can directly read the rule failed with the maximum severity by retrieving the checkFailureOid with a get_next command without specifying the checkRuleName.')
checkFailureSeverity = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 5, 1, 1), SeverityReturned())
if mibBuilder.loadTexts: checkFailureSeverity.setStatus('current')
if mibBuilder.loadTexts: checkFailureSeverity.setDescription('The severity with which the rule failed.')
checkFailureOid = MibTableColumn((1, 3, 6, 1, 2, 1, 7777, 1, 5, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: checkFailureOid.setStatus('current')
if mibBuilder.loadTexts: checkFailureOid.setDescription('The OID of the managed object for which a rule failed. This value contains the value of checkRuleOid of the rule failed.')
checkEvent = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 2, 0))
checkFailed = NotificationType((1, 3, 6, 1, 2, 1, 7777, 2, 0, 1)).setObjects(("CHECK-MIB", "checkResultSeverity"))
if mibBuilder.loadTexts: checkFailed.setStatus('current')
if mibBuilder.loadTexts: checkFailed.setDescription('This notification can be generated to report that a check failed. The notification is generated each time, the value of checkSeverityThreshold is greater than 0 and the performance of a check results in a value of checkResultSeverity that is greater than or equal to the value of checkSeverityThreshold. The notification contains the checkResultSeverity of the check failed.')
checkCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 3, 1))
checkGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 7777, 3, 2))
checkCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 7777, 3, 1, 1)).setObjects(("CHECK-MIB", "checkCapabilitiesGroup"), ("CHECK-MIB", "checkControlGroup"), ("CHECK-MIB", "checkResultGroup"), ("CHECK-MIB", "checkRuleGroup"), ("CHECK-MIB", "checkFailureGroup"), ("CHECK-MIB", "checkNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkCompliance = checkCompliance.setStatus('current')
if mibBuilder.loadTexts: checkCompliance.setDescription('The compliance statement for SNMP entities that implement the CHECK-MIB.')
checkCapabilitiesGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 1)).setObjects(("CHECK-MIB", "checkCapabMinCheckInterval"), ("CHECK-MIB", "checkCapabMaxResults"), ("CHECK-MIB", "checkCapabMaxRules"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkCapabilitiesGroup = checkCapabilitiesGroup.setStatus('current')
if mibBuilder.loadTexts: checkCapabilitiesGroup.setDescription('A collection of objects providing information about the capabilities of the CHECK-MIB implementation.')
checkControlGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 2)).setObjects(("CHECK-MIB", "checkCtrlAdminStatus"), ("CHECK-MIB", "checkCtrlOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkControlGroup = checkControlGroup.setStatus('current')
if mibBuilder.loadTexts: checkControlGroup.setDescription('A collection of objects controlling the state of the CHECK-MIB.')
checkResultGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 3)).setObjects(("CHECK-MIB", "checkResultSeverity"), ("CHECK-MIB", "checkResultSize"), ("CHECK-MIB", "checkResultTime"), ("CHECK-MIB", "checkResultInterval"), ("CHECK-MIB", "checkResultSeverityThreshold"), ("CHECK-MIB", "checkResultStorageType"), ("CHECK-MIB", "checkResultRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkResultGroup = checkResultGroup.setStatus('current')
if mibBuilder.loadTexts: checkResultGroup.setDescription('A collection of objects defining a check.')
checkRuleGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 4)).setObjects(("CHECK-MIB", "checkRuleOid"), ("CHECK-MIB", "checkRuleValue"), ("CHECK-MIB", "checkRuleOperation"), ("CHECK-MIB", "checkRuleSeverity"), ("CHECK-MIB", "checkRuleRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkRuleGroup = checkRuleGroup.setStatus('current')
if mibBuilder.loadTexts: checkRuleGroup.setDescription('A collection of objects defining the operations computed for each check.')
checkFailureGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 5)).setObjects(("CHECK-MIB", "checkFailureOid"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkFailureGroup = checkFailureGroup.setStatus('current')
if mibBuilder.loadTexts: checkFailureGroup.setDescription('A collection of objects indicating managed objects for which a check operation failed.')
checkNotificationsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 7777, 3, 2, 6)).setObjects(("CHECK-MIB", "checkFailed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    checkNotificationsGroup = checkNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: checkNotificationsGroup.setDescription('The notifications emitted by the CHECK-MIB.')
mibBuilder.exportSymbols("CHECK-MIB", checkResultInterval=checkResultInterval, checkCapabilities=checkCapabilities, checkCapabilitiesGroup=checkCapabilitiesGroup, checkNotifications=checkNotifications, checkRuleName=checkRuleName, checkRuleGroup=checkRuleGroup, checkRuleSeverity=checkRuleSeverity, RuleValue=RuleValue, PYSNMP_MODULE_ID=checkMIB, checkResultGroup=checkResultGroup, checkFailureTable=checkFailureTable, checkResultSeverity=checkResultSeverity, checkCompliance=checkCompliance, checkFailureOid=checkFailureOid, checkRuleTable=checkRuleTable, checkRuleValue=checkRuleValue, checkEvent=checkEvent, checkCapabMaxRules=checkCapabMaxRules, checkResultRowStatus=checkResultRowStatus, checkControl=checkControl, checkRuleEntry=checkRuleEntry, checkResultTime=checkResultTime, checkObjects=checkObjects, checkConformance=checkConformance, checkRuleOid=checkRuleOid, checkNotificationsGroup=checkNotificationsGroup, checkResultSize=checkResultSize, checkResultSeverityThreshold=checkResultSeverityThreshold, checkResultEntry=checkResultEntry, checkFailureSeverity=checkFailureSeverity, checkControlGroup=checkControlGroup, checkResultTable=checkResultTable, checkFailureEntry=checkFailureEntry, SeverityConfigured=SeverityConfigured, checkCapabMaxResults=checkCapabMaxResults, checkResultStorageType=checkResultStorageType, checkResultName=checkResultName, SeverityReturned=SeverityReturned, checkCapabMinCheckInterval=checkCapabMinCheckInterval, checkCtrlOperStatus=checkCtrlOperStatus, checkFailureGroup=checkFailureGroup, checkRuleOperation=checkRuleOperation, checkCompliances=checkCompliances, checkGroups=checkGroups, checkRuleRowStatus=checkRuleRowStatus, checkCtrlAdminStatus=checkCtrlAdminStatus, checkMIB=checkMIB, checkFailed=checkFailed)

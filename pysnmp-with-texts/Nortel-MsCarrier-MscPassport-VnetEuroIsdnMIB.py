#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
RowStatus, DisplayString, Unsigned32, Gauge32, StorageType, Counter32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "RowStatus", "DisplayString", "Unsigned32", "Gauge32", "StorageType", "Counter32")
Link, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "Link", "NonReplicated")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
mscSigChanIndex, mscSigChan = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex", "mscSigChan")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
iso, IpAddress, Counter64, MibIdentifier, Integer32, ModuleIdentity, ObjectIdentity, Unsigned32, Gauge32, TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "IpAddress", "Counter64", "MibIdentifier", "Integer32", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "Gauge32", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
vnetEuroIsdnMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138))
mscSigChanEIsdn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14))
mscSigChanEIsdnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1), )
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanEIsdn components.')
mscSigChanEIsdnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanEIsdn component.')
mscSigChanEIsdnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanEIsdn components. These components can be added and deleted.')
mscSigChanEIsdnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanEIsdnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnStorageType.setDescription('This variable represents the storage type value for the mscSigChanEIsdn tables.')
mscSigChanEIsdnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanEIsdnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnIndex.setDescription('This variable represents the index for the mscSigChanEIsdn tables.')
mscSigChanEIsdnL2Table = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11), )
if mibBuilder.loadTexts: mscSigChanEIsdnL2Table.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnL2Table.setDescription('This group specifies the provisionable layer 2 attributes of the Euro ISDN (ETSI-T) protocol.')
mscSigChanEIsdnL2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnL2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnL2Entry.setDescription('An entry in the mscSigChanEIsdnL2Table.')
mscSigChanEIsdnT23 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnT23.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnT23.setDescription('This attribute specifies duration of the layer 2 enable request timer.')
mscSigChanEIsdnT200 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 20)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnT200.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnT200.setDescription('This attribute specifies the maximum elapsed time between a layer 2 frame and its acknowledgment.')
mscSigChanEIsdnN200 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnN200.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnN200.setDescription('This attribute specifies the maximum number of re-transmissions of a layer 2 frame.')
mscSigChanEIsdnT203 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 40)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnT203.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnT203.setDescription('This attribute specifies the maximum time during which layer 2 frames may be absent. Expiry triggers a check on whether the far end is alive.')
mscSigChanEIsdnCircuitSwitchedK = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnCircuitSwitchedK.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnCircuitSwitchedK.setDescription('This attribute specifies the maximum number of sequentially numbered I frames (that is, window size (k)) that may be unacknowledged at any given time for a SAP supporting primary rate (64kbit/sec) signalling.')
mscSigChanEIsdnL3Table = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 12), )
if mibBuilder.loadTexts: mscSigChanEIsdnL3Table.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnL3Table.setDescription('This group represents the provisionable Layer 3 timer attributes of a the Euro ISDN (ETSI-T) protocol.')
mscSigChanEIsdnL3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnL3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnL3Entry.setDescription('An entry in the mscSigChanEIsdnL3Table.')
mscSigChanEIsdnT310 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnT310.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnT310.setDescription('This attribute specifies duration of the call proceeding state timer.')
mscSigChanEIsdnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13), )
if mibBuilder.loadTexts: mscSigChanEIsdnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnProvTable.setDescription('This group defines the general options of the D-channel signalling link.')
mscSigChanEIsdnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnProvEntry.setDescription('An entry in the mscSigChanEIsdnProvTable.')
mscSigChanEIsdnSide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("user", 2))).clone('network')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnSide.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnSide.setDescription('This attribute specifies whether the interface is the network or user side of the connection. The parameter applies to both the layer 2 and layer 3 of the interface. In addition, if this attribute is set to network, then the interface is master during channel negotiation. If this attribute is set to user, then the interface is slave during channel negotiation.')
mscSigChanEIsdnMaxNonCallConcurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnMaxNonCallConcurrent.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnMaxNonCallConcurrent.setDescription('This attribute specifies the maximum number of simultaneous active non call-associated sessions that are allowed. Reduction of the value does not impact NCAS sessions already in progress.')
mscSigChanEIsdnOverlapSending = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnOverlapSending.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOverlapSending.setDescription('This attribute specifies whether overlap sending to the PBX is enabled.')
mscSigChanEIsdnOverlapReceiving = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnOverlapReceiving.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOverlapReceiving.setDescription('This attribute specifies whether overlap receiving from the PBX is enabled.')
mscSigChanEIsdnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 14), )
if mibBuilder.loadTexts: mscSigChanEIsdnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscSigChanEIsdnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnStateEntry.setDescription('An entry in the mscSigChanEIsdnStateTable.')
mscSigChanEIsdnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscSigChanEIsdnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscSigChanEIsdnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscSigChanEIsdnStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15), )
if mibBuilder.loadTexts: mscSigChanEIsdnStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnStatsTable.setDescription('This group provides the statistical attributes for the SigChan/x EuroIsdn component.')
mscSigChanEIsdnStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnStatsEntry.setDescription('An entry in the mscSigChanEIsdnStatsTable.')
mscSigChanEIsdnTotalCallsToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnTotalCallsToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnTotalCallsToIf.setDescription('This attribute counts the total number of calls that have been made to the interface. The value wraps to zero when it exceeds its maximum.')
mscSigChanEIsdnTotalCallsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnTotalCallsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnTotalCallsFromIf.setDescription('This attribute counts the total number of calls that have been made from the interface. The value wraps to zero when it exceeds its maximum.')
mscSigChanEIsdnNonCallAssocSessionsToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnNonCallAssocSessionsToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnNonCallAssocSessionsToIf.setDescription('This attribute counts the total number of non call-associated sessions that have been made to the interface. The value wraps to zero when it exceeds its maximum.')
mscSigChanEIsdnNonCallAssocSessionsFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 15, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnNonCallAssocSessionsFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnNonCallAssocSessionsFromIf.setDescription('This attribute counts the total number of non call-associated sessions that have been made from the interface. The value wraps to zero when it exceeds its maximum.')
mscSigChanEIsdnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16), )
if mibBuilder.loadTexts: mscSigChanEIsdnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOperTable.setDescription('This group provides the operational attributes for the SigChan/x EuroIsdn component.')
mscSigChanEIsdnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOperEntry.setDescription('An entry in the mscSigChanEIsdnOperTable.')
mscSigChanEIsdnActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnActiveChannels.setDescription('This attribute indicates the number of currently active channels. This includes channels used by both, data and voice calls.')
mscSigChanEIsdnActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnActiveVoiceChannels.setDescription('This attribute indicates the number of channels that are currently used by voice calls. This includes modem calls.')
mscSigChanEIsdnActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnActiveDataChannels.setDescription('This attribute indicates the number of channels that are currently used by data calls. This does not include modem data.')
mscSigChanEIsdnPeakActiveChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveChannels.setDescription('This attribute indicates the maximum value of the activeChannels attribute during the last polling period.')
mscSigChanEIsdnPeakActiveVoiceChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveVoiceChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveVoiceChannels.setDescription('This attribute indicates the maximum value of the activeVoiceChannels attribute during the last polling period.')
mscSigChanEIsdnPeakActiveDataChannels = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveDataChannels.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnPeakActiveDataChannels.setDescription('This attribute indicates the maximum value of the activeDataChannels attribute during the last polling period.')
mscSigChanEIsdnDChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("outOfService", 0), ("establishing", 1), ("established", 2), ("enabling", 3), ("inService", 4), ("restarting", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnDChanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnDChanStatus.setDescription('This attribute indicates the state of the D-channel. outOfService means that there is no layer 2 or layer 3 connectivity to the PBX. establishing means that the signalling channel is attempting to stage the layer 2. established means that the layer 2 is enabled. If the signalling channel stays in the established state, then it is waiting for a restart from the PBX. enabling means that the resources for processing calls are being initialized. If the signalling channel stays in the enabling state then it is waiting for a restart acknowledgment from the PBX. inService means that the resources for processing calls are available. restarting means that the resources for call processing are being initialized.')
mscSigChanEIsdnToolsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 17), )
if mibBuilder.loadTexts: mscSigChanEIsdnToolsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnToolsTable.setDescription('This contains a series of operational attributes which turn on and off several kinds of tracing.')
mscSigChanEIsdnToolsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnToolsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnToolsEntry.setDescription('An entry in the mscSigChanEIsdnToolsTable.')
mscSigChanEIsdnTracing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 17, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnTracing.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnTracing.setDescription("This attribute defines which types of tracing are active on the signalling channel. The tracing messages are sent to the debug stream. To see the messages the agentQueueSize attribute of the Lp/x Eng Ds/debug component must be greater than 0 and the operator's NMIS session must have the debug stream included in its data stream list (for example: set Nmis Telnet Session/1 dataStreams deb). Several types of tracing can be enabled simultaneously. Note that tracing consumes additional CPU resources and slows down call processing on a heavily loaded card. If there is message block exhaustion tracing is suspended for a period of time and then automatically re-enabled. An alarm is generated on tracing suspension and resumption. This mechanism protects the function processor against excessive numbers of tracing messages. Types of tracing include: protocolErrors - get details of any protocol errors which are occurring. Protocol errors are also reported in summary form as alarms. q931Summary - summary of the Q.931 messages on the signalling link. q931Hex - Q.931 messages displayed in hex format. Useful to determine protocol compliance in case of errors reported on local or remote ends. q931Symbolic - Q.931 messages parsed to give maximum detail. Useful for understanding content of messages flowing on the link. portHex - Q.921 messages in hex format being sent and received on the link. Description of bits: protocolErrors(0) q931Summary(1) q931Hex(2) q931Symbolic(3) portHex(4)")
mscSigChanEIsdnOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18), )
if mibBuilder.loadTexts: mscSigChanEIsdnOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOptTable.setDescription('This group specifies the provisionable attributes specific to the Euro ISDN (ETSI-T) protocol.')
mscSigChanEIsdnOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnOptEntry.setDescription('An entry in the mscSigChanEIsdnOptTable.')
mscSigChanEIsdnVariant = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("etsiGeneric", 0), ("austria", 1), ("germany", 2))).clone('etsiGeneric')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnVariant.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnVariant.setDescription('This attribute specifies the specific variant of the Euro ISDN (ETSI- T) protocol. Supported variants are: etsiGeneric - provides generic ETSI-T protocol. Only proxy of the NETWORK side of the protocol is implemented, austria - provides ETSI-T protocol variant as per the Austrian national specification. Only the USER side of the protocol is implemented, germany - provides ETSI-T protocol variant as per the German national specification. Only the USER side of the protocol is implemented.')
mscSigChanEIsdnConnectServiceTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnConnectServiceTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnConnectServiceTimer.setDescription("This attribute specifies duration of the 'await connection' supervisory timer which applies to non call-associated sessions providing bearer-independent connection-oriented transport for supplementary services. The timer is started at the ingress Passport when a REGISTER message is received from the source PBX and stopped when a virtual circuit with the egress Passport is established. If the timer expires, the non call-associated session is cleared. The 'await connection' timer (attribute connectServiceTimer) together with 'await response' timer (attribute responseServiceTimer) provide equivalent of the T-ACTIVATE timer described in the relevant supplementary service specifications. A change of the timer value does not apply to timers already running.")
mscSigChanEIsdnResponseServiceTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnResponseServiceTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnResponseServiceTimer.setDescription("This attribute specifies duration of the 'await response' supervisory timer which applies to non call-associated sessions providing bearer-independent connection-oriented transport for supplementary services. The timer is started at the ingress Passport when creation of a virtual circuit with the egress Passport is confirmed and stopped when the first message from the destination PBX is received. If the timer expires, the non call-associated session is cleared. The 'await connection' timer (attribute connectServiceTimer) together with 'await response' timer (attribute responseServiceTimer) provide equivalent of the T-ACTIVATE timer described in the relevant supplementary service specifications. A change of the timer value does not apply to timers already running.")
mscSigChanEIsdnLifetimeServiceTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnLifetimeServiceTimer.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnLifetimeServiceTimer.setDescription('This attribute specifies duration of the service lifetime supervisory timer which applies to non call-associated sessions providing bearer-independent connection-oriented transport for supplementary services. The timer limits the duration of a virtual call. It is started at the ingress Passport at the moment the first response message from the destination PBX has been received and stopped when the non call-associated session is released. If the timer expires, the non call-associated session is cleared. This timer is equivalent to the T-CCBS6 timer described in the relevant supplementary service specifications. A change of the timer value does not apply to timers already running.')
mscSigChanEIsdnFramer = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2))
mscSigChanEIsdnFramerRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1), )
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatusTable.setDescription('This entry controls the addition and deletion of mscSigChanEIsdnFramer components.')
mscSigChanEIsdnFramerRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatusEntry.setDescription('A single entry in the table represents a single mscSigChanEIsdnFramer component.')
mscSigChanEIsdnFramerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscSigChanEIsdnFramer components. These components cannot be added nor deleted.')
mscSigChanEIsdnFramerComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscSigChanEIsdnFramerStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStorageType.setDescription('This variable represents the storage type value for the mscSigChanEIsdnFramer tables.')
mscSigChanEIsdnFramerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscSigChanEIsdnFramerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerIndex.setDescription('This variable represents the index for the mscSigChanEIsdnFramer tables.')
mscSigChanEIsdnFramerProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 10), )
if mibBuilder.loadTexts: mscSigChanEIsdnFramerProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerProvTable.setDescription('This group contains the base provisioning data for the Framer component. Application or hardware interface specific provisioning data is contained in other provisionable Framer groups.')
mscSigChanEIsdnFramerProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnFramerProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerProvEntry.setDescription('An entry in the mscSigChanEIsdnFramerProvTable.')
mscSigChanEIsdnFramerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerInterfaceName.setDescription("This attribute contains a hardware component name. The attribute associates the application with a specific link. This defines the module processor on which Framer's parent component (as well as Framer itself) will run.")
mscSigChanEIsdnFramerStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 12), )
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscSigChanEIsdnFramerStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStateEntry.setDescription('An entry in the mscSigChanEIsdnFramerStateTable.')
mscSigChanEIsdnFramerAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscSigChanEIsdnFramerOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscSigChanEIsdnFramerUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscSigChanEIsdnFramerStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13), )
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStatsTable.setDescription('This group contains the operational statistics data for a Framer component.')
mscSigChanEIsdnFramerStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VoiceNetworkingMIB", "mscSigChanIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnIndex"), (0, "Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", "mscSigChanEIsdnFramerIndex"))
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerStatsEntry.setDescription('An entry in the mscSigChanEIsdnFramerStatsTable.')
mscSigChanEIsdnFramerFrmToIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerFrmToIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerFrmToIf.setDescription('This attribute counts the number of frames transmitted to the link interface by the Framer. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerFrmFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerFrmFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerFrmFromIf.setDescription('This attribute counts the number of frames received from the link interface by the Framer. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerOctetFromIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOctetFromIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOctetFromIf.setDescription('This attribute counts the number of bytes received from the link interface by the Framer. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerAborts.setDescription('This attribute counts the total number of aborts received. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerCrcErrors.setDescription('This attribute counts the total number of frames with CRC errors. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerLrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerLrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerLrcErrors.setDescription('This attribute counts the total number of frames with LRC errors. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerNonOctetErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerNonOctetErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerNonOctetErrors.setDescription('This attribute counts the total number of frames that were non octet aligned. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerOverruns.setDescription('This attribute counts the total number of frames received from the link for which overruns occurred. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerUnderruns.setDescription('This attribute counts the total number of frames transmitted to the link for which underruns occurred. This count wraps to zero after exceeding its maximum value.')
mscSigChanEIsdnFramerLargeFrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 115, 14, 2, 13, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscSigChanEIsdnFramerLargeFrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscSigChanEIsdnFramerLargeFrmErrors.setDescription('This attribute counts the total number of frames received which were too large (longer than 500 bytes). This count wraps to zero after exceeding its maximum value.')
vnetEuroIsdnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 1))
vnetEuroIsdnGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 1, 1))
vnetEuroIsdnGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 1, 1, 3))
vnetEuroIsdnGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 1, 1, 3, 2))
vnetEuroIsdnCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 3))
vnetEuroIsdnCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 3, 1))
vnetEuroIsdnCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 3, 1, 3))
vnetEuroIsdnCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 138, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-VnetEuroIsdnMIB", mscSigChanEIsdnFramerCrcErrors=mscSigChanEIsdnFramerCrcErrors, mscSigChanEIsdnRowStatusTable=mscSigChanEIsdnRowStatusTable, mscSigChanEIsdnFramerLargeFrmErrors=mscSigChanEIsdnFramerLargeFrmErrors, mscSigChanEIsdnNonCallAssocSessionsToIf=mscSigChanEIsdnNonCallAssocSessionsToIf, mscSigChanEIsdnFramerOctetFromIf=mscSigChanEIsdnFramerOctetFromIf, mscSigChanEIsdnTotalCallsFromIf=mscSigChanEIsdnTotalCallsFromIf, mscSigChanEIsdnOptEntry=mscSigChanEIsdnOptEntry, vnetEuroIsdnMIB=vnetEuroIsdnMIB, mscSigChanEIsdnFramerNonOctetErrors=mscSigChanEIsdnFramerNonOctetErrors, vnetEuroIsdnCapabilitiesCA=vnetEuroIsdnCapabilitiesCA, mscSigChanEIsdnT203=mscSigChanEIsdnT203, mscSigChanEIsdnSide=mscSigChanEIsdnSide, mscSigChanEIsdnStateTable=mscSigChanEIsdnStateTable, mscSigChanEIsdnActiveVoiceChannels=mscSigChanEIsdnActiveVoiceChannels, mscSigChanEIsdnMaxNonCallConcurrent=mscSigChanEIsdnMaxNonCallConcurrent, mscSigChanEIsdnVariant=mscSigChanEIsdnVariant, mscSigChanEIsdnTotalCallsToIf=mscSigChanEIsdnTotalCallsToIf, mscSigChanEIsdnActiveDataChannels=mscSigChanEIsdnActiveDataChannels, mscSigChanEIsdnToolsTable=mscSigChanEIsdnToolsTable, mscSigChanEIsdnFramerStorageType=mscSigChanEIsdnFramerStorageType, mscSigChanEIsdnConnectServiceTimer=mscSigChanEIsdnConnectServiceTimer, mscSigChanEIsdnFramerOperationalState=mscSigChanEIsdnFramerOperationalState, mscSigChanEIsdnFramerStatsTable=mscSigChanEIsdnFramerStatsTable, mscSigChanEIsdnProvEntry=mscSigChanEIsdnProvEntry, mscSigChanEIsdnTracing=mscSigChanEIsdnTracing, mscSigChanEIsdnFramerIndex=mscSigChanEIsdnFramerIndex, mscSigChanEIsdnFramerAdminState=mscSigChanEIsdnFramerAdminState, mscSigChanEIsdnFramerUsageState=mscSigChanEIsdnFramerUsageState, mscSigChanEIsdnOverlapReceiving=mscSigChanEIsdnOverlapReceiving, mscSigChanEIsdnL2Table=mscSigChanEIsdnL2Table, mscSigChanEIsdnNonCallAssocSessionsFromIf=mscSigChanEIsdnNonCallAssocSessionsFromIf, mscSigChanEIsdnFramerProvTable=mscSigChanEIsdnFramerProvTable, mscSigChanEIsdnFramerAborts=mscSigChanEIsdnFramerAborts, mscSigChanEIsdnT200=mscSigChanEIsdnT200, mscSigChanEIsdnProvTable=mscSigChanEIsdnProvTable, mscSigChanEIsdnFramerInterfaceName=mscSigChanEIsdnFramerInterfaceName, mscSigChanEIsdnOperationalState=mscSigChanEIsdnOperationalState, vnetEuroIsdnCapabilitiesCA02A=vnetEuroIsdnCapabilitiesCA02A, mscSigChanEIsdnFramer=mscSigChanEIsdnFramer, mscSigChanEIsdnUsageState=mscSigChanEIsdnUsageState, vnetEuroIsdnCapabilitiesCA02=vnetEuroIsdnCapabilitiesCA02, vnetEuroIsdnGroupCA=vnetEuroIsdnGroupCA, mscSigChanEIsdnFramerProvEntry=mscSigChanEIsdnFramerProvEntry, mscSigChanEIsdnPeakActiveChannels=mscSigChanEIsdnPeakActiveChannels, mscSigChanEIsdnFramerUnderruns=mscSigChanEIsdnFramerUnderruns, mscSigChanEIsdnAdminState=mscSigChanEIsdnAdminState, mscSigChanEIsdnDChanStatus=mscSigChanEIsdnDChanStatus, mscSigChanEIsdnRowStatusEntry=mscSigChanEIsdnRowStatusEntry, mscSigChanEIsdnL3Entry=mscSigChanEIsdnL3Entry, mscSigChanEIsdnToolsEntry=mscSigChanEIsdnToolsEntry, mscSigChanEIsdnL2Entry=mscSigChanEIsdnL2Entry, mscSigChanEIsdnOperTable=mscSigChanEIsdnOperTable, mscSigChanEIsdnPeakActiveVoiceChannels=mscSigChanEIsdnPeakActiveVoiceChannels, mscSigChanEIsdnFramerStateTable=mscSigChanEIsdnFramerStateTable, mscSigChanEIsdnOptTable=mscSigChanEIsdnOptTable, mscSigChanEIsdnFramerStateEntry=mscSigChanEIsdnFramerStateEntry, mscSigChanEIsdnFramerRowStatusEntry=mscSigChanEIsdnFramerRowStatusEntry, mscSigChanEIsdnIndex=mscSigChanEIsdnIndex, vnetEuroIsdnGroupCA02A=vnetEuroIsdnGroupCA02A, mscSigChanEIsdnN200=mscSigChanEIsdnN200, vnetEuroIsdnGroup=vnetEuroIsdnGroup, mscSigChanEIsdnFramerOverruns=mscSigChanEIsdnFramerOverruns, mscSigChanEIsdnOverlapSending=mscSigChanEIsdnOverlapSending, mscSigChanEIsdnPeakActiveDataChannels=mscSigChanEIsdnPeakActiveDataChannels, mscSigChanEIsdnLifetimeServiceTimer=mscSigChanEIsdnLifetimeServiceTimer, mscSigChanEIsdnFramerFrmFromIf=mscSigChanEIsdnFramerFrmFromIf, mscSigChanEIsdnActiveChannels=mscSigChanEIsdnActiveChannels, mscSigChanEIsdn=mscSigChanEIsdn, mscSigChanEIsdnFramerLrcErrors=mscSigChanEIsdnFramerLrcErrors, mscSigChanEIsdnStatsEntry=mscSigChanEIsdnStatsEntry, vnetEuroIsdnCapabilities=vnetEuroIsdnCapabilities, mscSigChanEIsdnOperEntry=mscSigChanEIsdnOperEntry, vnetEuroIsdnGroupCA02=vnetEuroIsdnGroupCA02, mscSigChanEIsdnFramerComponentName=mscSigChanEIsdnFramerComponentName, mscSigChanEIsdnComponentName=mscSigChanEIsdnComponentName, mscSigChanEIsdnT23=mscSigChanEIsdnT23, mscSigChanEIsdnCircuitSwitchedK=mscSigChanEIsdnCircuitSwitchedK, mscSigChanEIsdnL3Table=mscSigChanEIsdnL3Table, mscSigChanEIsdnStatsTable=mscSigChanEIsdnStatsTable, mscSigChanEIsdnFramerStatsEntry=mscSigChanEIsdnFramerStatsEntry, mscSigChanEIsdnFramerRowStatus=mscSigChanEIsdnFramerRowStatus, mscSigChanEIsdnFramerFrmToIf=mscSigChanEIsdnFramerFrmToIf, mscSigChanEIsdnRowStatus=mscSigChanEIsdnRowStatus, mscSigChanEIsdnResponseServiceTimer=mscSigChanEIsdnResponseServiceTimer, mscSigChanEIsdnT310=mscSigChanEIsdnT310, mscSigChanEIsdnFramerRowStatusTable=mscSigChanEIsdnFramerRowStatusTable, mscSigChanEIsdnStorageType=mscSigChanEIsdnStorageType, mscSigChanEIsdnStateEntry=mscSigChanEIsdnStateEntry)

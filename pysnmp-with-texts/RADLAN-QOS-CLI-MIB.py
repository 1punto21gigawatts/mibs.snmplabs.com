#
# PySNMP MIB module RADLAN-QOS-CLI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-QOS-CLI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:48:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
VlanId, PortList = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "PortList")
VlanList4, VlanList1, VlanList3, VlanList2 = mibBuilder.importSymbols("RADLAN-BRIDGEMIBOBJECTS-MIB", "VlanList4", "VlanList1", "VlanList3", "VlanList2")
Percents, rnd = mibBuilder.importSymbols("RADLAN-MIB", "Percents", "rnd")
StatisticsDPType, StatisticsClearActionType = mibBuilder.importSymbols("RADLAN-POLICY-MIB", "StatisticsDPType", "StatisticsClearActionType")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Bits, NotificationType, ModuleIdentity, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, IpAddress, Gauge32, Integer32, iso, ObjectIdentity, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Bits", "NotificationType", "ModuleIdentity", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "IpAddress", "Gauge32", "Integer32", "iso", "ObjectIdentity", "MibIdentifier", "Counter32")
RowPointer, TruthValue, TextualConvention, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowPointer", "TruthValue", "TextualConvention", "RowStatus", "DisplayString")
rlQosCliMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 88))
rlQosCliMib.setRevisions(('2006-02-12 00:00', '2006-02-12 00:00', '2005-03-14 00:00', '2005-02-07 00:00', '2005-01-27 00:00', '2004-11-15 00:00', '2003-09-29 00:00', '2003-09-21 00:00', '2005-04-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlQosCliMib.setRevisionsDescriptions(('The private MIB module definition for Quality Of Service CLI in Radlan devices.', 'Editorial changes to support new MIB compilers.', 'Add rlQosPortRateLimitStatus,rlQosCirPortRateLimit, rlQosCbsPortRateLimit to rlQosIfPolicyTable', 'Add vpt,ether-type,tcp-flags,icmp-type,icmp-code,igmp-type to ClassTupleType Add mac-Offset,ip-ICMP,ip-IGMP To AceObjectType Add vpt,ethertype To ClassOffsetType', 'Add new advanced action : trustCosDscp', 'Add DSCP to Queue Default map table.', 'Add textual convention to QosObjectMode (service).', 'Added this MODULE-IDENTITY clause, changed IMPORT, removed ranges in SEQUENCE elements, changed access of rlQosCliQosMode, rlQosCliBasicModeCfg and rlQosMaxNumOfAce.', 'Added rlQosDscpToDpTable',))
if mibBuilder.loadTexts: rlQosCliMib.setLastUpdated('200604040000Z')
if mibBuilder.loadTexts: rlQosCliMib.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rlQosCliMib.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlQosCliMib.setDescription('Added: StatisticsCntrNumOfBitsType StatisticsCntrType rlQosStatistics rlQosPortPolicyStatisticsTable rlQosSinglePolicerStatisticsTable rlQosAggregatePolicerStatisticsTable rlQosOutQueueStatisticsTable rlQosGlobalStatisticsCntrsTable.')
class ClassOffsetType(TextualConvention, Integer32):
    description = 'Specifies one of 6 offset types: 1- Absolute-start of the packet. 2- Layer 2-start of MAC header. 3- MPLS-start of MPLS header. 4- Layer 3-start of layer 3 header. 5- Layer 4-start of layer 4 header. 6- Layer 5-after TCP/UDP header. 7- VLAN. 8- input device port. 9- input device port. 10-VPT. 11-EtherType. 12-innerVlan. 13-Layer 3 IPv6 - start of layer 3 IPv6 header'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("packetStart", 1), ("layer2-start", 2), ("mpls-start", 3), ("layer3-start", 4), ("layer4-start", 5), ("layer5-start", 6), ("vlan", 7), ("in-port", 8), ("out-port", 9), ("vpt", 10), ("ethertype", 11), ("inner-vlan", 12), ("layer3-ipv6-start", 13))

class ClassTupleType(TextualConvention, Integer32):
    description = 'Specifies one of Tuple types '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32))
    namedValues = NamedValues(("protocol", 1), ("ip-src", 2), ("ip-dest", 3), ("dscp", 4), ("ip-precedence", 5), ("udp-port-src", 6), ("udp-port-dest", 7), ("tcp-port-src", 8), ("tcp-port-dest", 9), ("mac-src", 10), ("mac-dest", 11), ("vlan", 12), ("in-port", 13), ("out-port", 14), ("general", 15), ("vpt", 16), ("ether-type", 17), ("tcp-flags", 18), ("icmp-type", 19), ("icmp-code", 20), ("igmp-type", 21), ("inner-vlan", 22), ("ipv6-src", 23), ("ipv6-dest", 24), ("udp-port-range-start-src", 25), ("udp-port-range-end-src", 26), ("udp-port-range-start-dest", 27), ("udp-port-range-end-dest", 28), ("tcp-port-range-start-src", 29), ("tcp-port-range-end-src", 30), ("tcp-port-range-start-dest", 31), ("tcp-port-range-end-dest", 32))

class AceActionType(TextualConvention, Integer32):
    description = 'Specifies one of 4 ACE Actions: 1- Permit- permit to the traffic that define by the parameters. 2- Deny- deny the traffic that define by the parameter. 3- Deny-DisablePort deny the traffic that defined by the parameters and disable the port. 4- Deny-LogInput deny the traffic that defined by the parameters and log incoming traffic. 5- Permit-LogInput permit the traffic that defined by the parameters and log incoming traffic.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("permit", 1), ("deny", 2), ("deny-DisablePort", 3), ("deny-LogInput", 4), ("permit-LogInput", 5))

class AceObjectType(TextualConvention, Integer32):
    description = 'Specifies one of 13 ACE types: 1- IP ACE. 2- IP-TCP ACE. 3- IP-UDP ACE. 4- IP-offset ACE. 5- MAC ACE. 6- MAC-offset ACE. 7- IP-ICMP ACE. 8- IP-IGMP ACE. 9- IPv6 ACE. 10- IPv6-TCP ACE. 11- IPv6-UDP ACE. 12- IPv6-offset ACE. 13- IPv6-ICMP ACE.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))
    namedValues = NamedValues(("ip", 1), ("ip-TCP", 2), ("ip-UDP", 3), ("ip-Offset", 4), ("mac", 5), ("mac-Offset", 6), ("ip-ICMP", 7), ("ip-IGMP", 8), ("ipv6", 9), ("ipv6-TCP", 10), ("ipv6-UDP", 11), ("ipv6-Offset", 12), ("ipv6-ICMP", 13))

class AclObjectType(TextualConvention, Integer32):
    description = 'Specifies one of 3 ACL types: 1- MAC ACL. 2- IPv4 ACL. 3- IPv6 ACL.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("mac", 1), ("ip", 2), ("ipv6", 3))

class ClassMapType(TextualConvention, Integer32):
    description = 'Specifies one of 2 Class-map types: 1- Match all. logical and between all statements. 2- Match any. logical or between all statements.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("matchAll", 1), ("matchAny", 2))

class ClassMapAction(TextualConvention, Integer32):
    description = 'Specifies one of 8 Class-map actios: 1- none - action not specified - use default action. 2 -Mark IP-Precedence. 3- Mark DSCP. 4- Set Egress queue 5- Mark VPT 6- Choose queue by global trust mode.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("none", 1), ("setIP-Precedence", 2), ("setDSCP", 3), ("setQueue", 4), ("setCos", 5), ("trust", 6))

class MarkVlanAction(TextualConvention, Integer32):
    description = 'Specifies the mark vlan action type in the class map table. 1 - noMark - No vlan marking 2 - mark - mark vlan tagged. 3 - markNestedVlan - add vlan tag to the packet. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noMark", 1), ("mark", 2), ("markNestedVlan", 3))

class RedirectAction(TextualConvention, Integer32):
    description = 'Specifies the packet redirection options. Redirection is applied only on permitted packets. 1 - disabled - no redirect 2 - trap - trap to local_host (CPU) 3 - redirectToInterface - redirect to a output interface (port, trunk or vlan) 4 - redirectToAllPorts - redirect to all ports, except the ingress port. 5 - mirror - forward the packet and sent a copy to local_host (CPU) 6 - analyzerPort - forward the packet and sent a copy to egress port. 7 - loopback - redirect the packet the the port it was received. 8 - redirectToPortGroup - send to group of ports, defined in rlUserAssignedVidxTable table 9 - mirror_and_redirectToInterface - send the packet to interface and send a copy to local_host(CPU) 10 -mirror_and_redirectToInterfacesGroup - send the packet to group of ports and send a copy to local_host(CPU) '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("disabled", 1), ("trap", 2), ("redirectToInterface", 3), ("redirectToAllPorts", 4), ("mirror", 5), ("analyzerPort", 6), ("loopback", 7), ("redirectToPortGroup", 8), ("mirrorAndRedirectToInterface", 9), ("mirrorAndRedirectToInterfacesGroup", 10))

class PolicerType(TextualConvention, Integer32):
    description = 'Specifies one of 3 Policer types: 1- Single policer only per one class map. 2- Aggregate policer can be applied to several class maps. 3- Cascade policer.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("single", 1), ("aggregate", 2), ("cascade", 3))

class PolicerAction(TextualConvention, Integer32):
    description = 'Specifies one of 4 Policer Action: 1- No Action 2- Drop out of profile packets. 3- Remark out of profile packets. 4- Remark to explicit value out of profile packets 5- this policer is part of cascade chain'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("drop", 2), ("remark", 3), ("explicit-remark", 4), ("cascadePointer", 5))

class QosGlobalMode(TextualConvention, Integer32):
    description = 'Specifies one of 3 QoS mode: 1- disable no QoS on the system 2- Basic Qos mode only trust mode with ACL are enabled. 3- Advance mode all Qos option are enabled. 4- Service Mode -v750 DEPEREACTED!!! all Qos option are enabled only in service mode configuration'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("disable", 1), ("basic", 2), ("advance", 3))

class QosTrustMode(TextualConvention, Integer32):
    description = 'Specifies one of 6 QoS trust mode: - none.- v750 DEPRECATED - same as globalMode = disable. means that only ACL can be applied. - 802.1p. queue is set by the VPT field. - DSCP. queue is set by the DSCP field - v750 deprecated. replaced with new scalar rlQosDscpMutationEnable . DSCP-Mutation. the DSCP mutate in the ingress and then the queue is set by the DSCP - tcp/udp.- v750 - DEPRECATED - not supported. the queue is set by the l4 port number. - cos-dscp. Queue is set for l2 traffic by VPT field and for l3 traffic by DSCP field. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("cos", 1), ("dscp", 2), ("cos-dscp", 3))

class BinaryStatus(TextualConvention, Integer32):
    description = 'Specifies Disable or enable.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disable", 1), ("enable", 2))

class QueueType(TextualConvention, Integer32):
    description = 'Queue type Ef or WRR.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ef", 1), ("wrr", 2))

class AclDefaultAction(TextualConvention, Integer32):
    description = 'Default action when the ACL reach end point.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("deny-all", 1), ("forward-all", 2), ("application-specific", 3))

class InterfaceType(TextualConvention, Integer32):
    description = 'Interface type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("vlan", 1), ("port", 2))

class StatisticsCntrNumOfBitsType(TextualConvention, Integer32):
    description = 'The counter can be of different sizes - 32 bit, 48 bit, 64 bit. Maximum is 64.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(32, 48, 64))
    namedValues = NamedValues(("uint32", 32), ("uint48", 48), ("uint64", 64))

class StatisticsCntrType(TextualConvention, Integer32):
    description = 'The counter can be of different types, depends on actions adhered to rules that the counter is working on.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("statisticsCntrTypeSetDSCP", 1), ("statisticsCntrTypeDeny", 2))

class RlQosTimeBasedAclWeekPeriodicList(TextualConvention, Bits):
    description = 'Bitmap that includes days of week. Each bit in the bitmap associated with corresponding day of the week.'
    status = 'current'
    namedValues = NamedValues(("monday", 0), ("tuesday", 1), ("wednesday", 2), ("thursday", 3), ("friday", 4), ("saturday", 5), ("sunday", 6))

class RlQosAceTidxActionDropType(TextualConvention, Integer32):
    description = 'The Action Drop Type.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("hardDrop", 1), ("softDrop", 2))

class RlQosApplicationDefaultActionType(TextualConvention, Integer32):
    description = 'Application default actions.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("forward", 1), ("hard-Drop", 2), ("soft-Drop", 3), ("trap", 4))

rlQosCliQosMode = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 1), QosGlobalMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosCliQosMode.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosCliQosMode.setDescription(' *********This Scalar is deprecated - rlQosGlobalCfgEntry - replaces its functionality*************** This scalar define in which mode the system will work: basic , advance or none.')
rlQosCliBasicModeCfg = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 2), QosTrustMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosCliBasicModeCfg.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosCliBasicModeCfg.setDescription('*********This Scalar is deprecated - rlQosGlobalCfgEntry - replaces its functionality*************** This scalar define in which trust mode the system will work:802.1p or DSCP or DSCP-Mutation or TCP/UDP or none or vpt-dscp.')
rlQosMaxNumOfAce = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosMaxNumOfAce.setStatus('current')
if mibBuilder.loadTexts: rlQosMaxNumOfAce.setDescription('This scalar define the max number of aces.')
rlQosOffsetTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 4), )
if mibBuilder.loadTexts: rlQosOffsetTable.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetTable.setDescription('This table specifies Offset Table information')
rlQosOffsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 4, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosOffsetIndex"))
if mibBuilder.loadTexts: rlQosOffsetEntry.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetEntry.setDescription('Each entry in this table describes one classifier field. The information includes: Offset Type the offset the mask and the Pattern. if the type is vlan then the value will be the vlan tag. if the Type is in/out port it will be the device in/out port. The index is sequential integer represent by rlQosOffsetIndex')
rlQosOffsetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosOffsetIndex.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetIndex.setDescription('An arbitrary incremental Index for the offset table.')
rlQosOffsetType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 2), ClassOffsetType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetType.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetType.setDescription('Start of the offset.')
rlQosOffsetValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetValue.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetValue.setDescription('The Offset value.')
rlQosOffsetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetMask.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetMask.setDescription('Define which bit to be extracted from the offset.')
rlQosOffsetPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetPattern.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetPattern.setDescription('The value to match too.')
rlQosOffsetTuplePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetTuplePointer.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetTuplePointer.setDescription('Pointer for the relevant Tuple.')
rlQosOffsetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosOffsetStatus.setStatus('deprecated')
if mibBuilder.loadTexts: rlQosOffsetStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosTupleTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 5), )
if mibBuilder.loadTexts: rlQosTupleTable.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleTable.setDescription('This table specifies Tuple Table information')
rlQosTupleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 5, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosTupleIndex"))
if mibBuilder.loadTexts: rlQosTupleEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleEntry.setDescription('Each entry in this table describes one Tuple. The information includes: Tuple Type and the Tuples values. The index is sequential integer represent by rlQosTupleIndex')
rlQosTupleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosTupleIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleIndex.setDescription('An arbitrary incremental Index for the offset table.')
rlQosTupleType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 2), ClassTupleType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleType.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleType.setDescription('Start of the offset.')
rlQosTupleValue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleValue1.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleValue1.setDescription('The Tuple no.1 value can be regular integer values only.')
rlQosTupleValue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleValue2.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleValue2.setDescription('The Tuple no.2 value can be IPv4/IPv6/MAC address or protocol number with mask')
rlQosTupleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTupleStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosTupleStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAceTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 6), )
if mibBuilder.loadTexts: rlQosAceTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTable.setDescription('This table specifies ACE table information')
rlQosAceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 6, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAceIndex"))
if mibBuilder.loadTexts: rlQosAceEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAceEntry.setDescription("Each entry in this table describes one Classifier Element. The information includes: Action the ACE's Type the up to 8 tuples pointers. The index is sequential integer represent by rlQosAceIndex")
rlQosAceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAceIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceIndex.setDescription('An arbitrary incremental Index for the ACE table.')
rlQosAceAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 2), AceActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAceAction.setDescription('ACE Action to take.')
rlQosAceType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 3), AceObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceType.setStatus('current')
if mibBuilder.loadTexts: rlQosAceType.setDescription('ACE Type')
rlQosAceTuple1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple1.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple1.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple2.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple2.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple3.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple3.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple4.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple4.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple5.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple5.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple6.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple6.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple7.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple7.setDescription('ACE Tuple 1 pointer.')
rlQosAceTuple8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTuple8.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTuple8.setDescription('ACE Tuple 1 pointer.')
rlQosAceAccount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 12), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceAccount.setStatus('current')
if mibBuilder.loadTexts: rlQosAceAccount.setDescription("ACE Accounting state. When set to 'enabled' than appropriate statistic's counter is provided for an ACE.")
rlQosAceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 6, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAceStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAclTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 7), )
if mibBuilder.loadTexts: rlQosAclTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclTable.setDescription('This table specifies ACL table information')
rlQosAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 7, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclIndex"))
if mibBuilder.loadTexts: rlQosAclEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclEntry.setDescription('Each entry in this table describes one Classifier Element. The information includes: Action and the row status. The ACE pointer are in the ACL-ACE reference table. The index is sequential integer represent by rlQosAceIndex')
rlQosAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclIndex.setDescription('An arbitrary incremental Index for the ACE table.')
rlQosAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclName.setStatus('current')
if mibBuilder.loadTexts: rlQosAclName.setDescription('Name ACL.')
rlQosAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 3), AclObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclType.setStatus('current')
if mibBuilder.loadTexts: rlQosAclType.setDescription('ACL Type.')
rlQosAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAclStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAclNumOfAces = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclNumOfAces.setStatus('current')
if mibBuilder.loadTexts: rlQosAclNumOfAces.setDescription('Holds number of aces in the acl.')
rlQosAclAceRefTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 8), )
if mibBuilder.loadTexts: rlQosAclAceRefTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefTable.setDescription('This table specifies the ACE to ACL relationship.')
rlQosAclAceRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 8, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclAceRefAcePointer"))
if mibBuilder.loadTexts: rlQosAclAceRefEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefEntry.setDescription('Each entry in this table describes the relationship between ACE to ACL. Show which ACE include in one ACL. The index is the ACE pointer represent by rlQosAclAceRefAcePointer')
rlQosAclAceRefAcePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAclAceRefAcePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefAcePointer.setDescription('The Index is the ACE pointer')
rlQosAclAceRefAclPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclAceRefAclPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefAclPointer.setDescription('ACL index Pointer')
rlQosAclAceRefStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 8, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclAceRefStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAclAceRefStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosClassMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 9), )
if mibBuilder.loadTexts: rlQosClassMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapTable.setDescription('This table specifies CCL table information')
rlQosClassMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 9, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosClassMapIndex"))
if mibBuilder.loadTexts: rlQosClassMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapEntry.setDescription('Each entry in this table describes one Class Map Element. The information includes: Classes Name,Class Action, Policer pointer, and 1 match statements. The index is sequential integer represent by rlQosClassMapIndex')
rlQosClassMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosClassMapIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapIndex.setDescription('Class Map Index')
rlQosClassMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapName.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapName.setDescription('Name of the Class Map.')
rlQosClassMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 3), ClassMapType().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapType.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapType.setDescription('Class map type')
rlQosClassMapAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 4), ClassMapAction().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapAction.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapAction.setDescription('Class Map Action.')
rlQosClassMapMarkValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMarkValue.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMarkValue.setDescription('Mark value when mark action has been chosen in Class Map Action field.')
rlQosClassMapPolicer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapPolicer.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapPolicer.setDescription('Policer pointer. 0-means no policer.')
rlQosClassMapMatch1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMatch1.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMatch1.setDescription('Match ACL 1 pointer.')
rlQosClassMapMatch2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMatch2.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMatch2.setDescription('Match ACL 2 pointer.')
rlQosClassMapMarkVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 9), MarkVlanAction().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMarkVlan.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMarkVlan.setDescription("If 'mark', than the classified traffic will be remarked with new VLAN id. If 'disabled' VLAN id is not changed. If markNestedVlan, if the egress interface defined as VLAN tagged member then a new VLAN tag is added to the packet.")
rlQosClassMapNewVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapNewVlan.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapNewVlan.setDescription("If rlQosClassMapMarkVlan is not 'noMark', than the classified traffic will be remarked with new VLAN id. The value of this field sets new VLAN id.")
rlQosClassMapRedirectAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 11), RedirectAction().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapRedirectAction.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapRedirectAction.setDescription('Specifiy the redirection action.')
rlQosClassMapDestInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapDestInterface.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapDestInterface.setDescription("Relevant if rlQosClassMapRedirect is either 'redirectToInterface' or 'analyzerPort' or 'toMultipleInterfaces'. Specified the output interface the packet is redireted to or the port that gets copy of the packet in addition to the port it was forwarded.")
rlQosClassMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosClassMapMatch3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapMatch3.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapMatch3.setDescription('Match ACL 3 pointer.')
rlQosClassMapTrapId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapTrapId.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapTrapId.setDescription('If now zero, Indicates the trap type id the matched packets arrives with, relevant when RedirectAction is trap or mirror.')
rlQosClassMapCounterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 16), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapCounterEnable.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapCounterEnable.setDescription('Enable/disable counting per class map. Counts packets matche the class map rules.')
rlQosClassMapTunnelIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 9, 1, 17), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosClassMapTunnelIdx.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapTunnelIdx.setDescription('If not zero, then the tunnel data pointed by rlQosClassMapTunnelIdx is added to the packet')
rlQosPolicerTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 10), )
if mibBuilder.loadTexts: rlQosPolicerTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerTable.setDescription('This table specifies All the Policers in the system Information')
rlQosPolicerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 10, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicerIndex"))
if mibBuilder.loadTexts: rlQosPolicerEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerEntry.setDescription('Each entry in this table describes one policer. The information includes: Policer name, Policer type, Committed Rate, Committed Burst, Out-of-Profile Action. The index is sequential integer represent by rlQosPolicerIndex')
rlQosPolicerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicerIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerIndex.setDescription('Policer Index.')
rlQosPolicerName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerName.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerName.setDescription('Name of the Policer.')
rlQosPolicerType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 3), PolicerType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerType.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerType.setDescription('Policer type')
rlQosPolicerCir = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 4), Unsigned32()).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCir.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCir.setDescription('Committed rate value.')
rlQosPolicerCbs = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 5), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCbs.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCbs.setDescription('Committed burst Value.')
rlQosPolicerAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 6), PolicerAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerAction.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerAction.setDescription('Out of profile Action.')
rlQosPolicerCasPointerRemVal = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerCasPointerRemVal.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerCasPointerRemVal.setDescription('Remark value in case of explicit remark. The functionality as cascade pointer is obsolete.')
rlQosPolicerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosPolicerPir = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 9), Unsigned32()).setUnits('kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerPir.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerPir.setDescription('Peak rate value. When both this and rlQosPolicerPbs are 0 this means the mode is Single Rate and when they are both non 0 this means the mode is Two Rate.')
rlQosPolicerPbs = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 10), Unsigned32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerPbs.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerPbs.setDescription('Peak burst Value. When both this and rlQosPolicerPir are 0 this means the mode is Single Rate and when they are both non 0 this means the mode is Two Rate.')
rlQosPolicerPeakAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 10, 1, 11), PolicerAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicerPeakAction.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicerPeakAction.setDescription('Out of profile peak action.')
rlQosPolicyMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 11), )
if mibBuilder.loadTexts: rlQosPolicyMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapTable.setDescription('This table specifies Policy Map Table Information')
rlQosPolicyMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 11, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyMapIndex"))
if mibBuilder.loadTexts: rlQosPolicyMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapEntry.setDescription('Each entry in this table describes one policy map. The information includes: Index, Policy Map name, Up to 6 class map names. The index is sequential integer represent by rlQosPolicerIndex')
rlQosPolicyMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicyMapIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapIndex.setDescription('Policy map Index.')
rlQosPolicyMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyMapName.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapName.setDescription('Policy map Name.')
rlQosPolicyMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 11, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyMapStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosPolicyClassRefTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 12), )
if mibBuilder.loadTexts: rlQosPolicyClassRefTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefTable.setDescription('This table specifies The relationship between policy map to class map')
rlQosPolicyClassRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 12, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyClassRefClassPointer"))
if mibBuilder.loadTexts: rlQosPolicyClassRefEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefEntry.setDescription('Each entry in this table describes the connection between class-map entry to policy map by using pointers. The index is Class map pointer represent by rlQosPolicyClassRefClassPointer')
rlQosPolicyClassRefClassPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicyClassRefClassPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefClassPointer.setDescription('The Index is the Class-map pointer')
rlQosPolicyClassRefPolicyPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassRefPolicyPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefPolicyPointer.setDescription('Policy map index Pointer')
rlQosPolicyClassRefStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 12, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassRefStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassRefStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosIfPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 13), )
if mibBuilder.loadTexts: rlQosIfPolicyTable.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyTable.setDescription('This table specifies for each interface the Policy Map attach to it')
rlQosIfPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 13, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlIfType"))
if mibBuilder.loadTexts: rlQosIfPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyEntry.setDescription('Each entry in this table describes what policy Map attached to specific Interface. The index is Interface Index represent by rlIfIndex and the interface type represent by rlIfType')
rlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 1), Integer32())
if mibBuilder.loadTexts: rlIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlIfIndex.setDescription('Interface Index.')
rlIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 2), InterfaceType())
if mibBuilder.loadTexts: rlIfType.setStatus('current')
if mibBuilder.loadTexts: rlIfType.setDescription('Interface Type(vlan/port).')
rlQosIfPolicyMapPointerIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerIn.setDescription('Policy map pointer Input.')
rlQosIfPolicyMapPointerOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerOut.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapPointerOut.setDescription('Policy map pointer Output.')
rlQosIfTrustActive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 5), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfTrustActive.setStatus('current')
if mibBuilder.loadTexts: rlQosIfTrustActive.setDescription('Interface Basic Mode Trust is active or not .')
rlQosPortShaperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 6), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPortShaperStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPortShaperStatus.setDescription('If there is shaper on the port')
rlQosCirPortShaper = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 7), Integer32()).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirPortShaper.setStatus('current')
if mibBuilder.loadTexts: rlQosCirPortShaper.setDescription('The CIR for the port shaper. N/A when the shper is disabled')
rlQosCbsPortShaper = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 8), Integer32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsPortShaper.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsPortShaper.setDescription('The CBS for the port shaper. N/A when the shper is disabled')
rlQosIfProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfilePointer.setDescription('Interface Profile name pointer.')
rlQosQueueProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfilePointer.setDescription(' Queue Profile name pointer.')
rlQosQueueShapeProfilePointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueShapeProfilePointer.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfilePointer.setDescription(' Queue shape Profile pointer.')
rlQosAclDefaultAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 12), AclDefaultAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclDefaultAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAclDefaultAction.setDescription(' When one ACL is enterd then what to do for the last rull.')
rlQosIfPolicyMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicyMapStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicyMapStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosIfAclIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfAclIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfAclIn.setDescription('Index of an ACL in the rlQosAclTable, which is applied to the ingress of an interface. 0 - means no ACL applied.')
rlQosIfAclOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfAclOut.setStatus('current')
if mibBuilder.loadTexts: rlQosIfAclOut.setDescription('Index of an ACL in the rlQosAclTable, which is applied to the egress of an interface. 0 - means no ACL applied.')
rlQosIfPolicerIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfPolicerIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfPolicerIn.setDescription('Index of an Policer in the rlQosPolicerTable, which is applied to the ingress of an interface. 0 - means no Policer applied.')
rlQosPortRateLimitStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 17), BinaryStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPortRateLimitStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPortRateLimitStatus.setDescription('If there is Rate limit on the port')
rlQosCirPortRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 18), Integer32()).setUnits('bps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: rlQosCirPortRateLimit.setDescription('The CIR for the port rate limit. N/A when the Rate limit is disabled')
rlQosCbsPortRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 19), Integer32()).setUnits('bytes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsPortRateLimit.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsPortRateLimit.setDescription('The CBS for the port Rate limit. N/A when the Rate limit is disabled')
rlQosIfIpv6AclIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 20), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfIpv6AclIn.setStatus('current')
if mibBuilder.loadTexts: rlQosIfIpv6AclIn.setDescription('Index of an IPv6 ACL in the rlQosAclTable, which is applied to the ingress of an interface. 0 - means no ACL applied.')
rlQosIfIpv6AclOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 21), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfIpv6AclOut.setStatus('current')
if mibBuilder.loadTexts: rlQosIfIpv6AclOut.setDescription('Index of an IPv6 ACL in the rlQosAclTable, which is applied to the egress of an interface. 0 - means no ACL applied.')
rlQosAclDefaultActionOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 13, 1, 22), AclDefaultAction()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAclDefaultActionOut.setStatus('current')
if mibBuilder.loadTexts: rlQosAclDefaultActionOut.setDescription(' When one egress ACL is enterd then what to do for the last rull.')
rlQosIfProfileCfgTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 14), )
if mibBuilder.loadTexts: rlQosIfProfileCfgTable.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfileCfgTable.setDescription('This table specifies for each Queue the Tail Drop or WRED parameters and the EF of WRR parameters.')
rlQosIfProfileCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 14, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfProfileName"), (0, "RADLAN-QOS-CLI-MIB", "rlQosQueueId"))
if mibBuilder.loadTexts: rlQosIfProfileCfgEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosIfProfileCfgEntry.setDescription('Each entry in this table describes one queue parameters: Tail-drop threshold for drop precedence 0,1,3 and the WRED min-max threshold and the probability factor for Drop precedence 0,1,2 and the WRED Q factor and the EF priority and the WRR weight. The index is Interface Index represent by rlIfProfileName and queue-id represent by rlQosQueueId')
rlIfProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlIfProfileName.setStatus('current')
if mibBuilder.loadTexts: rlIfProfileName.setDescription('Interface Index.')
rlQosQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: rlQosQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueId.setDescription('Queue id Index.')
rlQosTdThersholdDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp0.setDescription('Tail Drop Threshold for Drop Precedence 0.')
rlQosTdThersholdDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp1.setDescription('Tail Drop Threshold for Drop Precedence 1.')
rlQosTdThersholdDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTdThersholdDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosTdThersholdDp2.setDescription('Tail Drop Threshold for Drop Precedence 2.')
rlQosRedMinDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp0.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp0.setDescription('WRED Max Threshold for Drop Precedence 0.')
rlQosRedProbDp0 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp0.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp0.setDescription('WRED probability for Drop Precedence 0.')
rlQosRedMinDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp1.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp1.setDescription('WRED Max Threshold for Drop Precedence 1.')
rlQosRedProbDp1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp1.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp1.setDescription('WRED probability for Drop Precedence 1.')
rlQosRedMinDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMinDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMinDp2.setDescription('WRED Min Threshold for Drop Precedence 2.')
rlQosRedMaxDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('percent').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedMaxDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedMaxDp2.setDescription('WRED Max Threshold for Drop Precedence 2.')
rlQosRedProbDp2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedProbDp2.setStatus('current')
if mibBuilder.loadTexts: rlQosRedProbDp2.setDescription('WRED probability for Drop Precedence 2.')
rlQosRedQweight = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRedQweight.setStatus('current')
if mibBuilder.loadTexts: rlQosRedQweight.setDescription('Q factor for WRED.')
rlQosIfprofileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 14, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosIfprofileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosIfprofileStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosDscpMutationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 15), )
if mibBuilder.loadTexts: rlQosDscpMutationTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpMutationTable.setDescription('This table specifies The DSCP Mutation table')
rlQosDscpMutationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 15, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosOldDscp"))
if mibBuilder.loadTexts: rlQosDscpMutationEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpMutationEntry.setDescription('Each entry in this table describes the new DSCP for the packet. The index is Old DSCP represent by rlQosOldDscp')
rlQosOldDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 15, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosOldDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosOldDscp.setDescription('Old DSCP.')
rlQosNewDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosNewDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosNewDscp.setDescription('New DSCP.')
rlQosDscpRemarkTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 16), )
if mibBuilder.loadTexts: rlQosDscpRemarkTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpRemarkTable.setDescription('This table specifies The DSCP Remark table')
rlQosDscpRemarkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 16, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosRmOldDscp"))
if mibBuilder.loadTexts: rlQosDscpRemarkEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpRemarkEntry.setDescription('Each entry in this table describes the new DSCP for the packet. The index is Old DSCP represent by rlQosOldDscp')
rlQosRmOldDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 16, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosRmOldDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosRmOldDscp.setDescription('Old DSCP.')
rlQosRmNewDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 16, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRmNewDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosRmNewDscp.setDescription('Specifies new DSCP in the violation action.')
rlQosRmNewExceedDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosRmNewExceedDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosRmNewExceedDscp.setDescription('Specifies new DSCP in the exceed action.')
rlQosCosQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 17), )
if mibBuilder.loadTexts: rlQosCosQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueTable.setDescription('This table specifies The Cos to queue map table')
rlQosCosQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 17, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosCosIndex"))
if mibBuilder.loadTexts: rlQosCosQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueEntry.setDescription('Each entry in this table describes queue ID. The index is CoS represent by rlQosCosIndex')
rlQosCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 17, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: rlQosCosIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosCosIndex.setDescription('CoS value (0-7).')
rlQosCosQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 17, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCosQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueId.setDescription('Queue ID.')
rlQosDscpQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 18), )
if mibBuilder.loadTexts: rlQosDscpQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueTable.setDescription('This table specifies The DSCP to Queue map table')
rlQosDscpQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 18, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscpIndex"))
if mibBuilder.loadTexts: rlQosDscpQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueEntry.setDescription('Each entry in this table describes The Queue Number. The index is DSCP represent by rlQosDscpIndex')
rlQosDscpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosDscpIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpIndex.setDescription('DSCP value.')
rlQosQueueNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueNum.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueNum.setDescription('Queue Number.')
rlQosTcpPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 19), )
if mibBuilder.loadTexts: rlQosTcpPortQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueTable.setDescription('This table specifies TCP Port to Queue map table')
rlQosTcpPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 19, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosTcpPort"))
if mibBuilder.loadTexts: rlQosTcpPortQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueEntry.setDescription('Each entry in this table describes The Queue Number. The index is TCP/UDP port represent by rlQosTcpUdpPort')
rlQosTcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosTcpPort.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPort.setDescription('TCP port number.')
rlQosTcpQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTcpQueueValue.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpQueueValue.setDescription('Queue Number.')
rlQosTcpPortQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 19, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTcpPortQueueStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosTcpPortQueueStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosUdpPortQueueTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 20), )
if mibBuilder.loadTexts: rlQosUdpPortQueueTable.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueTable.setDescription('This table specifies UDP Port to Queue map table')
rlQosUdpPortQueueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 20, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosUdpPort"))
if mibBuilder.loadTexts: rlQosUdpPortQueueEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueEntry.setDescription('Each entry in this table describes The Queue Number. The index is UDP port represent by rlQosTcpUdpPort')
rlQosUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosUdpPort.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPort.setDescription('UDP port number.')
rlQosUdpQueueValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosUdpQueueValue.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpQueueValue.setDescription('Queue value.')
rlQosUdpPortQueueStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 20, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosUdpPortQueueStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosUdpPortQueueStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosEfManageTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 21), )
if mibBuilder.loadTexts: rlQosEfManageTable.setStatus('current')
if mibBuilder.loadTexts: rlQosEfManageTable.setDescription('This table specifies UDP Port to DSCP map table')
rlQosEfManageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 21, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosEfQueueId"))
if mibBuilder.loadTexts: rlQosEfManageEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosEfManageEntry.setDescription('This Table describes The EF management for the system. The index is UDP port represent by rlQosEfQueueId')
rlQosEfQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: rlQosEfQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosEfQueueId.setDescription('Queue-ID.')
rlQosEfState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 2), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosEfState.setStatus('current')
if mibBuilder.loadTexts: rlQosEfState.setDescription('Enable/disable')
rlQosEfPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 21, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosEfPriority.setStatus('current')
if mibBuilder.loadTexts: rlQosEfPriority.setDescription('The priority of the queue')
rlQosQueueProfileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 22), )
if mibBuilder.loadTexts: rlQosQueueProfileTable.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileTable.setDescription('This table describes the queue managment profiles ')
rlQosQueueProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 22, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQueueProfileName"))
if mibBuilder.loadTexts: rlQosQueueProfileEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileEntry.setDescription('Each entry in this table describes The queue managment profile Value. The index is profile name represent by rlQueueProfileName')
rlQueueProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlQueueProfileName.setStatus('current')
if mibBuilder.loadTexts: rlQueueProfileName.setDescription('Profile name for the Queue profile.')
rlQosTypeQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 2), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue1.setDescription('EF or WRR')
rlQosValueQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue1.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 4), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue2.setDescription('EF or WRR')
rlQosValueQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue2.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 6), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue3.setDescription('EF or WRR')
rlQosValueQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue3.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 8), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue4.setDescription('EF or WRR')
rlQosValueQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue4.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 10), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue5.setDescription('EF or WRR')
rlQosValueQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue5.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 12), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue6.setDescription('EF or WRR')
rlQosValueQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue6.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 14), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue7.setDescription('EF or WRR')
rlQosValueQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue7.setDescription('for EF read-only for wrr the weight')
rlQosTypeQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 16), QueueType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosTypeQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosTypeQueue8.setDescription('EF or WRR')
rlQosValueQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosValueQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosValueQueue8.setDescription('for EF read-only for wrr the weight')
rlQosQueueProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueProfileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueProfileStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosNumOfIfConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 22, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosNumOfIfConnections.setStatus('current')
if mibBuilder.loadTexts: rlQosNumOfIfConnections.setDescription('how many time this entry connected to the if policy table')
rlQosQueueShapeProfileTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 23), )
if mibBuilder.loadTexts: rlQosQueueShapeProfileTable.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileTable.setDescription('This table specifies the queue shaper profile')
rlQosQueueShapeProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 23, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosQueueShapeIndex"))
if mibBuilder.loadTexts: rlQosQueueShapeProfileEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileEntry.setDescription('Each entry in this table describes The shaper profile for all queues. The index sequencial index represent by rlQosQueueShapeIndex')
rlQosQueueShapeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosQueueShapeIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeIndex.setDescription('Profile Index.')
rlQosCirQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue1.setDescription('CIR for Queue1 0 for not active')
rlQosCbsQueue1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue1.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue1.setDescription('CBS for Queue1 0 for not active')
rlQosCirQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue2.setDescription('CIR for Queue2 0 for not active')
rlQosCbsQueue2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue2.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue2.setDescription('CBS for Queue2 0 for not active')
rlQosCirQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue3.setDescription('CIR for Queue3 0 for not active')
rlQosCbsQueue3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue3.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue3.setDescription('CBS for Queue3 0 for not active')
rlQosCirQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue4.setDescription('CIR for Queue4 0 for not active')
rlQosCbsQueue4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue4.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue4.setDescription('CBS for Queue4 0 for not active')
rlQosCirQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue5.setDescription('CIR for Queue5 0 for not active')
rlQosCbsQueue5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue5.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue5.setDescription('CBS for Queue5 0 for not active')
rlQosCirQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue6.setDescription('CIR for Queue6 0 for not active')
rlQosCbsQueue6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue6.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue6.setDescription('CBS for Queue6 0 for not active')
rlQosCirQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue7.setDescription('CIR for Queue7 0 for not active')
rlQosCbsQueue7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue7.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue7.setDescription('CBS for Queue7 0 for not active')
rlQosCirQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCirQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosCirQueue8.setDescription('CIR for Queue8 0 for not active')
rlQosCbsQueue8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosCbsQueue8.setStatus('current')
if mibBuilder.loadTexts: rlQosCbsQueue8.setDescription('CBS for Queue8 0 for not active')
rlQosQueueShapeProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 23, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosQueueShapeProfileStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosQueueShapeProfileStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAclCounterTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 24), )
if mibBuilder.loadTexts: rlQosAclCounterTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterTable.setDescription('The table is used to show statistics for ACL applied on an interface.')
rlQosAclCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 24, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterInterface"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterAclIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAclCounterAceIndex"))
if mibBuilder.loadTexts: rlQosAclCounterEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterEntry.setDescription('This entry shows value of conter for a particular ACE of an ACL.')
rlQosAclCounterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterInterface.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterInterface.setDescription('Interface Index on which ACL is applied.')
rlQosAclCounterAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterAclIndex.setDescription('Index of ACL, which was applied on the IfIndex.')
rlQosAclCounterAceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterAceIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterAceIndex.setDescription('Index of ACE, which is belong to an ACL.')
rlQosAclCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 24, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAclCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosAclCounterValue.setDescription('The value of the ACE counter.')
rlQosFreeIndexesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 25), )
if mibBuilder.loadTexts: rlQosFreeIndexesTable.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesTable.setDescription("The table is used to get free indexes of tables to create new entries. The algorithm for free indexes depends on table's type: Tuple table - first free index. Offset table - first free index. ACE table - last used index + ACE indexes delta. ACL table - first free index. Class Map table - last used index + Class Map indexes delta. Policy Map table - first free index. Policer Table - first free index. The ACE indexes delta and Class Map indexes delta are used to supply QoS MIB user easy insert entry capabilities. Values of these deltas depend on the MIB implementation. The 'Get and increment' approach is used in all cases. ")
rlQosFreeIndexesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 25, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosFreeIndexesTableId"))
if mibBuilder.loadTexts: rlQosFreeIndexesEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesEntry.setDescription('The entry is used to get free index for particular table.')
rlQosFreeIndexesTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 25, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("tuple", 1), ("offset", 2), ("ace", 3), ("acl", 4), ("class", 5), ("policy", 6), ("policer", 7), ("shaper", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosFreeIndexesTableId.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesTableId.setDescription('Identification of the table, for which free index is retrieved.')
rlQosFreeIndexesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 25, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosFreeIndexesValue.setStatus('current')
if mibBuilder.loadTexts: rlQosFreeIndexesValue.setDescription('Free index for table. 0 means no free entries.')
rlQosNamesToIndexesTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 26), )
if mibBuilder.loadTexts: rlQosNamesToIndexesTable.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesTable.setDescription('The table is used to get the ACL,Class-Map and Policy-Map indexes from the name.')
rlQosNamesToIndexesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 26, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosNamesToIndexesTableId"), (0, "RADLAN-QOS-CLI-MIB", "rlQosNamesToIndexesName"))
if mibBuilder.loadTexts: rlQosNamesToIndexesEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosNamesToIndexesTableId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("acl", 1), ("class", 2), ("policy", 3), ("policer", 4))))
if mibBuilder.loadTexts: rlQosNamesToIndexesTableId.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesTableId.setDescription('Identification of the table, for which the index is retrieved.')
rlQosNamesToIndexesName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: rlQosNamesToIndexesName.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesName.setDescription('The name of the entry')
rlQosNamesToIndexesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 26, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosNamesToIndexesValue.setStatus('current')
if mibBuilder.loadTexts: rlQosNamesToIndexesValue.setDescription('the index for table')
rlQosStackControlQueue = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosStackControlQueue.setStatus('current')
if mibBuilder.loadTexts: rlQosStackControlQueue.setDescription('This scalar object defines queue ID, which is used for stack control information transfer. For standalone systems the scalar value equals 0. This scalar object can be used for warning messages when users assign a QoS map item, or a Class to the stack control queue.')
rlQosStackControlCos = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosStackControlCos.setStatus('current')
if mibBuilder.loadTexts: rlQosStackControlCos.setDescription('This scalar object defines CoS (VPT), which is used for stack control information transfer. For standalone systems the scalar value equals 8 (not valid for VPT). This scalar object can be used for warning messages when users assign a stack control CoS to a non-stacking control queue.')
rlQosCosQueueDefaultMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 29), )
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapTable.setDescription('The table is used to set default 802.1p map (vpt to queue)')
rlQosCosQueueDefaultMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 29, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosCosQueueDefaultMapVpt"))
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosCosQueueDefaultMapVpt = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 29, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapVpt.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapVpt.setDescription('vlan priority tag , 3 bits of priority which determine the service class.')
rlQosCosQueueDefaultMapQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 29, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosCosQueueDefaultMapQueueId.setDescription('the queue id vary from the first queue id to Max Number of queues supported')
rlQosPredefBlockAclTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 30), )
if mibBuilder.loadTexts: rlQosPredefBlockAclTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclTable.setDescription("The table is used apply predefined ACLs to interfaces. Predefined ACLs is ACL to filter particular protocol or protocol's family. These ACL may operate simultaneously with IP and MAC ACLs.")
rlQosPredefBlockAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 30, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPredefBlockAclIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosPredefBlockAclIfType"))
if mibBuilder.loadTexts: rlQosPredefBlockAclEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclEntry.setDescription('The entry is used to apply predefined ACLs to the interface.')
rlQosPredefBlockAclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: rlQosPredefBlockAclIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclIfIndex.setDescription('IfIndex of port/trunk or VLAN tag of VLAN on which predefined ACLa will be configured.')
rlQosPredefBlockAclIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 2), InterfaceType())
if mibBuilder.loadTexts: rlQosPredefBlockAclIfType.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclIfType.setDescription('Interface Type(vlan/port).')
rlQosPredefBlockAclMask = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPredefBlockAclMask.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclMask.setDescription('This bitmap defines predefined ACL which are applied on an interface. The table below defines bitmasks for supported predefined ACL. Protocol/Family bitmask Description ===================================================== LLC NetBuei/NetBios 0x01 ACL filters out LLC encapsulated NetBuei/NetBios frames IP NetBuei/NetBios 0x02 ACL filters out IP encapsulated NetBuei/NetBios frames ')
rlQosPredefBlockAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 30, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPredefBlockAclStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPredefBlockAclStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAceTidxTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 31), )
if mibBuilder.loadTexts: rlQosAceTidxTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTable.setDescription('This table specifies ACE table with two index information')
rlQosAceTidxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 31, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosAceTidxAclIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosAceTidxIndex"))
if mibBuilder.loadTexts: rlQosAceTidxEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxEntry.setDescription("Each entry in this table describes one Classifier Element. The information includes: Action the ACE's Type the up to 11 tuples pointers. The index is sequential integer represent by rlQosAceTidxAclIndex ACL index and rlQosAceTidxIndex ACE index")
rlQosAceTidxAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosAceTidxAclIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAclIndex.setDescription('An arbitrary incremental Index for the ACL ACE connection.')
rlQosAceTidxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 2), Integer32())
if mibBuilder.loadTexts: rlQosAceTidxIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxIndex.setDescription('An arbitrary incremental Index for the ACE table.')
rlQosAceTidxAction = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 3), AceActionType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxAction.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAction.setDescription('ACE Action to take.')
rlQosAceTidxType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 4), AceObjectType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxType.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxType.setDescription('ACE Type')
rlQosAceTidxTuple1 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 5), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple1.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple1.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple2 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple2.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple2.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple3 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple3.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple3.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple4 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple4.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple4.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple5 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple5.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple5.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple6 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 10), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple6.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple6.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple7 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple7.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple7.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple8 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple8.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple8.setDescription('ACE Tuple pointer.')
rlQosAceTidxAccount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 13), BinaryStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxAccount.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxAccount.setDescription("ACE Accounting state. When set to 'enabled' than appropriate statistic's counter is provided for an ACE.")
rlQosAceTidxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosAceTidxTimeRange = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTimeRange.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTimeRange.setDescription('ACE time range name.')
rlQosAceTidxTimeRangeIsActive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAceTidxTimeRangeIsActive.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTimeRangeIsActive.setDescription('ACE time range is rule active state shows is ACE currently active or not.')
rlQosAceTidxTuple9 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple9.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple9.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple10 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple10.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple10.setDescription('ACE Tuple pointer.')
rlQosAceTidxTuple11 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 19), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxTuple11.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxTuple11.setDescription('ACE Tuple pointer.')
rlQosAceTidxActionDropType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 31, 1, 20), RlQosAceTidxActionDropType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosAceTidxActionDropType.setStatus('current')
if mibBuilder.loadTexts: rlQosAceTidxActionDropType.setDescription('This field is valid only if AceActionType is deny or deny-DisablePort.')
rlQosMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlQosMibVersion.setDescription("MIB's version, the current version is 11 1 - original version 2 - Add new two MIB's items. - rlQosAceTidxTable - Ace table with two indexes - rlQosMibVersion. Change the unit in Policer table from bps to kbps 3 - Add new MIB's value for Textual convention QosObjectMode 4 - Add new MIBs rlQosDscpQueueDefaultMapTable 5 - Add new advanced action : trustCosDscp 6 - Add vpt,ether-type,tcp-flags,icmp-type,icmp-code,igmp-type to ClassTupleType Add ip-ICMP,ip-IGMP To AceObjectType Add vpt,ethertype To ClassOffsetType 7- Add rlQosPortRateLimitStatus,rlQosCirPortRateLimit, rlQosCbsPortRateLimit to rlQosIfPolicyTable 8 - Add Added rlQosDscpToDpTable 9 - Add statistics 10 - Add innerVlan to ClassOffsetType And inner-vlan to ClassTupleType 11 - Added rlQosCPUSafeGuardEnable")
rlQosDscpQueueDefaultMapTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 33), )
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapTable.setDescription('The table is used to set default dscp to queue map')
rlQosDscpQueueDefaultMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 33, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscpQueueDefaultMapDscp"))
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapEntry.setDescription('The entry is used to get index form particular name and table type.')
rlQosDscpQueueDefaultMapDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 33, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapDscp.setDescription('dscp , 6 bits of priority which determine the service class.')
rlQosDscpQueueDefaultMapQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 33, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapQueueId.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpQueueDefaultMapQueueId.setDescription('the queue id vary from the first queue id to Max Number of queues supported')
rlQosDscpToDpTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 34), )
if mibBuilder.loadTexts: rlQosDscpToDpTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpToDpTable.setDescription('This table specifies The DSCP To Dp table')
rlQosDscpToDpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 34, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDscp"))
if mibBuilder.loadTexts: rlQosDscpToDpEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpToDpEntry.setDescription('Each entry in this table describes the new DP for the packet. The index is DSCP represent by rlQosDscp')
rlQosDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 34, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: rlQosDscp.setStatus('current')
if mibBuilder.loadTexts: rlQosDscp.setDescription('Packet DSCP.')
rlQosDp = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 34, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosDp.setStatus('current')
if mibBuilder.loadTexts: rlQosDp.setDescription('New DP.')
rlQosStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 88, 35))
rlQosPortPolicyStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 35, 1), )
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsTable.setDescription('This table specifies statistics counter for policies with specific actions ')
rlQosPortPolicyStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 35, 1, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlIfType"), (0, "RADLAN-QOS-CLI-MIB", "rlQosPortPolicyStatisticsCntrType"))
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsEntry.setDescription("Each entry in this table describes counter per port. The index is port represent by rlIfIndex. In each entry represents counter, it's type , it's size and whether it's enabled.")
rlQosPortPolicyStatisticsCntrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 1, 1, 1), StatisticsCntrType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCntrType.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCntrType.setDescription('Counter type.')
rlQosPortPolicyStatisticsCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 1, 1, 2), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCntrNumOfBits.setDescription('Counter size in bits.')
rlQosPortPolicyStatisticsEnableCounting = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsEnableCounting.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsEnableCounting.setDescription('Indication whether the counter is enabled.')
rlQosPortPolicyStatisticsCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosPortPolicyStatisticsCounterValue.setDescription('Counter value.')
rlQosSinglePolicerStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 35, 2), )
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsTable.setDescription('This table specifies statistics counters per QoS meter ')
rlQosSinglePolicerStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlIfIndex"), (0, "RADLAN-QOS-CLI-MIB", "rlQosPolicerIndex"))
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsEntry.setDescription('Each entry in this table describes counter per meter. The index is port represent by RlQosMeterStatisticsPort and RlQosMeterStatisticsPolicerPointer. In each entry there are fields representing whether the counter for the meter is enabled and two counters value - for in-profile bytes and for out-of-profile bytes. ')
rlQosSinglePolicerStatisticsInProfileCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsInProfileCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsInProfileCounterValue.setDescription(' Counter value of in profile traffic.')
rlQosSinglePolicerStatisticsInProfileCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1, 2), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsInProfileCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsInProfileCntrNumOfBits.setDescription('Counter size in bits for in profile counter.')
rlQosSinglePolicerStatisticsOutProfileCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsOutProfileCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsOutProfileCounterValue.setDescription(' Counter value of Out Profile traffic.')
rlQosSinglePolicerStatisticsOutProfileCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1, 4), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsOutProfileCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsOutProfileCntrNumOfBits.setDescription('Counter size in bits for out profile counter.')
rlQosSinglePolicerStatisticsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosSinglePolicerStatisticsStatus.setDescription('The status of a table entry. It is used to delete an entry from this table.')
rlQosAggregatePolicerStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 35, 3), )
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsTable.setDescription('This table specifies statistics counters per QoS aggregate meter ')
rlQosAggregatePolicerStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicerIndex"))
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsEntry.setDescription('Each entry in this table describes counter per aggregate meter. The index is rlQosPolicerIndex. In each entry there are fields representing whether the counter for the meter is enabled and three counters values - for green, yellow and red profiles bytes. ')
rlQosAggregatePolicerStatisticsInProfileCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsInProfileCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsInProfileCounterValue.setDescription('Counter value of In Profile amount of bytes.')
rlQosAggregatePolicerStatisticsInProfileCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1, 2), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsInProfileCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsInProfileCntrNumOfBits.setDescription('Counter size in bits for In Profile .')
rlQosAggregatePolicerStatisticsOutProfileCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsOutProfileCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsOutProfileCounterValue.setDescription(' Counter value of Out Profile amount of bytes.')
rlQosAggregatePolicerStatisticsOutProfileCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1, 4), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsOutProfileCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsOutProfileCntrNumOfBits.setDescription('Counter size in bits for Out Profile.')
rlQosAggregatePolicerStatisticsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosAggregatePolicerStatisticsStatus.setDescription('The status of a table entry. It is used to delete an entry from this table.')
rlQosOutQueueStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 35, 4), )
if mibBuilder.loadTexts: rlQosOutQueueStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsTable.setDescription('This table specifies statistics counters per VLAN/Port/Queue/Drop Precedence ')
rlQosOutQueueStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosOutQueueStatisticsCountrID"))
if mibBuilder.loadTexts: rlQosOutQueueStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsEntry.setDescription("Each entry in this table describes counter per any permutation of Port/VLAN/Queue/Drop Precedence. Each of the above can a group off 'All'. The index is port represent by rlQosOutQueueStatisticsCountrID. In each entry there are fields representing whether the counter is enabled and counters value. ")
rlQosOutQueueStatisticsCountrID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCountrID.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCountrID.setDescription('Counter id, the key of the table.')
rlQosOutQueueStatisticsIfIndexList = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsIfIndexList.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsIfIndexList.setDescription('Port for which the flow is counted.')
rlQosOutQueueStatisticsPortAll = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsPortAll.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsPortAll.setDescription('Indication for whether the port is configured as range of all the ports')
rlQosOutQueueStatisticsVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsVlan.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsVlan.setDescription('VLAN for which the flow is counted.')
rlQosOutQueueStatisticsVlanAll = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsVlanAll.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsVlanAll.setDescription('Indication for whether the VLAN is configured as range of all the VLANS')
rlQosOutQueueStatisticsQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsQueue.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsQueue.setDescription('Queue for which the flow is counted.')
rlQosOutQueueStatisticsQueueAll = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsQueueAll.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsQueueAll.setDescription('Indication for whether the queue is configured as range of all the Queues')
rlQosOutQueueStatisticsDP = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 8), StatisticsDPType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsDP.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsDP.setDescription('Drop Precedence for which the flow is counted.')
rlQosOutQueueStatisticsDPAll = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsDPAll.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsDPAll.setDescription('Indication for whether the DP is configured as range of all the DPs')
rlQosOutQueueStatisticsCounterTailDropValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCounterTailDropValue.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCounterTailDropValue.setDescription('The counter for tail dropped value.')
rlQosOutQueueStatisticsCounterAllValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCounterAllValue.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCounterAllValue.setDescription('The counter for all traffic value.')
rlQosOutQueueStatisticsCntrNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 12), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCntrNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsCntrNumOfBits.setDescription('Counter size in bits for the counter.')
rlQosOutQueueStatisticsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 4, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosOutQueueStatisticsStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosOutQueueStatisticsStatus.setDescription('The status of a table entry. It is used to delete an entry from this table.')
rlQosGlobalStatisticsCntrsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 35, 5), )
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsTable.setDescription('This table specifies statistics global counters for specific rules for all ports that they are connected to ')
rlQosGlobalStatisticsCntrsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 35, 5, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosGlobalStatisticsCntrsType"))
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsEntry.setDescription('Each entry represents global counter.')
rlQosGlobalStatisticsCntrsType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 5, 1, 1), StatisticsCntrType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsType.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsType.setDescription('Counter type.')
rlQosGlobalStatisticsCntrsNumOfBits = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 5, 1, 2), StatisticsCntrNumOfBitsType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsNumOfBits.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsNumOfBits.setDescription('Counter size in bits.')
rlQosGlobalStatisticsCntrsCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 5, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsCntrsCounterValue.setDescription('Counter value.')
rlQosGlobalStatisticsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 35, 5, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosGlobalStatisticsStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalStatisticsStatus.setDescription('The status of a table entry. It is used to delete an entry from this table.')
rlQosClearCounters = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 35, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosClearCounters.setStatus('current')
if mibBuilder.loadTexts: rlQosClearCounters.setDescription('This scalar indicates to clear all the counters.')
rlQosClassifierUtilization = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 88, 36))
rlQosClassifierUtilizationTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 36, 1), )
if mibBuilder.loadTexts: rlQosClassifierUtilizationTable.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationTable.setDescription('A table containing Classifier utilization information. Each row represents objects for a particular Unit present in this system.')
rlQosClassifierUtilizationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 36, 1, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosClassifierUtilizationUnitId"))
if mibBuilder.loadTexts: rlQosClassifierUtilizationEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationEntry.setDescription('A Single entry containing Classifier utilization information.')
rlQosClassifierUtilizationUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 36, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: rlQosClassifierUtilizationUnitId.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationUnitId.setDescription('The Unit ID of this Classifier. must be unique per entry. This is an index into the table.')
rlQosClassifierUtilizationPercent = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 36, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierUtilizationPercent.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationPercent.setDescription('The classifier utilization percentage. ')
rlQosClassifierUtilizationRulesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 36, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierUtilizationRulesNumber.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationRulesNumber.setDescription('The classifier utilization number of used rules, in short rules resolution.')
rlQosClassifierUtilizationFreeRulesNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 36, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierUtilizationFreeRulesNumber.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationFreeRulesNumber.setDescription('The classifier utilization number of not used yet rules on the unit, in short rules resolution.')
rlQosClassifierUtilizationSystem = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 36, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierUtilizationSystem.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierUtilizationSystem.setDescription('The system classifier utilization percentage. ')
rlQosClassifierRulesNumberUtilizationSystem = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 36, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierRulesNumberUtilizationSystem.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierRulesNumberUtilizationSystem.setDescription('Number of used rules per system, in short rule resolution ')
rlQosClassifierFreeRulesNumUtilizationSystem = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 36, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierFreeRulesNumUtilizationSystem.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierFreeRulesNumUtilizationSystem.setDescription('Number of free rules per system, in short rule resolution ')
rlQosClassifierMaxRulesNumberUtilizationSystem = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 36, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassifierMaxRulesNumberUtilizationSystem.setStatus('current')
if mibBuilder.loadTexts: rlQosClassifierMaxRulesNumberUtilizationSystem.setDescription('Maximum number of rules per system, in short rule resolution ')
rlQosPortToProfileMappingTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 37), )
if mibBuilder.loadTexts: rlQosPortToProfileMappingTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPortToProfileMappingTable.setDescription('This table maps between port and profile')
rlQosPortToProfileMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 37, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPort"))
if mibBuilder.loadTexts: rlQosPortToProfileMappingEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPortToProfileMappingEntry.setDescription('Each entry in this table describes mapping between port and profile')
rlQosPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 37, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPort.setStatus('current')
if mibBuilder.loadTexts: rlQosPort.setDescription('Port number')
rlQosProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 37, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosProfileName.setStatus('current')
if mibBuilder.loadTexts: rlQosProfileName.setDescription('profile')
rlQosCPUSafeGuardEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 38), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosCPUSafeGuardEnable.setStatus('current')
if mibBuilder.loadTexts: rlQosCPUSafeGuardEnable.setDescription('This scalar enables/disables CPU Safeguard.')
rlQosPolicyClassPriorityRefTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 39), )
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefTable.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefTable.setDescription('This table specifies The relationship between policy map to class map')
rlQosPolicyClassPriorityRefEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 39, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyClassPriorityRefPriority"), (0, "RADLAN-QOS-CLI-MIB", "rlQosPolicyClassPriorityRefClassPointer"))
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefEntry.setDescription('Each entry in this table describes the connection between class-map entry to policy map by using pointers. The index is Class map pointer represent by rlQosPolicyClassRefClassPointer. It is also specifies the class-map priotiry in the policy-map, which set the rules order within the policy-map')
rlQosPolicyClassPriorityRefPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 39, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefPriority.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefPriority.setDescription('The class-map priority within the policy-map')
rlQosPolicyClassPriorityRefClassPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 39, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefClassPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefClassPointer.setDescription('Class-map index Pointer')
rlQosPolicyClassPriorityRefPolicyPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 39, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefPolicyPointer.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefPolicyPointer.setDescription('Policy map index Pointer')
rlQosPolicyClassPriorityRefStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 39, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosPolicyClassPriorityRefStatus.setDescription('The status of a table entry. It is used to delete/Add an entry from this table.')
rlQosDenyAceStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 42), )
if mibBuilder.loadTexts: rlQosDenyAceStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsTable.setDescription('This table holds statistics for deny ACEs.')
rlQosDenyAceStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 42, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosDenyAceStatisticsIfIndex"))
if mibBuilder.loadTexts: rlQosDenyAceStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsEntry.setDescription('Each entry in this table holds number of hits for deny ACEs attached to specific Interface.')
rlQosDenyAceStatisticsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 42, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosDenyAceStatisticsIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsIfIndex.setDescription('Interface Index.')
rlQosDenyAceStatisticsIfCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 42, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDenyAceStatisticsIfCounter.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsIfCounter.setDescription('Number of hits on deny ACEs for this interface.')
rlQosDenyAceStatisticsOtherFlowCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosDenyAceStatisticsOtherFlowCounter.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsOtherFlowCounter.setDescription("Number of hits on deny ACEs for 'Other'-type flow.")
rlQosDenyAceStatisticsClearIfCounters = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 44), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosDenyAceStatisticsClearIfCounters.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsClearIfCounters.setDescription('Keeps ifIndex a port or trunk or vlan that its hit counters should be reset. If the value is 0 then all interfaces counters must be reset. ')
rlQosDenyAceStatisticsClearOtherFlowCounter = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosDenyAceStatisticsClearOtherFlowCounter.setStatus('current')
if mibBuilder.loadTexts: rlQosDenyAceStatisticsClearOtherFlowCounter.setDescription("This scalar indicates clearing 'Other'-type flow counter operation.")
rlQosModeGlobalCfgTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 46), )
if mibBuilder.loadTexts: rlQosModeGlobalCfgTable.setStatus('current')
if mibBuilder.loadTexts: rlQosModeGlobalCfgTable.setDescription('This table responsible to set the global qos mode configuration: qos mode, qos trust mode, and if port are trusted by default in qos advanced mode.')
rlQosModeGlobalCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 46, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosGlobalIndex"))
if mibBuilder.loadTexts: rlQosModeGlobalCfgEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosModeGlobalCfgEntry.setDescription('This table responsible to set the global qos mode configuration: qos mode, qos trust mode, and if port are trusted by default in qos advanced mode. Current implemnetaion assumes only one entry exist.')
rlQosGlobalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosGlobalIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalIndex.setDescription("Entry index - currenly only one entry can exist, indexes hard coded with value '1'.")
rlQosGlobalQoSMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 2), QosGlobalMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosGlobalQoSMode.setStatus('current')
if mibBuilder.loadTexts: rlQosGlobalQoSMode.setDescription('This field replaces deprecated scalar rlQosCliQosMode. Defines the global qos operation mode: disable, basic or advnaced. ')
rlQosBasicGlobalTrustMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 3), QosTrustMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosBasicGlobalTrustMode.setStatus('current')
if mibBuilder.loadTexts: rlQosBasicGlobalTrustMode.setDescription('This field replaces deprecated scalar rlQosCliBasicModeCfg. Defines the global qos trust operation mode relevant for qos basic mode. ')
rlQosAdvcGlobalTrustMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 4), QosTrustMode()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosAdvcGlobalTrustMode.setStatus('current')
if mibBuilder.loadTexts: rlQosAdvcGlobalTrustMode.setDescription('This field replaces deprecated scalar rlQosCliBasicModeCfg. Defines the global qos trust operation mode relevant for qos advanced mode. ')
rlQoSPortTrustAdvancedMode = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQoSPortTrustAdvancedMode.setStatus('current')
if mibBuilder.loadTexts: rlQoSPortTrustAdvancedMode.setDescription('This field specified whether ports are set to trused or not-trusted by default when switching to qos advanced mode.')
rlQosDscpMutationEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosDscpMutationEnable.setStatus('current')
if mibBuilder.loadTexts: rlQosDscpMutationEnable.setDescription('This field indicates if dscp to dscp mutation mode is enable. It can be set to true in the following terms: 1.rlQosGlobalTrustMode is in {dscp, vpt-dscp} ( rlQosGlobalQoSMode must be basic or advanced) 2.if rlQosGlobalQoSMode is advanced then rlQoSPortTrustAdvancedMode must be set to true.')
rlQosModeGlobalCfgStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 46, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQosModeGlobalCfgStatus.setStatus('current')
if mibBuilder.loadTexts: rlQosModeGlobalCfgStatus.setDescription('This status of entry action. In current implementation only one entry exist, therefor only status = active is acceptable.')
rlQosClassMapCounterTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 47), )
if mibBuilder.loadTexts: rlQosClassMapCounterTable.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapCounterTable.setDescription('The table is used to show statistics for ACL applied on an interface.')
rlQosClassMapCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 47, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosClassMapIndex"))
if mibBuilder.loadTexts: rlQosClassMapCounterEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapCounterEntry.setDescription('This entry returns the value of the class map counter. Entry is added/deleted to this MIB when counting is enabled/disabled on the class map. The counter is set to zero upon reading its value.')
rlQosClassMapCounterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 47, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosClassMapCounterValue.setStatus('current')
if mibBuilder.loadTexts: rlQosClassMapCounterValue.setDescription('This field returns the current value of the class map counter. ')
rlQosApplicationTrapIdTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 48), )
if mibBuilder.loadTexts: rlQosApplicationTrapIdTable.setStatus('current')
if mibBuilder.loadTexts: rlQosApplicationTrapIdTable.setDescription('The read only table is used to get the trapId assisated to application wants to use the trap action in the class map table')
rlQosApplicationTrapIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 48, 1), ).setIndexNames((1, "RADLAN-QOS-CLI-MIB", "rlQosApplicationName"))
if mibBuilder.loadTexts: rlQosApplicationTrapIdEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosApplicationTrapIdEntry.setDescription('This entry holds the trapId for application using the trap action in the class map table.')
rlQosApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 48, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: rlQosApplicationName.setStatus('current')
if mibBuilder.loadTexts: rlQosApplicationName.setDescription('This field represents the application name and traffic type. ')
rlQosApplicationTrapId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 48, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosApplicationTrapId.setStatus('current')
if mibBuilder.loadTexts: rlQosApplicationTrapId.setDescription('This field defines the trap id to be use in the class map entry. ')
rlQoSApplicationDefaultAction = MibScalar((1, 3, 6, 1, 4, 1, 89, 88, 49), RlQosApplicationDefaultActionType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlQoSApplicationDefaultAction.setStatus('current')
if mibBuilder.loadTexts: rlQoSApplicationDefaultAction.setDescription('This scalar specifies application-specific default action')
rlQosLogInputInterfacesAceMatchedTable = MibTable((1, 3, 6, 1, 4, 1, 89, 88, 50), )
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedTable.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedTable.setDescription('This table holds a list and of ACE matched log-input option interfaces.')
rlQosLogInputInterfacesAceMatchedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 88, 50, 1), ).setIndexNames((0, "RADLAN-QOS-CLI-MIB", "rlQosLogInputInterfacesAceMatchedIndex"))
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedEntry.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedEntry.setDescription('This table holds only one entry of port list and vlan list.')
rlQosLogInputInterfacesAceMatchedIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 1), Integer32())
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedIndex.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedIndex.setDescription("An index is entrie's sequence.")
rlQosLogInputInterfacesAceMatchedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 2), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedPorts.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedPorts.setDescription('the matched log-input ACEs port list')
rlQosLogInputInterfacesAceMatchedVlanList1to1024 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 3), VlanList1()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList1to1024.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList1to1024.setDescription('the matched log-input ACEs vlan list from 1 to 1024.')
rlQosLogInputInterfacesAceMatchedVlanList1025to2048 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 4), VlanList2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList1025to2048.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList1025to2048.setDescription('the matched log-input ACEs vlan list from 1025 to 2048.')
rlQosLogInputInterfacesAceMatchedVlanList2049to3072 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 5), VlanList3()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList2049to3072.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList2049to3072.setDescription('the matched log-input ACEs vlan list from 2049 to 3072.')
rlQosLogInputInterfacesAceMatchedVlanList3073to4094 = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 88, 50, 1, 6), VlanList4()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList3073to4094.setStatus('current')
if mibBuilder.loadTexts: rlQosLogInputInterfacesAceMatchedVlanList3073to4094.setDescription('the matched log-input ACEs vlan list from 3073 to 4094.')
mibBuilder.exportSymbols("RADLAN-QOS-CLI-MIB", rlQosOutQueueStatisticsDP=rlQosOutQueueStatisticsDP, rlQosGlobalStatisticsStatus=rlQosGlobalStatisticsStatus, rlQosValueQueue1=rlQosValueQueue1, rlQosStackControlQueue=rlQosStackControlQueue, rlQosPort=rlQosPort, rlQosClassMapMatch3=rlQosClassMapMatch3, rlQosAceTidxTuple2=rlQosAceTidxTuple2, rlQosAceTidxTuple7=rlQosAceTidxTuple7, rlQosTypeQueue6=rlQosTypeQueue6, rlQosGlobalStatisticsCntrsTable=rlQosGlobalStatisticsCntrsTable, rlQosTcpQueueValue=rlQosTcpQueueValue, rlQosEfPriority=rlQosEfPriority, rlQosTupleType=rlQosTupleType, rlQosOutQueueStatisticsCountrID=rlQosOutQueueStatisticsCountrID, rlQosCirQueue3=rlQosCirQueue3, rlQosSinglePolicerStatisticsEntry=rlQosSinglePolicerStatisticsEntry, rlQosPolicyClassRefEntry=rlQosPolicyClassRefEntry, rlQosPortRateLimitStatus=rlQosPortRateLimitStatus, rlQosQueueId=rlQosQueueId, rlQosTypeQueue4=rlQosTypeQueue4, rlQosQueueProfilePointer=rlQosQueueProfilePointer, rlQosOffsetTuplePointer=rlQosOffsetTuplePointer, rlQosSinglePolicerStatisticsTable=rlQosSinglePolicerStatisticsTable, rlQosCbsQueue7=rlQosCbsQueue7, rlQosEfQueueId=rlQosEfQueueId, rlQosCirQueue4=rlQosCirQueue4, rlQosAceTuple3=rlQosAceTuple3, rlQosPortPolicyStatisticsCntrType=rlQosPortPolicyStatisticsCntrType, PYSNMP_MODULE_ID=rlQosCliMib, rlQosPolicerType=rlQosPolicerType, rlQosTupleValue1=rlQosTupleValue1, AceObjectType=AceObjectType, rlQosCbsQueue6=rlQosCbsQueue6, rlQosDscpQueueDefaultMapTable=rlQosDscpQueueDefaultMapTable, rlQueueProfileName=rlQueueProfileName, rlQosCirQueue5=rlQosCirQueue5, rlQosAclAceRefAclPointer=rlQosAclAceRefAclPointer, rlQosOffsetStatus=rlQosOffsetStatus, rlQosLogInputInterfacesAceMatchedEntry=rlQosLogInputInterfacesAceMatchedEntry, rlQosClassifierUtilizationUnitId=rlQosClassifierUtilizationUnitId, rlQosRedMaxDp2=rlQosRedMaxDp2, rlQosAceTidxTable=rlQosAceTidxTable, rlQosAclStatus=rlQosAclStatus, RedirectAction=RedirectAction, rlQosAceTidxTuple11=rlQosAceTidxTuple11, rlQosDenyAceStatisticsIfIndex=rlQosDenyAceStatisticsIfIndex, BinaryStatus=BinaryStatus, rlQosValueQueue4=rlQosValueQueue4, rlQosLogInputInterfacesAceMatchedTable=rlQosLogInputInterfacesAceMatchedTable, rlQosAclIndex=rlQosAclIndex, rlQosAceEntry=rlQosAceEntry, rlQosAclCounterAclIndex=rlQosAclCounterAclIndex, rlQosCosQueueDefaultMapQueueId=rlQosCosQueueDefaultMapQueueId, rlQosSinglePolicerStatisticsOutProfileCntrNumOfBits=rlQosSinglePolicerStatisticsOutProfileCntrNumOfBits, rlQosPolicyMapStatus=rlQosPolicyMapStatus, rlQosClassifierUtilizationRulesNumber=rlQosClassifierUtilizationRulesNumber, rlQosBasicGlobalTrustMode=rlQosBasicGlobalTrustMode, rlQosCosQueueTable=rlQosCosQueueTable, rlQosAceTuple6=rlQosAceTuple6, rlQosAceTidxAction=rlQosAceTidxAction, rlQosPredefBlockAclTable=rlQosPredefBlockAclTable, rlQosPolicerCasPointerRemVal=rlQosPolicerCasPointerRemVal, rlQosCliBasicModeCfg=rlQosCliBasicModeCfg, rlQosApplicationTrapIdEntry=rlQosApplicationTrapIdEntry, rlQosDscpQueueDefaultMapQueueId=rlQosDscpQueueDefaultMapQueueId, rlQosPredefBlockAclIfType=rlQosPredefBlockAclIfType, rlQosAceStatus=rlQosAceStatus, rlQosClassMapEntry=rlQosClassMapEntry, rlQosValueQueue2=rlQosValueQueue2, rlQosClassMapMatch1=rlQosClassMapMatch1, rlQosFreeIndexesEntry=rlQosFreeIndexesEntry, rlQosCPUSafeGuardEnable=rlQosCPUSafeGuardEnable, rlQosLogInputInterfacesAceMatchedPorts=rlQosLogInputInterfacesAceMatchedPorts, rlQosPolicerEntry=rlQosPolicerEntry, rlQosIfPolicyMapPointerIn=rlQosIfPolicyMapPointerIn, rlQosIfProfilePointer=rlQosIfProfilePointer, rlQosAceTidxTuple3=rlQosAceTidxTuple3, rlQosAggregatePolicerStatisticsInProfileCounterValue=rlQosAggregatePolicerStatisticsInProfileCounterValue, rlQosClassMapRedirectAction=rlQosClassMapRedirectAction, rlQosAceTuple4=rlQosAceTuple4, rlQosIfIpv6AclIn=rlQosIfIpv6AclIn, rlQosDscpMutationEntry=rlQosDscpMutationEntry, rlQosDscpQueueEntry=rlQosDscpQueueEntry, rlQosLogInputInterfacesAceMatchedVlanList1025to2048=rlQosLogInputInterfacesAceMatchedVlanList1025to2048, rlQosAclTable=rlQosAclTable, rlQosAceTidxTuple1=rlQosAceTidxTuple1, AclObjectType=AclObjectType, rlQosDenyAceStatisticsOtherFlowCounter=rlQosDenyAceStatisticsOtherFlowCounter, rlQosEfManageEntry=rlQosEfManageEntry, rlQosSinglePolicerStatisticsInProfileCounterValue=rlQosSinglePolicerStatisticsInProfileCounterValue, rlQosApplicationName=rlQosApplicationName, rlQosValueQueue7=rlQosValueQueue7, rlQosAggregatePolicerStatisticsStatus=rlQosAggregatePolicerStatisticsStatus, rlQosDscpRemarkEntry=rlQosDscpRemarkEntry, rlQosCirQueue2=rlQosCirQueue2, rlQosUdpPortQueueStatus=rlQosUdpPortQueueStatus, rlQosAceTuple7=rlQosAceTuple7, rlQosDscpMutationTable=rlQosDscpMutationTable, StatisticsCntrNumOfBitsType=StatisticsCntrNumOfBitsType, ClassMapType=ClassMapType, rlQosValueQueue6=rlQosValueQueue6, rlQosOutQueueStatisticsTable=rlQosOutQueueStatisticsTable, rlQosClassMapAction=rlQosClassMapAction, rlQosPolicyClassRefPolicyPointer=rlQosPolicyClassRefPolicyPointer, rlQosPolicyClassPriorityRefClassPointer=rlQosPolicyClassPriorityRefClassPointer, rlQosQueueShapeProfilePointer=rlQosQueueShapeProfilePointer, rlQosClassMapName=rlQosClassMapName, rlQosPolicerName=rlQosPolicerName, rlQosClassMapNewVlan=rlQosClassMapNewVlan, rlQosPolicyClassRefStatus=rlQosPolicyClassRefStatus, rlQosUdpPortQueueEntry=rlQosUdpPortQueueEntry, rlQosPredefBlockAclMask=rlQosPredefBlockAclMask, rlQosPredefBlockAclEntry=rlQosPredefBlockAclEntry, rlQosCbsPortRateLimit=rlQosCbsPortRateLimit, rlQosAceAccount=rlQosAceAccount, rlQosClassMapTable=rlQosClassMapTable, rlQosPolicerStatus=rlQosPolicerStatus, ClassMapAction=ClassMapAction, rlQoSApplicationDefaultAction=rlQoSApplicationDefaultAction, rlQosOutQueueStatisticsPortAll=rlQosOutQueueStatisticsPortAll, rlQosOutQueueStatisticsStatus=rlQosOutQueueStatisticsStatus, rlQosClassMapCounterEntry=rlQosClassMapCounterEntry, rlQosCbsQueue8=rlQosCbsQueue8, rlQosCosQueueId=rlQosCosQueueId, rlQosGlobalIndex=rlQosGlobalIndex, rlQosClassMapIndex=rlQosClassMapIndex, AclDefaultAction=AclDefaultAction, rlQosAclAceRefEntry=rlQosAclAceRefEntry, rlQosClassMapDestInterface=rlQosClassMapDestInterface, rlQoSPortTrustAdvancedMode=rlQoSPortTrustAdvancedMode, rlQosPortPolicyStatisticsEntry=rlQosPortPolicyStatisticsEntry, rlQosQueueShapeProfileStatus=rlQosQueueShapeProfileStatus, rlQosOutQueueStatisticsDPAll=rlQosOutQueueStatisticsDPAll, rlQosDscp=rlQosDscp, rlQosOutQueueStatisticsIfIndexList=rlQosOutQueueStatisticsIfIndexList, rlQosAceTuple1=rlQosAceTuple1, rlQosAdvcGlobalTrustMode=rlQosAdvcGlobalTrustMode, rlQosIfPolicyTable=rlQosIfPolicyTable, rlQosCirPortShaper=rlQosCirPortShaper, rlQosClassMapCounterValue=rlQosClassMapCounterValue, rlQosClassMapMarkVlan=rlQosClassMapMarkVlan, rlQosClassifierUtilizationEntry=rlQosClassifierUtilizationEntry, rlQosAclDefaultAction=rlQosAclDefaultAction, rlQosAceTidxStatus=rlQosAceTidxStatus, rlQosAclEntry=rlQosAclEntry, rlQosCbsQueue3=rlQosCbsQueue3, rlQosAceTidxTuple4=rlQosAceTidxTuple4, rlQosGlobalStatisticsCntrsNumOfBits=rlQosGlobalStatisticsCntrsNumOfBits, rlQosModeGlobalCfgEntry=rlQosModeGlobalCfgEntry, rlQosIfprofileStatus=rlQosIfprofileStatus, rlQosCbsQueue5=rlQosCbsQueue5, rlQosPolicerPbs=rlQosPolicerPbs, rlQosDscpRemarkTable=rlQosDscpRemarkTable, rlQosTypeQueue7=rlQosTypeQueue7, rlIfProfileName=rlIfProfileName, rlQosTcpPortQueueEntry=rlQosTcpPortQueueEntry, rlIfIndex=rlIfIndex, rlQosRedMaxDp0=rlQosRedMaxDp0, rlQosIfAclIn=rlQosIfAclIn, rlQosClearCounters=rlQosClearCounters, rlQosAclCounterInterface=rlQosAclCounterInterface, rlQosRedMinDp1=rlQosRedMinDp1, rlQosLogInputInterfacesAceMatchedVlanList2049to3072=rlQosLogInputInterfacesAceMatchedVlanList2049to3072, rlQosOffsetType=rlQosOffsetType, rlQosAceTidxTuple6=rlQosAceTidxTuple6, rlQosPredefBlockAclStatus=rlQosPredefBlockAclStatus, rlQosPortShaperStatus=rlQosPortShaperStatus, rlQosAclAceRefTable=rlQosAclAceRefTable, rlQosSinglePolicerStatisticsOutProfileCounterValue=rlQosSinglePolicerStatisticsOutProfileCounterValue, rlQosTupleEntry=rlQosTupleEntry, rlQosPredefBlockAclIfIndex=rlQosPredefBlockAclIfIndex, rlQosTupleTable=rlQosTupleTable, rlQosClassifierUtilizationPercent=rlQosClassifierUtilizationPercent, rlQosPolicyMapTable=rlQosPolicyMapTable, rlQosQueueProfileStatus=rlQosQueueProfileStatus, rlQosOutQueueStatisticsCounterAllValue=rlQosOutQueueStatisticsCounterAllValue, rlQosDenyAceStatisticsTable=rlQosDenyAceStatisticsTable, rlQosTupleIndex=rlQosTupleIndex, rlQosRedMinDp0=rlQosRedMinDp0, rlQosPolicerPir=rlQosPolicerPir, rlQosClassMapTrapId=rlQosClassMapTrapId, rlQosAceTidxEntry=rlQosAceTidxEntry, InterfaceType=InterfaceType, rlQosPortPolicyStatisticsCntrNumOfBits=rlQosPortPolicyStatisticsCntrNumOfBits, rlQosAceAction=rlQosAceAction, rlQosAclCounterAceIndex=rlQosAclCounterAceIndex, rlQosMibVersion=rlQosMibVersion, rlQosAceTidxAccount=rlQosAceTidxAccount, rlQosTcpPortQueueTable=rlQosTcpPortQueueTable, rlIfType=rlIfType, rlQosTdThersholdDp0=rlQosTdThersholdDp0, rlQosNumOfIfConnections=rlQosNumOfIfConnections, rlQosOutQueueStatisticsVlanAll=rlQosOutQueueStatisticsVlanAll, rlQosValueQueue8=rlQosValueQueue8, ClassTupleType=ClassTupleType, rlQosRmNewExceedDscp=rlQosRmNewExceedDscp, rlQosAclType=rlQosAclType, rlQosStackControlCos=rlQosStackControlCos, rlQosTypeQueue5=rlQosTypeQueue5, rlQosAceTidxTimeRangeIsActive=rlQosAceTidxTimeRangeIsActive, rlQosDscpToDpEntry=rlQosDscpToDpEntry, rlQosAceTidxTuple10=rlQosAceTidxTuple10, rlQosAclNumOfAces=rlQosAclNumOfAces, rlQosIfTrustActive=rlQosIfTrustActive, rlQosModeGlobalCfgTable=rlQosModeGlobalCfgTable, rlQosAceTuple8=rlQosAceTuple8, rlQosNamesToIndexesTable=rlQosNamesToIndexesTable, rlQosLogInputInterfacesAceMatchedIndex=rlQosLogInputInterfacesAceMatchedIndex, rlQosPolicerCir=rlQosPolicerCir, rlQosRedMaxDp1=rlQosRedMaxDp1, rlQosOutQueueStatisticsQueueAll=rlQosOutQueueStatisticsQueueAll, rlQosCbsPortShaper=rlQosCbsPortShaper, rlQosClassifierUtilizationTable=rlQosClassifierUtilizationTable, rlQosOffsetValue=rlQosOffsetValue, rlQosAceTidxActionDropType=rlQosAceTidxActionDropType, RlQosApplicationDefaultActionType=RlQosApplicationDefaultActionType, rlQosAceTuple5=rlQosAceTuple5, rlQosAclCounterTable=rlQosAclCounterTable, rlQosOldDscp=rlQosOldDscp, rlQosCbsQueue4=rlQosCbsQueue4, rlQosModeGlobalCfgStatus=rlQosModeGlobalCfgStatus, rlQosNamesToIndexesValue=rlQosNamesToIndexesValue, rlQosClassifierFreeRulesNumUtilizationSystem=rlQosClassifierFreeRulesNumUtilizationSystem, rlQosDscpIndex=rlQosDscpIndex, rlQosIfAclOut=rlQosIfAclOut, rlQosClassMapMarkValue=rlQosClassMapMarkValue, rlQosDenyAceStatisticsIfCounter=rlQosDenyAceStatisticsIfCounter, rlQosPortPolicyStatisticsCounterValue=rlQosPortPolicyStatisticsCounterValue, rlQosPolicerPeakAction=rlQosPolicerPeakAction, rlQosNamesToIndexesEntry=rlQosNamesToIndexesEntry, rlQosPolicyClassRefClassPointer=rlQosPolicyClassRefClassPointer, rlQosAclDefaultActionOut=rlQosAclDefaultActionOut, rlQosDscpQueueDefaultMapEntry=rlQosDscpQueueDefaultMapEntry, rlQosClassMapStatus=rlQosClassMapStatus, rlQosRedMinDp2=rlQosRedMinDp2, rlQosStatistics=rlQosStatistics, rlQosRedProbDp0=rlQosRedProbDp0, rlQosTypeQueue1=rlQosTypeQueue1, MarkVlanAction=MarkVlanAction, rlQosMaxNumOfAce=rlQosMaxNumOfAce, AceActionType=AceActionType, rlQosOutQueueStatisticsCounterTailDropValue=rlQosOutQueueStatisticsCounterTailDropValue, rlQosOutQueueStatisticsEntry=rlQosOutQueueStatisticsEntry, rlQosPolicyClassPriorityRefPolicyPointer=rlQosPolicyClassPriorityRefPolicyPointer, rlQosDenyAceStatisticsClearOtherFlowCounter=rlQosDenyAceStatisticsClearOtherFlowCounter, rlQosPortPolicyStatisticsEnableCounting=rlQosPortPolicyStatisticsEnableCounting, rlQosClassMapTunnelIdx=rlQosClassMapTunnelIdx, rlQosNamesToIndexesTableId=rlQosNamesToIndexesTableId, rlQosIfProfileCfgTable=rlQosIfProfileCfgTable, rlQosGlobalStatisticsCntrsCounterValue=rlQosGlobalStatisticsCntrsCounterValue, rlQosAceType=rlQosAceType, rlQosOffsetMask=rlQosOffsetMask, rlQosAceTidxTuple9=rlQosAceTidxTuple9, rlQosAggregatePolicerStatisticsEntry=rlQosAggregatePolicerStatisticsEntry)
mibBuilder.exportSymbols("RADLAN-QOS-CLI-MIB", rlQosClassMapCounterTable=rlQosClassMapCounterTable, rlQosCosQueueDefaultMapVpt=rlQosCosQueueDefaultMapVpt, rlQosFreeIndexesValue=rlQosFreeIndexesValue, PolicerAction=PolicerAction, rlQosTypeQueue2=rlQosTypeQueue2, ClassOffsetType=ClassOffsetType, rlQosGlobalStatisticsCntrsEntry=rlQosGlobalStatisticsCntrsEntry, rlQosPortPolicyStatisticsTable=rlQosPortPolicyStatisticsTable, rlQosTcpPort=rlQosTcpPort, rlQosClassifierUtilizationSystem=rlQosClassifierUtilizationSystem, rlQosAggregatePolicerStatisticsTable=rlQosAggregatePolicerStatisticsTable, rlQosClassMapPolicer=rlQosClassMapPolicer, rlQosAceTidxType=rlQosAceTidxType, rlQosClassMapMatch2=rlQosClassMapMatch2, rlQosAceIndex=rlQosAceIndex, rlQosApplicationTrapIdTable=rlQosApplicationTrapIdTable, rlQosOffsetIndex=rlQosOffsetIndex, rlQosCosQueueEntry=rlQosCosQueueEntry, rlQosIfPolicyMapPointerOut=rlQosIfPolicyMapPointerOut, rlQosCbsQueue1=rlQosCbsQueue1, rlQosAclName=rlQosAclName, rlQosDenyAceStatisticsEntry=rlQosDenyAceStatisticsEntry, rlQosOffsetTable=rlQosOffsetTable, rlQosGlobalStatisticsCntrsType=rlQosGlobalStatisticsCntrsType, rlQosCirQueue6=rlQosCirQueue6, rlQosOutQueueStatisticsCntrNumOfBits=rlQosOutQueueStatisticsCntrNumOfBits, rlQosDscpQueueTable=rlQosDscpQueueTable, rlQosCirPortRateLimit=rlQosCirPortRateLimit, rlQosLogInputInterfacesAceMatchedVlanList1to1024=rlQosLogInputInterfacesAceMatchedVlanList1to1024, rlQosPolicyMapIndex=rlQosPolicyMapIndex, rlQosIfPolicerIn=rlQosIfPolicerIn, rlQosCosIndex=rlQosCosIndex, StatisticsCntrType=StatisticsCntrType, rlQosClassMapType=rlQosClassMapType, rlQosQueueProfileTable=rlQosQueueProfileTable, rlQosFreeIndexesTableId=rlQosFreeIndexesTableId, rlQosPolicerIndex=rlQosPolicerIndex, rlQosGlobalQoSMode=rlQosGlobalQoSMode, rlQosOffsetPattern=rlQosOffsetPattern, rlQosPolicyClassPriorityRefStatus=rlQosPolicyClassPriorityRefStatus, rlQosClassMapCounterEnable=rlQosClassMapCounterEnable, rlQosPolicyClassPriorityRefPriority=rlQosPolicyClassPriorityRefPriority, rlQosTcpPortQueueStatus=rlQosTcpPortQueueStatus, rlQosQueueShapeProfileEntry=rlQosQueueShapeProfileEntry, rlQosAclCounterValue=rlQosAclCounterValue, rlQosCirQueue7=rlQosCirQueue7, PolicerType=PolicerType, rlQosCliQosMode=rlQosCliQosMode, rlQosTypeQueue3=rlQosTypeQueue3, rlQosNewDscp=rlQosNewDscp, rlQosOffsetEntry=rlQosOffsetEntry, rlQosCosQueueDefaultMapTable=rlQosCosQueueDefaultMapTable, rlQosSinglePolicerStatisticsInProfileCntrNumOfBits=rlQosSinglePolicerStatisticsInProfileCntrNumOfBits, rlQosEfState=rlQosEfState, rlQosPolicerTable=rlQosPolicerTable, rlQosTdThersholdDp1=rlQosTdThersholdDp1, rlQosPolicyClassPriorityRefEntry=rlQosPolicyClassPriorityRefEntry, rlQosPolicerCbs=rlQosPolicerCbs, rlQosClassifierUtilizationFreeRulesNumber=rlQosClassifierUtilizationFreeRulesNumber, rlQosAggregatePolicerStatisticsInProfileCntrNumOfBits=rlQosAggregatePolicerStatisticsInProfileCntrNumOfBits, rlQosPortToProfileMappingTable=rlQosPortToProfileMappingTable, rlQosCirQueue1=rlQosCirQueue1, rlQosOutQueueStatisticsQueue=rlQosOutQueueStatisticsQueue, rlQosAceTidxTuple5=rlQosAceTidxTuple5, rlQosRedQweight=rlQosRedQweight, rlQosLogInputInterfacesAceMatchedVlanList3073to4094=rlQosLogInputInterfacesAceMatchedVlanList3073to4094, rlQosAceTidxIndex=rlQosAceTidxIndex, rlQosClassifierMaxRulesNumberUtilizationSystem=rlQosClassifierMaxRulesNumberUtilizationSystem, rlQosDp=rlQosDp, rlQosQueueProfileEntry=rlQosQueueProfileEntry, rlQosProfileName=rlQosProfileName, rlQosTupleValue2=rlQosTupleValue2, rlQosPolicyClassPriorityRefTable=rlQosPolicyClassPriorityRefTable, rlQosFreeIndexesTable=rlQosFreeIndexesTable, rlQosClassifierUtilization=rlQosClassifierUtilization, rlQosQueueShapeProfileTable=rlQosQueueShapeProfileTable, rlQosTypeQueue8=rlQosTypeQueue8, QosGlobalMode=QosGlobalMode, rlQosDscpMutationEnable=rlQosDscpMutationEnable, rlQosDscpToDpTable=rlQosDscpToDpTable, rlQosRedProbDp2=rlQosRedProbDp2, rlQosPolicyClassRefTable=rlQosPolicyClassRefTable, rlQosRedProbDp1=rlQosRedProbDp1, rlQosAclAceRefAcePointer=rlQosAclAceRefAcePointer, rlQosTdThersholdDp2=rlQosTdThersholdDp2, rlQosClassifierRulesNumberUtilizationSystem=rlQosClassifierRulesNumberUtilizationSystem, rlQosQueueShapeIndex=rlQosQueueShapeIndex, rlQosQueueNum=rlQosQueueNum, RlQosAceTidxActionDropType=RlQosAceTidxActionDropType, rlQosIfPolicyEntry=rlQosIfPolicyEntry, rlQosIfPolicyMapStatus=rlQosIfPolicyMapStatus, rlQosPolicyMapName=rlQosPolicyMapName, rlQosPolicyMapEntry=rlQosPolicyMapEntry, rlQosAceTidxTuple8=rlQosAceTidxTuple8, rlQosDscpQueueDefaultMapDscp=rlQosDscpQueueDefaultMapDscp, rlQosIfProfileCfgEntry=rlQosIfProfileCfgEntry, rlQosNamesToIndexesName=rlQosNamesToIndexesName, rlQosUdpPort=rlQosUdpPort, rlQosUdpPortQueueTable=rlQosUdpPortQueueTable, rlQosPolicerAction=rlQosPolicerAction, rlQosCirQueue8=rlQosCirQueue8, rlQosOutQueueStatisticsVlan=rlQosOutQueueStatisticsVlan, rlQosRmNewDscp=rlQosRmNewDscp, rlQosTupleStatus=rlQosTupleStatus, rlQosCbsQueue2=rlQosCbsQueue2, rlQosEfManageTable=rlQosEfManageTable, rlQosUdpQueueValue=rlQosUdpQueueValue, rlQosCosQueueDefaultMapEntry=rlQosCosQueueDefaultMapEntry, rlQosPortToProfileMappingEntry=rlQosPortToProfileMappingEntry, RlQosTimeBasedAclWeekPeriodicList=RlQosTimeBasedAclWeekPeriodicList, rlQosValueQueue5=rlQosValueQueue5, rlQosAceTuple2=rlQosAceTuple2, rlQosIfIpv6AclOut=rlQosIfIpv6AclOut, rlQosApplicationTrapId=rlQosApplicationTrapId, QueueType=QueueType, rlQosRmOldDscp=rlQosRmOldDscp, rlQosAclAceRefStatus=rlQosAclAceRefStatus, rlQosAggregatePolicerStatisticsOutProfileCntrNumOfBits=rlQosAggregatePolicerStatisticsOutProfileCntrNumOfBits, rlQosCliMib=rlQosCliMib, rlQosSinglePolicerStatisticsStatus=rlQosSinglePolicerStatisticsStatus, rlQosAceTable=rlQosAceTable, QosTrustMode=QosTrustMode, rlQosAceTidxTimeRange=rlQosAceTidxTimeRange, rlQosValueQueue3=rlQosValueQueue3, rlQosDenyAceStatisticsClearIfCounters=rlQosDenyAceStatisticsClearIfCounters, rlQosAclCounterEntry=rlQosAclCounterEntry, rlQosAceTidxAclIndex=rlQosAceTidxAclIndex, rlQosAggregatePolicerStatisticsOutProfileCounterValue=rlQosAggregatePolicerStatisticsOutProfileCounterValue)

#
# PySNMP MIB module MPLS-FTN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MPLS-FTN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:14:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
Dscp, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressType, InetPortNumber, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetPortNumber", "InetAddress")
mplsMIB, = mibBuilder.importSymbols("MPLS-TC-MIB", "mplsMIB")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Counter32, ObjectIdentity, ModuleIdentity, Counter64, MibIdentifier, Unsigned32, Gauge32, TimeTicks, Integer32, iso, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ObjectIdentity", "ModuleIdentity", "Counter64", "MibIdentifier", "Unsigned32", "Gauge32", "TimeTicks", "Integer32", "iso", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType")
TextualConvention, StorageType, DisplayString, RowStatus, RowPointer, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "StorageType", "DisplayString", "RowStatus", "RowPointer", "TimeStamp")
mplsFTNMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 9999, 5))
mplsFTNMIB.setRevisions(('2003-04-30 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mplsFTNMIB.setRevisionsDescriptions(('Initial version issued as part of RFC XXXX.',))
if mibBuilder.loadTexts: mplsFTNMIB.setLastUpdated('200304301200Z')
if mibBuilder.loadTexts: mplsFTNMIB.setOrganization('Multiprotocol Label Switching (MPLS) Working Group')
if mibBuilder.loadTexts: mplsFTNMIB.setContactInfo(' Thomas D. Nadeau Postal: Cisco Systems, Inc. 250 Apollo Drive Chelmsford, MA 01824 Tel: +1-978-244-3051 Email: tnadeau@cisco.com Cheenu Srinivasan Postal: Parama Networks, Inc. 1030 Broad Street Shrewsbury, NJ 07702 Tel: +1-732-544-9120 x731 Email: cheenu@paramanet.com Arun Viswanathan Postal: Force10 Networks, Inc. 1440 McCarthy Blvd Milpitas, CA 95035 Tel: +1-408-571-3516 Email: arun@force10networks.com IETF MPLS Working Group email: mpls@uu.net')
if mibBuilder.loadTexts: mplsFTNMIB.setDescription('Copyright (C) The Internet Society (2003). This version of this MIB module is part of RFC xxxx; see the RFC itself for full legal notices. This MIB module contains managed object definitions for specifying FEC to NHLFE (FTN) mappings and corresponding performance for MPLS.')
class MplsFTNEntryIndex(TextualConvention, Unsigned32):
    description = 'Index for an entry in mplsFTNTable.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class MplsFTNEntryIndexOrZero(TextualConvention, Unsigned32):
    description = 'Index for an entry in mplsFTNTable or the special value zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero might include situations when none or all entries in mplsFTNTable need to be referenced.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 4294967295)

mplsFTNNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 9999, 5, 0))
mplsFTNObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1))
mplsFTNConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2))
mplsFTNIndexNext = MibScalar((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 1), MplsFTNEntryIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNIndexNext.setStatus('current')
if mibBuilder.loadTexts: mplsFTNIndexNext.setDescription('This object contains the next available valid value to be used for mplsFTNIndex when creating entries in the mplsFTNTable. When creating a new conceptual row (configuration entry) in mplsFTNTable with an SNMP SET operation the command generator (Network Management Application) must first issue a management protocol retrieval operation to obtain the current value of this object. If the Command Responder (agent) does not wish to allow creation of more entries in mplsFTNTable, possibly because of resource exhaustion, this object MUST return a value of 0. If a non-zero value is returned it must determine whether the value is indeed still unused since two Network Management Applications may attempt to create a row simultaneously and use the same value. If it is currently unused and the SET succeeds, the agent MUST change the value of this object to a currently unused non-zero value (according to an implementation specific algorithm) or zero (if no further row creation will be permitted). If the value is in use, however, the SET fails and the Network Management Application must then reread this object to obtain a new usable value.')
mplsFTNTableLastChanged = MibScalar((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsFTNTableLastChanged.setDescription('Indicates the last time an entry was added, deleted or modified in mplsFTNTable. Management stations should consult this object to determine if mplsFTNTable requires their attention.')
mplsFTNTable = MibTable((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3), )
if mibBuilder.loadTexts: mplsFTNTable.setReference('Srinivasan, C., A. Viswanathan, and T. Nadeau, MPLS Label Switch Router Management Information Base, draft- ietf-mpls-lsr-mib-09.txt Srinivasan, C., A. Viswanathan, and T. Nadeau, MPLS Traffic Engineering Management Information Base, draft- ietf-mpls-te-mib-09.txt')
if mibBuilder.loadTexts: mplsFTNTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNTable.setDescription('This table contains the currently defined FTN entries. This table allows FEC to NHLFE mappings to be specified. Each entry in this table defines a rule to be applied to incoming packets (on interfaces that the FTN entry is activated on using mplsFTNMapTable) and an action to be taken on matching packets (mplsFTNActionPointer). This table provides a 5-tuple matching and allows addresses, port ranges and the exp bits to be specified. The action pointer points at either an mplsXCEntry in MPLS-LSR MIB when the NHLFE entry is a non-TE LSP, or it points at an mplsTunnelEntry in the MPLS-TE MIB when the NHLFE is an originating TE tunnel.')
mplsFTNEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1), ).setIndexNames((0, "MPLS-FTN-MIB", "mplsFTNIndex"))
if mibBuilder.loadTexts: mplsFTNEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNEntry.setDescription('Each entry represents one FTN entry which defines a rule to compare incoming packets with and an action to be taken on matching packets.')
mplsFTNIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 1), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNIndex.setDescription('This is the unique index for a conceptual row in mplsFTNTable. To create a new conceptual row in mplsFTNTable a Network Management Application SHOULD retrieve the current value of mplsFTNIndexNext to determine the next valid available value of mplsFTNIndex.')
mplsFTNRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFTNRowStatus.setDescription("Used for controlling the creation and deletion of this row. All writeable objects in this row may be modified at any time. If a Network Management Application attempts to delete a conceptual row by setting this object to 'destroy' and there are one or more entries in mplsFTNMapTable pointing to the row (i.e. when mplsFTNIndex of the conceptual row being deleted is equal to mplsFTNMapCurrIndex for one or more entries in mplsFTNMapTable), the agent MUST also destroy the corresponding entries in mplsFTNMapTable.")
mplsFTNDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDescr.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDescr.setDescription('The description of this FTN entry. Since the index for this table has no particular significance or meaning, this object should contain some meaningful text that an operator could use to further distinguish entries in this table.')
mplsFTNMask = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 4), Bits().clone(namedValues=NamedValues(("sourceAddr", 0), ("destAddr", 1), ("sourcePort", 2), ("destPort", 3), ("protocol", 4), ("dscp", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMask.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMask.setDescription('This bit map indicates which of the fields described next, namely source address range, destination address range, source port range, destination port range, IPv4 Protocol field or IPv6 next-header field and Differentiated Services Code Point (DSCP) is active for this FTN entry. If a particular bit is set to zero then the corresponding field in the packet MUST be ignored for comparison purposes.')
mplsFTNAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 5), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNAddrType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNAddrType.setDescription('This object determines the type of address contained in the source and destination address objects (mplsFTNSourceAddrMin, mplsFTNSourceAddrMax, mplsFTNDestAddrMin and mplsFTNDestAddrMax) of a conceptual row. This object MUST NOT be set to unknown(0) when mplsFTNMask has bit positions sourceAddr(0) or destAddr(1) set to one. When both these bit positions of mplsFTNMask are set to zero the value of mplsFTNAddrType SHOULD be set to unknown(0) and the corresponding source and destination address objects SHOULD be set to zero-length strings.')
mplsFTNSourceAddrMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 6), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourceAddrMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourceAddrMin.setDescription('The lower end of the source address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNSourceAddrMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 7), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourceAddrMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourceAddrMax.setDescription('The upper end of the source address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNDestAddrMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 8), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestAddrMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestAddrMin.setDescription('The lower end of the destination address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNDestAddrMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 9), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestAddrMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestAddrMax.setDescription('The higher end of the destination address range. The type of this object is determined by the corresponding mplsFTNAddrType object.')
mplsFTNSourcePortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 10), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourcePortMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourcePortMin.setDescription('The lower end of the source port range.')
mplsFTNSourcePortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 11), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNSourcePortMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNSourcePortMax.setDescription('The higher end of the source port range ')
mplsFTNDestPortMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestPortMin.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestPortMin.setDescription('The lower end of the destination port range.')
mplsFTNDestPortMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 13), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDestPortMax.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDestPortMax.setDescription('The higher end of the destination port range.')
mplsFTNProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNProtocol.setStatus('current')
if mibBuilder.loadTexts: mplsFTNProtocol.setDescription('The contents of the IPv4 Protocol field or IPv6 next- header field.')
mplsFTNDscp = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 15), Dscp()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNDscp.setReference('Nichols, K., Blake, S., Baker, F. and D. Black, Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers, RFC 2474, December 1998.')
if mibBuilder.loadTexts: mplsFTNDscp.setStatus('current')
if mibBuilder.loadTexts: mplsFTNDscp.setDescription('The contents of the DSCP field.')
mplsFTNActionType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redirectLsp", 1), ("redirectTunnel", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNActionType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNActionType.setDescription('The type of action to be taken on packets matching this FTN entry.')
mplsFTNActionPointer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 17), RowPointer()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNActionPointer.setStatus('current')
if mibBuilder.loadTexts: mplsFTNActionPointer.setDescription('If mplsFTNActionType is redirectLsp(2), then this object MUST contain zeroDotZero or point to a instance of mplsXCEntry indicating the LSP to redirect matching packets to. If mplsFTNActionType is redirectTunnel(3), then this object MUST contain zeroDotZero or point to a instance of mplsTunnelEntry indicating the MPLS TE tunnel to redirect matching packets to. If this object points to a conceptual row instance in a table consistent with mplsFTNActionType but this instance does not currently exist then no action will be taken on packets matching such an FTN entry till this instance comes into existence. If this object contains zeroDotZero then no action will be taken on packets matching such an FTN entry till it is populated with a valid pointer consistent with the value of mplsFTNActionType as explained above.')
mplsFTNStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 3, 1, 18), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNStorageType.setDescription("The storage type for this FTN entry. Conceptual rows having the value 'permanent' need not allow write- access to any columnar objects in the row.")
mplsFTNMapTableLastChanged = MibScalar((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNMapTableLastChanged.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapTableLastChanged.setDescription('Indicates the last time an entry was added, deleted or modified in mplsFTNMapTable. Management stations should consult this object to determine if the table requires their attention.')
mplsFTNMapTable = MibTable((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5), )
if mibBuilder.loadTexts: mplsFTNMapTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapTable.setDescription("This table contains objects for mapping previously defined entries in mplsFTNTable to interfaces. This table provides the capability to activate or map FTN entries defined in mplsFTNTable to specific interfaces in the system. FTN entries are compared with incoming packets in the order in which they are applied on an interface. For this reason, this table provides a mechanism to 'insert' an FTN entry between two existing FTN entries already applied on an interface. Using this linked-list structure, one can retrieve FTN entries in the order of application on a per-interface basis as follows: - To determine the first FTN entry on an interface with index ifIndex perform a GETNEXT retrieval operation on mplsFTNMapIndex.ifIndex.0.0; the returned object, if one exists, is (say) mplsFTNMapIndex.ifIndex.0.n. Then the index of the first FTN entry applied on this interface is n. - To determine the FTN entry applied after the one indexed by n perform a GETNEXT retrieval operation on mplsFTNMapIndex.ifIndex.n.0; the returned object, if one exists, is (say) mplsFTNMapIndex.ifIndex.n.m. Then the index of the next FTN entry applied on this interface is m. Use the above steps to retrieve all the applied FTN entries on a per-interface basis in application order. Note that the number of retrieval operations is the same as the number of applied FTN entries (i.e. the minimum number of GETNEXT operations needed using any indexing scheme).")
mplsFTNMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1), ).setIndexNames((0, "MPLS-FTN-MIB", "mplsFTNMapIndex"), (0, "MPLS-FTN-MIB", "mplsFTNMapPrevIndex"), (0, "MPLS-FTN-MIB", "mplsFTNMapCurrIndex"))
if mibBuilder.loadTexts: mplsFTNMapEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapEntry.setDescription('Each entry indicates the application of a particular entry as defined in mplsFTNTable on an interface. The order of application of FTN entries on an interface is the order in which they will be compared against incoming packets for a match. Each entry of this table is indexed by the interface index that the FTN entry is applied to, with the value 0 representing all interfaces, the index of the previous FTN entry applied on the interface and the index of the current FTN entry. This linked-list indexing style structure allows FTN entries to be inserted at arbitrary positions in the list. Agents MUST NOT allow the same FTN entries to be applied multiple times to the same interface. Agents MUST NOT allow the creation of rows in this table until the corresponding rows are created in the mplsFTNTable. If the corresponding row in the FTN table is destroyed, the agent MUST destroy the corresponding entries in this table as well. Although it is strongly recommended that managers destroy rows in this table in such a way that keeps the remainder of the table consistent, agents MUST ultimately make sure that if an entry in this table is destroyed, that inconsistencies in the table are not allowed to occur. To this end, rows that are no longer appropriate should be taken out of service.')
mplsFTNMapIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsFTNMapIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapIndex.setDescription('The interface index that this FTN entry is being applied to. A value of zero indicates an entry that is applied all interfaces. Entries mapped to an interface by specifying its (non- zero) interface index in mplsFTNMapIndex are applied ahead of entries with mplsFTNMapIndex equal to zero.')
mplsFTNMapPrevIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1, 2), MplsFTNEntryIndexOrZero())
if mibBuilder.loadTexts: mplsFTNMapPrevIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapPrevIndex.setDescription('The index of the previous FTN entry that was applied to this interface. The special value zero indicates that this should be the first FTN entry in the list.')
mplsFTNMapCurrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1, 3), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNMapCurrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapCurrIndex.setDescription('Index of the current FTN entry that is being applied to this interface.')
mplsFTNMapRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMapRowStatus.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapRowStatus.setDescription('Used for controlling the creation and deletion of this row. All writable objects in this row may be modified at any time. If a conceptual row instance of mplsFTNMapTable points to a conceptual row instance in mplsFTNTable which is subsequently deleted, the corresponding conceptual row in mplsFTNMapTable MUST also be deleted by the agent.')
mplsFTNMapStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 5, 1, 6), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsFTNMapStorageType.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapStorageType.setDescription("The storage type for this entry. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in this row.")
mplsFTNPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6), )
if mibBuilder.loadTexts: mplsFTNPerfTable.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfTable.setDescription('This table contains performance statistics on FTN entries on a per-interface basis.')
mplsFTNPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1), ).setIndexNames((0, "MPLS-FTN-MIB", "mplsFTNPerfIndex"), (0, "MPLS-FTN-MIB", "mplsFTNPerfCurrIndex"))
if mibBuilder.loadTexts: mplsFTNPerfEntry.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfEntry.setDescription('Each entry contains performance information for the specified interface and an FTN entry mapped to this interface.')
mplsFTNPerfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: mplsFTNPerfIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfIndex.setDescription('The interface index of an interface that an FTN entry has been applied/mapped to. Each instance of this object corresponds to an instance of mplsFTNMapIndex.')
mplsFTNPerfCurrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1, 2), MplsFTNEntryIndex())
if mibBuilder.loadTexts: mplsFTNPerfCurrIndex.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfCurrIndex.setDescription('Index of an FTN entry that has being applied/mapped to the specified interface. Each instance of this object corresponds to an instance of mplsFTNMapCurrIndex.')
mplsFTNPerfMatchedPackets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfMatchedPackets.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfMatchedPackets.setDescription('Number of packets that matched the specified FTN entry if it is applied/mapped to the specified interface. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsFTNDiscontinuityTime.')
mplsFTNPerfMatchedOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfMatchedOctets.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfMatchedOctets.setDescription('Number of octets that matched the specified FTN entry if it is applied/mapped to the specified interface. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of mplsFTNDiscontinuityTime.')
mplsFTNPerfDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 9999, 5, 1, 6, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsFTNPerfDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this entry's counters suffered a discontinuity. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
mplsFTNGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 1))
mplsFTNCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 2))
mplsFTNModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 2, 1)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-FTN-MIB", "mplsFTNRuleGroup"), ("MPLS-FTN-MIB", "mplsFTNMapGroup"), ("MPLS-FTN-MIB", "mplsFTNPerfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNModuleFullCompliance = mplsFTNModuleFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsFTNModuleFullCompliance.setDescription('Compliance statement for agents that provide full support for MPLS-FTN-MIB.')
mplsFTNModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 2, 2)).setObjects(("IF-MIB", "ifGeneralInformationGroup"), ("IF-MIB", "ifCounterDiscontinuityGroup"), ("MPLS-FTN-MIB", "mplsFTNRuleGroup"), ("MPLS-FTN-MIB", "mplsFTNMapGroup"), ("MPLS-FTN-MIB", "mplsFTNPerfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNModuleReadOnlyCompliance = mplsFTNModuleReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mplsFTNModuleReadOnlyCompliance.setDescription('Compliance requirement for implementations that only provide read-only support for MPLS-FTN-MIB. Such devices can then be monitored but cannot be configured using this MIB.')
mplsFTNRuleGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 1, 1)).setObjects(("MPLS-FTN-MIB", "mplsFTNIndexNext"), ("MPLS-FTN-MIB", "mplsFTNTableLastChanged"), ("MPLS-FTN-MIB", "mplsFTNRowStatus"), ("MPLS-FTN-MIB", "mplsFTNDescr"), ("MPLS-FTN-MIB", "mplsFTNMask"), ("MPLS-FTN-MIB", "mplsFTNAddrType"), ("MPLS-FTN-MIB", "mplsFTNSourceAddrMin"), ("MPLS-FTN-MIB", "mplsFTNSourceAddrMax"), ("MPLS-FTN-MIB", "mplsFTNDestAddrMin"), ("MPLS-FTN-MIB", "mplsFTNDestAddrMax"), ("MPLS-FTN-MIB", "mplsFTNSourcePortMin"), ("MPLS-FTN-MIB", "mplsFTNSourcePortMax"), ("MPLS-FTN-MIB", "mplsFTNDestPortMin"), ("MPLS-FTN-MIB", "mplsFTNDestPortMax"), ("MPLS-FTN-MIB", "mplsFTNProtocol"), ("MPLS-FTN-MIB", "mplsFTNActionType"), ("MPLS-FTN-MIB", "mplsFTNActionPointer"), ("MPLS-FTN-MIB", "mplsFTNDscp"), ("MPLS-FTN-MIB", "mplsFTNStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNRuleGroup = mplsFTNRuleGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNRuleGroup.setDescription('Collection of objects that implement MPLS FTN rules.')
mplsFTNMapGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 1, 2)).setObjects(("MPLS-FTN-MIB", "mplsFTNMapTableLastChanged"), ("MPLS-FTN-MIB", "mplsFTNMapRowStatus"), ("MPLS-FTN-MIB", "mplsFTNMapStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNMapGroup = mplsFTNMapGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNMapGroup.setDescription('Collection of objects that implement activation of MPLS FTN entries on interfaces.')
mplsFTNPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 9999, 5, 2, 1, 3)).setObjects(("MPLS-FTN-MIB", "mplsFTNPerfMatchedPackets"), ("MPLS-FTN-MIB", "mplsFTNPerfMatchedOctets"), ("MPLS-FTN-MIB", "mplsFTNPerfDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mplsFTNPerfGroup = mplsFTNPerfGroup.setStatus('current')
if mibBuilder.loadTexts: mplsFTNPerfGroup.setDescription('Collection of objects providing MPLS FTN performance information.')
mibBuilder.exportSymbols("MPLS-FTN-MIB", mplsFTNDestAddrMin=mplsFTNDestAddrMin, mplsFTNMapStorageType=mplsFTNMapStorageType, mplsFTNMapTable=mplsFTNMapTable, mplsFTNPerfMatchedOctets=mplsFTNPerfMatchedOctets, mplsFTNModuleReadOnlyCompliance=mplsFTNModuleReadOnlyCompliance, PYSNMP_MODULE_ID=mplsFTNMIB, mplsFTNPerfEntry=mplsFTNPerfEntry, mplsFTNTable=mplsFTNTable, mplsFTNDescr=mplsFTNDescr, mplsFTNMapTableLastChanged=mplsFTNMapTableLastChanged, mplsFTNRowStatus=mplsFTNRowStatus, mplsFTNObjects=mplsFTNObjects, mplsFTNNotifications=mplsFTNNotifications, mplsFTNProtocol=mplsFTNProtocol, mplsFTNPerfGroup=mplsFTNPerfGroup, mplsFTNModuleFullCompliance=mplsFTNModuleFullCompliance, mplsFTNDestPortMin=mplsFTNDestPortMin, mplsFTNIndex=mplsFTNIndex, mplsFTNSourcePortMax=mplsFTNSourcePortMax, mplsFTNPerfTable=mplsFTNPerfTable, mplsFTNPerfDiscontinuityTime=mplsFTNPerfDiscontinuityTime, mplsFTNMask=mplsFTNMask, mplsFTNMapIndex=mplsFTNMapIndex, mplsFTNPerfIndex=mplsFTNPerfIndex, mplsFTNIndexNext=mplsFTNIndexNext, mplsFTNPerfCurrIndex=mplsFTNPerfCurrIndex, mplsFTNAddrType=mplsFTNAddrType, mplsFTNDestAddrMax=mplsFTNDestAddrMax, mplsFTNDestPortMax=mplsFTNDestPortMax, mplsFTNActionPointer=mplsFTNActionPointer, mplsFTNGroups=mplsFTNGroups, mplsFTNConformance=mplsFTNConformance, MplsFTNEntryIndex=MplsFTNEntryIndex, mplsFTNMapRowStatus=mplsFTNMapRowStatus, mplsFTNCompliances=mplsFTNCompliances, mplsFTNStorageType=mplsFTNStorageType, mplsFTNMapCurrIndex=mplsFTNMapCurrIndex, mplsFTNTableLastChanged=mplsFTNTableLastChanged, mplsFTNRuleGroup=mplsFTNRuleGroup, mplsFTNMapPrevIndex=mplsFTNMapPrevIndex, MplsFTNEntryIndexOrZero=MplsFTNEntryIndexOrZero, mplsFTNActionType=mplsFTNActionType, mplsFTNDscp=mplsFTNDscp, mplsFTNPerfMatchedPackets=mplsFTNPerfMatchedPackets, mplsFTNMIB=mplsFTNMIB, mplsFTNEntry=mplsFTNEntry, mplsFTNSourceAddrMax=mplsFTNSourceAddrMax, mplsFTNMapGroup=mplsFTNMapGroup, mplsFTNSourceAddrMin=mplsFTNSourceAddrMin, mplsFTNSourcePortMin=mplsFTNSourcePortMin, mplsFTNMapEntry=mplsFTNMapEntry)

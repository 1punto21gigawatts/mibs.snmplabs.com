#
# PySNMP MIB module HP-ICF-SERVICE-TUNNEL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-ICF-SERVICE-TUNNEL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:35:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
hpSwitch, = mibBuilder.importSymbols("HP-ICF-OID", "hpSwitch")
ifIndex, ifAlias = mibBuilder.importSymbols("IF-MIB", "ifIndex", "ifAlias")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
NotificationType, Bits, Counter32, Unsigned32, iso, IpAddress, TimeTicks, ObjectIdentity, MibIdentifier, Gauge32, Integer32, ModuleIdentity, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Bits", "Counter32", "Unsigned32", "iso", "IpAddress", "TimeTicks", "ObjectIdentity", "MibIdentifier", "Gauge32", "Integer32", "ModuleIdentity", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TextualConvention")
tunnelInetConfigEntry, tunnelIfEntry = mibBuilder.importSymbols("TUNNEL-MIB", "tunnelInetConfigEntry", "tunnelIfEntry")
hpicfServiceTunnel = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100))
hpicfServiceTunnel.setRevisions(('2014-06-17 00:00', '2013-06-13 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpicfServiceTunnel.setRevisionsDescriptions(('Added support for Tap Tunnels', 'Initial Revision.',))
if mibBuilder.loadTexts: hpicfServiceTunnel.setLastUpdated('201406170000Z')
if mibBuilder.loadTexts: hpicfServiceTunnel.setOrganization('HP Networking')
if mibBuilder.loadTexts: hpicfServiceTunnel.setContactInfo('Hewlett-Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: hpicfServiceTunnel.setDescription('This MIB module contains HP proprietary objects for managing service tunnels.')
hpicfServiceTunnelNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 0))
hpicfServiceTunnelConfigurationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1))
hpicfServiceTunnelStatisticsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2))
hpicfServiceTunnelConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3))
hpicfServiceTunnelScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1))
hpicfServiceTunnelScalarStats = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1))
hpicfMaxIPv4ServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfMaxIPv4ServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfMaxIPv4ServiceTunnels.setDescription('Maximum number of IPv4 service tunnels supported on the device which is a sum of maximum Inspect and Tap tunnels.')
hpicfTotalIPv4ServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfTotalIPv4ServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfTotalIPv4ServiceTunnels.setDescription('Total number of IPv4 service tunnels configured on the device.This includes both Inspect and Tap tunnels')
hpicfMaxInterceptServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfMaxInterceptServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfMaxInterceptServiceTunnels.setDescription('Maximum number of Inspect service tunnels supported on the device.')
hpicfTotalIPv4InterceptServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfTotalIPv4InterceptServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfTotalIPv4InterceptServiceTunnels.setDescription('Total number of IPv4 service tunnels of type Inspect configured on the device.')
hpicfMaxIPv4TapServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfMaxIPv4TapServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfMaxIPv4TapServiceTunnels.setDescription('Maximum number of IPv4 service tunnels of type Tap supported on the device.')
hpicfTotalIPv4TapServiceTunnels = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfTotalIPv4TapServiceTunnels.setStatus('current')
if mibBuilder.loadTexts: hpicfTotalIPv4TapServiceTunnels.setDescription('Total number of IPv4 service tunnels of type Tap configured on the device.')
hpicfServiceTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 2), )
if mibBuilder.loadTexts: hpicfServiceTunnelTable.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelTable.setDescription('Table containing information on service tunnels. These are class of IP tunnels that can be used to encapsulate Ethernet frames along with the MAC and VLAN headers.')
hpicfServiceTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 2, 1), )
tunnelInetConfigEntry.registerAugmentions(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelEntry"))
hpicfServiceTunnelEntry.setIndexNames(*tunnelInetConfigEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfServiceTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelEntry.setDescription('An entry containing the information on a particular service tunnel.')
hpicfServiceTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("intercept", 1), ("tap", 2))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfServiceTunnelType.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelType.setDescription('This object is used to configure the service tunnel type. A value of none(0) indicates that this is not a service tunnel. A value of intercept(1) indicates that the service tunnel type is intercept. Intercept tunnels are to be used by applications that want to intercept and inspect traffic flowing through a device and re-insert traffic back to the device for forwarding after inspection. A value of tap(2) indicates that the service tunnel is of type Tap. Tap tunnels are used by applications that want to mirror traffic flowing through the device.')
hpicfServiceTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 2, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfServiceTunnelName.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelName.setDescription('This object is used to assign a textual name to the tunnel interface.')
hpicfServiceTunnelIfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3), )
if mibBuilder.loadTexts: hpicfServiceTunnelIfTable.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelIfTable.setDescription('Table containing information on service tunnels. These are IP tunnels that can be used to encapsulate Ethernet frames along with the MAC and VLAN headers.')
hpicfServiceTunnelIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3, 1), )
tunnelIfEntry.registerAugmentions(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelIfEntry"))
hpicfServiceTunnelIfEntry.setIndexNames(*tunnelIfEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfServiceTunnelIfEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelIfEntry.setDescription('An entry containing the information on a particular service tunnel.')
hpicfServiceTunnelIfMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3, 1, 1), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfServiceTunnelIfMTU.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelIfMTU.setDescription('The size of the largest packet which can be sent or received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
hpicfServiceTunnelInterfaceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceStatus.setDescription('This object indicates the operational state of the tunnel interface.')
hpicfServiceTunnelInterfaceDownReason = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("resourceUnavailable", 1), ("noRouteToDestination", 2), ("ifAdminDown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceDownReason.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceDownReason.setDescription('If the tunnelinterface state is DOWN, this object indicates the reason for which it is down.')
hpicfServiceTunnelInterfaceTruncate = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceTruncate.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelInterfaceTruncate.setDescription('Enables partial payloads to be sent on the Tap tunnels in case of MTU violations.')
hpicfServiceTunnelStatsRxInvalidKey = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxInvalidKey.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxInvalidKey.setDescription('Number of encapsulated packets to un-configured tunnel interfaces of type Intercept. This is not applicable to Tap tunnels.')
hpicfServiceTunnelStatsRxFragmentDrops = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxFragmentDrops.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxFragmentDrops.setDescription('Number of fragmented packets received and dropped on tunnel interface. This is not applicable to Tap tunnels.')
hpicfServiceTunnelStatsTxMTUViolationDrop = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxMTUViolationDrop.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxMTUViolationDrop.setDescription('Number of packets not transmitted on the tunnel interface for MTU violation reasons. This is common to all service tunnel types.')
hpicfServiceTunnelStatsUnknownSrcMac = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsUnknownSrcMac.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsUnknownSrcMac.setDescription('Number of packets received on tunnel interfaces but dropped because the source MAC address of the frame is not present in the FDB. This is not applicable to Tap tunnels.')
hpicfServiceTunnelStatsScalarClear = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsScalarClear.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsScalarClear.setDescription('This object clears tunnel statistics when set to TRUE. A GET request for this object always returns FALSE.')
hpicfServiceTunnelStatsIfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2), )
if mibBuilder.loadTexts: hpicfServiceTunnelStatsIfTable.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsIfTable.setDescription('Table containing statistics information on service tunnels. Service Tap tunnels are uni-directional and will not receive packets. Hence the MIB objects for Rx Statistics are not applicable for Tap tunnels and will always be 0.')
hpicfServiceTunnelStatsIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1), )
tunnelIfEntry.registerAugmentions(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsIfEntry"))
hpicfServiceTunnelStatsIfEntry.setIndexNames(*tunnelIfEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfServiceTunnelStatsIfEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsIfEntry.setDescription('An entry containing statistics information on a particular service tunnel.')
hpicfServiceTunnelStatsRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxPackets.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxPackets.setDescription('Number of packets received on the tunnel interface.')
hpicfServiceTunnelStatsTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxPackets.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxPackets.setDescription('Number of packets transmitted out of the tunnel interface.')
hpicfServiceTunnelStatsRxHeartbeat = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxHeartbeat.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsRxHeartbeat.setDescription('Number of heartbeat packets received on the tunnel interface.')
hpicfServiceTunnelStatsTxHeartbeat = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxHeartbeat.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsTxHeartbeat.setDescription('Number of heartbeat packets transmitted out of the tunnel interface.')
hpicfServiceTunnelLastHeartbeatPacketTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfServiceTunnelLastHeartbeatPacketTimestamp.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelLastHeartbeatPacketTimestamp.setDescription("The value of 'SysUpTime' correspondign to last heartbeat packet that was received on this tunnel.")
hpicfServiceTunnelStatsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 2, 2, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfServiceTunnelStatsClear.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsClear.setDescription('This object clears tunnel interface statistics when set to TRUE. A GET request for this object always returns FALSE.')
hpicfServiceTunnelIfUp = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAlias"))
if mibBuilder.loadTexts: hpicfServiceTunnelIfUp.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelIfUp.setDescription('An hpicfServiceTunnelIfUp trap is sent when the the hpicfServiceTunnelInterfaceStatus object for a tunnel changes from DOWN to UP.')
hpicfServiceTunnelIfDown = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("IF-MIB", "ifAlias"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceDownReason"))
if mibBuilder.loadTexts: hpicfServiceTunnelIfDown.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelIfDown.setDescription('An hpicfServiceTunnelIfDown trap is sent when the hpicfServiceTunnelInterfaceStatus object for a tunnel changes from UP to DOWN state.')
hpicfServiceTunnelCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 1))
hpicfServiceTunnelGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2))
hpicfServiceTunnelCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 1, 1)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceScalarsGroup"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceScalarsStatsGroup"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelGroup"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsGroup"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelNotificationGroup"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceScalarsGroup1"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelGroup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceTunnelCompliance = hpicfServiceTunnelCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelCompliance.setDescription('The compliance statement for the service tunnel MIB.')
hpicfServiceScalarsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 1)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfMaxIPv4ServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfTotalIPv4ServiceTunnels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceScalarsGroup = hpicfServiceScalarsGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceScalarsGroup.setDescription('The collection of objects providing information about the service tunnel.')
hpicfServiceScalarsGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 6)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfMaxIPv4ServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfTotalIPv4ServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfMaxInterceptServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfTotalIPv4InterceptServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfMaxIPv4TapServiceTunnels"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfTotalIPv4TapServiceTunnels"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceScalarsGroup1 = hpicfServiceScalarsGroup1.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceScalarsGroup1.setDescription('The collection of objects providing information about the service tunnel.')
hpicfServiceScalarsStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 2)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsRxInvalidKey"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsRxFragmentDrops"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsTxMTUViolationDrop"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsUnknownSrcMac"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsScalarClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceScalarsStatsGroup = hpicfServiceScalarsStatsGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceScalarsStatsGroup.setDescription('The collection of objects providing information about the service tunnel statistics.')
hpicfServiceTunnelGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 3)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelType"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelName"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelIfMTU"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceStatus"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceDownReason"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceTunnelGroup = hpicfServiceTunnelGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelGroup.setDescription('The collection of objects providing information about the service tunnel.')
hpicfServiceTunnelGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 7)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelType"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelName"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelIfMTU"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceStatus"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceDownReason"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelInterfaceTruncate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceTunnelGroup1 = hpicfServiceTunnelGroup1.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelGroup1.setDescription('The collection of objects providing information about the service tunnel.')
hpicfServiceTunnelStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 4)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsRxPackets"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsTxPackets"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsRxHeartbeat"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsTxHeartbeat"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelLastHeartbeatPacketTimestamp"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelStatsClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceTunnelStatsGroup = hpicfServiceTunnelStatsGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelStatsGroup.setDescription('The collection of objects providing information about the service tunnel statistics.')
hpicfServiceTunnelNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 100, 3, 2, 5)).setObjects(("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelIfUp"), ("HP-ICF-SERVICE-TUNNEL-MIB", "hpicfServiceTunnelIfDown"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfServiceTunnelNotificationGroup = hpicfServiceTunnelNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfServiceTunnelNotificationGroup.setDescription('Group of notifications.')
mibBuilder.exportSymbols("HP-ICF-SERVICE-TUNNEL-MIB", hpicfServiceTunnelLastHeartbeatPacketTimestamp=hpicfServiceTunnelLastHeartbeatPacketTimestamp, hpicfServiceTunnelScalarStats=hpicfServiceTunnelScalarStats, hpicfServiceTunnelIfTable=hpicfServiceTunnelIfTable, hpicfServiceTunnelCompliances=hpicfServiceTunnelCompliances, hpicfServiceTunnelStatsTxPackets=hpicfServiceTunnelStatsTxPackets, hpicfServiceTunnelScalars=hpicfServiceTunnelScalars, hpicfServiceTunnelGroups=hpicfServiceTunnelGroups, hpicfServiceTunnelGroup1=hpicfServiceTunnelGroup1, hpicfServiceTunnelInterfaceDownReason=hpicfServiceTunnelInterfaceDownReason, hpicfTotalIPv4InterceptServiceTunnels=hpicfTotalIPv4InterceptServiceTunnels, hpicfServiceTunnelIfDown=hpicfServiceTunnelIfDown, hpicfServiceTunnelStatsTxMTUViolationDrop=hpicfServiceTunnelStatsTxMTUViolationDrop, hpicfServiceTunnelStatsUnknownSrcMac=hpicfServiceTunnelStatsUnknownSrcMac, hpicfServiceTunnelStatsRxHeartbeat=hpicfServiceTunnelStatsRxHeartbeat, hpicfServiceTunnelStatsRxInvalidKey=hpicfServiceTunnelStatsRxInvalidKey, hpicfServiceTunnelStatsIfTable=hpicfServiceTunnelStatsIfTable, hpicfServiceTunnelConformance=hpicfServiceTunnelConformance, hpicfServiceTunnelEntry=hpicfServiceTunnelEntry, hpicfServiceTunnel=hpicfServiceTunnel, hpicfServiceTunnelIfEntry=hpicfServiceTunnelIfEntry, hpicfServiceTunnelInterfaceStatus=hpicfServiceTunnelInterfaceStatus, hpicfTotalIPv4ServiceTunnels=hpicfTotalIPv4ServiceTunnels, hpicfServiceTunnelStatisticsObjects=hpicfServiceTunnelStatisticsObjects, hpicfServiceTunnelType=hpicfServiceTunnelType, hpicfServiceTunnelStatsIfEntry=hpicfServiceTunnelStatsIfEntry, hpicfTotalIPv4TapServiceTunnels=hpicfTotalIPv4TapServiceTunnels, hpicfServiceTunnelCompliance=hpicfServiceTunnelCompliance, hpicfServiceTunnelNotifications=hpicfServiceTunnelNotifications, hpicfServiceTunnelStatsClear=hpicfServiceTunnelStatsClear, hpicfServiceScalarsStatsGroup=hpicfServiceScalarsStatsGroup, hpicfServiceTunnelNotificationGroup=hpicfServiceTunnelNotificationGroup, hpicfServiceTunnelGroup=hpicfServiceTunnelGroup, hpicfServiceTunnelStatsRxPackets=hpicfServiceTunnelStatsRxPackets, hpicfServiceTunnelStatsTxHeartbeat=hpicfServiceTunnelStatsTxHeartbeat, hpicfServiceTunnelName=hpicfServiceTunnelName, hpicfServiceTunnelIfUp=hpicfServiceTunnelIfUp, PYSNMP_MODULE_ID=hpicfServiceTunnel, hpicfServiceTunnelInterfaceTruncate=hpicfServiceTunnelInterfaceTruncate, hpicfServiceScalarsGroup=hpicfServiceScalarsGroup, hpicfServiceTunnelStatsScalarClear=hpicfServiceTunnelStatsScalarClear, hpicfServiceTunnelStatsGroup=hpicfServiceTunnelStatsGroup, hpicfServiceTunnelTable=hpicfServiceTunnelTable, hpicfServiceTunnelConfigurationObjects=hpicfServiceTunnelConfigurationObjects, hpicfServiceTunnelStatsRxFragmentDrops=hpicfServiceTunnelStatsRxFragmentDrops, hpicfMaxIPv4TapServiceTunnels=hpicfMaxIPv4TapServiceTunnels, hpicfMaxInterceptServiceTunnels=hpicfMaxInterceptServiceTunnels, hpicfMaxIPv4ServiceTunnels=hpicfMaxIPv4ServiceTunnels, hpicfServiceScalarsGroup1=hpicfServiceScalarsGroup1, hpicfServiceTunnelIfMTU=hpicfServiceTunnelIfMTU)

#
# PySNMP MIB module F5-3DNS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/F5-3DNS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:11:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Counter64, ObjectIdentity, Bits, NotificationType, Unsigned32, Integer32, Gauge32, NotificationType, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, enterprises, iso, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Counter64", "ObjectIdentity", "Bits", "NotificationType", "Unsigned32", "Integer32", "Gauge32", "NotificationType", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "enterprises", "iso", "ModuleIdentity")
TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "DateAndTime")
f5 = MibIdentifier((1, 3, 6, 1, 4, 1, 3375))
f5systems = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1))
f53dns = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2))
f53dnsMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1))
f53dnsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1))
globals = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1))
dataCenters = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2))
lbRouters = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3))
hosts = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4))
lbDnsServs = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5))
lbDomains = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6))
summary = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7))
threednsTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2))
threednsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2))
globalCheckStaticDepends = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCheckStaticDepends.setStatus('mandatory')
if mibBuilder.loadTexts: globalCheckStaticDepends.setDescription('Indicates whether the availability of virtual servers on load-balancing routers and hosts is checked. Normally true, but can be false for testing.')
globalDefaultAlternate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalDefaultAlternate.setStatus('mandatory')
if mibBuilder.loadTexts: globalDefaultAlternate.setDescription('Default static load balancing mode.')
globalTimerGetLBRouterData = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTimerGetLBRouterData.setStatus('mandatory')
if mibBuilder.loadTexts: globalTimerGetLBRouterData.setDescription('Interval in seconds between refreshes of load-balancing router data.')
globalTimerGetVServData = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTimerGetVServData.setStatus('mandatory')
if mibBuilder.loadTexts: globalTimerGetVServData.setDescription('Interval in seconds between refreshes of virtual server data.')
globalTimerGetPathData = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTimerGetPathData.setStatus('mandatory')
if mibBuilder.loadTexts: globalTimerGetPathData.setDescription('Interval in seconds between refreshes of path data.')
globalLBRouterTTL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalLBRouterTTL.setStatus('mandatory')
if mibBuilder.loadTexts: globalLBRouterTTL.setDescription('Amount of time in seconds that load-balancing router data is considered valid for name resolution and load balancing.')
globalVSTTL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalVSTTL.setStatus('mandatory')
if mibBuilder.loadTexts: globalVSTTL.setDescription('Amount of time in seconds that virtual server data is considered valid for name resolution and load balancing.')
globalPathTTL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathTTL.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathTTL.setDescription('Amount of time in seconds that path data is considered valid for name resolution and load balancing.')
globalRTTTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTTimeout.setDescription('Amount of time in seconds that the RTT listener daemon waits for a probe.')
globalRTTSampleCount = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTSampleCount.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTSampleCount.setDescription('Number of packets to send when measuring round-trip times.')
globalRTTPacketLength = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTPacketLength.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTPacketLength.setDescription('Length in bytes of packets used for measuring round-trip times.')
globalRTTProbeProtocol = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("icmp", 1), ("tcp", 2), ("udp", 3), ("dnsnslookupDot", 4), ("dnsRetrieveBindVers", 5), ("numberItems", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTProbeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTProbeProtocol.setDescription('Probing protocol used for measuring round-trip times.')
globalEncryption = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalEncryption.setStatus('mandatory')
if mibBuilder.loadTexts: globalEncryption.setDescription('Indicates whether encryption is used for iQuery events.')
globalEncryptionKeyFile = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalEncryptionKeyFile.setStatus('mandatory')
if mibBuilder.loadTexts: globalEncryptionKeyFile.setDescription('The pathname of the key file used for encryption.')
globalPathHiWater = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathHiWater.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathHiWater.setDescription('Path memory usage level that triggers reaping, in bytes.')
globalPathLoWater = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathLoWater.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathLoWater.setDescription('Path memory usage level at which reaping is discontinued, in bytes.')
globalPathDuration = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3600, 2419200))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathDuration.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathDuration.setDescription('Interval in seconds between checks of path memory usage to determine whether to reap.')
globalPathReapAlg = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lru", 1), ("fewestHits", 2), ("numberItems", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathReapAlg.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathReapAlg.setDescription('Algorithm used for selecting paths to be discarded when reaping.')
globalTimerKeepAlive = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTimerKeepAlive.setStatus('mandatory')
if mibBuilder.loadTexts: globalTimerKeepAlive.setDescription('Interval in seconds between periodic queries of load-balancing routers.')
globalRxBufSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8192, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRxBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalRxBufSize.setDescription('Size of each socket receive buffer, in bytes.')
globalTxBufSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8192, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTxBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalTxBufSize.setDescription('Size of each socket transmit buffer, in bytes.')
globalQosCoeffRTT = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosCoeffRTT.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosCoeffRTT.setDescription('Relative weight given to the round-trip time in the quality of service load balancing mode.')
globalQosCoeffCompletionRate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosCoeffCompletionRate.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosCoeffCompletionRate.setDescription('Relative weight given to the completion rate in the quality of service load balancing mode.')
globalQosCoeffHops = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosCoeffHops.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosCoeffHops.setDescription('Relative weight given to the hop count in the quality of service load balancing mode.')
globalQosCoeffPacketRate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosCoeffPacketRate.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosCoeffPacketRate.setDescription('Relative weight given to the packet rate in the quality of service load balancing mode.')
globalPathsNoClobber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathsNoClobber.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathsNoClobber.setDescription('Specifies whether the load-balancing DNS server overwrites existing path data with blank data when a path probe fails.')
globalPathsNeverDie = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPathsNeverDie.setStatus('mandatory')
if mibBuilder.loadTexts: globalPathsNeverDie.setDescription('Specifies whether dynamic load balancing modes can use path data even after the ttl for the path data has expired.')
globalRegulateInit = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRegulateInit.setStatus('mandatory')
if mibBuilder.loadTexts: globalRegulateInit.setDescription('Defines the initial amount of path probe requests 3DNS will send to each big3d after initialization. After the first series of probe requests, 3DNS adjusts the number of future probe requests according to the amount received during the last probe interval (defined by timer_get_path_data) plus the increment defined by regulate_paths.')
globalRegulatePaths = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRegulatePaths.setStatus('mandatory')
if mibBuilder.loadTexts: globalRegulatePaths.setDescription("If zero, no path regulation will be attempted. Every path in the cache that is not fresh will be sent to each big3d every timer_get_path_data seconds. If non-zero, this defines the increment over the amount of path's probed and refreshed over the past interval to determine an upper bound for probe requests to send to each big3d.")
globalProberAddr = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 30), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalProberAddr.setStatus('mandatory')
if mibBuilder.loadTexts: globalProberAddr.setDescription('The default prober for host status.')
globalCheckDynamicDepends = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCheckDynamicDepends.setStatus('mandatory')
if mibBuilder.loadTexts: globalCheckDynamicDepends.setDescription('Indicates whether the load-balancing DNS server checks the availability of a path before it uses the path for load balancing.')
globalDefaultFallback = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalDefaultFallback.setStatus('mandatory')
if mibBuilder.loadTexts: globalDefaultFallback.setDescription('The default load balancing mode used for the fallback method.')
globalDefaultTTL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalDefaultTTL.setStatus('mandatory')
if mibBuilder.loadTexts: globalDefaultTTL.setDescription('The amount of time (in seconds) that information is to be used for name resolution and load balancing.')
globalPersistLDns = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalPersistLDns.setStatus('mandatory')
if mibBuilder.loadTexts: globalPersistLDns.setDescription("If TRUE (default), then 3DNS will remember all LDNS's that make requests in its cache. This must be TRUE in order to store and use path information.")
globalFbRespectAcl = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalFbRespectAcl.setStatus('mandatory')
if mibBuilder.loadTexts: globalFbRespectAcl.setDescription('Indicates whether the load-balancing DNS server imposes access control when load balancing switches to the specified fallback mode.')
globalFbRespectDepends = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalFbRespectDepends.setStatus('mandatory')
if mibBuilder.loadTexts: globalFbRespectDepends.setDescription('Indicates whether the load-balancing DNS server respects virtual server status when load balancing switches to the specified fallback mode.')
globalHostTTL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalHostTTL.setStatus('mandatory')
if mibBuilder.loadTexts: globalHostTTL.setDescription('The amount of time (in seconds) that host machine information is to be used for name resolution and load balancing.')
globalTimerGetHostData = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalTimerGetHostData.setStatus('mandatory')
if mibBuilder.loadTexts: globalTimerGetHostData.setDescription('The interval (in seconds) between refreshes of host information.')
globalRTTRetireZero = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTRetireZero.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTRetireZero.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalRTTPortDiscovery = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTPortDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTPortDiscovery.setDescription('Indicates whether the load-balancing DNS server uses the discovery factory to find an alternate port to be used by the probing factory, if probing on port 53 fails.')
globalRTTDiscoveryMethod = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("short", 1), ("wks", 2), ("full", 3), ("all", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTDiscoveryMethod.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTDiscoveryMethod.setDescription('Indicates the set of ports scanned when searching for an alternate port to be used bythe probing factory, if probing on port 53 fails.')
globalRTTProbeDynamic = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTProbeDynamic.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTProbeDynamic.setDescription('Indicates whether the load-balancing DNS server attempts a second probe using the alternate probe protocol if the probe protocol specified by globalRTTProbeProtocol fails during the first probe.')
globalResolverRXBufSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8192, 131072))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalResolverRXBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalResolverRXBufSize.setDescription('The UDP receive buffer size.')
globalResolverTXBufSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(8192, 32768))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalResolverTXBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalResolverTXBufSize.setDescription('The TCP send buffer size.')
globalCoeffLastAccess = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffLastAccess.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffLastAccess.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalCoeffFreshRemain = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffFreshRemain.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffFreshRemain.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalCoeffAccessRefresh = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffAccessRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffAccessRefresh.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalCoeffAccessTotal = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffAccessTotal.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffAccessTotal.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalCoeffDRTT = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffDRTT.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffDRTT.setDescription('Relative weighting for round trip time when the load balancing mode is set to Quality of Service.')
globalCoeffDCompletionRate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalCoeffDCompletionRate.setStatus('mandatory')
if mibBuilder.loadTexts: globalCoeffDCompletionRate.setDescription('Default 0. Coefficient used in custom path prioritization algorithm.')
globalQosCoeffTopology = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosCoeffTopology.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosCoeffTopology.setDescription('Relative weighting for topology when the load balancing mode is set to Quality of Service.')
globalQosFactorRTT = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosFactorRTT.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosFactorRTT.setDescription('Factor used to normalize raw RTT values when computing the QOS score.')
globalQosFactorHops = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosFactorHops.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosFactorHops.setDescription('Factor used to normalize raw RTT values when computing the QOS score.')
globalQosFactorCompletionRate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosFactorCompletionRate.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosFactorCompletionRate.setDescription('Factor used to normalize raw RTT values when computing the QOS score.')
globalQosFactorPacketRate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosFactorPacketRate.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosFactorPacketRate.setDescription('Factor used to normalize raw RTT values when computing the QOS score.')
globalQosFactorTopology = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalQosFactorTopology.setStatus('mandatory')
if mibBuilder.loadTexts: globalQosFactorTopology.setDescription('Factor used to normalize raw RTT values when computing the QOS score.')
globalLDnsHiWater = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalLDnsHiWater.setStatus('mandatory')
if mibBuilder.loadTexts: globalLDnsHiWater.setDescription('LDNS memory usage level that triggers reaping, in bytes.')
globalLDnsLoWater = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalLDnsLoWater.setStatus('mandatory')
if mibBuilder.loadTexts: globalLDnsLoWater.setDescription('LDNS memory usage level at which reaping is discontinued, in bytes.')
globalLDnsDuration = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 59), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3600, 424967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalLDnsDuration.setStatus('mandatory')
if mibBuilder.loadTexts: globalLDnsDuration.setDescription('Interval in seconds between checks of LDNS memory usage to determine whether to reap.')
globalLDnsReapAlg = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lru", 1), ("fewestHits", 2), ("numberItems", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalLDnsReapAlg.setStatus('mandatory')
if mibBuilder.loadTexts: globalLDnsReapAlg.setDescription('Algorithm used for selecting LDNS entries to be discarded when reaping.')
globalUseAltIqPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalUseAltIqPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalUseAltIqPort.setDescription('If true, the registered port 4353 is used for iQuery traffic. If false, the traditional port 245 is used.')
globalMultiplexIq = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalMultiplexIq.setStatus('mandatory')
if mibBuilder.loadTexts: globalMultiplexIq.setDescription('If true, port 4353 is used for all incoming iQuery traffic. If false, ports from the ephemeral port range are used.')
globalRTTProbeProtocolList = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 63), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTProbeProtocolList.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTProbeProtocolList.setDescription('List of RTT probe protocols to use. The protocols are listed in the order in which they will be attempted. If an attempt to use a specified protocol fails, the next one in the list will be used for a subsequent attempt. If the last protocol in the list fails the first one in the list will then be used.')
globalRTTProbeProtocolState = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 64), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalRTTProbeProtocolState.setStatus('mandatory')
if mibBuilder.loadTexts: globalRTTProbeProtocolState.setDescription('The current RTT probe protocol being used. This will return the name of the protocol being used followed by a number signifying the position of that protocol in the list of protocols returned by globalRTTProbeProtocolList.')
globalResetCounters = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 65), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("unreset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: globalResetCounters.setStatus('mandatory')
if mibBuilder.loadTexts: globalResetCounters.setDescription('Writing a one to this variable will cause counters within 3DNS to be reset. If the counters have been reset this variable will have a value of 1. If the counters have not been reset the variable will have a value of 2.')
globalResetCounterTime = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 1, 66), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalResetCounterTime.setStatus('mandatory')
if mibBuilder.loadTexts: globalResetCounterTime.setDescription('The time of the last reset of the 3DNS counters. If the counters have not been reset this variable will contain the time when statistic gathering first started.')
dataCenterTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1), )
if mibBuilder.loadTexts: dataCenterTable.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterTable.setDescription('Information describing the defined data centers.')
dataCenterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1), ).setIndexNames((0, "F5-3DNS-MIB", "dataCenterName"))
if mibBuilder.loadTexts: dataCenterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterEntry.setDescription('This table contains a row for each data center. The rows are indexed by the names of the data centers.')
dataCenterName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterName.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterName.setDescription('The name of the data center in this row of the table.')
dataCenterContact = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterContact.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterContact.setDescription('Contact information for the data center in this row of the table.')
dataCenterLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterLocation.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterLocation.setDescription('The location of the data center in this row of the table.')
dataCenterPathCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterPathCount.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterPathCount.setDescription('The number of paths in the data center in this row of the table.')
dataCenterDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterDisabled.setDescription('Is this datacenter disabled. If a datacenter is disabled then all servers within the datacenter are treated as disabled.')
dataCenterDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterDisableDuration.setDescription('The duration of a disable of this datacenter.')
dataCenterServTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 2), )
if mibBuilder.loadTexts: dataCenterServTable.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterServTable.setDescription('Information about the servers associated with each data center.')
dataCenterServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 2, 1), ).setIndexNames((0, "F5-3DNS-MIB", "dataCenterName"), (0, "F5-3DNS-MIB", "dataCenterServAddr"))
if mibBuilder.loadTexts: dataCenterServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterServEntry.setDescription('This table contains a row for each server in each data center.')
dataCenterServAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterServAddr.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterServAddr.setDescription('The IP address of the server.')
dataCenterServType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("lbRouter", 2), ("lbDnsServ", 3), ("host", 4), ("lDns", 5), ("prober", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dataCenterServType.setStatus('mandatory')
if mibBuilder.loadTexts: dataCenterServType.setDescription('The server type.')
lbRouterTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1), )
if mibBuilder.loadTexts: lbRouterTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterTable.setDescription('Information about the defined load-balancing routers.')
lbRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbRouterAddr"))
if mibBuilder.loadTexts: lbRouterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterEntry.setDescription("This table contains a row for each load-balancing router known to the system. It is indexed by the router's canonical IP address.")
lbRouterAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterAddr.setDescription("The load-balancing router's canonical IP address.")
lbRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterName.setDescription("The load-balancing router's name.")
lbRouterVServCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServCount.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServCount.setDescription('The number of virtual servers associated with the load-balancing router.')
lbRouterPicks = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterPicks.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterPicks.setDescription('The number of times the specified load-balancing router has been chosen by the load-balancing DNS server.')
lbRouterRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterRefreshes.setDescription('The number of times that server and connection counts have been refreshed with new data from the load-balancing router.')
lbRouterDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterDisabled.setDescription('Is this load -balancing router disabled. If a load-balancing router is disabled then all of its virtual servers are considered to be disabled.')
lbRouterDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterDisableDuration.setDescription('Duration of a disable of this load-balancing router.')
lbRouterIQProto = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tcp", 1), ("udp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIQProto.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIQProto.setDescription('IQuery protocol to use for this load-balancing router.')
lbRouterIfTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2), )
if mibBuilder.loadTexts: lbRouterIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfTable.setDescription('Information about the network interfaces on a load-balancing router.')
lbRouterIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbRouterAddr"), (0, "F5-3DNS-MIB", "lbRouterIfAddr"))
if mibBuilder.loadTexts: lbRouterIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfEntry.setDescription('This table contains a row for each network interface associated with a load-balancing router. It is indexed by the canonical IP address of the router and the specific IP address of the interface.')
lbRouterIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfAddr.setDescription('The specific IP address of the network interface in this row of the table.')
lbRouterIfShared = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfShared.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfShared.setDescription('Whether the interface is the shared IP address of the load-balancing router.')
lbRouterIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("waiting", 4), ("alert", 5), ("panic", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfStatus.setDescription('The status of the network interface.')
lbRouterIfTXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfTXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfTXPackets.setDescription('The number of packets that have been transmitted on the network interface.')
lbRouterIfRXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfRXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfRXPackets.setDescription('The number of packets that have been received on the network interface.')
lbRouterIfPacketRate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPacketRate.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPacketRate.setDescription("The interface's current packet rate in packets per second.")
lbRouterIfUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfUpTime.setDescription('The amount of time the interface has been up.')
lbRouterIfAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfAliveTime.setDescription('The most recent date and time when the interface was known to be running.')
lbRouterIfDataTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfDataTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfDataTime.setDescription('The most recent date and time when data was transmitted through the interface.')
lbRouterIfPathSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 10), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPathSentTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPathSentTime.setDescription('The date and time when path data corresponding to the interface was most recently sent.')
lbRouterIfPathsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPathsSent.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPathsSent.setDescription('The number of paths sent in the most recent batch.')
lbRouterIfPathsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPathsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPathsRcvd.setDescription('The number of paths received in the most recent batch.')
lbRouterIfPathSends = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPathSends.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPathSends.setDescription('The number of batches of paths that have been sent.')
lbRouterIfPathRcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfPathRcvs.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfPathRcvs.setDescription('The number of batches of paths that have been received.')
lbRouterIfAvgPathsSentX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfAvgPathsSentX1000.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfAvgPathsSentX1000.setDescription('The average sent path batch size, multiplied by 1000.')
lbRouterIfAvgPathsRcvdX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfAvgPathsRcvdX1000.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfAvgPathsRcvdX1000.setDescription('The average received path batch size, multiplied by 1000.')
lbRouterIfFctryTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 3), )
if mibBuilder.loadTexts: lbRouterIfFctryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfFctryTable.setDescription('Information about the factories running on each load-balancing router interface.')
lbRouterIfFctryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 3, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbRouterAddr"), (0, "F5-3DNS-MIB", "lbRouterIfAddr"), (0, "F5-3DNS-MIB", "lbRouterIfFctryType"))
if mibBuilder.loadTexts: lbRouterIfFctryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfFctryEntry.setDescription('This table gives the number of factories of each type that are running on each load-balancing router interface.')
lbRouterIfFctryType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lbRouter", 1), ("prober", 2), ("discovery", 3), ("snmp", 4), ("hops", 5), ("server", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfFctryType.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfFctryType.setDescription('The type of the factory in this row of the table.')
lbRouterIfFctryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterIfFctryCount.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterIfFctryCount.setDescription('The number of factories of the type corresponding to this row of the table.')
lbRouterVServTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4), )
if mibBuilder.loadTexts: lbRouterVServTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServTable.setDescription('Information about the virtual servers associated with each load-balancing router.')
lbRouterVServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbRouterAddr"), (0, "F5-3DNS-MIB", "lbRouterVServAddr"), (0, "F5-3DNS-MIB", "lbRouterVServPort"))
if mibBuilder.loadTexts: lbRouterVServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServEntry.setDescription('This table contains a row for each virtual server on each load-balancing router. It is indexed by the router address and by the address/port combination that defines the virtual server.')
lbRouterVServAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServAddr.setDescription('The IP address of the virtual server.')
lbRouterVServPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServPort.setDescription('The port number of the virtual server.')
lbRouterVServXlatedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServXlatedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServXlatedAddr.setDescription('The translated (NAT) address of the virtual server.')
lbRouterVServXlatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServXlatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServXlatedPort.setDescription('The translated (NAT) port number of the virtual server.')
lbRouterVServProbeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("icmp", 1), ("tcp", 2), ("udp", 3), ("dnsnslookupDot", 4), ("dnsRetrieveBindVers", 5), ("numberItems", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServProbeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServProbeProtocol.setDescription('The probing protocol used for measuring round-trip times to the virtual server.')
lbRouterVServPicks = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServPicks.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServPicks.setDescription('The number of times the specified virtual server has been chosen by the load-balancing DNS server.')
lbRouterVServRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServRefreshes.setDescription('The number of times that data associated with the virtual server have been refreshed with new information.')
lbRouterVServAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServAliveTime.setDescription('When the virtual server was last known to be up.')
lbRouterVServDataTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServDataTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServDataTime.setDescription('When data was last received from the virtual server.')
lbRouterVServCurConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServCurConns.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServCurConns.setDescription('The current number of connections being processed by the virtual server.')
lbRouterVServCurConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServCurConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServCurConnLimit.setDescription('The current connection limit for the virtual server.')
lbRouterVServCurNodesUp = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServCurNodesUp.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServCurNodesUp.setDescription('The current number of nodes associated with the virtual server that are up.')
lbRouterVServCurEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServCurEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServCurEnabled.setDescription('Whether the virtual server is currently enabled.')
lbRouterVServDnsServDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServDnsServDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServDnsServDisabled.setDescription('Whether the virtual server is currently disabled from the load-balancing DNS server.')
lbRouterVServDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 3, 4, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbRouterVServDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lbRouterVServDisableDuration.setDescription('Duration of a disable of this server by the load-balancing DNS server.')
hostTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1), )
if mibBuilder.loadTexts: hostTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostTable.setDescription('Information about the defined hosts other than load-balancing routers.')
hostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1), ).setIndexNames((0, "F5-3DNS-MIB", "hostAddr"))
if mibBuilder.loadTexts: hostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostEntry.setDescription('This table contains a row for each host other than the load-balancing routers. It is indexed by the canonical IP address of each host.')
hostAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hostAddr.setDescription('The canonical IP address of the host.')
hostName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostName.setStatus('mandatory')
if mibBuilder.loadTexts: hostName.setDescription('The name of the host.')
hostProber = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostProber.setStatus('mandatory')
if mibBuilder.loadTexts: hostProber.setDescription('The IP address of the prober for the host.')
hostProbeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("icmp", 1), ("tcp", 2), ("udp", 3), ("dnsnslookupDot", 4), ("dnsRetrieveBindVers", 5), ("numberItems", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostProbeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: hostProbeProtocol.setDescription('The protocol used when probing the host.')
hostProbePort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostProbePort.setStatus('mandatory')
if mibBuilder.loadTexts: hostProbePort.setDescription('The port to which probes are directed.')
hostVServCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServCount.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServCount.setDescription('The number of virtual servers associated with the host.')
hostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("waiting", 4), ("alert", 5), ("panic", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hostStatus.setDescription('The current status of the host.')
hostPicks = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostPicks.setStatus('mandatory')
if mibBuilder.loadTexts: hostPicks.setDescription('The number of times the host has been chosen by the load-balancing DNS server.')
hostRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: hostRefreshes.setDescription('The number of times the data from the host has been refreshed with new information.')
hostDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: hostDisabled.setDescription('Is this load host disabled. If a host is disabled then all of its virtual servers are considered to be disabled.')
hostDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: hostDisableDuration.setDescription('Duration of a disable of this host.')
hostMetrics = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unkown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostMetrics.setStatus('mandatory')
if mibBuilder.loadTexts: hostMetrics.setDescription('Are Cisco virtual server metrics available for the virtual servers on this host.')
hostMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostMemory.setStatus('mandatory')
if mibBuilder.loadTexts: hostMemory.setDescription('Total number of kilobytes of free virtual memory for this host. If this statistic is not available it will have a value of -1.')
hostCPU = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostCPU.setStatus('mandatory')
if mibBuilder.loadTexts: hostCPU.setDescription('CPU utilization. All CPU utilization is expressed a percentage rounded up to the nearest integer. CPU utilization is computed differently for each SNMP agent. CPU usage is computed for the UCD mib as the load average in the last 5 minutes divided by a configured maximum saturated load average. CPU usage is computed for the Solstice mib as the number of time ticks spent in user and system execution divided by the total number of elapsed time tics. If this statistic is not available it will have a value of -1.')
hostDiskSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostDiskSpace.setStatus('mandatory')
if mibBuilder.loadTexts: hostDiskSpace.setDescription('The amount of available disk space for / in kilobytes. If this statistic is not available it will have a value of -1.')
hostSNMPConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPConfigured.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPConfigured.setDescription('Is an SNMP agent configured for this host.')
hostSNMPAgentType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ciscold", 1), ("ciscold2", 2), ("ciscold3", 3), ("ucd", 4), ("solstice", 5), ("ntserv", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPAgentType.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPAgentType.setDescription('Is an SNMP agent configured for this host.')
hostSNMPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPAddress.setDescription('The IP address of the SNMP agent for this host. If no SNMP agent is configured for this host this will have a value of 0.0.0.0.')
hostSNMPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPPort.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPPort.setDescription('The port for the SNMP agent of this host. If no SNMP agent is configured for this host this will have a value of -1.')
hostSNMPRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPRetries.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPRetries.setDescription('Number of retries to use when attempting to query the SNMP agent of this host. If no SNMP agent is configured for this host this will have a value of -1.')
hostSNMPTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPTimeout.setDescription('Time in seconds to wait before retrying a query of the SNMP agent for this host. If no SNMP agent is configured for this host this will have a value of -1.')
hostSNMPVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2), ("v3", 3), ("notset", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPVersion.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPVersion.setDescription('SNMP version number to use when communicating with the SNMP agent for this host. If no SNMP agent is configured for this host this will have a value of -1.')
hostSNMPCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostSNMPCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: hostSNMPCommunity.setDescription('SNMP community name to use when communicating with the SNMP agent for this host. If no SNMP agent is configured for this host this will have a value of none.')
hostIfTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2), )
if mibBuilder.loadTexts: hostIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfTable.setDescription('Information about the network interfaces on a host.')
hostIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1), ).setIndexNames((0, "F5-3DNS-MIB", "hostAddr"), (0, "F5-3DNS-MIB", "hostIfAddr"))
if mibBuilder.loadTexts: hostIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfEntry.setDescription('This table contains a row for each network interface associated with a host. It is indexed by the canonical IP address of the host and the specific IP address of the interface.')
hostIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfAddr.setDescription('The specific IP address of the network interface in this row of the table.')
hostIfShared = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfShared.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfShared.setDescription('Whether the interface is the shared IP address of the host.')
hostIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("waiting", 4), ("alert", 5), ("panic", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfStatus.setDescription('The status of the network interface.')
hostIfTXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfTXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfTXPackets.setDescription('The number of packets that have been transmitted on the network interface.')
hostIfRXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfRXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfRXPackets.setDescription('The number of packets that have been received on the network interface.')
hostIfUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfUpTime.setDescription('The amount of time the interface has been up.')
hostIfAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfAliveTime.setDescription('The most recent date and time when the interface was known to be running.')
hostIfDataTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfDataTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfDataTime.setDescription('The most recent date and time when data was transmitted through the interface.')
hostIfPathSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfPathSentTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfPathSentTime.setDescription('The date and time when path data corresponding to the interface was most recently sent.')
hostIfPathsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfPathsSent.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfPathsSent.setDescription('The number of paths sent in the most recent batch.')
hostIfPathsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfPathsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfPathsRcvd.setDescription('The number of paths received in the most recent batch.')
hostIfPathSends = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfPathSends.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfPathSends.setDescription('The number of batches of paths that have been sent.')
hostIfPathRcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfPathRcvs.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfPathRcvs.setDescription('The number of batches of paths that have been received.')
hostIfAvgPathsSentX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfAvgPathsSentX1000.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfAvgPathsSentX1000.setDescription('The average sent path batch size, multiplied by 1000.')
hostIfAvgPathsRcvdX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfAvgPathsRcvdX1000.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfAvgPathsRcvdX1000.setDescription('The average received path batch size, multiplied by 1000.')
hostIfFctryTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 3), )
if mibBuilder.loadTexts: hostIfFctryTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfFctryTable.setDescription('Information about the factories running on each host interface.')
hostIfFctryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 3, 1), ).setIndexNames((0, "F5-3DNS-MIB", "hostAddr"), (0, "F5-3DNS-MIB", "hostIfAddr"), (0, "F5-3DNS-MIB", "hostIfFctryType"))
if mibBuilder.loadTexts: hostIfFctryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfFctryEntry.setDescription('This table gives the number of factories of each type that are running on each host interface.')
hostIfFctryType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lbRouter", 1), ("prober", 2), ("discovery", 3), ("snmp", 4), ("hops", 5), ("server", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfFctryType.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfFctryType.setDescription('The type of the factory in this row of the table.')
hostIfFctryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostIfFctryCount.setStatus('mandatory')
if mibBuilder.loadTexts: hostIfFctryCount.setDescription('The number of factories of the type corresponding to this row of the table.')
hostVServTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4), )
if mibBuilder.loadTexts: hostVServTable.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServTable.setDescription('Information about the virtual servers associated with each host.')
hostVServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1), ).setIndexNames((0, "F5-3DNS-MIB", "hostAddr"), (0, "F5-3DNS-MIB", "hostVServAddr"), (0, "F5-3DNS-MIB", "hostVServPort"))
if mibBuilder.loadTexts: hostVServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServEntry.setDescription('This table contains a row for each virtual server on each host other than load-balancing routers. It is indexed by the host address and by the address/port combination that defines the virtual server.')
hostVServAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServAddr.setDescription('The IP address of the virtual server.')
hostVServPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServPort.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServPort.setDescription('The port number of the virtual server.')
hostVServXlatedAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServXlatedAddr.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServXlatedAddr.setDescription('The translated (NAT) address of the virtual server.')
hostVServXlatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServXlatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServXlatedPort.setDescription('The translated (NAT) port number of the virtual server.')
hostVServProbeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("icmp", 1), ("tcp", 2), ("udp", 3), ("dnsnslookupDot", 4), ("dnsRetrieveBindVers", 5), ("numberItems", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServProbeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServProbeProtocol.setDescription('The probing protocol used for measuring round-trip times to the virtual server.')
hostVServPicks = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServPicks.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServPicks.setDescription('The number of times the specified virtual server has been chosen by the load-balancing DNS server.')
hostVServRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServRefreshes.setDescription('The number of times that data associated with the virtual server have been refreshed with new information.')
hostVServAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServAliveTime.setDescription('When the virtual server was last known to be up.')
hostVServDataTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServDataTime.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServDataTime.setDescription('When data was last received from the virtual server.')
hostVServDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServDisabled.setDescription('Is this virtual server disabled. If a virtual server is disabled it is considered unavailable for load balancing by 3DNS.')
hostVServDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 4, 4, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hostVServDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: hostVServDisableDuration.setDescription('Disable duration of this virtual server.')
lbDnsServTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1), )
if mibBuilder.loadTexts: lbDnsServTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServTable.setDescription('Information about the load-balancing DNS servers.')
lbDnsServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDnsServAddr"))
if mibBuilder.loadTexts: lbDnsServEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServEntry.setDescription("This table contains a row for each load-balancing DNS server, indexed by the server's canonical IP address.")
lbDnsServAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServAddr.setDescription('The canonical IP address of the load-balancing DNS server.')
lbDnsServName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServName.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServName.setDescription('The name of the load-balancing DNS server.')
lbDnsServProber = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServProber.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServProber.setDescription("The IP address of the server's prober.")
lbDnsServProbeProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("icmp", 1), ("tcp", 2), ("udp", 3), ("dnsnslookupDot", 4), ("dnsRetrieveBindVers", 5), ("numberItems", 6), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServProbeProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServProbeProtocol.setDescription('The The probing protocol used for measuring round-trip times to the server.')
lbDnsServProbePort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServProbePort.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServProbePort.setDescription('The port to which probes are directed.')
lbDnsServStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("waiting", 4), ("alert", 5), ("panic", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServStatus.setDescription('The current status of the server.')
lbDnsServPicks = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServPicks.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServPicks.setDescription('The number of times the host has been chosen.')
lbDnsServRefreshes = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServRefreshes.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServRefreshes.setDescription('The number of times the data from the server has been refreshed with new information.')
lbDnsServDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServDisabled.setDescription('Is this load-balancing DNS server disabled. If a load balancing DNS server is disabled then it is not available for load-balancing and it will not be included in any sync groups.')
lbDnsServDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServDisableDuration.setDescription('Duration of a disable of this load-balancing DNS server.')
lbDnsServIQProto = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("tcp", 1), ("udp", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIQProto.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIQProto.setDescription('Iquery protocol to use for this load-balancing DNS server.')
lbDnsServIfTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2), )
if mibBuilder.loadTexts: lbDnsServIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfTable.setDescription('Information about the network interfaces on a load-balancing DNS server.')
lbDnsServIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDnsServAddr"), (0, "F5-3DNS-MIB", "lbDnsServIfAddr"))
if mibBuilder.loadTexts: lbDnsServIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfEntry.setDescription('This table contains a row for each network interface associated with a load-balancing DNS server. It is indexed by the canonical IP address of the server and the specific IP address of the interface.')
lbDnsServIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfAddr.setDescription('The specific IP address of the network interface in this row of the table.')
lbDnsServIfShared = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfShared.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfShared.setDescription('Whether the interface is the shared IP address of the server.')
lbDnsServIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("down", 3), ("waiting", 4), ("alert", 5), ("panic", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfStatus.setDescription('The status of the network interface.')
lbDnsServIfTXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfTXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfTXPackets.setDescription('The number of packets that have been transmitted on the network interface.')
lbDnsServIfRXPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfRXPackets.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfRXPackets.setDescription('The number of packets that have been received on the network interface.')
lbDnsServIfUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfUpTime.setDescription('The amount of time the interface has been up.')
lbDnsServIfAliveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfAliveTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfAliveTime.setDescription('The most recent date and time when the interface was known to be running.')
lbDnsServIfDataTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfDataTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfDataTime.setDescription('The most recent date and time when data was transmitted through the interface.')
lbDnsServIfPathSentTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfPathSentTime.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfPathSentTime.setDescription('The date and time when path data corresponding to the interface was most recently sent.')
lbDnsServIfPathsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfPathsSent.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfPathsSent.setDescription('The number of paths sent in the most recent batch.')
lbDnsServIfPathsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfPathsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfPathsRcvd.setDescription('The number of paths received in the most recent batch.')
lbDnsServIfPathSends = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfPathSends.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfPathSends.setDescription('The number of batches of paths that have been sent.')
lbDnsServIfPathRcvs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfPathRcvs.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfPathRcvs.setDescription('The number of batches of paths that have been received.')
lbDnsServIfAvgPathsSentX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfAvgPathsSentX1000.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfAvgPathsSentX1000.setDescription('The average sent path batch size, multiplied by 1000.')
lbDnsServIfAvgPathsRcvdX1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfAvgPathsRcvdX1000.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfAvgPathsRcvdX1000.setDescription('The average received path batch size, multiplied by 1000.')
lbDnsServIfFctryTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 3), )
if mibBuilder.loadTexts: lbDnsServIfFctryTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfFctryTable.setDescription('Information about the factories running on each load-balancing DNS server interface.')
lbDnsServIfFctryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 3, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDnsServAddr"), (0, "F5-3DNS-MIB", "lbDnsServIfAddr"), (0, "F5-3DNS-MIB", "lbDnsServIfFctryType"))
if mibBuilder.loadTexts: lbDnsServIfFctryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfFctryEntry.setDescription('This table gives the number of factories of each type that are running on each load-balancing DNS server interface.')
lbDnsServIfFctryType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("lbRouter", 1), ("prober", 2), ("discovery", 3), ("snmp", 4), ("hops", 5), ("server", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfFctryType.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfFctryType.setDescription('The type of the factory in this row of the table.')
lbDnsServIfFctryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDnsServIfFctryCount.setStatus('mandatory')
if mibBuilder.loadTexts: lbDnsServIfFctryCount.setDescription('The number of factories of the type corresponding to this row of the table.')
lbDomainTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1), )
if mibBuilder.loadTexts: lbDomainTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainTable.setDescription('Information about the load-balanced domains.')
lbDomainEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDomainName"))
if mibBuilder.loadTexts: lbDomainEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainEntry.setDescription('This table contains a row for each load-balanced domain. It is indexed by the domain name.')
lbDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainName.setDescription('The domain name of the load-balanced domain in this row of the table.')
lbDomainAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAddr.setDescription('The canonical IP address of the load-balanced domain.')
lbDomainPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPort.setDescription("The load-balanced domain's default service port number.")
lbDomainTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainTTL.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainTTL.setDescription("The amount of time (in seconds) that the specified domain's information is to be used by the load-balancing DNS server for name resolution and load balancing.")
lbDomainLBModePool = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainLBModePool.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainLBModePool.setDescription('The load balancing mode to use to balance requests over all pools.')
lbDomainQosCoeffRTT = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainQosCoeffRTT.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainQosCoeffRTT.setDescription('Relative weighting for round trip time when the load balancing mode is set to Quality of Service.')
lbDomainQosCoeffHops = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainQosCoeffHops.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainQosCoeffHops.setDescription('Relative weighting for number of hops when the load balancing mode is set to Quality of Service.')
lbDomainQosCoeffTopology = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainQosCoeffTopology.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainQosCoeffTopology.setDescription('Relative weighting for topology when the load balancing mode is set to Quality of Service.')
lbDomainQosCoeffCompletionRate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainQosCoeffCompletionRate.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainQosCoeffCompletionRate.setDescription('Relative weighting for completion rate when the load balancing mode is set to Quality of Service.')
lbDomainQosCoeffPacketRate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainQosCoeffPacketRate.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainQosCoeffPacketRate.setDescription('Relative weighting for packet rate when the load balancing mode is set to Quality of Service.')
lbDomainRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainRequests.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainRequests.setDescription('The number of DNS requests for this domain.')
lbDomainPreferredResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPreferredResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPreferredResolves.setDescription('The number of times the domain has been resolved using the preferred mode.')
lbDomainAlternateResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainAlternateResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAlternateResolves.setDescription('The number of times the domain has been resolved using the alternate mode.')
lbDomainFallbackResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainFallbackResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainFallbackResolves.setDescription('The number of times the domain has been resolved using the fallback mode.')
lbDomainReturnsToDns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainReturnsToDns.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainReturnsToDns.setDescription('The number of times the domain has been resolved using standard DNS.')
lbDomainLastResolve = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 16), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainLastResolve.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainLastResolve.setDescription('When the domain was most recently resolved.')
lbDomainDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainDisabled.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainDisabled.setDescription('Is this domain disabled. If a domain is disabled then all name resolution requests are returned to DNS.')
lbDomainDisableDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 18), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainDisableDuration.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainDisableDuration.setDescription('The duration of a disable of this domain.')
lbDomainPersist = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPersist.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPersist.setDescription("When this is true this domain will maintain connections between LDNS's and virtual servers.")
lbDomainPersistTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 1, 1, 20), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPersistTTL.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPersistTTL.setDescription("The duration that the domain will maintain connections between LDNS's and virtual servers.")
lbDomainAliasTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 2), )
if mibBuilder.loadTexts: lbDomainAliasTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAliasTable.setDescription('Information about the domain names serverd by each load-balanced domain.')
lbDomainAliasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 2, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDomainName"), (0, "F5-3DNS-MIB", "lbDomainAliasIndex"))
if mibBuilder.loadTexts: lbDomainAliasEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAliasEntry.setDescription('This table contains a row for each domain name associated with a load-balanced domain. The table is indexed by the canonical domain name as well as a numeric index into the list of associated domain names.')
lbDomainAliasIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainAliasIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAliasIndex.setDescription('The index into the list of domain names.')
lbDomainAliasName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainAliasName.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAliasName.setDescription('The domain name in this row of the table.')
lbDomainAliasRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainAliasRequests.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainAliasRequests.setDescription('The number of requests for the domain name in this row of the table.')
lbDomainPortTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 3), )
if mibBuilder.loadTexts: lbDomainPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPortTable.setDescription('Information about the ports associated with a load-balanced domain.')
lbDomainPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 3, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDomainName"), (0, "F5-3DNS-MIB", "lbDomainPortPort"))
if mibBuilder.loadTexts: lbDomainPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPortEntry.setDescription('This table contains a row for each port associated with each load-balanced domain. It is indexed by the canonical domain name and by the port number.')
lbDomainPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPortPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPortPort.setDescription('A port number associated with the load-balanced domain.')
lbDomainPoolTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4), )
if mibBuilder.loadTexts: lbDomainPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolTable.setDescription('Information about the resource pools associated with each load-balanced domain.')
lbDomainPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDomainName"), (0, "F5-3DNS-MIB", "lbDomainPoolIndex"))
if mibBuilder.loadTexts: lbDomainPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolEntry.setDescription('This table contains a row for each resource pool associated with each load-balanced domain. It is indexed by the canonical domain name as well as by a numeric index specifying the resource pool.')
lbDomainPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolIndex.setDescription('A numeric index into the list of resource pools for this domain.')
lbDomainPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolName.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolName.setDescription('The name of the resource pool in this row of the table.')
lbDomainPoolType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("lbRouter", 2), ("host", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolType.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolType.setDescription('The type of the resource pool.')
lbDomainPoolState = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("preferred", 2), ("alternate", 3), ("fallback", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolState.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolState.setDescription('The current state of the pool.')
lbDomainPoolVSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolVSCount.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSCount.setDescription('The number of virtual servers in the pool.')
lbDomainPoolLBMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolLBMode.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolLBMode.setDescription('The preferred load-balancing mode for the pool.')
lbDomainPoolAlternateLBMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolAlternateLBMode.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolAlternateLBMode.setDescription('The alternate load-balancing mode for the pool.')
lbDomainPoolFallbackLBMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("returnDNS", 1), ("none", 2), ("returnVS", 3), ("roundRobin", 4), ("ratio", 5), ("random", 6), ("topology", 7), ("staticPersist", 8), ("globalAvailability", 9), ("servers", 10), ("connections", 11), ("roundTripTime", 12), ("hops", 13), ("packetRate", 14), ("mem", 15), ("cpu", 16), ("diskSpace", 17), ("hitRatio", 18), ("qos", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolFallbackLBMode.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolFallbackLBMode.setDescription('The fallback load-balancing mode for the pool.')
lbDomainPoolCheckStaticDepends = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolCheckStaticDepends.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolCheckStaticDepends.setDescription('Indicates whether the availability of virtual servers in the pool is checked.')
lbDomainPoolCheckDynamicDepends = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolCheckDynamicDepends.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolCheckDynamicDepends.setDescription('Indicates whether the availability of paths associated with the pool is checked.')
lbDomainPoolRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolRatio.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolRatio.setDescription('The default weighting to use with respect to other pools.')
lbDomainPoolRipeness = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolRipeness.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolRipeness.setDescription('The counter used to determine whether the pool can be chosen during load balancing when the pool_lbmode is ratio. It is initialized to the pool ratio value, and decremented each time the pool is chosen. When non-zero the pool can be chosen. When zero, the pool will be skipped. When all pools reach zero ripeness, all pool ripeness values are re-initialized to their ratio values.')
lbDomainPoolPreferredResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolPreferredResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolPreferredResolves.setDescription('The number of times the pool has been resolved using the preferred mode.')
lbDomainPoolAlternateResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolAlternateResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolAlternateResolves.setDescription('The number of times the pool has been resolved using the alternate mode.')
lbDomainPoolFallbackResolves = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolFallbackResolves.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolFallbackResolves.setDescription('The number of times the pool has been resolved using the fallback mode.')
lbDomainPoolReturnsToDns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolReturnsToDns.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolReturnsToDns.setDescription('The number of times the pool has been resolved using standard DNS.')
lbDomainPoolRRLdns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolRRLdns.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolRRLdns.setDescription('Enables passing of blocks of ip addresses back to local dns servers.')
lbDomainPoolRRLdnsLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 4, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolRRLdnsLimit.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolRRLdnsLimit.setDescription('The limit of the number of addresses to be passed back in an rr_ldns block. There will be no limit if this attribute is 0.')
lbDomainPoolVSTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5), )
if mibBuilder.loadTexts: lbDomainPoolVSTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSTable.setDescription('Information about the virtual servers in each resource pool.')
lbDomainPoolVSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5, 1), ).setIndexNames((0, "F5-3DNS-MIB", "lbDomainName"), (0, "F5-3DNS-MIB", "lbDomainPoolIndex"), (0, "F5-3DNS-MIB", "lbDomainPoolVSAddr"), (0, "F5-3DNS-MIB", "lbDomainPoolVSPort"))
if mibBuilder.loadTexts: lbDomainPoolVSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSEntry.setDescription('This table contains a row for each virtual server in each resource pool associated with each load-balanced domain.')
lbDomainPoolVSAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolVSAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSAddr.setDescription('The IP address of the virtual server.')
lbDomainPoolVSPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolVSPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSPort.setDescription('The port number of the virtual server.')
lbDomainPoolVSRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolVSRatio.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSRatio.setDescription('The weighting to use with respect to other virtual servers in the pool.')
lbDomainPoolVSRipeness = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 6, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbDomainPoolVSRipeness.setStatus('mandatory')
if mibBuilder.loadTexts: lbDomainPoolVSRipeness.setDescription('The counter used to determine whether the VS can be chosen during load balancing when the lbmode is ratio. It is initialized to the VS ratio value as specified in the pool, and decremented each time the VS is chosen. When non-zero the VS can be chosen. When zero, the VS will be skipped. When all VS reach zero ripeness, all VS ripeness values are re-initialized to their ratio values.')
summaryVersion = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryVersion.setStatus('mandatory')
if mibBuilder.loadTexts: summaryVersion.setDescription('The version number of the system.')
summaryUpTime = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: summaryUpTime.setDescription('The elapsed time since the system was last initialized.')
summaryDate = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryDate.setStatus('mandatory')
if mibBuilder.loadTexts: summaryDate.setDescription("The system's notion of the local date and time of day.")
summaryLastReload = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryLastReload.setStatus('mandatory')
if mibBuilder.loadTexts: summaryLastReload.setDescription('The value of summaryUpTime when the system was most recently commanded to reload its DNS database.')
summaryLastDump = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryLastDump.setStatus('mandatory')
if mibBuilder.loadTexts: summaryLastDump.setDescription('The value of summaryUpTime when the system was most recently commanded to dump its database, cache, and status information.')
summaryRequests = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryRequests.setStatus('mandatory')
if mibBuilder.loadTexts: summaryRequests.setDescription('The total number of requests received.')
summarySyncMode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncMode.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncMode.setDescription('Whether the system is a primary 3DNS, secondary 3DNS, or neither.')
summarySyncFile = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncFile.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncFile.setDescription('The pathname of the file to which sync dumps are written. Valid only if summarySyncMode is primary.')
summarySyncIns = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncIns.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncIns.setDescription('The total number of incoming syncs performed.')
summarySyncInErrors = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncInErrors.setDescription('The total number of errors encountered when performing incoming syncs.')
summaryLastSyncIn = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryLastSyncIn.setStatus('mandatory')
if mibBuilder.loadTexts: summaryLastSyncIn.setDescription('The value of summaryUpTime when the most recent incoming sync was performed.')
summarySyncOuts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncOuts.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncOuts.setDescription('The total number of outgoing syncs performed.')
summarySyncOutErrors = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summarySyncOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: summarySyncOutErrors.setDescription('The total number of errors encountered when performing outgoing syncs.')
summaryLastSyncOut = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 2, 1, 1, 7, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: summaryLastSyncOut.setStatus('mandatory')
if mibBuilder.loadTexts: summaryLastSyncOut.setDescription('The value of summaryUpTime when the most recent outgoing sync was performed.')
threednsTrapVSGreenToRed = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2) + (0,1))
if mibBuilder.loadTexts: threednsTrapVSGreenToRed.setDescription('Virtual server change from green to red status.')
threednsTrapVSRedToGreen = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2) + (0,2))
if mibBuilder.loadTexts: threednsTrapVSRedToGreen.setDescription('Virtual server change from red to green status.')
threednsTrapServerRedToGreen = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2) + (0,3))
if mibBuilder.loadTexts: threednsTrapServerRedToGreen.setDescription('Server change from red to green status.')
threednsTrapServerGreenToRed = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2) + (0,4))
if mibBuilder.loadTexts: threednsTrapServerGreenToRed.setDescription('Server change from green to red status.')
threednsTrapCRCFailure = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 2, 2, 2) + (0,5))
if mibBuilder.loadTexts: threednsTrapCRCFailure.setDescription('CRC failure.')
mibBuilder.exportSymbols("F5-3DNS-MIB", summaryRequests=summaryRequests, hostIfPathSends=hostIfPathSends, hostTable=hostTable, lbRouterVServProbeProtocol=lbRouterVServProbeProtocol, lbDnsServStatus=lbDnsServStatus, lbDnsServIQProto=lbDnsServIQProto, hostSNMPConfigured=hostSNMPConfigured, f5systems=f5systems, hostIfAliveTime=hostIfAliveTime, summarySyncIns=summarySyncIns, lbDomainAddr=lbDomainAddr, hostIfFctryType=hostIfFctryType, lbDomainPortPort=lbDomainPortPort, globalCoeffDRTT=globalCoeffDRTT, f53dnsMIBObjects=f53dnsMIBObjects, globalQosFactorHops=globalQosFactorHops, hostProber=hostProber, globalQosCoeffTopology=globalQosCoeffTopology, lbDnsServProber=lbDnsServProber, globalPathLoWater=globalPathLoWater, threednsTrap=threednsTrap, hostSNMPCommunity=hostSNMPCommunity, lbDnsServRefreshes=lbDnsServRefreshes, lbRouterIfTXPackets=lbRouterIfTXPackets, globalPathDuration=globalPathDuration, globalRTTPacketLength=globalRTTPacketLength, globalRTTSampleCount=globalRTTSampleCount, globalPathHiWater=globalPathHiWater, hostIfUpTime=hostIfUpTime, lbRouterVServPicks=lbRouterVServPicks, globalTimerKeepAlive=globalTimerKeepAlive, globalFbRespectDepends=globalFbRespectDepends, lbDomainPoolVSRatio=lbDomainPoolVSRatio, dataCenterTable=dataCenterTable, lbDomainPoolReturnsToDns=lbDomainPoolReturnsToDns, dataCenterEntry=dataCenterEntry, hostIfAvgPathsSentX1000=hostIfAvgPathsSentX1000, lbDomainQosCoeffRTT=lbDomainQosCoeffRTT, lbDnsServIfFctryType=lbDnsServIfFctryType, summaryDate=summaryDate, lbRouterVServDataTime=lbRouterVServDataTime, hostVServTable=hostVServTable, lbDnsServIfShared=lbDnsServIfShared, lbDnsServIfFctryTable=lbDnsServIfFctryTable, hostIfEntry=hostIfEntry, lbDomainPoolCheckStaticDepends=lbDomainPoolCheckStaticDepends, globalCoeffAccessRefresh=globalCoeffAccessRefresh, lbDomainQosCoeffPacketRate=lbDomainQosCoeffPacketRate, globalPathReapAlg=globalPathReapAlg, lbDomainPoolType=lbDomainPoolType, globalTxBufSize=globalTxBufSize, lbRouterIfFctryEntry=lbRouterIfFctryEntry, hostIfTable=hostIfTable, lbDomainPoolLBMode=lbDomainPoolLBMode, lbDnsServIfAliveTime=lbDnsServIfAliveTime, lbDomainPoolRatio=lbDomainPoolRatio, lbDomainTable=lbDomainTable, globalCoeffDCompletionRate=globalCoeffDCompletionRate, threednsTrapServerGreenToRed=threednsTrapServerGreenToRed, hostVServPicks=hostVServPicks, lbRouterIfAliveTime=lbRouterIfAliveTime, summarySyncMode=summarySyncMode, lbDomainPoolVSPort=lbDomainPoolVSPort, f5=f5, lbRouterIQProto=lbRouterIQProto, globalEncryptionKeyFile=globalEncryptionKeyFile, globalLBRouterTTL=globalLBRouterTTL, lbDomainQosCoeffHops=lbDomainQosCoeffHops, summarySyncFile=summarySyncFile, hostPicks=hostPicks, lbRouterVServAddr=lbRouterVServAddr, lbDomainPreferredResolves=lbDomainPreferredResolves, globalQosFactorRTT=globalQosFactorRTT, globalRTTProbeProtocol=globalRTTProbeProtocol, lbRouterIfAddr=lbRouterIfAddr, lbRouterIfFctryTable=lbRouterIfFctryTable, lbDnsServIfAddr=lbDnsServIfAddr, summarySyncInErrors=summarySyncInErrors, hostVServProbeProtocol=hostVServProbeProtocol, hostIfStatus=hostIfStatus, globalQosFactorPacketRate=globalQosFactorPacketRate, globalCheckStaticDepends=globalCheckStaticDepends, threednsTrapCRCFailure=threednsTrapCRCFailure, lbDomainTTL=lbDomainTTL, hostDisableDuration=hostDisableDuration, globalVSTTL=globalVSTTL, lbDomainPoolFallbackLBMode=lbDomainPoolFallbackLBMode, lbRouterIfStatus=lbRouterIfStatus, lbRouters=lbRouters, globalUseAltIqPort=globalUseAltIqPort, lbDnsServIfFctryEntry=lbDnsServIfFctryEntry, hostSNMPAgentType=hostSNMPAgentType, lbRouterAddr=lbRouterAddr, hostSNMPPort=hostSNMPPort, lbRouterVServDisableDuration=lbRouterVServDisableDuration, dataCenterLocation=dataCenterLocation, hostIfPathSentTime=hostIfPathSentTime, lbDnsServName=lbDnsServName, globalCheckDynamicDepends=globalCheckDynamicDepends, lbRouterIfEntry=lbRouterIfEntry, threednsTrapServerRedToGreen=threednsTrapServerRedToGreen, hostSNMPTimeout=hostSNMPTimeout, lbDomainQosCoeffTopology=lbDomainQosCoeffTopology, lbDomainAliasEntry=lbDomainAliasEntry, threednsTrapVSGreenToRed=threednsTrapVSGreenToRed, hostIfFctryEntry=hostIfFctryEntry, summarySyncOutErrors=summarySyncOutErrors, lbDnsServIfUpTime=lbDnsServIfUpTime, hostVServAliveTime=hostVServAliveTime, lbDomainLastResolve=lbDomainLastResolve, hostMetrics=hostMetrics, globalResolverTXBufSize=globalResolverTXBufSize, globalTimerGetLBRouterData=globalTimerGetLBRouterData, lbRouterVServCurConnLimit=lbRouterVServCurConnLimit, lbDomainLBModePool=lbDomainLBModePool, lbRouterVServEntry=lbRouterVServEntry, globalQosCoeffCompletionRate=globalQosCoeffCompletionRate, lbRouterIfDataTime=lbRouterIfDataTime, lbRouterIfAvgPathsRcvdX1000=lbRouterIfAvgPathsRcvdX1000, globalCoeffLastAccess=globalCoeffLastAccess, globalQosFactorCompletionRate=globalQosFactorCompletionRate, lbRouterVServXlatedPort=lbRouterVServXlatedPort, hostSNMPRetries=hostSNMPRetries, lbDnsServAddr=lbDnsServAddr, summaryVersion=summaryVersion, lbDomainPoolEntry=lbDomainPoolEntry, lbDnsServIfPathsRcvd=lbDnsServIfPathsRcvd, hostVServPort=hostVServPort, lbRouterIfTable=lbRouterIfTable, globalQosFactorTopology=globalQosFactorTopology, lbRouterVServPort=lbRouterVServPort, globalRTTProbeDynamic=globalRTTProbeDynamic, lbRouterVServCurConns=lbRouterVServCurConns, dataCenterServAddr=dataCenterServAddr, lbDnsServProbePort=lbDnsServProbePort, lbRouterIfPathRcvs=lbRouterIfPathRcvs, lbDomainPoolVSRipeness=lbDomainPoolVSRipeness, summaryLastSyncIn=summaryLastSyncIn, lbRouterEntry=lbRouterEntry, hostIfAvgPathsRcvdX1000=hostIfAvgPathsRcvdX1000, hostProbeProtocol=hostProbeProtocol, globalRTTProbeProtocolList=globalRTTProbeProtocolList, hostMemory=hostMemory, threednsTraps=threednsTraps, lbRouterIfFctryCount=lbRouterIfFctryCount, lbDnsServIfPathsSent=lbDnsServIfPathsSent, lbDomainPoolVSCount=lbDomainPoolVSCount, globalResetCounterTime=globalResetCounterTime, lbRouterVServAliveTime=lbRouterVServAliveTime, globalRTTDiscoveryMethod=globalRTTDiscoveryMethod, lbDomainPortEntry=lbDomainPortEntry, hostVServXlatedAddr=hostVServXlatedAddr, hostIfShared=hostIfShared, lbRouterIfAvgPathsSentX1000=lbRouterIfAvgPathsSentX1000, hostVServDisabled=hostVServDisabled, lbDnsServIfTable=lbDnsServIfTable, lbDnsServIfAvgPathsSentX1000=lbDnsServIfAvgPathsSentX1000, lbDomainPoolIndex=lbDomainPoolIndex, lbDomainPoolTable=lbDomainPoolTable, hosts=hosts, globalQosCoeffRTT=globalQosCoeffRTT, lbRouterVServDnsServDisabled=lbRouterVServDnsServDisabled, globalTimerGetVServData=globalTimerGetVServData, lbRouterVServCount=lbRouterVServCount, summaryLastDump=summaryLastDump, lbDomainName=lbDomainName, lbDnsServEntry=lbDnsServEntry, lbDnsServIfEntry=lbDnsServIfEntry, hostIfDataTime=hostIfDataTime, lbRouterVServCurNodesUp=lbRouterVServCurNodesUp, lbDomainFallbackResolves=lbDomainFallbackResolves, lbDnsServIfPathSends=lbDnsServIfPathSends, summaryLastSyncOut=summaryLastSyncOut, lbRouterDisableDuration=lbRouterDisableDuration, hostName=hostName, globalProberAddr=globalProberAddr, lbDomainPoolRipeness=lbDomainPoolRipeness, lbDnsServIfRXPackets=lbDnsServIfRXPackets, f53dns=f53dns, hostDisabled=hostDisabled, hostIfPathRcvs=hostIfPathRcvs, hostProbePort=hostProbePort, globalRTTPortDiscovery=globalRTTPortDiscovery, hostRefreshes=hostRefreshes, lbDnsServIfStatus=lbDnsServIfStatus, lbRouterIfShared=lbRouterIfShared, dataCenterDisabled=dataCenterDisabled, globalHostTTL=globalHostTTL, lbDnsServIfPathSentTime=lbDnsServIfPathSentTime, lbDomainPoolVSTable=lbDomainPoolVSTable, lbRouterIfFctryType=lbRouterIfFctryType, globalDefaultTTL=globalDefaultTTL, lbDomainAliasIndex=lbDomainAliasIndex, dataCenterContact=dataCenterContact, lbRouterVServTable=lbRouterVServTable, lbDnsServs=lbDnsServs, lbRouterRefreshes=lbRouterRefreshes, lbDnsServIfDataTime=lbDnsServIfDataTime, globalDefaultAlternate=globalDefaultAlternate, lbDomainEntry=lbDomainEntry, dataCenterDisableDuration=dataCenterDisableDuration, lbDnsServDisableDuration=lbDnsServDisableDuration, hostSNMPAddress=hostSNMPAddress, lbRouterIfUpTime=lbRouterIfUpTime, lbRouterIfPacketRate=lbRouterIfPacketRate, lbRouterTable=lbRouterTable, globalCoeffFreshRemain=globalCoeffFreshRemain, globalDefaultFallback=globalDefaultFallback, lbDomainPoolName=lbDomainPoolName, hostIfFctryCount=hostIfFctryCount, globalTimerGetHostData=globalTimerGetHostData, lbDomainDisabled=lbDomainDisabled, dataCenterServTable=dataCenterServTable, globalMultiplexIq=globalMultiplexIq, hostIfTXPackets=hostIfTXPackets, dataCenters=dataCenters, summaryLastReload=summaryLastReload, f53dnsMIB=f53dnsMIB, hostVServCount=hostVServCount, lbDomainQosCoeffCompletionRate=lbDomainQosCoeffCompletionRate, globalPathTTL=globalPathTTL, lbDnsServIfFctryCount=lbDnsServIfFctryCount, lbDomainAliasRequests=lbDomainAliasRequests, lbRouterVServCurEnabled=lbRouterVServCurEnabled, lbDomainAlternateResolves=lbDomainAlternateResolves, lbDomainPoolPreferredResolves=lbDomainPoolPreferredResolves, lbDomainReturnsToDns=lbDomainReturnsToDns, lbDomainPoolAlternateResolves=lbDomainPoolAlternateResolves, lbDomainPoolRRLdnsLimit=lbDomainPoolRRLdnsLimit, globalRTTTimeout=globalRTTTimeout, globalEncryption=globalEncryption, dataCenterName=dataCenterName, lbDomainPortTable=lbDomainPortTable, globalRegulatePaths=globalRegulatePaths, lbDomainPoolCheckDynamicDepends=lbDomainPoolCheckDynamicDepends, lbDomainAliasTable=lbDomainAliasTable, lbDnsServIfPathRcvs=lbDnsServIfPathRcvs, lbDomains=lbDomains, globalFbRespectAcl=globalFbRespectAcl, lbRouterIfPathSends=lbRouterIfPathSends, hostVServDataTime=hostVServDataTime, globalLDnsHiWater=globalLDnsHiWater, hostIfFctryTable=hostIfFctryTable, lbRouterIfRXPackets=lbRouterIfRXPackets, hostIfPathsSent=hostIfPathsSent, dataCenterServType=dataCenterServType, summary=summary, hostVServRefreshes=hostVServRefreshes, lbDnsServIfTXPackets=lbDnsServIfTXPackets, globalPathsNoClobber=globalPathsNoClobber, globalQosCoeffPacketRate=globalQosCoeffPacketRate, hostIfRXPackets=hostIfRXPackets, lbRouterIfPathsRcvd=lbRouterIfPathsRcvd, globalRegulateInit=globalRegulateInit)
mibBuilder.exportSymbols("F5-3DNS-MIB", globalLDnsLoWater=globalLDnsLoWater, lbRouterPicks=lbRouterPicks, hostStatus=hostStatus, globalResetCounters=globalResetCounters, lbRouterDisabled=lbRouterDisabled, summarySyncOuts=summarySyncOuts, lbDomainPort=lbDomainPort, lbDomainPoolAlternateLBMode=lbDomainPoolAlternateLBMode, lbDomainPoolVSEntry=lbDomainPoolVSEntry, lbDomainPoolRRLdns=lbDomainPoolRRLdns, globalRxBufSize=globalRxBufSize, lbDomainPoolVSAddr=lbDomainPoolVSAddr, globalQosCoeffHops=globalQosCoeffHops, globalCoeffAccessTotal=globalCoeffAccessTotal, lbDnsServDisabled=lbDnsServDisabled, lbRouterIfPathsSent=lbRouterIfPathsSent, dataCenterPathCount=dataCenterPathCount, hostCPU=hostCPU, lbDomainPersist=lbDomainPersist, globalTimerGetPathData=globalTimerGetPathData, hostVServEntry=hostVServEntry, lbRouterIfPathSentTime=lbRouterIfPathSentTime, globals=globals, lbRouterVServXlatedAddr=lbRouterVServXlatedAddr, hostVServAddr=hostVServAddr, hostDiskSpace=hostDiskSpace, hostIfPathsRcvd=hostIfPathsRcvd, lbDomainPersistTTL=lbDomainPersistTTL, lbDnsServIfAvgPathsRcvdX1000=lbDnsServIfAvgPathsRcvdX1000, lbDomainPoolFallbackResolves=lbDomainPoolFallbackResolves, globalResolverRXBufSize=globalResolverRXBufSize, lbDnsServProbeProtocol=lbDnsServProbeProtocol, globalRTTRetireZero=globalRTTRetireZero, lbRouterName=lbRouterName, lbDnsServTable=lbDnsServTable, lbRouterVServRefreshes=lbRouterVServRefreshes, summaryUpTime=summaryUpTime, globalPathsNeverDie=globalPathsNeverDie, lbDomainDisableDuration=lbDomainDisableDuration, lbDomainPoolState=lbDomainPoolState, hostVServDisableDuration=hostVServDisableDuration, hostVServXlatedPort=hostVServXlatedPort, lbDnsServPicks=lbDnsServPicks, threednsTrapVSRedToGreen=threednsTrapVSRedToGreen, globalLDnsReapAlg=globalLDnsReapAlg, hostEntry=hostEntry, lbDomainAliasName=lbDomainAliasName, dataCenterServEntry=dataCenterServEntry, hostIfAddr=hostIfAddr, globalRTTProbeProtocolState=globalRTTProbeProtocolState, globalLDnsDuration=globalLDnsDuration, globalPersistLDns=globalPersistLDns, hostSNMPVersion=hostSNMPVersion, hostAddr=hostAddr, lbDomainRequests=lbDomainRequests)

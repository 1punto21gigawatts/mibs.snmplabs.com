#
# PySNMP MIB module XPNNI-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/XPNNI-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:44:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Integer32, Counter32, MibIdentifier, Gauge32, Counter64, ObjectIdentity, iso, Bits, Unsigned32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Integer32", "Counter32", "MibIdentifier", "Gauge32", "Counter64", "ObjectIdentity", "iso", "Bits", "Unsigned32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
xylanPnni, = mibBuilder.importSymbols("XYLAN-BASE-MIB", "xylanPnni")
pnnixMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1))
pnnixMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1))
class PnnixAtmAddr(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class PnnixNodeIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class InterfaceIndex(Integer32):
    pass

class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class AtmpTrafficDescrParamIndex(Integer32):
    pass

class PnnixNodeId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(22, 22)
    fixedLength = 22

class PnnixPortId(Gauge32):
    pass

class PnnixAggrToken(Gauge32):
    pass

class PnnixPeerGroupId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(14, 14)
    fixedLength = 14

class PnnixLevel(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 104)

class PnnixSvccRccIndex(Integer32):
    pass

class AtmAddrPrefix(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(19, 19)
    fixedLength = 19

class PnnixPrefixLength(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 152)

class PnnixMetricsTag(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class ServiceCategory(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("other", 1), ("cbr", 2), ("rtVbr", 3), ("nrtVbr", 4), ("abr", 5), ("ubr", 6))

class ClpType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("clpEqual0", 1), ("clpEqual0Or1", 2))

class TnsType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 8))
    namedValues = NamedValues(("nationalNetworkIdentification", 2), ("other", 8))

class TnsPlan(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 16))
    namedValues = NamedValues(("carrierIdentificationCode", 1), ("other", 16))

class PnnixVersion(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("unsupported", 1), ("version1point0", 2))

class PnnixHelloState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("notApplicable", 1), ("down", 2), ("attempt", 3), ("oneWayInside", 4), ("twoWayInside", 5), ("oneWayOutside", 6), ("twoWayOutside", 7), ("commonOutside", 8))

pnnixBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1))
pnnixHighestVersion = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 1), PnnixVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixHighestVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixHighestVersion.setDescription('The highest version of the PNNI protocol that the software in this switching system is capable of executing.')
pnnixLowestVersion = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 2), PnnixVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLowestVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLowestVersion.setDescription('The lowest version of the PNNI Protocol that the software in this switching system is capable of executing.')
pnnixDtlCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixDtlCountOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDtlCountOriginator.setDescription('The total number of DTL stacks that this switching system has originated as the DTLOriginator and placed into signalling messages. This includes the initial DTL stacks computed by this system as well as any alternate route (second, third choice etc.) DTL stacks computed by this switching system in response to crankbacks.')
pnnixDtlCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixDtlCountBorder.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDtlCountBorder.setDescription('The number of partial DTL stacks that this switching system has added into signalling messages as an entry border node. This includes the initial partial DTL stacks computed by this system as well as any alternate route (second, third choice etc.) partial DTL stacks computed by this switching system in response to crankbacks.')
pnnixCrankbackCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixCrankbackCountOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixCrankbackCountOriginator.setDescription('The count of the total number of connection setup messages including DTL stacks originated by this switching system that have cranked back to this switching system at all levels of the hierarchy.')
pnnixCrankbackCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixCrankbackCountBorder.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixCrankbackCountBorder.setDescription('The count of the total number of connection setup messages including DTLs added by this switching system as an entry border node that have cranked back to this switching system at all levels of the hierarchy. This count does not include Crankbacks for which this switching system was not the crankback destination, only those crankbacks that were directed to this switching system are counted here.')
pnnixAltRouteCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixAltRouteCountOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixAltRouteCountOriginator.setDescription('The total number of alternate DTL stacks that this switching system has computed and placed into signalling messages as the DTLOriginator.')
pnnixAltRouteCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixAltRouteCountBorder.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixAltRouteCountBorder.setDescription('The total number of alternate partial DTL stacks that this switching system has computed and placed into signalling messages as an entry border node.')
pnnixRouteFailCountOriginator = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteFailCountOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteFailCountOriginator.setDescription('The total number of times where the switching system failed to compute a viable DTL stack as the DTLOriginator for some call. It indicates the number of times a call was cleared from this switching system due to originator routing failure.')
pnnixRouteFailCountBorder = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteFailCountBorder.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteFailCountBorder.setDescription('The total number of times where the switching system failed to compute a viable partial DTL stack as an entry border node for some call. It indicates the number of times a call was either cleared or cranked back from this switching system due to border routing failure.')
pnnixRouteFailUnreachableOriginator = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteFailUnreachableOriginator.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteFailUnreachableOriginator.setDescription("The total number of times where the switching system failed to compute a viable DTL stack as the DTLOriginator because the destination was unreachable, i.e., those calls that are cleared with cause #2 `specified transit network unreachable' or cause #3 `destination unreachable' in the cause IE.")
pnnixRouteFailUnreachableBorder = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteFailUnreachableBorder.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteFailUnreachableBorder.setDescription("The total number of times where the switching system failed to compute a viable partial DTL stack as an entry border node because the target of the path calculation was unreachable, i.e., those calls that are cleared or cranked back with cause #2 `specified transit network unreachable' or cause #3 `destination unreachable' in the cause IE.")
pnnixNodeTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2), )
if mibBuilder.loadTexts: pnnixNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeTable.setDescription('The pnnixNodeTable collects attributes that affect the operation of a PNNI logical node. There is a single row in this table for each PNNI peer group that the managed system is expected or eligible to become a member of.')
pnnixNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"))
if mibBuilder.loadTexts: pnnixNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
pnnixNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 1), PnnixNodeIndex())
if mibBuilder.loadTexts: pnnixNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeIndex.setDescription('A value assigned to a node in this switching system that uniquely identifies it in the MIB.')
pnnixNodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 2), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeLevel.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeLevel.setDescription('The level of PNNI hierarchy at which this node exists. This attribute is used to determine the default node ID and the default peer group ID for this node. This object may only be written when pnnixNodeAdminStatus has the value down.')
pnnixNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 3), PnnixNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeId.setDescription('The value the switching system is using to represent itself as this node. This object may only be written when pnnixNodeAdminStatus has the value down. If pnnixNodeLowest is true, then the default node ID takes the form defined in Section 5.3.3 for lowest level nodes, with the first octet equal to pnnixNodeLevel, the second octet equal to 160, and the last 20 octets equal to pnnixNodeAtmAddress. If pnnixNodeLowest is false, then the default node ID takes the form defined in Section 5.3.3 for logical group nodes, with the first octet equal to pnnixNodeLevel, the next fourteen octets equal to the value of pnnixNodePeerGroupId for the child node whose election as PGL causes this LGN to be instantiated, the next six octets equal to the ESI of pnnixNodeAtmAddress, and the last octet equal to zero.')
pnnixNodeLowest = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeLowest.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeLowest.setDescription("Indicates whether this node acts as a lowest level node or whether this node is a logical group node that becomes active when one of the other nodes in this switching system becomes a peer group leader. The value 'false' must not be used with nodes that are not PGL/LGN capable. This object may only be written when pnnixNodeAdminStatus has the value down.")
pnnixNodeAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeAdminStatus.setDescription('Indicates whether the administrative status of the node is up (the node is allowed to become active) or down (the node is forced to be inactive). When pnnixNodeAdminStatus is down, then pnnixNodeOperStatus must also be down.')
pnnixNodeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodeOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeOperStatus.setDescription('Indicates whether the node is active or whether the node has yet to become operational. When the value is down, all state has been cleared from the node and the node is not communicating with any of its neighbor nodes.')
pnnixNodeDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeDomainName.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeDomainName.setDescription('The name of the PNNI routing domain in which this node participates. All lowest-level PNNI nodes with the same pnnixNodeDomainName are presumed to be connected.')
pnnixNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 8), PnnixAtmAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeAtmAddress.setDescription("This node's ATM End System Address. Remote systems wishing to exchange PNNI protocol packets with this node should direct packets or calls to this address. This attribute may only be written when pnnixNodeAdminStatus has the value down.")
pnnixNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 9), PnnixPeerGroupId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePeerGroupId.setDescription('The Peer Group Identifier of the peer group that the given node is to become a member of. The default value of this attribute has the first octet equal to pnnixNodeLevel, the next pnnixNodeLevel bits equal to the pnnixNodeLevel bits starting from the third octet of pnnixNodeId, and the remainder padded with zeros. This object may only be written when pnnixNodeAdminStatus has the value down.')
pnnixNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeRestrictedTransit.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeRestrictedTransit.setDescription('Specifies whether the node is restricted to not allowing support of SVCs transiting this node. This attribute determines the setting of the restricted transit bit in the nodal information group originated by this node.')
pnnixNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeComplexRep.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeComplexRep.setDescription("Specifies whether this node uses the complex node representation. A value of `true' indicates that the complex node representation is used, whereas a value of `false' indicates that the simple node representation is used. This attribute determines the setting of the nodal representation bit in the nodal information group originated by this node.")
pnnixNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodeRestrictedBranching.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeRestrictedBranching.setDescription("Indicates whether the node is able to support additional point-to-multipoint branches. A value of 'false' indicates that additional branches can be supported, and a value of 'true' indicates that additional branches cannot be supported. This attribute reflects the setting of the restricted branching bit in the nodal information group originated by this node.")
pnnixNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodeDatabaseOverload.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeDatabaseOverload.setDescription('Specifies whether the node is currently operating in topology database overload state. This attribute has the same value as the Non-transit for PGL Election bit in the nodal information group originated by this node.')
pnnixNodePtses = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodePtses.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePtses.setDescription("Gauges the total number of PTSEs currently in this node's topology database(s).")
pnnixNodeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeRowStatus.setDescription('To create, delete, activate and de-activate a Node.')
pnnixNodePglTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3), )
if mibBuilder.loadTexts: pnnixNodePglTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglTable.setDescription('Peer group leader election information for a PNNI node in this switching system.')
pnnixNodePglEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"))
if mibBuilder.loadTexts: pnnixNodePglEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglEntry.setDescription('An entry in the table, containing PGL election information of a PNNI logical node in this switching system.')
pnnixNodePglLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 205))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePglLeadershipPriority.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglLeadershipPriority.setDescription('The Leadership priority value this node should advertise in its nodal information group for the given peer group. Only the value zero can be used with nodes that are not PGL/LGN capable. If there is no configured parent node index or no corresponding entry in the pnnixNodeTable, then the advertised leadership priority is zero regardless of this value.')
pnnixNodeCfgParentNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 2), PnnixNodeIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeCfgParentNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeCfgParentNodeIndex.setDescription('The local node index used to identify the node that will represent this peer group at the next higher level of hierarchy, if this node becomes peer group leader. The value 0 indicates that there is no parent node.')
pnnixNodePglInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePglInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglInitTime.setDescription('The amount of time in seconds this node will delay advertising its choice of preferred PGL after having initialized operation and reached the full state with at least one neighbor in the peer group.')
pnnixNodePglOverrideDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePglOverrideDelay.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglOverrideDelay.setDescription('The amount of time in seconds a node will wait for itself to be declared the preferred PGL by unanimous agreement among its peers. In the absence of unanimous agreement this will be the amount of time that will pass before this node considers a two thirds majority as sufficient agreement to declare itself peer group leader, abandoning the attempt to get unanimous agreement.')
pnnixNodePglReelectTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePglReelectTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglReelectTime.setDescription('The amount of time in seconds after losing connectivity to the current peer group leader, that this node will wait before re-starting the process of electing a new peer group leader.')
pnnixNodePglState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("starting", 1), ("awaiting", 2), ("awaitingFull", 3), ("initialDelay", 4), ("calculating", 5), ("awaitUnanimity", 6), ("operPgl", 7), ("operNotPgl", 8), ("hungElection", 9), ("awaitReElection", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodePglState.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglState.setDescription("Indicates the state that this node is in with respect to the Peer Group Leader election that takes place in the node's peer group. The values are enumerated in the Peer Group Leader State Machine.")
pnnixNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 7), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodePreferredPgl.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePreferredPgl.setDescription("The Node ID of the node which the local node believes should be or become the peer group leader. This is also the value the local node is currently advertising in the `Preferred Peer Group Leader Node ID' field of its nodal information group within the given peer group. If a Preferred PGL has not been chosen, this attribute's value is set to (all) zero(s).")
pnnixNodePeerGroupLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 8), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodePeerGroupLeader.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePeerGroupLeader.setDescription("The Node Identifier of the node which is currently operating as peer group leader of the peer group this node belongs to. If a PGL has not been elected, this attribute's value is set to (all) zero(s).")
pnnixNodePglTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodePglTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePglTimeStamp.setDescription('The time at which the current Peer Group Leader established itself.')
pnnixNodeActiveParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 3, 1, 10), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNodeActiveParentNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeActiveParentNodeId.setDescription('The Node Identifier value being used by the Peer Group Leader to represent this peer group at the next higher level of the hierarchy. If this node is at the highest level of the hierarchy or if no PGL has yet been elected the PNNI Protocol Entity sets the value of this attribute to (all) zero(s).')
pnnixNodeTimerTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4), )
if mibBuilder.loadTexts: pnnixNodeTimerTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeTimerTable.setDescription('A table of initial PNNI timer values and significant change thresholds.')
pnnixNodeTimerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"))
if mibBuilder.loadTexts: pnnixNodeTimerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeTimerEntry.setDescription('An entry in the table, containing initial PNNI timer values and significant change thresholds of a PNNI logical node in this switching system.')
pnnixNodePtseHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePtseHolddown.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePtseHolddown.setDescription('The initial value for the PTSE hold down timer that will be used by the given node to limit the rate at which it can re-originate PTSEs. It must be a positive non-zero number.')
pnnixNodeHelloHolddown = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeHelloHolddown.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeHelloHolddown.setDescription('The initial value for the Hello hold down timer that will be used by the given node to limit the rate at which it sends Hellos. It must be a positive non-zero number.')
pnnixNodeHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeHelloInterval.setDescription('The initial value for the Hello Timer. In the absence of triggered Hellos, this node will send one Hello packet on each of its ports on this interval.')
pnnixNodeHelloInactivityFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeHelloInactivityFactor.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeHelloInactivityFactor.setDescription('The value for the Hello Inactivity factor that this node will use to determine when a neighbor has gone down.')
pnnixNodeHlinkInact = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeHlinkInact.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeHlinkInact.setDescription('The amount of time a node will continue to advertise a horizontal (logical) link for which it has not received and processed a LGN Horizontal Link information group.')
pnnixNodePtseRefreshInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePtseRefreshInterval.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePtseRefreshInterval.setDescription('The initial value for the Refresh timer that this node will use to drive (re-)origination of PTSEs in the absence of triggered updates.')
pnnixNodePtseLifetimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(101, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePtseLifetimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePtseLifetimeFactor.setDescription('The value for the lifetime multiplier, expressed as a percentage. The result of multiplying the pnnixNodePtseRefreshInterval attribute value by this attribute value is used as the initial lifetime that this node places into self-originated PTSEs.')
pnnixNodeRxmtInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeRxmtInterval.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeRxmtInterval.setDescription('The period between retransmissions of unacknowledged Database Summary packets, PTSE Request packets, and PTSPs.')
pnnixNodePeerDelayedAckInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodePeerDelayedAckInterval.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodePeerDelayedAckInterval.setDescription('The minimum amount of time between transmissions of delayed PTSE acknowledgement packets.')
pnnixNodeAvcrPm = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeAvcrPm.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeAvcrPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for AvCR parameters, expressed as a percentage.')
pnnixNodeAvcrMt = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeAvcrMt.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeAvcrMt.setDescription('The minimum threshold used in the algorithms that determine significant change for AvCR parameters, expressed as a percentage.')
pnnixNodeCdvPm = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeCdvPm.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeCdvPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for CDV metrics, expressed as a percentage.')
pnnixNodeCtdPm = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeCtdPm.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeCtdPm.setDescription('The proportional multiplier used in the algorithms that determine significant change for CTD metrics, expressed as a percentage.')
pnnixNodeSvccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5), )
if mibBuilder.loadTexts: pnnixNodeSvccTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccTable.setDescription('A table of variables related to SVCC-based routing control channels..')
pnnixNodeSvccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"))
if mibBuilder.loadTexts: pnnixNodeSvccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccEntry.setDescription('An entry in the table, containing SVCC-based RCC variables of a PNNI logical node in this switching system.')
pnnixNodeSvccInitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeSvccInitTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccInitTime.setDescription('The amount of time this node will delay initiating establishment of an SVCC to a neighbor with a numerically lower ATM address, after determining that such an SVCC should be established.')
pnnixNodeSvccRetryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeSvccRetryTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccRetryTime.setDescription('The amount of time this node will delay after an apparently still necessary and viable SVCC-based RCC is unexpectedly torn down, before attempting to re-establish it.')
pnnixNodeSvccCallingIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeSvccCallingIntegrityTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccCallingIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which it has initiated establishment of as the calling party, to become fully established before giving up and tearing it down.')
pnnixNodeSvccCalledIntegrityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeSvccCalledIntegrityTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccCalledIntegrityTime.setDescription('The amount of time this node will wait for an SVCC, which it has decided to accept as the called party, to become fully established before giving up and tearing it down.')
pnnixNodeSvccTrafficDescriptorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 5, 1, 5), AtmpTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixNodeSvccTrafficDescriptorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNodeSvccTrafficDescriptorIndex.setDescription('An index into the atmTrafficDescrParamTable defined in RFC 1695. This traffic descriptor is used when establishing switched virtual channels for use as SVCC-based RCCs to/from PNNI logical group nodes.')
pnnixScopeMappingTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6), )
if mibBuilder.loadTexts: pnnixScopeMappingTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeMappingTable.setDescription('The pnnixScopeTable contains the mappings of membership and connection scope from organizational scope values (used at UNI interfaces) to PNNI scope (i.e. in terms of PNNI routing level indicators).')
pnnixScopeMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"))
if mibBuilder.loadTexts: pnnixScopeMappingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeMappingEntry.setDescription('An entry in the table, containing scope mapping information for a PNNI logical node in this switching system.')
pnnixScopeLocalNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 1), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeLocalNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeLocalNetwork.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetwork(1).')
pnnixScopeLocalNetworkPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 2), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeLocalNetworkPlusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeLocalNetworkPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetworkPlusOne(2).')
pnnixScopeLocalNetworkPlusTwo = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 3), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeLocalNetworkPlusTwo.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeLocalNetworkPlusTwo.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value localNetworkPlusTwo(3).')
pnnixScopeSiteMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 4), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeSiteMinusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeSiteMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value siteMinusOne(4).')
pnnixScopeIntraSite = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 5), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeIntraSite.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeIntraSite.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraSite(5).')
pnnixScopeSitePlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 6), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeSitePlusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeSitePlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value sitePlusOne(6).')
pnnixScopeOrganizationMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 7), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeOrganizationMinusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeOrganizationMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value organizationMinusOne(7).')
pnnixScopeIntraOrganization = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 8), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeIntraOrganization.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeIntraOrganization.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraOrganization(8).')
pnnixScopeOrganizationPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 9), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeOrganizationPlusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeOrganizationPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value organizationPlusOne(9).')
pnnixScopeCommunityMinusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 10), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeCommunityMinusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeCommunityMinusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value communityMinusOne(10).')
pnnixScopeIntraCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 11), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeIntraCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeIntraCommunity.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value intraCommunity(11).')
pnnixScopeCommunityPlusOne = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 12), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeCommunityPlusOne.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeCommunityPlusOne.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value communityPlusOne(12).')
pnnixScopeRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 13), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeRegional.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value regional(13).')
pnnixScopeInterRegional = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 14), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeInterRegional.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeInterRegional.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value interRegional(14).')
pnnixScopeGlobal = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 6, 1, 15), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixScopeGlobal.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixScopeGlobal.setDescription('The highest level of PNNI hierarchy (i.e. smallest PNNI routing level) that lies within the organizational scope value global(15).')
pnnixSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7), )
if mibBuilder.loadTexts: pnnixSummaryTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryTable.setDescription('A list of the summary address prefixes that may be advertised by the specified logical PNNI entity.')
pnnixSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixSummaryAddress"), (0, "XPNNI-MIB", "pnnixSummaryPrefixLength"))
if mibBuilder.loadTexts: pnnixSummaryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryEntry.setDescription('An entry in the table, containing summary address prefix information in this switching system.')
pnnixSummaryAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnnixSummaryAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryAddress.setDescription('The ATM End System Address prefix for the summary.')
pnnixSummaryPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 2), PnnixPrefixLength())
if mibBuilder.loadTexts: pnnixSummaryPrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryPrefixLength.setDescription('The prefix length for the summary.')
pnnixSummaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("exterior", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixSummaryType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryType.setDescription('The type (e.g. internal or exterior) of summary being described.')
pnnixSummarySuppress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixSummarySuppress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummarySuppress.setDescription("Determines what is done with addresses that are being summarized by the instance. The default value (e.g. false) will indicate that the summary should propagate into the peer group. Network Management will be able to set the value of this attribute to `suppress' (e.g. true), which suppresses the summary and any reachable addresses it summarizes from being advertised into the peer group.")
pnnixSummaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertising", 1), ("suppressing", 2), ("inactive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSummaryState.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryState.setDescription('Indicates whether the summary is currently being advertised by the node within the local switching system into its peer group.')
pnnixSummaryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixSummaryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSummaryRowStatus.setDescription('To create, delete, activate and de-activate a summary.')
pnnixIfTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8), )
if mibBuilder.loadTexts: pnnixIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfTable.setDescription("The pnnixIfTable contains the attributes necessary to configure a physical interface on a switching system which is capable of being used for PNNI routing. Interfaces may represent physical connection points (i.e. copper/fiber connection points) or VPCs which have been configured for PNNI's use. Each interface is attached to a specific lowest-level node within the switching system. An ifIndex is used as the instance ID to uniquely identify the interface on the local switching system. This index has the same value as the ifIndex object defined in RFC 1573 for the same interface, since this table correlates with the ifTable in RFC 1573. One row in this table is created by the managed system for each row in the ifTable that has an ifType of atm(37) or atmLogical(80).")
pnnixIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pnnixIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfEntry.setDescription('An entry in the table, containing PNNI specific interface information in this switching system.')
pnnixIfNodeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 1), PnnixNodeIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfNodeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfNodeIndex.setDescription('Identifies the node within the switching system that the interface is directly attached to.')
pnnixIfPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 2), PnnixPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIfPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfPortId.setDescription('The Port Identifier of the port as selected by the PNNI protocol entity for the given interface. This value has meaning only within the context of the node to which the port is attached.')
pnnixIfAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 3), PnnixAggrToken()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAggrToken.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAggrToken.setDescription('The configured aggregation token for this interface. The aggregation token controls what other links the link associated with this interface will be aggregated together with.')
pnnixIfVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfVPCapability.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfVPCapability.setDescription("Indicates whether the interface is capable of having VPCs established within it or not. This object may only have the value `true' for physical ATM interfaces, i.e. those with an ifType of atm(37).")
pnnixIfAdmWeightCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 5), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAdmWeightCbr.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAdmWeightCbr.setDescription('The administrative weight of this interface for the constant bit rate service category.')
pnnixIfAdmWeightRtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 6), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAdmWeightRtVbr.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAdmWeightRtVbr.setDescription('The administrative weight of this interface for the real-time variable bit rate service category.')
pnnixIfAdmWeightNrtVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 7), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAdmWeightNrtVbr.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAdmWeightNrtVbr.setDescription('The administrative weight of this interface for the non-real-time variable bit rate service category.')
pnnixIfAdmWeightAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAdmWeightAbr.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAdmWeightAbr.setDescription('The administrative weight of this interface for the available bit rate service category.')
pnnixIfAdmWeightUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 9), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfAdmWeightUbr.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfAdmWeightUbr.setDescription('The administrative weight of this interface for the unspecified bit rate service category.')
pnnixIfRccServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 10), ServiceCategory()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfRccServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfRccServiceCategory.setDescription('The service category used for the PNNI routing control channel (VCI=18) on this interface.')
pnnixIfRccTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 8, 1, 11), AtmpTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixIfRccTrafficDescrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIfRccTrafficDescrIndex.setDescription('The traffic descriptor index referring to the entry in the atmTrafficDescrParamTable defined in RFC 1695 that specifies the traffic allocation for the PNNI routing control channel (VCI=18) on this interface.')
pnnixLinkTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9), )
if mibBuilder.loadTexts: pnnixLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkTable.setDescription('This table contains the attributes necessary to describe the operation of logical links attached to the local switching system and the relationship with the neighbor nodes on the other end of the links. Links are attached to a specific node within the switching system. A concatenation of the Node Index of the node within the local switching system and the port ID are used as the instance ID to uniquely identify the link. Links may represent horizontal links between lowest level neighboring peers, outside links, uplinks, or horizontal links to/from LGNs. The entire pnnixLink object is read-only, reflecting the fact that this information is discovered dynamically by the PNNI protocol rather than configured.')
pnnixLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixLinkPortId"))
if mibBuilder.loadTexts: pnnixLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkEntry.setDescription('An entry in the table, containing information about a link attached to a PNNI logical node in this switching system.')
pnnixLinkPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 1), Integer32())
if mibBuilder.loadTexts: pnnixLinkPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkPortId.setDescription('The Port Identifier of the link as selected by the local node. This value has meaning only within the context of the node to which the port is attached.')
pnnixLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("lowestLevelHorizontalLink", 2), ("horizontalLinkToFromLgn", 3), ("lowestLevelOutsideLink", 4), ("uplink", 5), ("outsideLinkAndUplink", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkType.setDescription('Indicates the type of link being described.')
pnnixLinkVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 3), PnnixVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkVersion.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute indicates the version of PNNI routing protocol used to exchange information over this link. If communication with the neighbor node has not yet been established, then the Version is set to `unknown'. For uplinks (where the port ID is not also used for the underlying outside link) or links to/from LGNs, the Version is set to `unknown'.")
pnnixLinkHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 4), PnnixHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkHelloState.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkHelloState.setDescription('For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute indicates the state of the Hello protocol exchange over this link. For links to/from LGNs, this attribute indicates the state of the corresponding LGN Horizontal Link Hello State Machine. For uplinks (where the port ID is not also used for the underlying outside link), this attribute is set to notApplicable.')
pnnixLinkRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 5), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkRemoteNodeId.setDescription("Indicates the node identifier of the remote (neighboring) node on the other end of the link. If the pnnixLinkType is `outside link and uplink', this is the node identifier of the lowest-level neighbor node on the other end of the outside link. If the remote node ID is unknown or if the pnnixLinkType is `uplink', this attribute is set to all zeros.")
pnnixLinkRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 6), PnnixPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkRemotePortId.setDescription("Indicates the port identifier of the port at the remote end of the link as assigned by the remote node. If the pnnixLinkType is `outside link and uplink', this is the port identifier assigned by the lowest-level neighbor node to identify the outside link. If the remote port ID is unknown or if the pnnixLinkType is `uplink', this attribute is set to zero.")
pnnixLinkDerivedAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 7), PnnixAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkDerivedAggrToken.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkDerivedAggrToken.setDescription('Indicates the derived aggregation token value used on this link. For horizontal links between lowest-level nodes and when the link type is not yet known, this attribute takes the value of zero.')
pnnixLinkUpnodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 8), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkUpnodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkUpnodeId.setDescription("For outside links and uplinks, this attribute contains the Node Identifier of the upnode (the neighbor node's identity at the level of the common peer group). When the upnode has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to zero.")
pnnixLinkUpnodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 9), PnnixAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkUpnodeAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkUpnodeAtmAddress.setDescription('For outside links and uplinks, this attribute contains the ATM End System Address used to establish connections to the upnode. When the upnode has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to zero.')
pnnixLinkCommonPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 10), PnnixPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkCommonPeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkCommonPeerGroupId.setDescription('For outside links and uplinks, this attribute contains the peer group identifier of the lowest level common Peer Group in the ancestry of the neighboring node and the node within the local switching system. The value of this attribute takes on a value determined by the Hello exchange of hierarchical information that occurs between the two lowest-level border nodes. When the common peer group has not yet been identified, this attribute is set to zero. For horizontal links or when the link type is not yet known, this attribute is set to all zeros.')
pnnixLinkIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 11), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkIfIndex.setDescription('For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute identifies the interface to which the logical link corresponds. For all other cases, the value of this object is zero.')
pnnixLinkSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 12), PnnixSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkSvccRccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkSvccRccIndex.setDescription("For horizontal links to/from LGNs, this attribute identifies the SVCC-based RCC used to exchange information with the neighboring peer logical group node. If the pnnixLinkType is not `horizontal link to/from LGN', this attribute shall take the value of zero.")
pnnixLinkRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkRcvHellos.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkRcvHellos.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute contains a count of the number of Hello Packets received over this link. If the pnnixLinkType is `horizontal link to/from LGN' or `uplink', this attribute is set to zero.")
pnnixLinkXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 9, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixLinkXmtHellos.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixLinkXmtHellos.setDescription("For horizontal and outside links between lowest-level nodes and for links of unknown type, this attribute contains a count of the number of Hello Packets transmitted over this link. If the pnnixLinkType is `horizontal link to/from LGN' or `uplink', this attribute is set to zero.")
pnnixNbrPeerTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10), )
if mibBuilder.loadTexts: pnnixNbrPeerTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerTable.setDescription("The pnnixNbrPeer Object contains all the attributes necessary to describe the relationship a node in this switching system has with a neighboring node within the same peer group. A concatenation of the Node Identifier of the node within the local switching system and the neighboring peer's Node Identifier is used to form the instance ID for this object. The entire pnnixNbrPeer object is read-only, reflecting the fact that neighboring peers are discovered dynamically by the PNNI protocol rather than configured.")
pnnixNbrPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixNbrPeerRemoteNodeId"))
if mibBuilder.loadTexts: pnnixNbrPeerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerEntry.setDescription("An entry in the table, containing information about this node's relationship with a neighboring peer node.")
pnnixNbrPeerRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 1), PnnixNodeId())
if mibBuilder.loadTexts: pnnixNbrPeerRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerRemoteNodeId.setDescription('The Node Identifier of the neighboring peer node.')
pnnixNbrPeerState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("npdown", 1), ("negotiating", 2), ("exchanging", 3), ("loading", 4), ("full", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerState.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerState.setDescription("Indicates the state of this node's Neighboring Peer State Machine associated with pnnixNbrPeerRemoteNodeId.")
pnnixNbrPeerSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 3), PnnixSvccRccIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerSvccRccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerSvccRccIndex.setDescription('Identifies the SVCC-based RCC being used to communicate with the neighboring peer if one exists. If both the local node and the neighboring peer node are lowest-level nodes, this attribute is set to zero.')
pnnixNbrPeerPortCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerPortCount.setDescription('A count of the total number of ports that connect to the neighboring peer. If the neighboring peer only communicates via an SVCC-based RCC, the value of this attribute is set to zero. Otherwise it is set to the total number of ports to the neighboring peer in the Hello state 2-WayInside.')
pnnixNbrPeerRcvDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerRcvDbSums.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerRcvDbSums.setDescription('A count of the number of Database Summary Packets received from the neighboring peer.')
pnnixNbrPeerXmtDbSums = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerXmtDbSums.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerXmtDbSums.setDescription('A count of the number of Database Summary Packets transmitted to the neighboring peer.')
pnnixNbrPeerRcvPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtsps.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtsps.setDescription('A count of the number of PTSPs received from the neighboring peer.')
pnnixNbrPeerXmtPtsps = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtsps.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtsps.setDescription('A count of the number of PTSPs (re)transmitted to the neighboring peer.')
pnnixNbrPeerRcvPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtseReqs.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtseReqs.setDescription('A count of the number of PTSE Request packets received from the neighboring peer.')
pnnixNbrPeerXmtPtseReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtseReqs.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtseReqs.setDescription('A count of the number of PTSE Request packets transmitted to the neighboring peer.')
pnnixNbrPeerRcvPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtseAcks.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerRcvPtseAcks.setDescription('A count of the number of PTSE Ack packets received from the neighboring peer.')
pnnixNbrPeerXmtPtseAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtseAcks.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerXmtPtseAcks.setDescription('A count of the number of PTSE Ack packets transmitted to the neighboring peer.')
pnnixNbrPeerPortTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 11), )
if mibBuilder.loadTexts: pnnixNbrPeerPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerPortTable.setDescription("A table of all ports in Hello state 2-Way Inside to a given neighboring peer node. A concatenation of the Node Index of the node within the local switching system, the neighbor's Node Identifier and the Interface Index of the port being described forms the instance ID for this object. This object is only used for lowest-level nodes.")
pnnixNbrPeerPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 11, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixNbrPeerRemoteNodeId"), (0, "XPNNI-MIB", "pnnixNbrPeerPortId"))
if mibBuilder.loadTexts: pnnixNbrPeerPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerPortEntry.setDescription('An entry in the table, containing information about a port in the Hello state 2-Way Inside from a PNNI logical node in this switching system to a neighboring peer node.')
pnnixNbrPeerPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 11, 1, 1), Integer32())
if mibBuilder.loadTexts: pnnixNbrPeerPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerPortId.setDescription('The port ID of a port to the neighboring peer that is in the Hello state 2-Way Inside.')
pnnixNbrPeerPortFloodStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 11, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNbrPeerPortFloodStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNbrPeerPortFloodStatus.setDescription('Indicates whether the port is being used for transmission of flooding and database synchronization information to the neighboring peer.')
pnnixSvccRccTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12), )
if mibBuilder.loadTexts: pnnixSvccRccTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccTable.setDescription('A table containing the attributes necessary to analyze the operation of the PNNI protocol on SVCC-based Routing Control Channels. This entire object is read-only, reflecting the fact that SVCC-based RCCs are established dynamically during operation of the PNNI protocol rather than configured.')
pnnixSvccRccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixSvccRccIndex"))
if mibBuilder.loadTexts: pnnixSvccRccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccEntry.setDescription('An entry in the table, containing information about an SVCC-based RCC from a PNNI logical node in this switching system.')
pnnixSvccRccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 1), PnnixSvccRccIndex())
if mibBuilder.loadTexts: pnnixSvccRccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccIndex.setDescription("An index into the node's tables of SVCC-based RCCs.")
pnnixSvccRccVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 2), PnnixVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccVersion.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccVersion.setDescription('The version of the PNNI routing protocol used to exchange information with the neighbor node.')
pnnixSvccRccHelloState = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 3), PnnixHelloState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccHelloState.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccHelloState.setDescription('The state of the Hello protocol exchange over the SVCC-based RCC. Note: the Down state indicates that the SVCC establishment is in progress.')
pnnixSvccRccRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 4), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccRemoteNodeId.setDescription('The remote node at which the SVCC-based RCC terminates.')
pnnixSvccRccRemoteAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 5), PnnixAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccRemoteAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccRemoteAtmAddress.setDescription('The ATM End System Address to which SVCC establishment is attempted.')
pnnixSvccRccRcvHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccRcvHellos.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccRcvHellos.setDescription('A count of the number of Hello Packets received over this SVCC-based RCC.')
pnnixSvccRccXmtHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccXmtHellos.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccXmtHellos.setDescription('A count of the number of Hello Packets transmitted over this SVCC-based RCC.')
pnnixSvccRccIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 8), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccIfIndex.setDescription('The interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero.')
pnnixSvccRccVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccVpi.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccVpi.setDescription('The VPI used at the interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero ')
pnnixSvccRccVci = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 12, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixSvccRccVci.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixSvccRccVci.setDescription('The VCI used at the interface from which the SVCC-based RCC leaves the switching system. If the SVCC-based RCC has not yet been established, then this attribute takes the value of zero ')
pnnixPtseTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13), )
if mibBuilder.loadTexts: pnnixPtseTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseTable.setDescription("The pnnixPtse object contains the attributes that describe the most recent instances of PTSEs in a node's topology database. A concatenation of the Node Identifier of the local node that received the PTSE, the originating Node's Node Identifier and the PTSE Identifier are used to form the instance ID for an instance of this object.")
pnnixPtseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixPtseOriginatingNodeId"), (0, "XPNNI-MIB", "pnnixPtseId"))
if mibBuilder.loadTexts: pnnixPtseEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseEntry.setDescription('An entry in the table, containing information about a PTSE in the topology database of a PNNI logical node in this switching system.')
pnnixPtseOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 1), PnnixNodeId())
if mibBuilder.loadTexts: pnnixPtseOriginatingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseOriginatingNodeId.setDescription('The Node Identifier of the node that originated the PTSE.')
pnnixPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 2), Integer32())
if mibBuilder.loadTexts: pnnixPtseId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseId.setDescription('The value of the PTSE Identifier assigned to the PTSE by its originator.')
pnnixPtseType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96, 97, 224, 256, 288, 289))).clone(namedValues=NamedValues(("other", 1), ("nodalStateParameters", 96), ("nodalInformation", 97), ("internalReachableAddresses", 224), ("exteriorReachableAddresses", 256), ("horizontalLinks", 288), ("uplinks", 289)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixPtseType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseType.setDescription('The type of information contained in the PTSE.')
pnnixPtseSequenceNum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixPtseSequenceNum.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseSequenceNum.setDescription('The sequence number of the instance of the PTSE as it appears in the local topology database.')
pnnixPtseChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixPtseChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseChecksum.setDescription('The value of the PTSE checksum as it appears in the local topology database.')
pnnixPtseLifeTime = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixPtseLifeTime.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseLifeTime.setDescription('The value of the remaining lifetime for the given PTSE as it appears in the local topology database.')
pnnixPtseInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 13, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixPtseInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixPtseInfo.setDescription('An unformatted hexadecimal dump of the PTSE contents in full. Note: If the size of the PTSE contents is larger than the maximum size of SNMP packets then this is truncated.')
pnnixMapTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14), )
if mibBuilder.loadTexts: pnnixMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTable.setDescription('A table containing attributes necessary to find and analyze the operation of all links and nodes within the PNNI hierarchy, as seen from the perspective of a local node. An instance of a pnniMap Object describes a link in terms of a node at one end of the link. Normally there will be two instances of the pnniMap object in the MIB for each horizontal link. The two instances provide information for Network management to map port identifiers from the nodes at both ends to the link between them. A concatenation of the Local Node Index, Originating Node Identifier and Originating Port Identifier are used to form the instance ID for this object. This entire object is read-only, reflecting the fact that the map is discovered dynamically during operation of the PNNI protocol rather than configured.')
pnnixMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixMapOriginatingNodeId"), (0, "XPNNI-MIB", "pnnixMapOriginatingPortId"), (0, "XPNNI-MIB", "pnnixMapIndex"))
if mibBuilder.loadTexts: pnnixMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapEntry.setDescription('An entry in the table, containing connectivity information about a node or link in the PNNI routing domain, as seen from the perspective of a PNNI logical node in this switching system.')
pnnixMapOriginatingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 1), PnnixNodeId())
if mibBuilder.loadTexts: pnnixMapOriginatingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapOriginatingNodeId.setDescription('The node identifier of the node whose connectivity within itself or to other nodes is being described.')
pnnixMapOriginatingPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 2), Integer32())
if mibBuilder.loadTexts: pnnixMapOriginatingPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapOriginatingPortId.setDescription('The port identifier of the port as assigned by the originating node, to which the port is attached.')
pnnixMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: pnnixMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapIndex.setDescription('An index into the set of link and nodal connectivity associated with the originating node and port. This index is needed since there may be multiple entries for nodal connectivity from a specific node and port pair, in addition to any entry for a horizontal link or uplink.')
pnnixMapType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("horizontalLink", 1), ("uplink", 2), ("node", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapType.setDescription('The type of PNNI entity being described by this entry in the table.')
pnnixMapPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 5), PnnixPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapPeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapPeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnnixMapAggrToken = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 6), PnnixAggrToken()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapAggrToken.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAggrToken.setDescription('For horizontal links to/from LGNs and for uplinks, this attribute contains the derived aggregation token value for this link. For nodes and for horizontal links between lowest-level nodes, this attribute is set to zero.')
pnnixMapRemoteNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 7), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapRemoteNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapRemoteNodeId.setDescription("For horizontal links and uplinks, this attribute contains the node identifier of the node at the other end of the link from the originating node. If unknown, the PNNI protocol entity sets this attribute's value to (all) zero(s). For nodes, this attribute's value is set to (all) zero(s).")
pnnixMapRemotePortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 8), PnnixPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapRemotePortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapRemotePortId.setDescription("For horizontal links and uplinks, this attribute contains the port identifier of the port at the remote end of the link as assigned by the remote node. If unknown, the PNNI protocol entity sets this attribute's value to zero. For nodes, this attribute contains the port identifier of the port at the other end of the spoke or bypass from the originating port. When the originating port ID is zero, a value of zero indicates the default radius. When the originating port ID is non-zero, a value of zero indicates the nodal nucleus.")
pnnixMapVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapVPCapability.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapVPCapability.setDescription('Indicates whether VPCs can be established across the PNNI entity being described by this entry in the pnnixMapTable.')
pnnixMapPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapPtseId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapPtseId.setDescription('The value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the PNNI entity.')
pnnixMapMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 14, 1, 11), PnnixMetricsTag().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapMetricsTag.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapMetricsTag.setDescription('An arbitrary integer that is used to associate a set of traffic parameters that are always advertised together. Within this set, the parameters are distinguished by the service categories and direction to which a set of parameters apply.')
pnnixMapNodeTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15), )
if mibBuilder.loadTexts: pnnixMapNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeTable.setDescription('A list of nodes as seen from the perspective of a local node. The pnnixMapNodeTable contains all information learned by the local node from nodal information PTSEs. This entire object is read-only, reflecting the fact that the map is discovered dynamically during operation of the PNNI protocol rather than configured.')
pnnixMapNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixMapNodeId"))
if mibBuilder.loadTexts: pnnixMapNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeEntry.setDescription('An entry in the table, containing information about a node in the PNNI routing domain, as seen from the perspective of a logical node in this switching system.')
pnnixMapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 1), PnnixNodeId())
if mibBuilder.loadTexts: pnnixMapNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeId.setDescription('Identifies the node whose nodal information is being described.')
pnnixMapNodePeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 2), PnnixPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodePeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodePeerGroupId.setDescription('Identifies the peer group of the originating node.')
pnnixMapNodeAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 3), PnnixAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeAtmAddress.setDescription('The ATM End System Address of the originating node.')
pnnixMapNodeRestrictedTransit = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeRestrictedTransit.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeRestrictedTransit.setDescription("Indicates whether the originating node is restricted to only allow support of SVCs originating or terminating at this node. A value of `true' indicates that the transit capabilities are restricted, i.e., transit connections are not allowed, whereas a value of `false' indicates that transit connections are allowed. This attribute reflects the setting of the restricted transit bit received in the nodal information PTSE of the originating node.")
pnnixMapNodeComplexRep = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeComplexRep.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeComplexRep.setDescription("Indicates whether the originating node uses the complex node representation. If the value is `true', the spokes and bypasses that make up the complex node representation should be found in the pnnixMapTable. This attribute reflects the setting of the nodal representation bit received in the nodal information PTSE of the originating node.")
pnnixMapNodeRestrictedBranching = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeRestrictedBranching.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeRestrictedBranching.setDescription("Indicates whether the originating node is able to support additional branches. If the value is 'false', then it can support additional branches. This attribute reflects the setting of the restricted branching bit received in the nodal information PTSE of the originating node.")
pnnixMapNodeDatabaseOverload = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeDatabaseOverload.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeDatabaseOverload.setDescription('Indicates whether the originating node is currently operating in topology database overload state. This attribute has the same value as the Non-transit for PGL Election bit in the nodal information group originated by this node.')
pnnixMapNodeIAmLeader = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeIAmLeader.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeIAmLeader.setDescription("Indicates whether the originating node claims to be peer group leader of its peer group. This attribute reflects the setting of the 'I am Leader' bit received in the nodal information PTSE of the originating node.")
pnnixMapNodeLeadershipPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeLeadershipPriority.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeLeadershipPriority.setDescription('The Leadership priority value advertised by the originating node.')
pnnixMapNodePreferredPgl = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 10), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodePreferredPgl.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodePreferredPgl.setDescription("Identifies the node which the originating node believes should be or is peer group leader of its peer group. If the originating node has not chosen a Preferred PGL, this attribute's value is set to (all) zero(s).")
pnnixMapNodeParentNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 11), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeParentNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeParentNodeId.setDescription("When the originating node is a peer group leader, indicates the node ID of the parent LGN. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnnixMapNodeParentAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 12), PnnixAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeParentAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeParentAtmAddress.setDescription("When the originating node is a peer group leader, indicates the ATM address of the parent LGN. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnnixMapNodeParentPeerGroupId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 13), PnnixPeerGroupId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeParentPeerGroupId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeParentPeerGroupId.setDescription("When the originating node is a peer group leader, indicates the node's parent peer group ID. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnnixMapNodeParentPglNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 15, 1, 14), PnnixNodeId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapNodeParentPglNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapNodeParentPglNodeId.setDescription("When the originating node is a peer group leader, identifies the node elected as peer group leader of the parent peer group. If the originating node is not peer group leader of its peer group, this attribute's value is set to (all) zero(s).")
pnnixMapAddrTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16), )
if mibBuilder.loadTexts: pnnixMapAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrTable.setDescription('The pnnixMapAddr MIB Object contains a list of all reachable addresses from each node visible to the local node. The Local Node Index, Advertising Node ID, Advertised Port ID, Reachable Address, and Address prefix length are combined to form an instance ID for this object. The entire object is read-only, reflecting the fact that reachable addresses are discovered during dynamic operation of the PNNI protocol rather than configured.')
pnnixMapAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixMapAddrAdvertisingNodeId"), (0, "XPNNI-MIB", "pnnixMapAddrAdvertisedPortId"), (0, "XPNNI-MIB", "pnnixMapAddrIndex"))
if mibBuilder.loadTexts: pnnixMapAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrEntry.setDescription('An entry in the table, containing information about an address prefix reachable from a node in the PNNI routing domain, as seen from the perspective of a PNNIX logical node in this switching system.')
pnnixMapAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1, 1), PnnixNodeId())
if mibBuilder.loadTexts: pnnixMapAddrAdvertisingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the address prefix.')
pnnixMapAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1, 2), Integer32())
if mibBuilder.loadTexts: pnnixMapAddrAdvertisedPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given address prefix.')
pnnixMapAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnnixMapAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrIndex.setDescription('An arbitrary index that is used to enumerate all of the addresses advertised by the specified node.')
pnnixMapAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1, 4), AtmAddrPrefix()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnnixMapAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 16, 1, 5), PnnixPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapAddrPrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapAddrPrefixLength.setDescription('The Prefix length to be applied to the ATM End System Address prefix.')
pnnixMapTnsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17), )
if mibBuilder.loadTexts: pnnixMapTnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsTable.setDescription('A list of all reachable transit networks from each node visible to the local node. The Local Node Index, Advertising Node ID, Advertised Port ID, Transit Network Type, Transit Network Plan, and Transit Network ID are combined to form an instance ID for this object. The entire object is read-only, reflecting the fact that reachable transit networks are discovered during dynamic operation of the PNNI protocol rather than configured..')
pnnixMapTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixMapTnsAdvertisingNodeId"), (0, "XPNNI-MIB", "pnnixMapTnsAdvertisedPortId"), (0, "XPNNI-MIB", "pnnixMapTnsType"), (0, "XPNNI-MIB", "pnnixMapTnsPlan"), (0, "XPNNI-MIB", "pnnixMapTnsId"))
if mibBuilder.loadTexts: pnnixMapTnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsEntry.setDescription('An entry in the table, containing information about a transit network reachable from a node in the PNNI routing domain, as seen from the perspective of a PNNI logical node in this switching system.')
pnnixMapTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1, 1), Integer32())
if mibBuilder.loadTexts: pnnixMapTnsAdvertisingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the transit network.')
pnnixMapTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1, 2), Integer32())
if mibBuilder.loadTexts: pnnixMapTnsAdvertisedPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given transit network.')
pnnixMapTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1, 3), TnsType())
if mibBuilder.loadTexts: pnnixMapTnsType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsType.setDescription('The type of network identification used for this transit network.')
pnnixMapTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1, 4), TnsPlan())
if mibBuilder.loadTexts: pnnixMapTnsPlan.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsPlan.setDescription('The network identification plan according to which network identification has been assigned.')
pnnixMapTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 17, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixMapTnsId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMapTnsId.setDescription('The value of the transit network identifier.')
pnnixMetricsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18), )
if mibBuilder.loadTexts: pnnixMetricsTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsTable.setDescription("This entity's table of PNNI parameters either associated with a PNNI entity or for the connectivity between a PNNI node and a reachable address or transit network.")
pnnixMetricsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixMetricsTag"), (0, "XPNNI-MIB", "pnnixMetricsDirection"), (0, "XPNNI-MIB", "pnnixMetricsIndex"))
if mibBuilder.loadTexts: pnnixMetricsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsEntry.setDescription('A set of parameters that applies to the connectivity from a certain node and port to another node or port or to one or more reachable address prefixes and/or transit networks, for one (or more) particular service category(s). Note that there can be multiple sets of parameters with the same tag, in which case all sets apply to the specified connectivity.')
pnnixMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 1), PnnixMetricsTag().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnnixMetricsTag.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsTag.setDescription('An arbitrary integer that is used to associate a set of traffic parameters that are always advertised together. Within this set, the parameters are distinguished by the service categories and direction to which a set of parameters apply.')
pnnixMetricsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2))))
if mibBuilder.loadTexts: pnnixMetricsDirection.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsDirection.setDescription('The direction, with respect to the advertising node, in which the parameters in this entry apply.')
pnnixMetricsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnnixMetricsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsIndex.setDescription('An index into the set of parameters associated with the given tag and direction.')
pnnixMetricsClasses = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetricsClasses.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsClasses.setDescription('The service categories to which this set of parameters applies. This is an integer used as a bit mask with each bit that is set representing a single service category for which the resources indicated are available. Bit 5 represents CBR, bit 4 represents real-time VBR, bit 3 represents non-real-time VBR, bit 2 represents ABR, and bit 1 (LSB) represents UBR.')
pnnixMetricsGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 5), ClpType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetricsGcacClp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsGcacClp.setDescription('Indicates whether the advertised GCAC parameters apply for CLP=0 traffic or for CLP=0+1 traffic.')
pnnixMetricsAdminWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 6), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetricsAdminWeight.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsAdminWeight.setDescription('The administrative weight from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. If this metric is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 7), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics1.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics1.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the maximum cell rate in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 8), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics2.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics2.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the available cell rate in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 9), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics3.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics3.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the maximum cell transfer delay in microseconds for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics4 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 10), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics4.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics4.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the cell delay variation in microseconds for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics5 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 11), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics5.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics5.setDescription("An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For PNNI, this is the cell loss ratio for CLP=0 traffic for the specified service categories. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixMetrics6 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 12), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics6.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics6.setDescription("An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For PNNI, this is the cell loss ratio for CLP=0+1 traffic for the specified service categories. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixMetrics7 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 13), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics7.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics7.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the cell rate margin in cells per second for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetrics8 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 14), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetrics8.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetrics8.setDescription('An alternate routing parameter from the advertising node to the remote end of the PNNI entity or to the reachable address or transit network, for the specified service categories. For information learned from PNNI nodes, this is the variance factor in units of 2**(-8) for the specified service categories. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixMetricsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 18, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixMetricsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixMetricsRowStatus.setDescription('To create, delete, activate and de-activate a set of metrics.')
pnnixRoutingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19))
pnnixRouteBaseGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 1))
pnnixRouteNodeNumber = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeNumber.setDescription('The number of current precalculated PNNI routes to PNNI nodes that are not invalid.')
pnnixRouteAddrNumber = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteAddrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrNumber.setDescription('The number of current PNNI routes from nodes in the PNNI routing domain to addresses and transit networks that are not invalid.')
pnnixRouteNodeTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2), )
if mibBuilder.loadTexts: pnnixRouteNodeTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeTable.setDescription("This entity's PNNI Routing table (of routes to other nodes).")
pnnixRouteNodeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixRouteNodeClass"), (0, "XPNNI-MIB", "pnnixRouteNodeDestNodeId"), (0, "XPNNI-MIB", "pnnixRouteNodeDTL"))
if mibBuilder.loadTexts: pnnixRouteNodeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeEntry.setDescription('A particular route to a particular destination node, under a particular policy.')
pnnixRouteNodeClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 1), ServiceCategory())
if mibBuilder.loadTexts: pnnixRouteNodeClass.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeClass.setDescription('Indicates the service category with which this forwarding table entry is associated.')
pnnixRouteNodeDestNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 2), PnnixNodeId())
if mibBuilder.loadTexts: pnnixRouteNodeDestNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeDestNodeId.setDescription('The node ID of the destination node to which this route proceeds, and at which the DTL stack for this route terminates.')
pnnixRouteNodeDTL = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pnnixRouteNodeDTL.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeDTL.setDescription("The index into the owning PNNI node's DTL table of the DTL stack that goes with this route.")
pnnixRouteNodeDestPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 4), PnnixPortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeDestPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeDestPortId.setDescription('The port ID of the destination node at which the route terminates. A port ID of zero indicates the node nucleus. When the destination node is represented by the simple node representation, this value should be set to zero.')
pnnixRouteNodeProto = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteNodeProto.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeProto.setDescription('The routing mechanism via which this route was learned.')
pnnixRouteNodeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteNodeTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeTimeStamp.setDescription("The time at which this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
pnnixRouteNodeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 7), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this route, as determined by the value specified in the route's pnnixRouteNodeProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }.")
pnnixRouteNodeGcacClp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 8), ClpType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeGcacClp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeGcacClp.setDescription('For PNNI, indicates whether any advertised GCAC parameters apply for CLP=0 traffic or for CLP=0+1 traffic.')
pnnixRouteNodeFwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 9), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetricAW.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetricAW.setDescription('The cumulative administrative weight calculated for the forward direction of this route. If this metric is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 10), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric1.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric1.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the maximum possible cell rate (in cells per second) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 11), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric2.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric2.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Available cell rate (in cells per second) for the forward direction of the route. Further information on available bandwidth may be obtainable by reference to the nodal advertisements of the nodes in the path. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 12), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric3.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric3.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Maximum Cell Transfer Delay (in microseconds) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 13), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric4.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric4.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Delay Variation (in microseconds) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 14), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric5.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric5.setDescription("An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0 traffic for the forward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixRouteNodeFwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 15), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric6.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric6.setDescription("An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0+1 traffic for the forward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixRouteNodeFwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 16), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric7.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric7.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Cell Rate Margin (in cells per second) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeFwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 17), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric8.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeFwdMetric8.setDescription('An alternate routing parameter for the forward direction of this route. For information learned from PNNI nodes, this is the Variance Factor (in units of 2**(-8)) for the forward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetricAW = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 18), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetricAW.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetricAW.setDescription('The administrative weight calculated for the backward direction of this route. If this metric is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 19), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric1.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric1.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the maximum possible cell rate (in cells per second) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 20), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric2.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric2.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Available cell rate (in cells per second) for the backward direction of the route. Further information on available bandwidth may be obtainable by reference to the nodal advertisements of the nodes in the path. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 21), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric3.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric3.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Maximum Cell Transfer Delay (in microseconds) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 22), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric4.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric4.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Delay Variation (in microseconds) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 23), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric5.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric5.setDescription("An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0 traffic for the backward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixRouteNodeBwdMetric6 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 24), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric6.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric6.setDescription("An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the cumulative Cell Loss Ratio for CLP=0+1 traffic for the backward direction of the route. The cell loss ratio value is computed as 10**(-n) where 'n' is the value returned in this variable. If this parameter is not used, its value should be set to 0xFFFFFFFF.")
pnnixRouteNodeBwdMetric7 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 25), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric7.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric7.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Cell Rate Margin (in cells per second) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeBwdMetric8 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 26), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric8.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeBwdMetric8.setDescription('An alternate routing parameter for the backward direction of this route. For information learned from PNNI nodes, this is the Variance Factor (in units of 2**(-8)) for the backward direction of the route. If this parameter is not used, its value should be set to 0xFFFFFFFF.')
pnnixRouteNodeVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 27), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeVPCapability.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeVPCapability.setDescription('This attribute indicates whether a VPC setup on this route is possible.')
pnnixRouteNodeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteNodeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteNodeStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
pnnixDTLTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3), )
if mibBuilder.loadTexts: pnnixDTLTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLTable.setDescription('The set of all DTL stacks used for the pre-computed routes maintained by this managed entity.')
pnnixDTLEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixDTLIndex"), (0, "XPNNI-MIB", "pnnixDTLEntryIndex"))
if mibBuilder.loadTexts: pnnixDTLEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLEntry.setDescription('A segment of a DTL stack. The complete DTL stack is formed by traversing the rows of the table for which the pnniDTLIndex is the same. Level transitions are indicated using the pnnixDLTLinkType column.')
pnnixDTLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnnixDTLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLIndex.setDescription("The index in the node's DTL table of this DTL stack.")
pnnixDTLEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)))
if mibBuilder.loadTexts: pnnixDTLEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLEntryIndex.setDescription('The index in the current DTL stack of this entry.')
pnnixDTLNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 3), PnnixNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixDTLNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLNodeId.setDescription('The node which is this hop in the DTL stack.')
pnnixDTLPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 4), PnnixPortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixDTLPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLPortId.setDescription('The port from the pnnixDTLNodeId to use as the exit. If the DTL stack does not care, this is coded as zero.')
pnnixDTLLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("horizontal", 2), ("uplink", 3), ("last", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixDTLLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLLinkType.setDescription('The type of link out from this node (pnnixDTLNodeId). This is well defined even if the specific port is not specified.')
pnnixDTLStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixDTLStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixDTLStatus.setDescription('The row status variable, used according to row installation and removal conventions.')
pnnixRouteAddrTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4), )
if mibBuilder.loadTexts: pnnixRouteAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrTable.setDescription('A table containing all the attributes necessary to determine what the PNNI entity believes is reachable in terms of ATM End System Addresses and to determine which nodes are advertising this reachability. This table is also used to configure static routes to reachable address prefixes. The local node index that received the reachability information, reachable address, address prefix length, and an index that distinguishes between multiple listings of connectivity to a given address prefix from a given local node are combined to form an instance ID for this object..')
pnnixRouteAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixRouteAddrAddress"), (0, "XPNNI-MIB", "pnnixRouteAddrPrefixLength"), (0, "XPNNI-MIB", "pnnixRouteAddrIndex"))
if mibBuilder.loadTexts: pnnixRouteAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrEntry.setDescription('An entry in the table, containing information about a reachable address prefix.')
pnnixRouteAddrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 1), AtmAddrPrefix())
if mibBuilder.loadTexts: pnnixRouteAddrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrAddress.setDescription('The value of the ATM End System Address prefix.')
pnnixRouteAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 2), PnnixPrefixLength())
if mibBuilder.loadTexts: pnnixRouteAddrPrefixLength.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrPrefixLength.setDescription('The prefix length to be applied to the ATM End System Address prefix.')
pnnixRouteAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnnixRouteAddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrIndex.setDescription('An index into the set of listings of connectivity to a given address prefix from a given local node. In our implementation we allow the range of 1-5 for each type of QOS class.')
pnnixRouteAddrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 4), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrIfIndex.setDescription("The local interface over which the reachable address can be reached. The value zero indicates an unknown interface or reachability through a remote node. This object may only have a non-zero value if the value of the corresponding instance of pnniRouteAddrProto is other than 'pnni', pnnixRouteAddrType is other than 'reject', and the node identified by pnnixRouteAddrAdvertisingNodeId is instantiated within this switching system.")
pnnixRouteAddrAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 5), PnnixNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrAdvertisingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the address prefix. If the local node index is zero, then the advertising node ID must be set to all zeros.')
pnnixRouteAddrAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 6), PnnixPortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrAdvertisedPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given address prefix.')
pnnixRouteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reject", 2), ("internal", 3), ("exterior", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrType.setDescription('The type (e.g. internal or exterior) of reachability from the advertising node to the address prefix. Reject(2) refers to an address prefix which, if matched, indicates that the message should be discarded as unreachable. This is used in some protocols as a means of correctly aggregating routes.')
pnnixRouteAddrProto = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteAddrProto.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrProto.setDescription('The routing mechanism via which the connectivity from the advertising node to the reachable address prefix was learned.')
pnnixRouteAddrPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 9), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrPnniScope.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrPnniScope.setDescription('The PNNIX scope of advertisement (i.e. level of PNNI hierarchy) of the reachability from the advertising node to the address prefix.')
pnnixRouteAddrVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrVPCapability.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrVPCapability.setDescription('Indicates whether VPCs can be established from the advertising node to the reachable address prefix.')
pnnixRouteAddrMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 11), PnnixMetricsTag()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrMetricsTag.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrMetricsTag.setDescription('The index into the pnnixMetricsTable for the traffic parameter values that apply for the connectivity from the advertising node to the reachable address prefix. There will be one or more entries in the pnnixMetricsTable whose first instance identifier matches the value of this variable. If there are no parameters associated with this reachable address prefix then the distinguished value zero is used.')
pnnixRouteAddrPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteAddrPtseId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrPtseId.setDescription('For reachable addresses learned via PNNI, this attribute contains the value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the reachable address. For reachable addresses learned by means other than PNNI, this attribute is set to zero.')
pnnixRouteAddrOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrOriginateAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrOriginateAdvertisement.setDescription("Whether or not the reachable address specified by this entry is to be advertised by the local node into its PNNI routing domain. This object may only take on the value 'true' when the value of the corresponding instance of pnnixRouteAddrProto is other than 'pnni'.")
pnnixRouteAddrInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 14), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this reachable address prefix, as determined by the value specified in the route's pnnixRouteAddrProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }.")
pnnixRouteAddrOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteAddrOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrOperStatus.setDescription('Indicates whether the reachable address prefix is operationally valid and whether it is being advertised by this node.')
pnnixRouteAddrTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteAddrTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrTimeStamp.setDescription('Indicates when the connectivity from the advertising node to the reachable address prefix became known to the local node.')
pnnixRouteAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 4, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteAddrRowStatus.setDescription('To create, delete, activate and de-activate a reachable address prefix.')
pnnixRouteTnsTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5), )
if mibBuilder.loadTexts: pnnixRouteTnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsTable.setDescription('A table containing all the attributes necessary to determine what transit networks the PNNI entity believes are reachable and to determine which nodes are advertising this reachability. This table is also used to add static routes to reachable transit networks. The local node index which received the reachability information, type of network identification, network identification plan, transit network identifier, and an index that distinguishes between multiple listings of connectivity to a given transit network from a given local node are combined to form an instance ID for this object.')
pnnixRouteTnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixRouteTnsType"), (0, "XPNNI-MIB", "pnnixRouteTnsPlan"), (0, "XPNNI-MIB", "pnnixRouteTnsId"), (0, "XPNNI-MIB", "pnnixRouteTnsIndex"))
if mibBuilder.loadTexts: pnnixRouteTnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsEntry.setDescription('An entry in the table, containing information about a reachable transit network.')
pnnixRouteTnsType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 1), TnsType())
if mibBuilder.loadTexts: pnnixRouteTnsType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsType.setDescription('The type of network identification used for this transit network.')
pnnixRouteTnsPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 2), TnsPlan())
if mibBuilder.loadTexts: pnnixRouteTnsPlan.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsPlan.setDescription('The network identification plan according to which network identification has been assigned.')
pnnixRouteTnsId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 3), DisplayString())
if mibBuilder.loadTexts: pnnixRouteTnsId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsId.setDescription('The value of the transit network identifier.')
pnnixRouteTnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: pnnixRouteTnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsIndex.setDescription('An index into the set of listings of connectivity to a given transit network from a given local node. In our implementation we allow the range of 1-5 for each type of QOS class.')
pnnixRouteTnsIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 5), InterfaceIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsIfIndex.setDescription("The local interface over which the transit network can be reached. The value zero indicates an unknown interface or reachability through a remote node. This object may only have a non-zero value if the value of the corresponding instance of pnnixRouteTnsProto is other than 'pnni' and the node identified by pnnixRouteTnsAdvertisingNodeId is instantiated within this switching system.")
pnnixRouteTnsAdvertisingNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 6), PnnixNodeId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsAdvertisingNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsAdvertisingNodeId.setDescription('The node ID of a node advertising reachability to the transit network. If the local node index is zero, then the advertising node ID must also be set to zero.')
pnnixRouteTnsAdvertisedPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 7), PnnixPortId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsAdvertisedPortId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsAdvertisedPortId.setDescription('The port identifier used from the advertising node to reach the given transit network.')
pnnixRouteTnsRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("other", 1), ("exterior", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsRouteType.setDescription('The type (e.g. exterior or other) of reachability from the advertising node to the transit network.')
pnnixRouteTnsProto = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("mgmt", 3), ("pnni", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteTnsProto.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsProto.setDescription('The routing mechanism via which the connectivity from the advertising node to the transit network was learned.')
pnnixRouteTnsPnniScope = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 10), PnnixLevel()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsPnniScope.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsPnniScope.setDescription('The PNNI scope of advertisement (i.e. level of PNNI hierarchy) of the reachability from the advertising node to the transit network.')
pnnixRouteTnsVPCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 11), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsVPCapability.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsVPCapability.setDescription('Indicates whether VPCs can be established from the advertising node to the reachable transit network.')
pnnixRouteTnsMetricsTag = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 12), PnnixMetricsTag()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsMetricsTag.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsMetricsTag.setDescription('The index into the pnnixMetricsTable for the traffic parameter values that apply for the connectivity from the advertising node to the transit network. There will be one or more entries in the pnnixMetricsTable whose first instance identifier matches the value of this variable. If there are no parameters associated with this transit network then the distinguished value zero is used.')
pnnixRouteTnsPtseId = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteTnsPtseId.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsPtseId.setDescription('For reachable transit networks learned via PNNI, this attribute contains the value of the PTSE Identifier for the PTSE being originated by the originating node which contains the information group(s) describing the transit network. For reachable transit networks learned by means other than PNNI, this attribute is set to zero.')
pnnixRouteTnsOriginateAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsOriginateAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsOriginateAdvertisement.setDescription("Whether or not the transit network specified by this entry is to be advertised by the local node into its PNNI routing domain. This object may only take on the value 'true' when the value of the corresponding instance of pnniRouteNodeProto is other than 'pnni'.")
pnnixRouteTnsInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 15), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsInfo.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsInfo.setDescription("A reference to MIB definitions specific to the particular routing protocol which is responsible for this transit network, as determined by the value specified in the route's pnnixRouteTnsProto value. If this information is not present, its value should be set to the OBJECT IDENTIFIER { 0 0 }.")
pnnixRouteTnsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2), ("advertised", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteTnsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsOperStatus.setDescription('Indicates whether the reachable transit network is operationally valid and whether it is being advertised by this node.')
pnnixRouteTnsTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRouteTnsTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsTimeStamp.setDescription('Indicates how long the connectivity from the advertising node to the reachable transit network has been known to the local node.')
pnnixRouteTnsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 1, 19, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("create", 1), ("modify", 2), ("delete", 3), ("active", 4), ("notActive", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnnixRouteTnsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRouteTnsRowStatus.setDescription('To create, delete, activate and de-activate a reachable transit network.')
pnniIAdjMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3))
pnnixIAdjGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1))
pnnixNumIAdj = MibScalar((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixNumIAdj.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixNumIAdj.setDescription('The number of adjacencies registered via ILMI in PNNIs lowest nodes adjacency table in this switching system.')
pnnixIAdjTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2), )
if mibBuilder.loadTexts: pnnixIAdjTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjTable.setDescription('The pnnixIAdjTable stores records of adjacncies which ILMI has registered with the lowest level PNNI node in this network. There is a single row in this table for each adjacency which ILMI has registered.')
pnnixIAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixIadjIndex"))
if mibBuilder.loadTexts: pnnixIAdjEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjEntry.setDescription('An entry in the table, containing information about a PNNI logical node in this switching system.')
pnnixIadjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: pnnixIadjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIadjIndex.setDescription('A value assigned to an ILMI client registered via ILMI in this switching system that uniquely identifies it in the PNNI ILMI adjacency table.')
pnnixIAdjAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 2), PnnixAtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjAtmAddress.setDescription("This adjacency's ATM End System Address.")
pnnixIAdjSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjSlot.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjSlot.setDescription('The slot in which this adjacency is physically connected to this switching system.')
pnnixIAdjPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjPort.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjPort.setDescription('The port in the slot which this adjacency is physically connected to this switching system.')
pnnixIAdjInst = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjInst.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjInst.setDescription('The instance identifier on the slot port pair which this adjacency is physically connected to this switching system. In the event that this is not a tunnel, this value will be zero.')
pnnixIAdjCsmPPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjCsmPPort.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjCsmPPort.setDescription('The unique port id which PNNI has bound to this physical slot, port, and instance tuple.')
pnnixIAdjAdvertised = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjAdvertised.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjAdvertised.setDescription('Indicates if this ILMI client is advertised by this switching system. Note that if this value is False, the summary address may be used by remote nodes to still reach this ILMI client if pnnixIAdjSummarized is set to True (below).')
pnnixIAdjSummarized = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjSummarized.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjSummarized.setDescription("Indicates if this ILMI client is summarized by this switching system. Note that if this value is True, other nodes in the peer group will route to this node's advertised port of 1. Calls terminating at end-systems attached to this node will then be vectored out the pnnixIAdjCsmPPort.")
pnnixIAdjLearned = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 3, 1, 2, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixIAdjLearned.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixIAdjLearned.setDescription('This field contains a timestamp of when ILMI registered this adjacency with PNNI.')
pnniTestMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4))
pnniRtstMIBGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1))
pnnixRtstTable = MibTable((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1), )
if mibBuilder.loadTexts: pnnixRtstTable.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstTable.setDescription('The pnnixRtstTable is a single-row table which returns the results of a route test requested by a remote mgmt station. The route test parameters are specified in the INDEX.')
pnnixRtstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1), ).setIndexNames((0, "XPNNI-MIB", "pnnixNodeIndex"), (0, "XPNNI-MIB", "pnnixRtstClass"), (0, "XPNNI-MIB", "pnnixRtstType"), (0, "XPNNI-MIB", "pnnixRtstDest"))
if mibBuilder.loadTexts: pnnixRtstEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstEntry.setDescription('An entry in the route test table, containing information about a route lookup request.')
pnnixRtstClass = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("ubr", 1), ("cbr", 2), ("vbrRt", 3), ("vbrNrt", 4), ("abr", 5))))
if mibBuilder.loadTexts: pnnixRtstClass.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstClass.setDescription('The class the route request is to use.')
pnnixRtstType = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ptpt", 1), ("pmp", 2))))
if mibBuilder.loadTexts: pnnixRtstType.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstType.setDescription('This index specifies the type of call which may be either point to point or point to multi-point.')
pnnixRtstDest = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20))
if mibBuilder.loadTexts: pnnixRtstDest.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstDest.setDescription('The destination address. This may be specified by the user as an address prefix, but the snmp manager must pad this out to 20 octets.')
pnnixRtstError = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("success", 1), ("noRouteToDest", 2), ("dtlExhaustion", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstError.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstError.setDescription('Indicates if an error has occurred and if so, the nature of the error. If this is set to success, then no error occurred and the rest of the row contains useful information.')
pnnixRtstFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dtlAdded", 1), ("direct", 2), ("myself", 3), ("directEreach", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstFlags.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstFlags.setDescription("If error is set to success, this flag indicates the nature of the route lookup confirmation. If this flag is set to dtlAdded, then the route request resulted in a DTL being allocated for this request. In this case, the pnnixRtstOutboundPort, pnnixRtstHopCount, pnnixRtstDTL, and pnnixRtstCurPointer contain useful information. (Also, after this information is conveyed back to the manager, the DTL entry is freed.) If this flag is set to direct, then the route request is informing the caller to proceed out a directly attached port. In this case, the pnnixRtstOutboundPort is valid and is either 1 (to indicate a match on this node's summary address) or is a reference to the pnni advertised outbound port. If this flag is set to myself, then the route request is informing the caller that the test call to the node in this switching system (identified by pnnixNodeIndex) returned a successful match of myself as the destination. In this case, the pnnixRtstOutboundPort is valid and is set to 0 (which indicates a match on this node's own address). If this flag is set to directEreach, then the route request is informing the caller that the test call to the destination resulted in a direct indication. In this case, the pnnixRtstOutboundPort is valid and is set to the static route's pnni advertised port ID. If the user also specified a VPI and E.164 address, then the pnnixRtstVPI and pnnixRtstE164 fields will also be present.")
pnnixRtstOutboundPort = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 6), PnnixPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstOutboundPort.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstOutboundPort.setDescription("If error is set to success, this indicates the outbound port of the route lookup confirmation. If this is set to 0, then this indicates the call was placed to this switching system's pnnixNodeIndex. If this is set to 1, then this indicates the call was placed to a reachability which matched this node's summary address. In this event, the IAdj table would be consulted to determine the actual port (if any) where the destination resided. If set to any other value, it indicates the pnni advertised port of the static route which caused this port to be returned.")
pnnixRtstVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstVPI.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstVPI.setDescription('If error is set to success, and pnnixRtstFlags is set to directEreach, then this indicates the vpi (if set by the user) used to route the call.')
pnnixRtstE164 = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstE164.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstE164.setDescription('If error is set to success, and pnnixRtstFlags is set to directEreach, then this indicates the E.164 address (if set by the user) used to route the call.')
pnnixRtstE164len = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstE164len.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstE164len.setDescription('If error is set to success, and pnnixRtstFlags is set to directEreach, then this indicates the number of significant octets used in the above E.164 address.')
pnnixRtstHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 50))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstHopCount.setDescription('If error is set to success, and pnnixRtstFlags is set to dtlAdded, then this indicates the number of hops in the pnnixRtstDTL.')
pnnixRtstDTL = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(52, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstDTL.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstDTL.setDescription("If error is set to success, and pnnixRtstFlags is set to dtlAdded, then this indicates the DTL generated by the route lookup function in the switching system. Note that this is a complete DTL meaning that the DTL IE header is also present. It has enough room for 50 entries (50 hops). Each entry has a 22-octet node-ID followed by a 4-octet PnniPortId. Entries therefore are 26 octets each and each entry is contiguous with its predecessor and successor. This DTL will not appear in the DTL table since it's freed after generating the reply to the management station.")
pnnixRtstCurPointer = MibTableColumn((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 4, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnnixRtstCurPointer.setStatus('mandatory')
if mibBuilder.loadTexts: pnnixRtstCurPointer.setDescription('If error is set to success, and pnnixRtstFlags is set to dtlAdded, then this indicates the offset (in bytes) into pnnixRtstDTL of the curPtr.')
pnnixMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2))
pnnixMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 1))
pnnixMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2))
pnnixMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 1, 1))
pnnixGeneralMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 1))
pnnixGeneralBorderGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 2))
pnnixNodeMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 3))
pnnixNodePglMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 4))
pnnixNodePglLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 5))
pnnixNodeTimerMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 6))
pnnixNodeTimerLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 7))
pnnixNodeSvccLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 8))
pnnixScopeMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 9))
pnnixSummaryLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 10))
pnnixIfMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 11))
pnnixIfBorderGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 12))
pnnixLinkMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 13))
pnnixLinkBorderOrLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 14))
pnnixLinkLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 15))
pnnixNbrPeerMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 16))
pnnixNbrPeerLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 17))
pnnixNbrPeerPortMinGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 18))
pnnixSvccRccLgnGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 19))
pnnixPtseOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 20))
pnnixMapOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 21))
pnnixMapNodeOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 22))
pnnixMapAddrOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 23))
pnnixMapTnsOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 24))
pnnixMetricsOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 25))
pnnixRouteGeneralOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 26))
pnnixRouteNodeOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 27))
pnnixDTLOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 28))
pnnixRouteAddrOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 29))
pnnixRouteTnsOptionalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 800, 3, 2, 1, 1, 2, 2, 30))
mibBuilder.exportSymbols("XPNNI-MIB", PnnixPortId=PnnixPortId, pnnixIAdjLearned=pnnixIAdjLearned, pnnixNumIAdj=pnnixNumIAdj, pnnixRtstCurPointer=pnnixRtstCurPointer, pnnixRouteNodeBwdMetric6=pnnixRouteNodeBwdMetric6, pnnixMapEntry=pnnixMapEntry, pnnixRouteAddrRowStatus=pnnixRouteAddrRowStatus, pnnixSummaryType=pnnixSummaryType, pnnixRouteNodeBwdMetricAW=pnnixRouteNodeBwdMetricAW, pnnixRouteAddrProto=pnnixRouteAddrProto, pnnixMIBCompliances=pnnixMIBCompliances, pnnixRouteFailCountOriginator=pnnixRouteFailCountOriginator, pnnixCrankbackCountBorder=pnnixCrankbackCountBorder, pnnixMapAddrOptionalGroup=pnnixMapAddrOptionalGroup, pnnixNodePreferredPgl=pnnixNodePreferredPgl, pnnixRouteNodeBwdMetric2=pnnixRouteNodeBwdMetric2, pnnixMapNodeComplexRep=pnnixMapNodeComplexRep, pnnixSummaryPrefixLength=pnnixSummaryPrefixLength, pnnixNodeSvccTable=pnnixNodeSvccTable, pnnixAltRouteCountBorder=pnnixAltRouteCountBorder, pnnixNodeHelloInactivityFactor=pnnixNodeHelloInactivityFactor, PnnixAggrToken=PnnixAggrToken, pnnixMapAddrTable=pnnixMapAddrTable, pnnixRouteAddrMetricsTag=pnnixRouteAddrMetricsTag, PnnixLevel=PnnixLevel, pnnixRouteNodeDestPortId=pnnixRouteNodeDestPortId, ClpType=ClpType, pnnixNbrPeerRemoteNodeId=pnnixNbrPeerRemoteNodeId, pnnixIfEntry=pnnixIfEntry, pnnixIfRccTrafficDescrIndex=pnnixIfRccTrafficDescrIndex, pnnixRouteTnsPnniScope=pnnixRouteTnsPnniScope, pnnixMapPeerGroupId=pnnixMapPeerGroupId, PnnixPrefixLength=PnnixPrefixLength, pnnixNodePglReelectTime=pnnixNodePglReelectTime, pnnixNodeSvccEntry=pnnixNodeSvccEntry, pnnixMetricsTag=pnnixMetricsTag, pnnixRouteNodeFwdMetric5=pnnixRouteNodeFwdMetric5, pnnixNbrPeerRcvPtseReqs=pnnixNbrPeerRcvPtseReqs, pnnixMapNodeParentNodeId=pnnixMapNodeParentNodeId, pnnixNodePtseHolddown=pnnixNodePtseHolddown, pnnixMIBCompliance=pnnixMIBCompliance, pnnixNbrPeerPortFloodStatus=pnnixNbrPeerPortFloodStatus, pnnixMapOriginatingPortId=pnnixMapOriginatingPortId, pnnixNbrPeerPortCount=pnnixNbrPeerPortCount, pnnixRouteNodeNumber=pnnixRouteNodeNumber, pnnixRouteTnsPlan=pnnixRouteTnsPlan, pnnixMapAddrIndex=pnnixMapAddrIndex, pnnixNodePglTable=pnnixNodePglTable, pnnixNodeSvccCalledIntegrityTime=pnnixNodeSvccCalledIntegrityTime, pnnixMapNodeEntry=pnnixMapNodeEntry, pnnixIAdjTable=pnnixIAdjTable, pnniTestMIBObjects=pnniTestMIBObjects, pnnixScopeLocalNetworkPlusOne=pnnixScopeLocalNetworkPlusOne, pnnixMapNodeParentAtmAddress=pnnixMapNodeParentAtmAddress, pnnixDTLStatus=pnnixDTLStatus, pnnixRtstEntry=pnnixRtstEntry, pnnixNbrPeerRcvPtsps=pnnixNbrPeerRcvPtsps, pnnixMetricsAdminWeight=pnnixMetricsAdminWeight, pnnixMapAddrAdvertisedPortId=pnnixMapAddrAdvertisedPortId, pnnixNodeIndex=pnnixNodeIndex, TnsType=TnsType, pnnixRouteAddrAdvertisedPortId=pnnixRouteAddrAdvertisedPortId, PnnixSvccRccIndex=PnnixSvccRccIndex, pnnixDTLTable=pnnixDTLTable, pnnixRouteNodeFwdMetric7=pnnixRouteNodeFwdMetric7, pnnixRouteFailUnreachableOriginator=pnnixRouteFailUnreachableOriginator, pnnixRoutingGroup=pnnixRoutingGroup, pnnixRouteTnsIndex=pnnixRouteTnsIndex, pnnixMetrics1=pnnixMetrics1, pnnixSvccRccHelloState=pnnixSvccRccHelloState, pnnixScopeInterRegional=pnnixScopeInterRegional, pnnixRouteAddrPnniScope=pnnixRouteAddrPnniScope, pnnixNodePtseLifetimeFactor=pnnixNodePtseLifetimeFactor, pnnixSvccRccRemoteAtmAddress=pnnixSvccRccRemoteAtmAddress, pnnixScopeSiteMinusOne=pnnixScopeSiteMinusOne, pnnixSummaryAddress=pnnixSummaryAddress, pnnixNbrPeerXmtDbSums=pnnixNbrPeerXmtDbSums, pnnixRouteTnsType=pnnixRouteTnsType, pnnixRouteNodeTable=pnnixRouteNodeTable, pnnixRouteTnsOptionalGroup=pnnixRouteTnsOptionalGroup, pnnixNbrPeerSvccRccIndex=pnnixNbrPeerSvccRccIndex, pnnixNbrPeerXmtPtseReqs=pnnixNbrPeerXmtPtseReqs, pnnixMIBConformance=pnnixMIBConformance, pnnixNodePeerGroupLeader=pnnixNodePeerGroupLeader, pnnixNodeRestrictedTransit=pnnixNodeRestrictedTransit, TruthValue=TruthValue, pnnixNodeHlinkInact=pnnixNodeHlinkInact, pnnixNodeCdvPm=pnnixNodeCdvPm, pnnixSvccRccRcvHellos=pnnixSvccRccRcvHellos, pnnixRouteNodeFwdMetricAW=pnnixRouteNodeFwdMetricAW, pnnixRouteNodeEntry=pnnixRouteNodeEntry, pnnixMIB=pnnixMIB, pnnixNodeId=pnnixNodeId, pnnixIfAggrToken=pnnixIfAggrToken, pnnixRouteTnsProto=pnnixRouteTnsProto, pnnixRouteNodeGcacClp=pnnixRouteNodeGcacClp, pnnixNodeEntry=pnnixNodeEntry, pnnixNbrPeerXmtPtsps=pnnixNbrPeerXmtPtsps, pnnixNodePeerGroupId=pnnixNodePeerGroupId, pnnixSummaryTable=pnnixSummaryTable, pnnixNodeTimerLgnGroup=pnnixNodeTimerLgnGroup, pnnixDTLIndex=pnnixDTLIndex, pnnixRtstFlags=pnnixRtstFlags, pnnixSummaryRowStatus=pnnixSummaryRowStatus, pnnixScopeCommunityMinusOne=pnnixScopeCommunityMinusOne, pnnixIAdjSlot=pnnixIAdjSlot, pnnixMetrics2=pnnixMetrics2, pnnixMetrics4=pnnixMetrics4, pnnixMapNodeAtmAddress=pnnixMapNodeAtmAddress, pnnixLinkIfIndex=pnnixLinkIfIndex, pnnixSummaryLgnGroup=pnnixSummaryLgnGroup, pnnixRouteNodeBwdMetric7=pnnixRouteNodeBwdMetric7, PnnixVersion=PnnixVersion, pnnixRtstE164len=pnnixRtstE164len, pnnixNodeAvcrMt=pnnixNodeAvcrMt, pnnixMapAddrAddress=pnnixMapAddrAddress, pnnixRouteAddrAdvertisingNodeId=pnnixRouteAddrAdvertisingNodeId, pnnixNodeMinGroup=pnnixNodeMinGroup, pnnixLinkRemotePortId=pnnixLinkRemotePortId, pnnixSvccRccEntry=pnnixSvccRccEntry, pnnixSvccRccLgnGroup=pnnixSvccRccLgnGroup, pnnixNodeLowest=pnnixNodeLowest, pnnixNodePglLeadershipPriority=pnnixNodePglLeadershipPriority, pnnixNodeCtdPm=pnnixNodeCtdPm, pnnixNodePglState=pnnixNodePglState, pnnixRouteTnsPtseId=pnnixRouteTnsPtseId, pnnixPtseType=pnnixPtseType, pnnixRouteAddrIfIndex=pnnixRouteAddrIfIndex, pnnixNbrPeerPortMinGroup=pnnixNbrPeerPortMinGroup, pnnixIfRccServiceCategory=pnnixIfRccServiceCategory, pnnixRouteTnsOriginateAdvertisement=pnnixRouteTnsOriginateAdvertisement, pnnixIfAdmWeightUbr=pnnixIfAdmWeightUbr, pnnixRouteNodeOptionalGroup=pnnixRouteNodeOptionalGroup, pnnixRouteNodeProto=pnnixRouteNodeProto, pnnixPtseOriginatingNodeId=pnnixPtseOriginatingNodeId, ServiceCategory=ServiceCategory, pnnixNodeTable=pnnixNodeTable, pnnixRtstDest=pnnixRtstDest, pnnixMetrics3=pnnixMetrics3, pnnixNbrPeerPortId=pnnixNbrPeerPortId, pnnixMapNodeParentPeerGroupId=pnnixMapNodeParentPeerGroupId, pnnixMIBObjects=pnnixMIBObjects, pnnixMapAddrPrefixLength=pnnixMapAddrPrefixLength, pnnixScopeMappingEntry=pnnixScopeMappingEntry, pnnixIadjIndex=pnnixIadjIndex, pnnixNodeCfgParentNodeIndex=pnnixNodeCfgParentNodeIndex, pnnixNodePtseRefreshInterval=pnnixNodePtseRefreshInterval, pnnixIfPortId=pnnixIfPortId, pnnixRouteTnsMetricsTag=pnnixRouteTnsMetricsTag, pnnixMapNodeId=pnnixMapNodeId, pnnixIfAdmWeightCbr=pnnixIfAdmWeightCbr, pnnixNodeTimerTable=pnnixNodeTimerTable, pnnixSvccRccIfIndex=pnnixSvccRccIfIndex, pnnixMapNodeRestrictedTransit=pnnixMapNodeRestrictedTransit, pnnixMapMetricsTag=pnnixMapMetricsTag, pnnixNodeTimerEntry=pnnixNodeTimerEntry, pnnixLinkVersion=pnnixLinkVersion, pnnixRouteTnsOperStatus=pnnixRouteTnsOperStatus, pnnixMapNodePreferredPgl=pnnixMapNodePreferredPgl, pnnixRouteAddrOriginateAdvertisement=pnnixRouteAddrOriginateAdvertisement, pnnixNodePtses=pnnixNodePtses, pnnixLinkBorderOrLgnGroup=pnnixLinkBorderOrLgnGroup, pnnixBaseGroup=pnnixBaseGroup, pnnixRouteTnsVPCapability=pnnixRouteTnsVPCapability, pnnixMapTnsAdvertisedPortId=pnnixMapTnsAdvertisedPortId, pnnixNodeSvccLgnGroup=pnnixNodeSvccLgnGroup, pnnixLinkDerivedAggrToken=pnnixLinkDerivedAggrToken, pnnixIfMinGroup=pnnixIfMinGroup, pnnixMapTnsOptionalGroup=pnnixMapTnsOptionalGroup, pnnixScopeIntraCommunity=pnnixScopeIntraCommunity, pnnixMapAggrToken=pnnixMapAggrToken, pnnixMapTnsType=pnnixMapTnsType, pnniRtstMIBGroup=pnniRtstMIBGroup, pnnixIfNodeIndex=pnnixIfNodeIndex, pnnixNbrPeerRcvPtseAcks=pnnixNbrPeerRcvPtseAcks, pnnixRouteNodeFwdMetric8=pnnixRouteNodeFwdMetric8, pnnixIfAdmWeightRtVbr=pnnixIfAdmWeightRtVbr, pnnixMapAddrEntry=pnnixMapAddrEntry, pnnixMetrics5=pnnixMetrics5, pnnixPtseEntry=pnnixPtseEntry, pnnixRouteNodeBwdMetric3=pnnixRouteNodeBwdMetric3, pnnixRouteFailCountBorder=pnnixRouteFailCountBorder, pnnixSvccRccRemoteNodeId=pnnixSvccRccRemoteNodeId, pnnixRtstError=pnnixRtstError, InterfaceIndex=InterfaceIndex, pnnixRouteNodeBwdMetric8=pnnixRouteNodeBwdMetric8, PnnixMetricsTag=PnnixMetricsTag, pnnixNbrPeerTable=pnnixNbrPeerTable, pnnixRouteTnsIfIndex=pnnixRouteTnsIfIndex, pnnixNodePglLgnGroup=pnnixNodePglLgnGroup, pnnixRouteNodeBwdMetric5=pnnixRouteNodeBwdMetric5, pnnixDTLLinkType=pnnixDTLLinkType, pnnixRouteNodeClass=pnnixRouteNodeClass, pnnixSummarySuppress=pnnixSummarySuppress, pnnixRouteNodeBwdMetric1=pnnixRouteNodeBwdMetric1, pnnixIfBorderGroup=pnnixIfBorderGroup, pnnixNbrPeerMinGroup=pnnixNbrPeerMinGroup, pnnixMapNodeLeadershipPriority=pnnixMapNodeLeadershipPriority, pnnixLinkCommonPeerGroupId=pnnixLinkCommonPeerGroupId, pnnixMapNodeDatabaseOverload=pnnixMapNodeDatabaseOverload, pnnixScopeLocalNetwork=pnnixScopeLocalNetwork, pnnixNbrPeerRcvDbSums=pnnixNbrPeerRcvDbSums, pnnixMapNodeOptionalGroup=pnnixMapNodeOptionalGroup, pnnixMapNodePeerGroupId=pnnixMapNodePeerGroupId, pnnixRouteAddrPtseId=pnnixRouteAddrPtseId, pnnixHighestVersion=pnnixHighestVersion, pnnixRouteTnsInfo=pnnixRouteTnsInfo, pnnixRouteAddrVPCapability=pnnixRouteAddrVPCapability, pnnixRouteAddrOptionalGroup=pnnixRouteAddrOptionalGroup, pnnixRouteNodeBwdMetric4=pnnixRouteNodeBwdMetric4, pnnixRouteNodeInfo=pnnixRouteNodeInfo, pnnixNodeAtmAddress=pnnixNodeAtmAddress, pnnixLinkHelloState=pnnixLinkHelloState, pnnixScopeGlobal=pnnixScopeGlobal, pnnixNbrPeerXmtPtseAcks=pnnixNbrPeerXmtPtseAcks, pnnixDtlCountBorder=pnnixDtlCountBorder, pnnixRouteNodeDTL=pnnixRouteNodeDTL, pnnixIfAdmWeightNrtVbr=pnnixIfAdmWeightNrtVbr, pnnixMapNodeTable=pnnixMapNodeTable, pnnixPtseSequenceNum=pnnixPtseSequenceNum, pnnixMapTable=pnnixMapTable, pnnixNodeSvccCallingIntegrityTime=pnnixNodeSvccCallingIntegrityTime, pnnixRouteNodeTimeStamp=pnnixRouteNodeTimeStamp, pnnixSvccRccVersion=pnnixSvccRccVersion, pnnixNodeDatabaseOverload=pnnixNodeDatabaseOverload, pnnixNodePeerDelayedAckInterval=pnnixNodePeerDelayedAckInterval, pnnixRouteNodeVPCapability=pnnixRouteNodeVPCapability, pnnixRtstTable=pnnixRtstTable, pnnixRouteTnsTimeStamp=pnnixRouteTnsTimeStamp, pnnixRouteTnsTable=pnnixRouteTnsTable, pnnixRouteTnsAdvertisedPortId=pnnixRouteTnsAdvertisedPortId, pnnixMIBGroups=pnnixMIBGroups, pnnixScopeIntraSite=pnnixScopeIntraSite, pnnixMetrics6=pnnixMetrics6, TnsPlan=TnsPlan, pnnixAltRouteCountOriginator=pnnixAltRouteCountOriginator, pnnixIfTable=pnnixIfTable, pnnixPtseTable=pnnixPtseTable, pnnixScopeLocalNetworkPlusTwo=pnnixScopeLocalNetworkPlusTwo, pnnixNodePglOverrideDelay=pnnixNodePglOverrideDelay, pnnixRtstType=pnnixRtstType, pnnixRouteAddrNumber=pnnixRouteAddrNumber, pnnixNodeHelloHolddown=pnnixNodeHelloHolddown, pnnixMapIndex=pnnixMapIndex, pnnixNodeRestrictedBranching=pnnixNodeRestrictedBranching, pnnixNodeTimerMinGroup=pnnixNodeTimerMinGroup, pnnixNodeAdminStatus=pnnixNodeAdminStatus, pnnixSvccRccTable=pnnixSvccRccTable, pnnixRouteNodeFwdMetric4=pnnixRouteNodeFwdMetric4, pnnixNodeAvcrPm=pnnixNodeAvcrPm, pnnixNodePglTimeStamp=pnnixNodePglTimeStamp, pnnixDTLEntryIndex=pnnixDTLEntryIndex, pnnixMetricsOptionalGroup=pnnixMetricsOptionalGroup, pnnixRouteAddrTable=pnnixRouteAddrTable)
mibBuilder.exportSymbols("XPNNI-MIB", pnnixPtseOptionalGroup=pnnixPtseOptionalGroup, pnnixRouteNodeFwdMetric6=pnnixRouteNodeFwdMetric6, pnnixMapOptionalGroup=pnnixMapOptionalGroup, pnnixScopeMinGroup=pnnixScopeMinGroup, pnnixNbrPeerLgnGroup=pnnixNbrPeerLgnGroup, pnnixIfVPCapability=pnnixIfVPCapability, pnnixPtseChecksum=pnnixPtseChecksum, pnnixIAdjPort=pnnixIAdjPort, pnnixNodePglMinGroup=pnnixNodePglMinGroup, pnnixSvccRccIndex=pnnixSvccRccIndex, PnnixAtmAddr=PnnixAtmAddr, pnnixMetricsEntry=pnnixMetricsEntry, pnnixLinkTable=pnnixLinkTable, pnnixSvccRccXmtHellos=pnnixSvccRccXmtHellos, pnnixPtseInfo=pnnixPtseInfo, pnnixMapAddrAdvertisingNodeId=pnnixMapAddrAdvertisingNodeId, pnnixRouteTnsRowStatus=pnnixRouteTnsRowStatus, pnnixNbrPeerState=pnnixNbrPeerState, pnnixNodeComplexRep=pnnixNodeComplexRep, pnnixIAdjGroup=pnnixIAdjGroup, pnnixIAdjInst=pnnixIAdjInst, pnnixGeneralBorderGroup=pnnixGeneralBorderGroup, pnnixLinkUpnodeId=pnnixLinkUpnodeId, PnnixNodeIndex=PnnixNodeIndex, pnnixLinkPortId=pnnixLinkPortId, pnnixNodeDomainName=pnnixNodeDomainName, pnnixScopeCommunityPlusOne=pnnixScopeCommunityPlusOne, pnnixGeneralMinGroup=pnnixGeneralMinGroup, pnnixLinkRemoteNodeId=pnnixLinkRemoteNodeId, pnnixRouteNodeFwdMetric3=pnnixRouteNodeFwdMetric3, pnnixRouteGeneralOptionalGroup=pnnixRouteGeneralOptionalGroup, pnnixRouteAddrOperStatus=pnnixRouteAddrOperStatus, pnnixRtstVPI=pnnixRtstVPI, pnnixMetricsGcacClp=pnnixMetricsGcacClp, pnnixRouteNodeStatus=pnnixRouteNodeStatus, pnnixRouteAddrIndex=pnnixRouteAddrIndex, pnnixScopeRegional=pnnixScopeRegional, pnnixLinkMinGroup=pnnixLinkMinGroup, pnnixLinkSvccRccIndex=pnnixLinkSvccRccIndex, pnnixNodeSvccTrafficDescriptorIndex=pnnixNodeSvccTrafficDescriptorIndex, pnnixIAdjEntry=pnnixIAdjEntry, pnnixRouteNodeFwdMetric1=pnnixRouteNodeFwdMetric1, pnnixMapRemotePortId=pnnixMapRemotePortId, pnnixNodePglEntry=pnnixNodePglEntry, pnnixLowestVersion=pnnixLowestVersion, pnnixRouteAddrAddress=pnnixRouteAddrAddress, pnnixScopeOrganizationMinusOne=pnnixScopeOrganizationMinusOne, pnnixLinkLgnGroup=pnnixLinkLgnGroup, pnnixIAdjAdvertised=pnnixIAdjAdvertised, pnnixDtlCountOriginator=pnnixDtlCountOriginator, PnnixNodeId=PnnixNodeId, pnnixMapPtseId=pnnixMapPtseId, pnnixNbrPeerPortEntry=pnnixNbrPeerPortEntry, pnnixRouteTnsId=pnnixRouteTnsId, pnnixMapOriginatingNodeId=pnnixMapOriginatingNodeId, pnnixNodeOperStatus=pnnixNodeOperStatus, AtmAddrPrefix=AtmAddrPrefix, pnnixSvccRccVpi=pnnixSvccRccVpi, pnnixLinkUpnodeAtmAddress=pnnixLinkUpnodeAtmAddress, pnnixIAdjAtmAddress=pnnixIAdjAtmAddress, pnnixDTLEntry=pnnixDTLEntry, pnnixMapNodeIAmLeader=pnnixMapNodeIAmLeader, pnnixPtseId=pnnixPtseId, pnnixMapNodeParentPglNodeId=pnnixMapNodeParentPglNodeId, pnnixScopeIntraOrganization=pnnixScopeIntraOrganization, pnnixRouteTnsRouteType=pnnixRouteTnsRouteType, pnnixLinkType=pnnixLinkType, pnnixMetrics8=pnnixMetrics8, pnnixMetricsClasses=pnnixMetricsClasses, pnnixNbrPeerEntry=pnnixNbrPeerEntry, pnnixRouteTnsEntry=pnnixRouteTnsEntry, pnnixRouteFailUnreachableBorder=pnnixRouteFailUnreachableBorder, pnnixScopeOrganizationPlusOne=pnnixScopeOrganizationPlusOne, pnnixRouteBaseGroup=pnnixRouteBaseGroup, pnnixRouteAddrPrefixLength=pnnixRouteAddrPrefixLength, pnnixMetricsRowStatus=pnnixMetricsRowStatus, pnnixRtstHopCount=pnnixRtstHopCount, pnnixMapTnsAdvertisingNodeId=pnnixMapTnsAdvertisingNodeId, pnnixDTLOptionalGroup=pnnixDTLOptionalGroup, pnnixPtseLifeTime=pnnixPtseLifeTime, pnnixNodeSvccRetryTime=pnnixNodeSvccRetryTime, pnnixMapTnsTable=pnnixMapTnsTable, PnnixPeerGroupId=PnnixPeerGroupId, pnnixLinkRcvHellos=pnnixLinkRcvHellos, pnnixMapTnsPlan=pnnixMapTnsPlan, pnnixCrankbackCountOriginator=pnnixCrankbackCountOriginator, pnnixMapType=pnnixMapType, pnniIAdjMIBObjects=pnniIAdjMIBObjects, pnnixNodeRowStatus=pnnixNodeRowStatus, pnnixMapTnsId=pnnixMapTnsId, PnnixHelloState=PnnixHelloState, pnnixMetricsDirection=pnnixMetricsDirection, pnnixRtstE164=pnnixRtstE164, pnnixLinkXmtHellos=pnnixLinkXmtHellos, pnnixRtstClass=pnnixRtstClass, pnnixRouteTnsAdvertisingNodeId=pnnixRouteTnsAdvertisingNodeId, pnnixRouteAddrType=pnnixRouteAddrType, pnnixRouteAddrInfo=pnnixRouteAddrInfo, pnnixMapVPCapability=pnnixMapVPCapability, pnnixRouteAddrEntry=pnnixRouteAddrEntry, pnnixIAdjSummarized=pnnixIAdjSummarized, pnnixIAdjCsmPPort=pnnixIAdjCsmPPort, pnnixDTLNodeId=pnnixDTLNodeId, pnnixNodeHelloInterval=pnnixNodeHelloInterval, pnnixDTLPortId=pnnixDTLPortId, pnnixMetrics7=pnnixMetrics7, pnnixRouteNodeDestNodeId=pnnixRouteNodeDestNodeId, AtmpTrafficDescrParamIndex=AtmpTrafficDescrParamIndex, pnnixSvccRccVci=pnnixSvccRccVci, pnnixMapRemoteNodeId=pnnixMapRemoteNodeId, pnnixRtstOutboundPort=pnnixRtstOutboundPort, pnnixMapNodeRestrictedBranching=pnnixMapNodeRestrictedBranching, pnnixIfAdmWeightAbr=pnnixIfAdmWeightAbr, pnnixRouteNodeFwdMetric2=pnnixRouteNodeFwdMetric2, pnnixNbrPeerPortTable=pnnixNbrPeerPortTable, pnnixSummaryEntry=pnnixSummaryEntry, pnnixMetricsTable=pnnixMetricsTable, pnnixNodeLevel=pnnixNodeLevel, pnnixNodeRxmtInterval=pnnixNodeRxmtInterval, pnnixMetricsIndex=pnnixMetricsIndex, pnnixRouteAddrTimeStamp=pnnixRouteAddrTimeStamp, pnnixSummaryState=pnnixSummaryState, pnnixNodeSvccInitTime=pnnixNodeSvccInitTime, pnnixRtstDTL=pnnixRtstDTL, pnnixNodeActiveParentNodeId=pnnixNodeActiveParentNodeId, pnnixScopeMappingTable=pnnixScopeMappingTable, pnnixScopeSitePlusOne=pnnixScopeSitePlusOne, pnnixMapTnsEntry=pnnixMapTnsEntry, pnnixNodePglInitTime=pnnixNodePglInitTime, pnnixLinkEntry=pnnixLinkEntry)

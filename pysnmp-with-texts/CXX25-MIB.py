#
# PySNMP MIB module CXX25-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXX25-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:33:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
Alias, SapIndex, cxX25, ThruputClass = mibBuilder.importSymbols("CXProduct-SMI", "Alias", "SapIndex", "cxX25", "ThruputClass")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, NotificationType, Integer32, ModuleIdentity, Unsigned32, IpAddress, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, NotificationType, MibIdentifier, TimeTicks, Counter64, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "Integer32", "ModuleIdentity", "Unsigned32", "IpAddress", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "NotificationType", "MibIdentifier", "TimeTicks", "Counter64", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class SapType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("lower", 1), ("upper", 2))

class PacketSize(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))
    namedValues = NamedValues(("bytes16", 4), ("bytes32", 5), ("bytes64", 6), ("bytes128", 7), ("bytes256", 8), ("bytes512", 9), ("bytes1024", 10), ("bytes2048", 11), ("bytes4096", 12))

class Ces(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 63)

class Lcn(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 1024)

class CugIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 99)

class CugIC(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class RoutePartition(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class RouteIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 999)

class HGIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 99)

class PvcIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 200)

class X25Address(DisplayString):
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(0, 15)

x25LowerPoolThreshold = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LowerPoolThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: x25LowerPoolThreshold.setDescription('Determines the minimum amount of system resources which are required by the X.25 layer. When system resources drop below this threshold, the X.25 layer clears any virtual circuits for which data activity is detected. The value of this object must not be greater than the value of object x25UpperPoolThreshold. Range of Values: 1 - 99 Default Value: 30 (30 percent) Related Objects: x25UpperPoolThreshold x25SapFlowControlState x25SapFlowControlTimer Configuration Changed: administrative')
x25UpperPoolThreshold = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25UpperPoolThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: x25UpperPoolThreshold.setDescription('Determines the amount of system resources which are required by the X.25 layer to avoid congestion. When system resources drop below this threshold, the X.25 layer does the following: - prohibits new virtual circuits from being established on any SAP (service access point) - initiates flow control on all existing virtual circuits receiving data (an RNR is transmitted on each circuit) When global resources rise above this threshold after having dropped below it, the X.25 layer does the following: - it disables flow control on all suspended virtual circuits (transmits a RR on each circuit that that it previously transmitted an RNR on) - permits new virtual circuits to be established The value of this object must not be less than the value of object x25LowerPoolThreshold. Range of Values: 1 - 99 Default Value: 40 (40 percent) Related Objects: x25LowerPoolThreshold x25SapFlowControlTimer Configuration Changed: administrative')
x25RouteMask = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteMask.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteMask.setDescription("Determines the number of digits to use for routing calls. If set to value '0', calls are routed normally, according to the called address specified. A value greater than '0' indicates how many called address digits are used to scan the route table. Any call received with a called address containing less or more digits than specified for this object is refused. Range of Values: 0 - 15 Default Value: 0 Related Objects: x25SapRouteDirection x25RouteTable Configuration Changed: administrative")
x25BillingSegmentSize = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 1024)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25BillingSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25BillingSegmentSize.setDescription('Determines the size of billing data segments. Range of Values: 16 - 1024 bytes Default Value: 16 bytes Related Objects: x25Billing x25SapPvcBillingTimer x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication Configuration Changed: administrative')
x25Billing = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25Billing.setStatus('mandatory')
if mibBuilder.loadTexts: x25Billing.setDescription('Determines if this layer generates the x25BillingIndication trap. For switched virtual circuits the trap is generated each time a call is cleared. For permanent virtual circuits the trap is generated each time the x25SapPvcBillingTimer expires. Options: disabled (1): This layer does not generate the x25BillingIndication trap. enabled (2): This layer generates the x25BillingIndication trap. Default Value: disabled (1) Related Objects: x25BillingSegmentSize x25SapPvcBillingTimer x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication Configuration Changed: administrative and operative')
x25NetworkType = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("publicDataNetwork", 1), ("privateDataNetwork", 2), ("dteEndpoint", 3))).clone('dteEndpoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25NetworkType.setStatus('mandatory')
if mibBuilder.loadTexts: x25NetworkType.setDescription("Determines the format of the cause codes the X.25 layer adds to Reset, Restart, and Clear packets. Note: The X.25 layer will not generate Diagnostics packets for any SAP when configured with value 'dteEndpoint'. Options: publicDataNetwork (1): Standard cause codes are generated. privateDataNetwork (2): Cause codes have the most significant bit set. dteEndpoint (3): Cause codes (with most significant bit set) are only generated for SAPs configured as DCEs, and are set to 0 for SAPs configured as DTEs. Related Objects: x25SapInterfaceType Default Value: dteEndpoint (3) Configuration Changed: administrative")
x25HuntGroupRotation = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25HuntGroupRotation.setStatus('mandatory')
if mibBuilder.loadTexts: x25HuntGroupRotation.setDescription('Determines if hunt group members are rotated. Enabling rotation causes hunting to begin with a different hunt group member each time. For example, a group with three members would be hunted as follows: 123, 231, 312, 123. Group members are rotated after each use or after detection of a member which is unavailable. Options: disabled (1): Hunt group members are not rotated. enabled (2):. Hunt group members are rotated. Default Value: disabled (1) Related Objects: x25HuntGroupTable Configuration Changed: administrative')
x25Alarms = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25Alarms.setStatus('mandatory')
if mibBuilder.loadTexts: x25Alarms.setDescription('For future use. Determines if this layer generates the x25SapAlarm trap. Options: disabled (1): This layer does not generate the x25SapAlarm trap. enabled (2): This layer generates the x25SapAlarm trap. Default Value: disabled (1) Related Objects: x25SapStatusEvent x25SapAlarm Configuration Changed: administrative and operative')
x25SapStatusEvent = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("noEvent", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatusEvent.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatusEvent.setDescription("For future use. Indicates the status reported by an x25SapAlarm trap when it occurs. This object always returns the value 'noEvent' when read. Options: noEvent (1): There is no status to report. Related Objects: x25Alarms x25SapStatusEvent")
x25ConfigErrorEvent = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("noError", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25ConfigErrorEvent.setStatus('mandatory')
if mibBuilder.loadTexts: x25ConfigErrorEvent.setDescription("For future use. Indicates the status reported by an x25ConfigErrorIndication trap when it occurs. This object always returns the value 'noEvent' when read. Options: noEvent (1): There is no error event to report. Related Objects: x25ConfigErrorIndication")
x25SoftwareVersions = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SoftwareVersions.setStatus('mandatory')
if mibBuilder.loadTexts: x25SoftwareVersions.setDescription('Identifies the X.25 software revision number, which is displayed as a string of five numbers each separated by a period (1.2.3.4.5). The five numbers represent: - (1) main version number - (2) main revision number - (3) branch version number - (4) branch revision number - (5) part number')
x25LogicalLinkTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20), )
if mibBuilder.loadTexts: x25LogicalLinkTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25LogicalLinkTable.setDescription('A logical link is a group of one or more lower service access points(SAPs) created for the purpose of route balancing. Two types of route balancing algorithms are supported: prioritized or balanced. In order to use a logical link group for routing, one or more route table entries must be created that refer to the group. Members of a logical link group are uniquely identified by two values: SAP Number and CES.')
x25LogicalLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1), ).setIndexNames((0, "CXX25-MIB", "x25LLNumber"), (0, "CXX25-MIB", "x25LLSapNumber"), (0, "CXX25-MIB", "x25LLSapCes"))
if mibBuilder.loadTexts: x25LogicalLinkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25LogicalLinkEntry.setDescription('Defines a row in the x25LogicalLinkTable. Each row contains the objects which are used to define a member of a logical link.')
x25LLNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 1), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LLNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLNumber.setDescription('Identifies the logical link entry with a unique numerical value.')
x25LLSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 2), SapIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LLSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLSapNumber.setDescription('Determines the lower X.25 layer SAP (service access point) this logical link is associated with. This is the first half of the SAP identification. The second half is specified by object x25LLSapCes. Only lower SAPs can be part of a logical link. Range of Values: 1 - 255 Configuration Changed: administrative')
x25LLSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 3), Ces()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LLSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLSapCes.setDescription('Determines the CES (connection endpoint suffix) this logical link is associated with. CES is used by X.25 over the ISDN D channel to support multiple data links on one physical (LAPD) link. The CES for each link must be unique and is normally set in the range 0 to 63. In the case of X.25 LAPB, CES is not used and is set to 0. Range of Values: 1 - 63 Default Value: none Configuration Changed: administrative')
x25LLRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LLRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Configuration Changed: administrative')
x25LLRouteAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("balanced", 1), ("prioritized", 2))).clone('prioritized')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25LLRouteAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLRouteAlgorithm.setDescription('Determines the algorithm used by this logical link to choose the member to route a call to. The value set for the first member of a logical group (lowest SAP/CES combination) overrides the settings for all other members of the group. Therefore, if you want to change the route algorithm for a group you need to alter the settings of the first member only. Options: balanced (1): Members are chosen in round-robin fashion. prioritized (2): The first member is always chosen for routing. The second is chosen if the first is not available (disconnected or congested). The third is chosen if the first and the second are not available, etc. Default Value: prioritized (2) Related Objects: x25LLSapNumber x25LLSapCes Configuration Changed: administrative')
x25LLEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 20, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLine", 1), ("onLine", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LLEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: x25LLEntryState.setDescription('Indicates the state of this logical link. Options: offLine (1): This logical link is configured. onLine (2): This logical link is not configured.')
x25SapTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21), )
if mibBuilder.loadTexts: x25SapTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapTable.setDescription("The SAP table contains configuration information for each X.25 layer SAP (service access point). Service Access Points Two types of SAPs exist: - Upper: A SAP that exists at the upper interface of the X.25 layer and serves an embedded application. - Lower: A SAP that exists at the lower interface of the X.25 layer and serves a single data link connection (LAPB) or multiple data link connections (LAPD). This data link connection, when attached to the sub-layer, can complete a LAPB service, or can be one of many supported data link connections over a LAPD service. SAPs are identified by a SAP Number and CES (connection endpoint suffix). X.25 LAPB service supports only one data link connection and thus only one SAP is required. Its CES is irrelevant and is normally set to 0 at this SAP. This SAP communicates with its 'companion' SAP at the sub-layer in a one-to-one relationship. X.25 LAPD service supports multiple data link connections, and thus multiple SAPs are required. The CES for each must be unique and is normally in the range of 0 to 63. Each of these SAPs (which are grouped according to SAP Number) communicate with the same 'companion' SAP at the sub-layer in a many-to-one relationship. Facilities This table contains numerous facilities subscription parameters. Each facility subscription that is part of the standard, is referenced to the appropriate section in the ITU(CCITT) X.25 (1988) blue book in the REFERENCE section of the object. Terms used in this table Incoming calls: For lower SAPs, these are the X.25 calls received from the sub-layer. For upper SAPs, these are the X.25 calls received from the associated application. Outgoing calls: Are the X.25 calls routed from other SAPs, which are to go out this SAP. Source side: The side that received an incoming call. Destination side: The side that will send the outgoing call.")
x25SapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1), ).setIndexNames((0, "CXX25-MIB", "x25SapNumber"), (0, "CXX25-MIB", "x25SapCes"))
if mibBuilder.loadTexts: x25SapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapEntry.setDescription('Defines a row in the x25SapTable. Each row contains the objects which define a service access point.')
x25SapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 1), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapNumber.setDescription('Identifies this SAP (service access point) with a numerical value. This is the first half of the SAP identifier. The second half is specified by object x25SapCes. The full SAP identification must uniquely identify a SAP which exists within the X.25 layer. Range of Values: 1 - 255 Default Value: none Related Objects: x25SapCes Configuration Changed: administrative')
x25SapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 2), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapCes.setDescription('Identifies the CES (connection endpoint suffix) that is associated with this SAP (service access point). CES is used by X.25 over the ISDN D channel to support multiple data links on one physical (LAPD) link. The CES for each link must be unique and is normally set in the range 0 to 63. When associated with a LAPD service at the Data Link layer, the CES is combined with the data link SAPI (sap identification index) to form the connection endpoint identifier (CEI). This uniquely identifies each data link connection. The Data Link layer maps the CES to a TEI (terminal endpoint identifier), and combines it with the SAPI to form the DLCI (data link connection identifier), which is used on the ISDN D-Channel. In the case of X.25 LAPB, CES is not used and is set to 0. When this object is not specified (upper SAPs), its value defaults to 0. Range of Values: 0 - 63 Default Value: none Related Objects: x25SapNumber Configuration Changed: administrative')
x25SapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: none Configuration Changed: administrative')
x25SapType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 4), SapType().clone('lower')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapType.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapType.setDescription("Specifies this SAP (service access point) as either 'upper' or 'lower'. Options: lower (1): This is a lower SAP. upper (2): This is an upper SAP. Default Value: lower (1) Configuration Changed: administrative")
x25SapAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 5), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapAlias.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapAlias.setDescription('Identifies this service access point by a textual name. Names must be unique across all service access points at all layers. Range of Values: 1 -16 alphanumeric characters (first character must be a letter) Default Value: none Configuration Changed: administrative')
x25SapCompanionAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 6), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapCompanionAlias.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapCompanionAlias.setDescription('This object applies only to lower SAPs (service access points). Determines the sub-layer SAP this SAP communicates with. This object contains the textual name of the sub- layer SAP. All service access points whose CES share the same SAP number (as specified by object x25SapNumber) must specify the same companion alias. Range of Values: 1 -16 alphanumeric characters (first character must be a letter) Related Objects: x25SapNumber Default Value: none Configuration Changed: administrative')
x25SapInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapInterfaceType.setDescription('This object applies only to lower SAPs (service access points). Determines the SAP interface type. This is used to determine the how cause codes are generated, and how facility subscriptions are handled. Options: dte (1): This SAP communicates with an external X.25 DCE. dce (2): This SAP communicates with an external X.25 DTE. Default Value: dte (1) Configuration Changed: administrative')
x25SapLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("x25Link", 1), ("x75Link", 2))).clone('x25Link')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLinkType.setDescription('This object applies only to lower SAPs (service access points). Determines the type of service provided by this SAP. Options: x25Link (1): This SAP provides support for the X.25 protocol. x75Link (2): This SAP provides support for the X.75 protocol. (For future use.) Default Value: x25Link (1) Configuration Changed: administrative')
x25SapRoutePartition = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 19), RoutePartition()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRoutePartition.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRoutePartition.setDescription('Determines the route table partition used to route incoming calls. Default Value: 0 Related Objects: x25RouteTable Configuration Changed: administrative and operative')
x25SapRouteDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("upper", 2), ("lower", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRouteDirection.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRouteDirection.setDescription('This object applies only to lower SAPs (service access points). Determines the direction for the routing of incoming calls. Options: both (1): Permits calls to be routed to both upper and lower SAPs. upper (2): Restricts the routing of calls to upper SAPs only. lower (3): Restricts the routing of calls to other lower SAPs only. Default Value: both (1) Related Objects: x25RouteMask x25RouteTable Configuration Changed: administrative and operative')
x25SapWildCardRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapWildCardRouting.setStatus('obsolete')
if mibBuilder.loadTexts: x25SapWildCardRouting.setDescription('Determines if this SAP applies a routing mask to the called address in incoming calls prior to routing. This implies that certain called address digits may be masked out prior to searching the route table. The mask is specified by object x25SapWildCardRoutingMask. Options: false (1):No mask is applied to incoming calls prior to routing. true (2): A mask is applied to the called address in incoming calls prior to routing. Default Value: false (1) Related Objects: x25RouteMask x25SapRouteDirection x25SapWildCardRoutingMask x25RouteTable Configuration Changed: administrative and operative')
x25SapWildCardRoutingMask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapWildCardRoutingMask.setStatus('obsolete')
if mibBuilder.loadTexts: x25SapWildCardRoutingMask.setDescription('Determines the route mask, which is applied to the called address in incoming calls prior to routing. The route mask is a bit mask, with each bit directly mapped to the corresponding digit in the X.25 called address, starting with the least significant bit (bit 1) and ending with the most significant bit (bit 15.) Turning a mask bit on (setting it to 1), means the corresponding digit in the X.25 address is used during routing. Turning a mask bit off (setting it to 0), means the corresponding digit is ignored during routing. Range of Values: 0 - 32767 Default Value: 0 Related Objects: x25SapWildCardRouting Configuration Changed: administrative and operative')
x25SapActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("normal", 1), ("dynamic", 2), ("dynamic-30s-delay", 3), ("dynamic-60s-delay", 4), ("dynamic-90s-delay", 5), ("dynamic-120s-delay", 6))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapActivation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapActivation.setDescription('This object applies only to lower SAPs (service access points). Determines the type of data link activation used by this SAP. These are internal commands exchanged between X.25 and the sub-layer. Options: normal (1): Forces this SAP to attempt a connection to the sub-layer immediately following a system reset, and periodically thereafter until confirmed. dynamic (2): Forces this SAP to attempt a connection to the sub-layer only when an outgoing call is routed through this SAP. Subsequently forces this SAP to disconnect from the sub-layer following the clearing of the last existing call routed through this SAP. dynamic-30s-delay (3): Forces this SAP to attempt a connection to the sub-layer only when an outgoing call is routed through this SAP. Subsequently forces this SAP to delay disconnect from the sub-layer following the clearing of the last existing call routed through this SAP until either a new call is received, or 30 seconds have elapsed, whichever comes first. dynamic-60s-delay (4): Forces this SAP to attempt a connection to the sub-layer only when an outgoing call is routed through this SAP. Subsequently forces this SAP to delay disconnect from the sub-layer following the clearing of the last existing call routed through this SAP until either a new call is received, or 60 seconds have elapsed, whichever comes first. dynamic-90s-delay (5): Forces this SAP to attempt a connection to the sub-layer only when an outgoing call is routed through this SAP. Subsequently forces this SAP to delay disconnect from the sub-layer following the clearing of the last existing call routed through this SAP until either a new call is received, or 90 seconds have elapsed, whichever comes first. dynamic-120s-delay (6): Forces this SAP to attempt a connection to the sub-layer only when an outgoing call is routed through this SAP. Subsequently forces this SAP to delay disconnect from the sub-layer following the clearing of the last existing call routed through this SAP until either a new call is received, or 120 seconds have elapsed, whichever comes first. Default Value: normal Configuration Changed: administrative and operative')
x25SapPvcBillingTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapPvcBillingTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapPvcBillingTimer.setDescription("For future use. This object applies only to lower SAPs (service access points). Determines the period between generation of billing information for all configured PVCs (permanent virtual circuits) at this SAP. A value of '0' indicates no billing information is generated. Range of Values: 0 - 300 seconds Default Value: 0 (no billing) Related Objects: x25BillingSegmentSize x25Billing x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication Configuration Changed: administrative and operative")
x25SapModulo = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2))).clone('modulo8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapModulo.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapModulo.setDescription('This object applies only to lower SAPs (service access points). Determines the range of sequence numbers available for packet numbering at this SAP (service access point). The modulo specified for this object must match that specified on the destination SAP for a route to be successful. If not, this SAP will refuse the call. Options: modulo8 (1): Sequence numbers range from 0 to 7, supporting a maximum window size of 8. modulo128 (2): Sequence numbers range from 0 to 128, supporting a maximum window size of 128 Default Value: modulo8 (1) Related Objects: x25SapRxWindowSize x25SapTxWindowSize x25PvcRxWindow x25PvcTxWindow Configuration Changed: administrative')
x25SapRxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 32), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRxPacketSize.setReference('X.25(1988) Section 7.2.2.1.1')
if mibBuilder.loadTexts: x25SapRxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRxPacketSize.setDescription('Determines the default receive packet size used by this SAP. This value is used only when flow control negotiation (x25SapSbscrFlowCntrlParamNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Related Objects: x25SapSbscrFlowCntrlParamNegotiation Configuration Changed: administrative and operative')
x25SapTxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 33), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapTxPacketSize.setReference('X25(1988) Section 7.2.2.1.1')
if mibBuilder.loadTexts: x25SapTxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapTxPacketSize.setDescription('Determines the default transmit packet size used by this SAP. This value is used only when flow control negotiation (x25SapSbscrFlowCntrlParamNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Related Objects: x25SapSbscrFlowCntrlParamNegotiation Configuration Changed: administrative and operative')
x25SapRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRxWindowSize.setReference('X.25(1988) Section 7.2.2.1.2')
if mibBuilder.loadTexts: x25SapRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRxWindowSize.setDescription('Determines the default receive window size used by this SAP. This value is used only when flow control negotiation (x25SapSbscrFlowCntrlParamNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Range of Values: 1 - 7 for modulo 8 1 - 127 for modulo 128 Default Value: 2 Related Objects: x25SapSbscrFlowCntrlParamNegotiation x25SapModulo Configuration Changed: administrative and operative')
x25SapTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapTxWindowSize.setReference('X.25(1988) Section 7.2.2.1.2')
if mibBuilder.loadTexts: x25SapTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapTxWindowSize.setDescription('Determines the default transmit window size used by this SAP. This value is used only when flow control negotiation (x25SapSbscrFlowCntrlParamNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Range of Values: 1 - 7 for modulo 8 1 - 127 for modulo 128 Default Value: 2 Related Objects: x25SapSbscrFlowCntrlParamNegotiation x25SapModulo Configuration Changed: administrative and operative')
x25SapRxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 36), ThruputClass().clone('bps9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRxThruputClass.setReference('X.25(1988) Section 7.2.2.2 and Table 30/X.25')
if mibBuilder.loadTexts: x25SapRxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRxThruputClass.setDescription('Determines the default receive throughput class used by this SAP. This value is used only when throughput class negotiation (x25SapSbscrThruputClassNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Options: bps75 (3) bps150 (4) bps300 (5) bps600 (6) bps1200 (7) bps2400 (8) bps4800 (9) bps9600 (10) bps19200 (11) bps48000 (12) bps64000 (13) Default Value: bps9600 (10) Related Objects: x25SapTxThruputClass x25SapSbscrThruputClassNegotiation Configuration Changed: administrative and operative')
x25SapTxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 37), ThruputClass().clone('bps9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapTxThruputClass.setReference('X.25(1988) Section 7.2.2.2 and Table 30/X.25')
if mibBuilder.loadTexts: x25SapTxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapTxThruputClass.setDescription('Determines the default transmit throughput class used by this SAP. This value is used only when throughput class negotiation (x25SapSbscrThruputClassNegotiation) is not subscribed to, or when a D-bit call is routed through this SAP. Options: bps75 (3) bps150 (4) bps300 (5) bps600 (6) bps1200 (7) bps2400 (8) bps4800 (9) bps9600 (10) bps19200 (11) bps48000 (12) bps64000 (13) Default Value: bps9600 (10) Related Objects: x25SapRxThruputClass x25SapSbscrThruputClassNegotiation Configuration Changed: administrative and operative')
x25SapRxWindowThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRxWindowThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRxWindowThreshold.setDescription('This object applies only to lower SAPs (service access points). Determines the threshold at which this lower SAP is forced to close its receive window (issue RNRs). This threshold is only effective if set as follows: - if no receive window negotiation has taken place during the call establishment phase, the threshold is effective if configured to less than the value for object x25SapRxWindowSize. - if the receive window has been negotiated to a value other than its default, as specified by object x25SapRxWindowSize, the threshold is only effective if configured less than the negotiated value. Range of Values: 1 - 7 for modulo 8 1 - 127 for modulo 128 Default Value: 7 Related Objects: x25SapSbscrFlowCntrlParamNegotiation x25SapModulo x25SapRxWindowSize Configuration Changed: administrative and operative')
x25SapLcnAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ascending", 1), ("descending", 2))).clone('descending')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLcnAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLcnAllocation.setDescription('Determines the order in which logical channel numbers (LCNs) are assigned by this SAP (service access point). Options: ascending (1): LCNs are assigned in ascending order. descending: (2): LCNs are assigned in descending order. Default Value: descending (2) Configuration Changed: administrative')
x25SapLpvcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLpvcLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapLpvcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLpvcLcn.setDescription('Determines the lowest LCN (logical channel number) for permanent virtual circuits established at this SAP. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapHpvcLcn Configuration Changed: administrative')
x25SapHpvcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapHpvcLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapHpvcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapHpvcLcn.setDescription('Determines the highest LCN (logical channel number) for permanent virtual circuits established at this SAP. This value must be greater than x25SapLpvcLcn and less than x25SapLicLcn. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapLpvcLcn x25SapLicLcn Configuration Changed: administrative')
x25SapLicLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLicLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapLicLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLicLcn.setDescription('This object applies only to lower SAPs (service access points). Determines the lowest LCN (logical channel number) for incoming virtual circuits at this SAP. This value must be greater than x25SapHpvcLcn and less than x25SapHicLcn. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapHpvcLcn x25SapHicLcn Configuration Changed: administrative')
x25SapHicLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapHicLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapHicLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapHicLcn.setDescription('This object applies only to lower SAPs (service access points). Determines the highest LCN (logical channel number) for incoming virtual circuits at this SAP. This value must be greater than x25SapLicLcn and less than x25SapLtcLcn. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapLicLcn x25SapLtcLcn Configuration Changed: administrative')
x25SapLtcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLtcLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapLtcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLtcLcn.setDescription('Determines the lowest LCN (logical channel number) for two-way virtual circuits at this SAP. This value must be greater than x25SapHicLcn and less than x25SapHtcLcn. Range of Values: 0 - 1023 Default Value: 1 Related Objects: x25SapHicLcn x25SapHtcLcn Configuration Changed: administrative')
x25SapHtcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapHtcLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapHtcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapHtcLcn.setDescription('Determines the lowest LCN (logical channel number) for two-way virtual circuits at this SAP. This value must be greater than x25SapLtcLcn and less than x25SapLocLcn. Range of Values: 0 - 1023 Default Value: 16 Related Objects: x25SapLtcLcn x25SapLocLcn Configuration Changed: administrative')
x25SapLocLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapLocLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapLocLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLocLcn.setDescription('This object applies only to lower SAPs (service access points). Determines the lowest LCN (logical channel number) for two-way virtual circuits at this SAP. This value must be greater than x25SapHtcLcn and less than x25SapHocLcn. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapHtcLcn x25SapHocLcn Configuration Changed: administrative')
x25SapHocLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapHocLcn.setReference('X.25(1988) Annex-A Figure A-1')
if mibBuilder.loadTexts: x25SapHocLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapHocLcn.setDescription('This object applies only to lower SAPs (service access points). Determines the highest LCN (logical channel number) for outgoing virtual circuits at this SAP. This value must be greater than x25SapLocLcn. Range of Values: 0 - 1023 Default Value: 0 Related Objects: x25SapLocLcn Configuration Changed: administrative')
x25SapConnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 200)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapConnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapConnectTimer.setDescription('This object applies only to lower SAPs (service access points). Determines the maximum time that this SAP waits for the sub-layer (typically the Data Link layer)to establish the physical/logical line. Range of Values: 0 - 200 seconds Default Value: 5 seconds Configuration Changed: administrative and operative')
x25SapDisconnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapDisconnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapDisconnectTimer.setDescription('This object applies only to lower SAPs (service access points). Determines the maximum time that this SAP waits for the sub-layer (typically the Data Link layer)to confirm that the physical/logical line has been taken down as previously requested by this SAP. Range of Values: 1 - 200 seconds Default Value: 60 seconds Configuration Changed: administrative and operative')
x25SapRestartTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRestartTimer.setReference('X.25(1988) Annex-D Tables D-1/X.25 & D-2/X.25 T10(DCE...defval:60) or T20(DTE...defval:180)')
if mibBuilder.loadTexts: x25SapRestartTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRestartTimer.setDescription('This object applies only to lower SAPs (service access points). Determines the maximum time that this SAP waits for a Restart Confirmation packet in response to a previously sent Restart Request packet. Range of Values: 1 - 300 seconds Default Value: 180 seconds Configuration Changed: administrative and operative')
x25SapCallTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapCallTimer.setReference('X.25(1988) Annex-D Tables D-1/X.25 & D-2/X.25 (T11(DCE...defval:180) or T21(DTE...defval:200)')
if mibBuilder.loadTexts: x25SapCallTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapCallTimer.setDescription('Determines the maximum amount of time this SAP waits for a Call Connected packet in response to a previously sent Call Request packet. Range of Values: 1 - 300 Default Value: 200 seconds Configuration Changed: administrative and operative')
x25SapResetTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 65), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapResetTimer.setReference('X.25(1988) Annex-D Tables D-1/X.25 & D-2/X.25 T12(DCE...defval:60) or T22(DTE...defval:180)')
if mibBuilder.loadTexts: x25SapResetTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapResetTimer.setDescription('Determines the maximum amount of time this SAP waits for a Reset Confirmation packet in response to a previously sent Reset Request packet. Range of Values: 1 - 300 Default Value: 180 seconds Configuration Changed: administrative and operative')
x25SapClearTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapClearTimer.setReference('X.25(1988) Annex-D Tables D-1/X.25 & D-2/X.25 T13(DCE...defval:60) or T23(DTE...defval:180)')
if mibBuilder.loadTexts: x25SapClearTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapClearTimer.setDescription('Determines the maximum amount of time this SAP waits for a Clear Confirmation packet in response to a previously sent Clear Request packet. Range of Values: 1 - 300 Default Value: 180 seconds Configuration Changed: administrative and operative')
x25SapInactivityTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 300)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapInactivityTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapInactivityTimer.setDescription("Determines the maximum amount of time this SAP (service access point) can hold outbound queued data for a virtual circuit. If this timer expires before the queued data can be sent, the virtual circuit is reset (the SAP issues a Reset Request packet). This is a global setting that applies to all virtual circuits established at this SAP. A value of '0' disables this timer, and is the recommended setting for upper SAPs. Range of Values: 0 - 300 seconds Default Value: 60 seconds Configuration Changed: administrative and operative")
x25SapFlowControlTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapFlowControlTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapFlowControlTimer.setDescription('This object applies only to lower SAPs (service access points). Determines the amount of time between checks of available system resources when the virtual circuits at this SAP have entered flow control. Flow control is initiated when system resources have fallen below the threshold specified by object x25LowerPoolThreshold. This timer is started when flow control is initiated, and when it expires, system resources are rechecked. If resources have risen above x25UpperPoolThreshold, flow control is terminated (a packet-level RR is issued on the affected virtual circuit), otherwise the timer is restarted. Packet level RNR/RR are only issued for virtual circuits on lower SAPs. Virtual circuits on upper SAPs issue internal flow control messages. This is a global setting that applies to all virtual circuits established at this SAP. Range of Values: 1 - 300 seconds Default Value: 10 seconds Related Objects: x25LowerPoolThreshold x25UpperPoolThreshold Configuration Changed: administrative and operative')
x25SapWindowStatusTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 300)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapWindowStatusTimer.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapWindowStatusTimer.setDescription('Determines the maximum amount of time this SAP waits for an outgoing packet to piggy-back an acknowledgment onto. If this timer expires, it forces an acknowledgment packet to be sent. This timer is restarted each time a packet is sent. Range of Values: 1 - 300 seconds Default Value: 60 seconds Configuration Changed: administrative and operative')
x25SapSbscrCalledAddressInsertion = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCalledAddressInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCalledAddressInsertion.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP inserts the called address in Call Accept packets, and if the called address is validated. The behavior of this facility changes depending on the whether this SAP routes calls to an upper or lower SAP. See the X25RouteTable for more information on routes. This object only applies to the source SAP in a route. Options: false (1): Not subscribed: no action is taken. true (2): Subscribed: When this SAP receives a Call Accepted packet that contains a called address, it verifies the address against the called address contained in the Incoming Call packet. If they do not match, the call is cleared. When this SAP receives a Call Accepted packet that does not contain a called address, the action it takes depends on the type of route. If routing to an upper SAP, then the called address from the Incoming Call packet is inserted into the Call Accepted packet. If routing to a lower SAP, no action is taken. Default Value: true (2) Configuration Changed: administrative and operative')
x25SapSbscrCallingAddressInsertion = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCallingAddressInsertion.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCallingAddressInsertion.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP inserts the calling address in Call Accept packets, and if the calling address is validated. The behavior of this facility changes depending on the whether this SAP routes calls to an upper or lower SAP. See the X25RouteTable for more information on routes. This object only applies to the source SAP in a route. Options: false (1): Not subscribed: no action is taken. true (2): Subscribed: When this SAP receives a Call Accepted packet that contains a calling address, it verifies the address against the calling address contained in the Incoming Call packet. If they do not match, the call is cleared. When this SAP receives a Call Accepted packet that does not contain a calling address, the action it takes depends on the type of route. If routing to an upper SAP, then the calling address from the Incoming Call packet is inserted into the Call Accepted packet. If routing to a lower SAP, no action is taken. Default Value: true (2) Configuration Changed: administrative and operative')
x25SapSbscrPktRetransmission = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrPktRetransmission.setReference('X.25 - Section 6.4')
if mibBuilder.loadTexts: x25SapSbscrPktRetransmission.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrPktRetransmission.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Packet Retransmission facility. Options: false (1): Not subscribed: This SAP does not maintain copies of transmitted packets, and responds to packet-level Reject packets by resetting the virtual circuit. true (2): Subscribed: This SAP responds to Reject packets by retransmitting all unacknowledged data packets on the affected virtual circuit. This SAP maintains copies of each data packet transmitted across all active virtual circuits in anticipation of Rejects. The copies are kept until they are acknowledged. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapSbscrInAccessBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrInAccessBarred.setReference('X.25 - Section 6.5')
if mibBuilder.loadTexts: x25SapSbscrInAccessBarred.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrInAccessBarred.setDescription("Determines if this SAP subscribes to the Incoming Calls Barred facility. Options: false (1): Not subscribed. true (2): Subscribed: If this is a lower SAP configured as DTE (x25SapInterfaceType set to 'DTE'), it will refuse(bar) all incoming calls from the DCE. If this is a lower SAP configured as DCE (x25SapInterfaceType set to 'DCE'), it will refuse(bar) all outgoing calls to the DTE.If this is an upper SAP, it will refuse(bar) all outgoing calls. Default Value: false (1) Configuration Changed: administrative and operative")
x25SapSbscrOutAccessBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrOutAccessBarred.setReference('X.25 - Section 6.6')
if mibBuilder.loadTexts: x25SapSbscrOutAccessBarred.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrOutAccessBarred.setDescription("This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Outgoing Calls Barred facility. Options: false (1): Not subscribed. true (2): Subscribed: If this SAP is configured as DTE (x25SapInterfaceType set to 'DTE'), it will refuse(bar) all outgoing calls to the DCE. If this SAP is configured as DCE (x25SapInterfaceType set to 'DCE'), it will refuse(bar) all incoming calls from the DTE. Default Value: false (2) Configuration Changed: administrative and operative")
x25SapSbscrFlowCntrlParamNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrFlowCntrlParamNegotiation.setReference('X.25 - Section 6.12')
if mibBuilder.loadTexts: x25SapSbscrFlowCntrlParamNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrFlowCntrlParamNegotiation.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Flow Control Parameter Negotiation facility. This allows negotiation of packet sizes and window sizes for all incoming or outgoing calls. Options; false (1): Not subscribed. Incoming calls: This SAP refuses all Incoming Call and Call Connected packets that contain the flow control facility. Outgoing calls from upper SAPs: This SAP refuses all Call Accept packets containing flow control facilities which originate from an upper SAP. Outgoing calls from lower SAPs: If the lower SAP (incoming side) subscribes to the flow control facility, then the default settings for flow control parameters (window sizes and packet sizes) at this SAP are used to replace the flow control facilities in the Call Request/Call Accepted packet. If the lower SAP (incoming side) does not subscribe to the flow control facility, then the facility settings in the Call Request/Call Accepted packet are compared against the default flow control parameters settings (window sizes and packet sizes) for this SAP. If equal the packet is routed, if not the packet is refused and the call is cleared. true (2): Subscribed. Incoming Calls: This SAP does not alter any flow control facilities found in incoming Call Request and Call Accept packets. Outgoing Calls: This SAP does not alter any flow control facilities found in outgoing Call Request and Call Accept packets. If no flow control facilities are found this SAP inserts its default settings into the Call Request or Call Accept packet. Note: An incoming/outgoing Call Request with the D-bit set implies the use of the default packet and window sizes configured at this SAP for the virtual circuit being connected. Default Value: true (2) Related Objects: x25SapRxPacketSize x25SapTxPacketSize x25SapRxWindowSize x25SapTxWindowSize Configuration Changed: administrative and operative')
x25SapSbscrThruputClassNegotiation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrThruputClassNegotiation.setReference('X.25 - Section 6.13')
if mibBuilder.loadTexts: x25SapSbscrThruputClassNegotiation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrThruputClassNegotiation.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Throughput Class Negotiation facility. This allows negotiation of performance characteristics for all incoming or outgoing calls. Options; false (1): Not subscribed. This SAP refuses all Incoming Call and Call Connected packets that contains the throughput class negotiation facility. true (2): Subscribed. Incoming Calls: This SAP does not alter any throughput class facilities found in incoming Call Request and Call Accept packets. Outgoing Calls: This SAP may alter throughput class facilities found in outgoing Call Request and Call Accept packets. If the outgoing packet contain throughput facilities they are compared against the settings for this SAP, and the lesser of the two is used. If no throughput class facilities are found, this SAP inserts its default settings into the Call Request or Call Accept packet. Default Value: false (1) Related Objects: x25SapRxThruputClass x25SapTxThruputClass Configuration Changed: administrative and operative')
x25SapSbscrFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrFastSelect.setReference('X.25 - Section 6.16')
if mibBuilder.loadTexts: x25SapSbscrFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrFastSelect.setDescription('Determines if this SAP subscribes to the Fast Select facility. This applies to outgoing calls only. Options: false (1): Not subscribed. This SAP will refuse incoming calls contained the Fast Select facility, and will refuse incoming Call Request/Accept packets containing a user data field larger than 16 bytes. true (2): Subscribed: This SAP permits up to 128 bytes of user data to be included in Call Request, Call Accept, and Clear Request packets. This SAP routes incoming calls containing the fast select facility only if the destination side has subscribed to the Fast Select Acceptance facility. Default Value: true (2) Configuration Changed: administrative and operative')
x25SapSbscrFastSelectAcceptance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrFastSelectAcceptance.setReference('X.25 - Section 6.17')
if mibBuilder.loadTexts: x25SapSbscrFastSelectAcceptance.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrFastSelectAcceptance.setDescription('Determines if this SAP subscribes to the Fast Select Acceptance facility. This applies to incoming calls only. Options: false (1): Not subscribed. This SAP will refuse outgoing calls containing the Fast Select facility. true (2): Subscribed: This SAP permits outgoing calls containing the Fast Select facility. A call containing the fast select facility will only be routed here if the inbound side subscribes to the fast select facility (X25SapSbscrFastSelect). Default Value: true (2) Configuration Changed: administrative and operative')
x25SapSbscrReverseChargingAcceptance = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrReverseChargingAcceptance.setReference('X.25 - Section 6.19')
if mibBuilder.loadTexts: x25SapSbscrReverseChargingAcceptance.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrReverseChargingAcceptance.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Reverse Charging Acceptance facility. This facility applies to outgoing calls only. Options: false (1): Not subscribed. This SAP refuses outgoing calls containing the Reverse Charging facility. true (2): Subscribed: This SAP permits outgoing calls containing the Reverse Charging facility. Default Value: true (2) Configuration Changed: administrative and operative')
x25SapSbscrLocalChargingPrevention = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrLocalChargingPrevention.setReference('X.25 - Section 6.20')
if mibBuilder.loadTexts: x25SapSbscrLocalChargingPrevention.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrLocalChargingPrevention.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Local Charging Prevention facility. This facility applies to incoming calls only. Options: false (1): Not subscribed. This SAP routes all incoming calls containing neither the Reverse Charging nor the NUI facility. true (2): Subscribed: If an incoming call contains neither the Reverse Charging, nor the NUI facility, this SAP adds the Reverse Charging facility prior to routing to the outbound side, if the outbound side has subscribed to the Reverse Charging facility. If the outbound side has not subscribed to the Reverse Charging facility, this SAP refuses the call. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapSbscrChargingInformation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrChargingInformation.setReference('X.25 - Section 6.22')
if mibBuilder.loadTexts: x25SapSbscrChargingInformation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrChargingInformation.setDescription('Determines if this SAP subscribes to the Charging Information facility. This facility applies to incoming calls only. Options: false (1): Not subscribed. This SAP refuses all calls containing the Charging Information facility. true (2): Subscribed: This SAP routes incoming calls containing the Charging Information facility. When such calls are established and later cleared, this SAP inserts billing information about the connection within the clear packet generated/received. This is only done if the incoming call that established the connection also contained the Charging Information facility and if the SAP is configured as DCE (x25SapInterfaceType). Default Value: false (1) Related Objects: x25Billing x25SapPvcBillingTimer x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication x25SapInterfaceType Configuration Changed: administrative and operative')
x25SapSbscrCallRedirection = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCallRedirection.setReference('X.25 - Section 6.25')
if mibBuilder.loadTexts: x25SapSbscrCallRedirection.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCallRedirection.setDescription('Determines if this SAP subscribes to the Call Redirection facility. This facility applies to outgoing calls only. Options: false (1): Not subscribed. This SAP does not redirect calls. true (2): Subscribed: This SAP redirects outgoing calls to the configured call redirection address (x25SapRedirectionAddress). Redirection takes place only if: - this outbound SAP is not available (lower SAPs only) - this outbound SAP is out of available LCNs - incoming calls are barred at this outbound SAP (configured as a DTE) - outgoing calls are barred at this outbound SAP (configured as a DCE) In addition, redirection can then only succeed if the inbound side has subscribed to the Permission to Redirect facility. Default Value: false (1) Related Objects: x25SapRedirectionAddress Configuration Changed: administrative and operative')
x25SapSbscrPermissionToRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 93), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrPermissionToRedirect.setReference('X.25 - Section 6.25')
if mibBuilder.loadTexts: x25SapSbscrPermissionToRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrPermissionToRedirect.setDescription('Determines if this SAP subscribes to the Permission to Redirect facility. This facility applies to incoming calls only. Options: false (1): Not subscribed. This SAP refuses incoming calls even if the outgoing side subscribes to the Call Redirection facility and supplies a redirection address. true (2): Subscribed: This SAP redirects incoming calls to the redirection address specified by the outgoing side which refused the outgoing call. The redirection address is only supplied by an outgoing side if it subscribes to the Call Redirection facility, and is configured with a redirection address. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapRedirectionAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 94), X25Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRedirectionAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRedirectionAddress.setDescription('Determines the address this SAP redirects calls to. To make use of this address this SAP must subscribe to the Call Redirection facility. Range of Values: DTE address enclosed in quotes (up to 15 characters in length) Default Value: none Related Objects: x25SapSbscrCallRedirection Configuration Changed: administrative and operative')
x25SapSbscrNetworkUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 95), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrNetworkUserId.setReference('X.25 - Section 6.21')
if mibBuilder.loadTexts: x25SapSbscrNetworkUserId.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrNetworkUserId.setDescription('Determines if this SAP subscribes to the Network User Indentification (NUI) facility. This facility applies to incoming calls only. Options: false (1): Not subscribed. This SAP refuses all incoming calls containing the Network User Identification facility. true (2): Subscribed: This SAP routes incoming calls containing the NUI facility When such calls are established and are later cleared, this SAP inserts billing information about the connection within the Clear packet generated/received. The charging information contains the NUI which is used for third party billing. This is only done if the incoming call that established the connection contained the Charging Information facility and this facility was also subscribed to by this SAP, and this SAP is configured as DCE (x25SapInterfaceType). Default Value: true (2) Related Objects: x25Billing x25SapPvcBillingTimer x25SapSbscrChargingInformation x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication x25SapInterfaceType Configuration Changed: administrative and operative')
x25SapSbscrCallingAddressValidation = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 96), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCallingAddressValidation.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCallingAddressValidation.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Calling Address Validation facility. This facility applies to incoming calls only. This facility can be used for security purposes to restrict calls originating from a specific source. Options: false (1): Not subscribed. This SAP does not insert nor validate any calling address contained within incoming calls. true (2): Subscribed: This SAP inserts the calling address (x25SapSourceAddress) into incoming call packets that do not contain one, prior to routing the call. For incoming calls that do contain a calling address, this SAP validates it against that specified address (x25SapSourceAddress). If the addresses match, the incoming call is routed, otherwise the incoming call is cleared. Default Value: false (2) Related Objects: x25SapSourceAddress Configuration Changed: administrative and operative')
x25SapSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 97), X25Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSourceAddress.setDescription('This object applies only to lower SAPs (service access points). Determines the calling address used by this SAP when it subscribes to the Calling Address Validation facility. Range of Values: DTE address enclosed in quotes (up to 15 characters in length) Default Value: none Related Objects: x25SapSbscrCallingAddressValidation Configuration Changed: administrative and operative')
x25SapSbscrRouteUsingCUDF = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 98), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrRouteUsingCUDF.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrRouteUsingCUDF.setDescription('Determines if this SAP subscribes to the Call User Data facility for routing. This facility applies to incoming calls only. Each SAP can only subscribe to one of the following routing decisions: - Route using the call user data field (object x25SapRouteUsingCUDF) - Route using sub-address (object x25SapRouteUsingSubAddress) - Route using the called address extension facility (object x25SapRouteUsingCAE) Options: false (1): Not subscribed. This SAP does not look at the call user data field for routing information. true (2): Subscribed: This SAP uses digits found in the call user data field of incoming calls as the destination address for routing. The number of digits to be used from the call user data field is defined by object x25SapRouteAddressLength. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapSbscrRouteUsingSubAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 99), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrRouteUsingSubAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrRouteUsingSubAddress.setDescription('Determines if this SAP uses the subaddress field for routing. This facility applies to incoming calls only. Each SAP can only subscribe to one of the following routing decisions: - Route using the call user data field (object x25SapRouteUsingCUDF) - Route using sub-address (object x25SapRouteUsingSubAddress) - Route using the called address extension facility (object x25SapRouteUsingCAE) Options: false (1): Not subscribed. This SAP does not look at the subaddress field for routing information. true (2): Subscribed: This SAP uses digits found in the called address of incoming calls as the destination address for routing. The number of digits used as the subaddress is defined by object x25SapRouteAddressLength Default Value: false (1) Related Objects: x25SapRouteAddressLength Configuration Changed: administrative and operative')
x25SapSbscrRouteUsingCAE = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrRouteUsingCAE.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrRouteUsingCAE.setDescription('Determines if this SAP uses the called address extension facility for routing. This facility applies to incoming calls only. Each SAP can only subscribe to one of the following routing decisions: -Route using the call user data field (object x25SapRouteUsingCUDF) -Route using sub-address (object x25SapRouteUsingSubAddress) -Route using the called address extension facility (object x25SapRouteUsingCAE) Options: false (1): Not subscribed. This SAP does not look at the called address extension facility for routing information. true (2): Subscribed: This SAP uses digits found in the called address extension facility of incoming calls as the destination address for routing. The number of digits used for routing is specified as part of the facility within the incoming call. This SAP will refuse the incoming call if the called address extension facility is not present. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapRouteAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 101), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapRouteAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapRouteAddressLength.setDescription('Determines the number of digits this SAP uses as the destination address when routing incoming calls. This applies when one of the following routing decisions are set for this SAP: - x25SapRouteUsingCUDF - x25SapRouteUsingSubAddress: digits used for the subaddress are counted backward starting at last digit in the called address Range of Values: 0 - 15 Default Value: 0 Configuration Changed: administrative and operative')
x25SapSbscrTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 102), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrTransitDelay.setReference('X.25 - Section 6.27')
if mibBuilder.loadTexts: x25SapSbscrTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrTransitDelay.setDescription('This object applies only to lower SAPs (service access points). Determines if this SAP subscribes to the Calling Address Validation facility. This facility applies to both incoming and outgoing calls. Options: true (1): Subscribed: This SAP appends the transit delay facility (with the value specified by object x25SapTransitDelay) to incoming/outgoing calls that do not already contain the transit delay facility. false (2): Not subscribed. This SAP does append the transit delay facility. Default Value: false (1) Related Objects: x25SapTransitDelay Configuration Changed: administrative and operative')
x25SapTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 103), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapTransitDelay.setReference('X.25 - Section 6.27')
if mibBuilder.loadTexts: x25SapTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapTransitDelay.setDescription('This object applies only to lower SAPs (service access points). Defines the transit delay appended by this SAP if it subscribes to the transit delay facility. This facility applies to both incoming and outgoing calls. Range of Values: 0 - 65535 Default Value: 0 Related Objects: x25SapSbscrTransitDelay Configuration Changed: administrative and operative')
x25SapSbscrCugIncomingAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 104), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCugIncomingAccess.setReference('X.25 - Section 6.14.3')
if mibBuilder.loadTexts: x25SapSbscrCugIncomingAccess.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCugIncomingAccess.setDescription('Determines if this SAP subscribes to the Closed User Group with Incoming Access facility. This facility applies to outgoing calls only. Options: false (1): Not subscribed. If this SAP is part of a closed user group, outgoing calls not containing the closed user group selection facility (calls from the open network which are not part of any CUGs) are refused. true (2): Subscribed: If this SAP is part of a closed user group, outgoing calls not containing the closed user group selection facility (calls from the open network which are not part of any CUGs) are sent out. At the upper SAP, they are sent to the attached application, at the lower SAP are sent out to the line. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapSbscrCugOutgoingAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 105), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapSbscrCugOutgoingAccess.setReference('X.25 - Section 6.14.2')
if mibBuilder.loadTexts: x25SapSbscrCugOutgoingAccess.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapSbscrCugOutgoingAccess.setDescription('Determines if this SAP subscribes to the Closed User Group with Outgoing Access facility. This facility applies to incoming calls only. Options: false (1): Not subscribed. If this SAP is part of a closed user group, incoming calls not containing the closed user group selection facility (calls from the open network which are not part of any CUG) are refused. true (2): Subscribed: If this SAP is part of a closed user group, incoming calls not containing the closed user group selection Facility (calls from the open network which are not part of any CUG), are routed. Default Value: false (1) Configuration Changed: administrative and operative')
x25SapPreferentialCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 106), CugIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25SapPreferentialCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapPreferentialCugIndex.setDescription("Determines the preferential CUG index for this SAP. This is required when this SAP belongs to more than one CUG. Range of Values: 0 - 99 ('0' indicates no preferential CUG exits) Default Value: 0 (no preferential CUG exists) Configuration Changed: administrative and operative")
x25SapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 120), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clearStats", 1), ("enableSap", 2), ("disableSap", 3)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: x25SapControl.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapControl.setDescription("Permits control of a specific SAP (service access point). Options: clearStats (1): Clear all statistics stored by x25Sap statistics objects. enableSap (2):. Lower SAPs only. Forces this SAP to attempt reconnection to the sub-layer. A previous 'disableSap' must have been invoked. This may force the LAPB link to issue a SABM frame (depending on its configuration). disableSap (3):. Lower SAPs only. Forces this SAP to disconnect from the sub-layer. This may force the LAPB link to issue a DISC frame (depending on its configuration). Default Value: none Configuration Changed: administrative and operative")
x25SapLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 125), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("connecting", 1), ("dataTransfer", 2), ("restartInternal", 3), ("restartExternal", 4), ("down", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapLinkState.setDescription('Determines the current state of this SAP (service access point). Options: connecting (1): In the process of establishing a call. dataTransfer (2): In data transfer mode. restartInternal (3): Sent a Restart Request packet. restartExternal (4): Received a Restart Request packet. down (5): Not functioning.')
x25SapFlowControlState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 21, 1, 126), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("flowNormal", 1), ("flowStopped", 2), ("noFlow", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapFlowControlState.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapFlowControlState.setDescription('Indicates the status of flow control on this SAP (service access point). Flow control is initiated by this SAP when overall system resources drop lower than the percentage specified by the global object x25UpperPoolThreshold, and are terminated when the overall system resources exceed the percentage specified by the global object x25UpperPoolThreshold. Options: flowNormal (1): Data flow is normal. No flow control procedures are active. flowStopped (2): Flow control procedures are active, since overall system resources have dropped lower than the percentage specified by global object x25LowerPoolThreshold. noFlow (3): Indicates this SAP is configured incorrectly. Related Objects: x25UpperPoolThreshold')
x25SapStatsTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22), )
if mibBuilder.loadTexts: x25SapStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTable.setDescription('A table containing statistical information about each service access point.')
x25SapStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1), ).setIndexNames((0, "CXX25-MIB", "x25SapStatsSapNumber"), (0, "CXX25-MIB", "x25SapStatsSapCes"))
if mibBuilder.loadTexts: x25SapStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsEntry.setDescription('The statistical information for a specific service access point. ')
x25SapStatsSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 1), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsSapNumber.setDescription('Determines the lower X.25 layer SAP (service access point) these statistics are associated with. This is the first half of the SAP identification. The second half is specified by object x25SapStatsSapCes.')
x25SapStatsSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 2), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsSapCes.setDescription('Determines the lower X.25 layer SAP (service access point) these statistics are associated with. This is the second half of the SAP identification. The first half is specified by object x25SapStatsSapNumber. ')
x25SapStatsTxDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxDataPkts.setDescription('Indicates the number of data packets transmitted by this SAP.')
x25SapStatsRxDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxDataPkts.setDescription('Indicates the number of data packets received by this SAP.')
x25SapStatsTxDataChars = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxDataChars.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxDataChars.setDescription('Indicates the number of data characters transmitted by this SAP.')
x25SapStatsRxDataChars = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxDataChars.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxDataChars.setDescription('Indicates the number of data characters received by this SAP.')
x25SapStatsTxQDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxQDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxQDataPkts.setDescription('Indicates the number of Q-bit data packets transmitted by this SAP.')
x25SapStatsRxQDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxQDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxQDataPkts.setDescription('Indicates the number of Q-bit data packets received by this SAP.')
x25SapStatsTxQDataChars = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxQDataChars.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxQDataChars.setDescription('Indicates the number of Q-bit data character transmitted by this SAP.')
x25SapStatsRxQDataChars = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxQDataChars.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxQDataChars.setDescription('Indicates the number of Q-bit data characters received by this SAP.')
x25SapStatsTxCallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxCallPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxCallPkts.setDescription('Indicates the number of Call Request packets transmitted by this SAP.')
x25SapStatsRxCallPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxCallPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxCallPkts.setDescription('Indicates the number of Call Request packets received by this SAP.')
x25SapStatsTxClrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxClrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxClrPkts.setDescription('Indicates the number of Clear packets transmitted by this SAP.')
x25SapStatsRxClrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxClrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxClrPkts.setDescription('Indicates the number of Clear packets received by this SAP.')
x25SapStatsTxRRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxRRPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxRRPkts.setDescription('Indicates the number of Receiver Ready (RR) packets transmitted by this SAP.')
x25SapStatsRxRRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxRRPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxRRPkts.setDescription('Indicates the number of Receiver Ready (RR) packets received by this SAP.')
x25SapStatsTxRNRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxRNRPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxRNRPkts.setDescription('Indicates the number of Receiver Not Ready (RNR) packets transmitted by this SAP.')
x25SapStatsRxRNRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxRNRPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxRNRPkts.setDescription('Indicates the number of Receiver Not Ready (RNR) packets received by this SAP.')
x25SapStatsTxResPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxResPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxResPkts.setDescription('Indicates the number of Reset packets transmitted by this SAP.')
x25SapStatsRxResPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxResPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxResPkts.setDescription('Indicates the number of Reset packets received by this SAP.')
x25SapStatsTxRstPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxRstPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxRstPkts.setDescription('This object applies only to lower SAPs (service access points). Indicates the number of Restart packets transmitted by this SAP.')
x25SapStatsRxRstPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxRstPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxRstPkts.setDescription('This object applies only to lower SAPs (service access points). Indicates the number of Restart packets received by this SAP.')
x25SapStatsTxIntPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxIntPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxIntPkts.setDescription('Indicates the number of Interrupt packets transmitted by this SAP.')
x25SapStatsRxIntPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxIntPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxIntPkts.setDescription('Indicates the number of Interrupt packets received by this SAP.')
x25SapStatsTxDiagPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsTxDiagPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsTxDiagPkts.setDescription('This object applies only to lower SAPs (service access points). Indicates the number of Diagnostic packets transmitted by this SAP.')
x25SapStatsRxDiagPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxDiagPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxDiagPkts.setDescription('This object applies only to lower SAPs (service access points). Indicates the number of Diagnostic packets received by this SAP.')
x25SapStatsRxInvPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsRxInvPkts.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsRxInvPkts.setDescription('Indicates the number of packets that were received by this SAP, but were discarded because they were invalid for the state the X.25 interface was in at the time.')
x25SapStatsCons = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsCons.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsCons.setDescription('For future use. Indicates the number of connections established through this SAP.')
x25SapStatsDiscs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsDiscs.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsDiscs.setDescription('For future use. Indicates the number of disconnects through this SAP.')
x25SapStatsLastCauseCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsLastCauseCode.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsLastCauseCode.setDescription('Indicates the last cause code received by this SAP.')
x25SapStatsLastDiagCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsLastDiagCode.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsLastDiagCode.setDescription('Indicates the last diagnostics code received by this SAP.')
x25SapStatsActiveLcns = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 22, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25SapStatsActiveLcns.setStatus('mandatory')
if mibBuilder.loadTexts: x25SapStatsActiveLcns.setDescription('For future use. Indicates the active number of open logical channels at this SAP.')
x25CugTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23), )
if mibBuilder.loadTexts: x25CugTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugTable.setDescription('This tables contains CUG (closed user group) definitions for the X.25 layer. Any service access point (upper or lower) can be part of one or more CUGs. Each row in the table identifies the CUG parameters for a single member of the specified CUG. CUGs provide the means to regulate incoming and outgoing calls at particular SAP. Generally, members of a CUG are defined to only support making and receiving calls from other members of the group. However, other options are available. When a SAP belongs to more than one closed user group, a preferential closed user group must be specified. Each CUG entry consists of an interlock code and the facilities for incoming/outgoing calls barred within the CUG. Objects in this table make references to the appropriate sections in the blue book: ITU(CCITT) X.25 Recommendation (1988). The reference is specified in the REFERENCE section of an object. Only BASIC CUGs are supported.')
x25CugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1), ).setIndexNames((0, "CXX25-MIB", "x25CugSapNumber"), (0, "CXX25-MIB", "x25CugSapCes"), (0, "CXX25-MIB", "x25CugIndex"))
if mibBuilder.loadTexts: x25CugEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugEntry.setDescription('Defines a row in the x25CugTable. Each row contains the objects which define a member of a closed user group. ')
x25CugSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 1), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CugSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugSapNumber.setDescription('Identifies the SAP (service access point) this entry is associated with. This is the first half of the SAP identification. The second half is specified by object x25CugSapCes. Range of Values: 1 - 255 Default Value: none Related Objects: x25CugSapCes Configuration Changed: administrative and operative')
x25CugSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 2), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CugSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugSapCes.setDescription('Identifies the CES (connection endpoint suffix) this entry is associated with. This is the second half of the SAP identification. The first half is specified by object x25CugSapNumbers. Range of Values: 0 - 63 Default Value: none Configuration Changed: administrative and operative')
x25CugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 3), CugIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugIndex.setDescription("Determines the CUG index assigned to this member for use when routing outgoing CUG calls, or for validating when receiving incoming CUG calls. A value of '0' is not permitted for this object. Range of Values: 1 - 99 Default Value: none Configuration Changed: administrative and operative")
x25CugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: valid (2) Configuration Changed: administrative and operative')
x25CugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 5), CugIC()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugInterlockCode.setDescription('Determines the CUG (closed user group) that member belongs to. This number also represents the interlock code used by the layer when translating index codes from one member to another. Interlock codes must be unique at each SAP. Range of Values: 0 - 65535 Default Value: none Configuration Changed: administrative and operative')
x25CugSbscrInCallsBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CugSbscrInCallsBarred.setReference('X.25 - Section 6.5')
if mibBuilder.loadTexts: x25CugSbscrInCallsBarred.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugSbscrInCallsBarred.setDescription('Determines if this SAP subscribes to the Incoming Calls Barred with a Closed User Group facility. Options: false (1): Not subscribed. true (2): Subscribed: Permits this member to originate virtual calls to other members in this closed user group, but prevents the reception of incoming calls from other members in this closed user group. Default Value: false (1) Configuration Changed: administrative and operative')
x25CugSbscrOutCallsBarred = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25CugSbscrOutCallsBarred.setReference('X.25 - Section 6.6')
if mibBuilder.loadTexts: x25CugSbscrOutCallsBarred.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugSbscrOutCallsBarred.setDescription('Determines if this SAP subscribes to the Outgoing Calls Barred with a Closed User Group facility. Options: false (1): Not subscribed. true (2): Subscribed: Permits this member to originate virtual calls to other members in this closed user group, but prevents this member from originating virtual calls to other members in this closed user group. Default Value: false (1) Configuration Changed: administrative and operative')
x25CugEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 23, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLine", 1), ("onLine", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25CugEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: x25CugEntryState.setDescription('Determines the state of the CUG (closed user group) entry. Options: offLine (1): Indicates this CUG entry has not been configured. onLine (2): Indicates that this CUG entry has been configured.')
x25RouteTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24), )
if mibBuilder.loadTexts: x25RouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteTable.setDescription('The SVC Route table contains the definitions used to route all switched virtual circuits. A route entry consists of the called address that activates the route, and a destination. Four categories of destinations are available, providing four possible route types. - 1) Route to a specific upper SAP destination. - 2) Route to a specific lower SAP destination. This type of route can be used in place of route type 3, when route balancing is not required. This avoids the need to configure a logical link containing only one SAP entry, which is ideal for LAPB routing when no load balancing is required. This type of route is also ideal when targeting a specific data link connection (identified by the CES) on a LAPD link. 3) Route to a logical link destination. A logical link is a grouping of one or more lower SAPs for the purpose of route balancing. 4) Route to a hunt group destination. A hunt group consists of one or more SAPs (upper or lower) which are grouped for the purpose of route hunting.')
x25RouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1), ).setIndexNames((0, "CXX25-MIB", "x25RoutePartition"), (0, "CXX25-MIB", "x25RouteId"))
if mibBuilder.loadTexts: x25RouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteEntry.setDescription('Defines a row in the x25RouteTable. Each row contains the objects which define a route for switched virtual circuits.')
x25RoutePartition = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 1), RoutePartition()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RoutePartition.setStatus('mandatory')
if mibBuilder.loadTexts: x25RoutePartition.setDescription('Identifies the partition within the route table that this route belongs to. Not significant for routing.')
x25RouteId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 2), RouteIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RouteId.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteId.setDescription('The index of the route within the partition. Not significant for routing.')
x25RouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: valid (2) Configuration Changed: administrative and operative')
x25RouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("specUpperSap", 1), ("specLowerSap", 2), ("logicalLink", 3), ("huntGroup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteType.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteType.setDescription('Determines the type of route this entry defines. Options: specUpperSap (1): Route to a specific upper SAP. specLowerSap (2): Rout to a specific lower SAP. logicalLink (3): Route to a logical link. huntGroup (4): Route to a Hunt Group. Configuration Changed: administrative and operative')
x25RouteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 5), X25Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteAddress.setDescription('Determines the called DTE address that triggers routing. If an incoming call is received at any upper or lower SAP with this address, it is routed to the destination SAP defined by x25RouteType. Options: none Range of Values: DTE address enclosed in quotes (up to 15 characters in length) Default Value: none Related Objects: x25RouteType Configuration Changed: administrative and operative')
x25RouteSLHNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 6), SapIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteSLHNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteSLHNumber.setDescription('Determines the destination SAP, logical link, or Hunt Group to route to. The destination depends on the setting of x25RouteType. - If x25RouteType = 1 then this object specifies an upper SAP number. - If x25RouteType = 2 then this object specifies a lower SAP number. - If x25RouteType = 3 then this object specifies the number of the logical link group to use. - If x25RouteType = 4 then this object specifies the number of the Hunt Group to use. Default Value: none Related Objects: x25RouteType Configuration Changed: administrative and operative')
x25RouteSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 7), Ces()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25RouteSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteSapCes.setDescription('Determines the CES number to route to. The value you set depends on the setting of x25RouteType. - If x25RouteType = 1 then this object must be set to 0. - If x25RouteType = 2 then this object must be set to a valid CES for the associated SAP (x25LLSapCes). - If x25RouteType = 3 or 4 this object is not used. Range of Values: 0 - 99 Default Value: 0 Related Objects: x25RouteType x25LLSapCes Configuration Changed: administrative and operative')
x25RouteEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 24, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLine", 1), ("onLine", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25RouteEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: x25RouteEntryState.setDescription('Determines the state of the route entry. Options: offLine (1): Indicates this route entry has not been configured. onLine (2): Indicates that this route entry has been configured.')
x25HuntGroupTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25), )
if mibBuilder.loadTexts: x25HuntGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25HuntGroupTable.setDescription('This table contains Hunt Group definitions for the X.25 layer. A hunt group is a grouping of upper and lower SAPs (service access points) for the purpose of routing incoming switched virtual circuit calls. A SAP can belong to more than one hunt group at the same time. Additions to this table are offline only. To determine the list of active Hunt Groups members, see the x25HuntGroupOperTable. Any incoming call whose address is determined to be associated with a hunt group (via the routing table), is subjected to hunting. Hunting means that the incoming call is routed to the first member of the hunt group. If this member refuses the call, the next member is attempted, and so on. If all members of a hunt group refuse the call, the call is refused back to its source. Enabling hunt group rotation (x25HuntGroupRotation) causes hunting to begin with a different hunt group member each time. For example, a group with three members would be hunted as follows: 123, 231, 312, 123. Members are identified by x25HGMember Index. Hunt groups can only be used via a route entry, they cannot be used stand alone.')
x25HuntGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1), ).setIndexNames((0, "CXX25-MIB", "x25HGId"), (0, "CXX25-MIB", "x25HGMemberIndex"))
if mibBuilder.loadTexts: x25HuntGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25HuntGroupEntry.setDescription('Defines a row in the x25HuntGroupTable. Each row contains the objects which define the parameters for one member of a hunt group.')
x25HGId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1, 1), HGIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGId.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGId.setDescription('Identifies the hunt group that the member belongs to. Range of Values: 1 - 99 Default Value: none Configuration Changed: administrative')
x25HGMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1, 2), HGIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGMemberIndex.setDescription('Identifies the order of the member within the hunt group. Range of Values: 1 - 99 Default Value: none Configuration Changed: administrative')
x25HGSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1, 3), SapIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25HGSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGSapNumber.setDescription('Identifies the SAP (service access point) this entry is associated with. This is the first half of the SAP identification. The second half is specified by object x25HGSapCes. Range of Values: 1 - 255 Default Value: none Configuration Changed: administrative')
x25HGSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1, 4), Ces()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25HGSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGSapCes.setDescription('Identifies the CES (connection endpoint suffix) this entry is associated with. This is the second half of the SAP identification. The first half is specified by object x25HGSapNumbers. Range of Values: 1 - 255 Default Value: 0 Configuration Changed: administrative')
x25HGRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 25, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25HGRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: valid (2) Configuration Changed: administrative')
x25HuntGroupOperTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26), )
if mibBuilder.loadTexts: x25HuntGroupOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25HuntGroupOperTable.setDescription('This table contains the current active Hunt Group (closed user group) definitions for the X.25 layer. Use the x25HuntGroupTable to define Hunt Group members. When a system reset occurs the definitions in x25HuntGroupTable become active and appear here.')
x25HuntGroupOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26, 1), ).setIndexNames((0, "CXX25-MIB", "x25HGOperId"), (0, "CXX25-MIB", "x25HGOperMemberIndex"))
if mibBuilder.loadTexts: x25HuntGroupOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25HuntGroupOperEntry.setDescription('Identifies one operational member of a hunt group.')
x25HGOperId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26, 1, 1), HGIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGOperId.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGOperId.setDescription('Identifies the hunt group that this operational member belongs to.')
x25HGOperMemberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26, 1, 2), HGIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGOperMemberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGOperMemberIndex.setDescription('Identifies the order of this operational member within the hunt group.')
x25HGOperSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26, 1, 3), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGOperSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGOperSapNumber.setDescription('Identifies the SAP (service access point) this entry is associated with. This is the first half of the SAP identification. The second half is specified by object x25HGOperSapCes.')
x25HGOperSapCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 26, 1, 4), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25HGOperSapCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25HGOperSapCes.setDescription('Identifies the CES (connection endpoint suffix) this entry is associated with. This is the second half of the SAP identification. The first half is specified by object x25HGOperSapNumbers.')
x25PvcTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27), )
if mibBuilder.loadTexts: x25PvcTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcTable.setDescription('This table contains definitions used to route X.25 PVCs (permanent virtual circuits). A PVC is always routed between two lower SAPs, or between a lower SAP and an upper SAP. The source SAP must always be a lower SAP. The destination SAP can be either an upper or lower SAP.')
x25PvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1), ).setIndexNames((0, "CXX25-MIB", "x25PvcId"))
if mibBuilder.loadTexts: x25PvcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcEntry.setDescription('Defines a row in the x25PvcTable. Each row contains the objects which define a route for a permanent virtual circuit.')
x25PvcId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 1), PvcIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PvcId.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcId.setDescription('The index of the PVC within the table. No significance for routing.')
x25PvcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): Row is deleted from the table immediately, however values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row. Default Value: valid (2) Configuration Changed: administrative')
x25PvcSrcSap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 3), SapIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcSap.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcSap.setDescription('Determines the source SAP (service access point) for the PVC, which must be a lower SAP. This is the first half of the SAP identification. The second half is specified by object x25PvcSrcCes. Related Objects: x25PvcSrcCes Default Value: none Range of Values: 1 - 255 Configuration Changed: administrative')
x25PvcSrcCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 4), Ces()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcCes.setDescription('Identifies the source SAP for the PVC, which must be a lower SAP. This is the second half of the SAP identification. The first half is specified by object x25PvcSrcSap. Range of Values: 0 - 63 Default Value: 0 Related Objects: x25PvcSrcSap Configuration Changed: administrative')
x25PvcDstSap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 5), SapIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstSap.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstSap.setDescription('Determines the destination SAP (service access point) for the PVC, which can be an upper or lower SAP. This is the first half of the SAP identification. The second half is specified by object x25PvcDstCes. Range of Values: 1 - 255 Default Value: none Related Objects: x25PvcDstCes Configuration Changed: administrative')
x25PvcDstCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 6), Ces()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstCes.setDescription('Identifies the destination SAP for the PVC, which can be an upper or lower SAP. This is the second half of the SAP identification. The first half is specified by object x25PvcDstSap. Range of Values: 0 - 63 Default Value: 0 Related Objects: x25PvcDstSap Configuration Changed: administrative')
x25PvcSrcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcLcn.setDescription('Determines the LCN (logical channel number) used by this PVC at the source SAP (service access point). The value assigned must be within the range of PVC LCNs assigned to the source SAP (x25SapLpvcLcn and X25SapHpvcLcn). Range of Values: 1 - 1023 Default Value: none Related Objects: x25SapLpvcLcn X25SapHpvcLcn Configuration Changed: administrative')
x25PvcDstLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstLcn.setDescription('Determines the LCN (logical channel number) used by this PVC at the source SAP (service access point). The value assigned must be within the range of PVC LCNs assigned to the destination SAP (x25SapLpvcLcn and X25SapHpvcLcn). Range of Values: 1 - 1023 Default Value: none Related Objects: x25SapLpvcLcn X25SapHpvcLcn Configuration Changed: administrative')
x25PvcSrcRxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 9), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcRxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcRxPacketSize.setDescription('Determines the receive packet size used by the associated source SAP (service access point). This overrides the default settings for the SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Configuration Changed: administrative')
x25PvcSrcTxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 10), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcTxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcTxPacketSize.setDescription('Determines the transmit packet size used by the associated source SAP (service access point). This overrides the default settings for the SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Configuration Changed: administrative')
x25PvcDstRxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 11), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstRxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstRxPacketSize.setDescription('Determines the receive packet size used by the associated destination SAP (service access point). This overrides the default settings for the SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Configuration Changed: administrative')
x25PvcDstTxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 12), PacketSize().clone('bytes128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstTxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstTxPacketSize.setDescription('Determines the receive packet size used by the associated destination SAP (service access point). This overrides the default settings for the SAP. Options: bytes16 (4) bytes32 (5) bytes64 (6) bytes128 (7) bytes256 (8) bytes512 (9) bytes1024 (10) bytes2048 (11) bytes4096 (12) Default Value: bytes128 (7) Configuration Changed: administrative')
x25PvcRxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcRxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcRxWindow.setDescription('Determines the receive window size. At the source side, it defines the window for packets received from the source interface. At the destination side, it defines the window for packets transmitted to the destination interface. This overrides the default settings for the SAP. Range of Values: 1 - 7 for modulo 8 1 - 127 for modulo 128 Default Value: 7 Related Objects: x25SapModulo Configuration Changed: administrative')
x25PvcTxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcTxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcTxWindow.setDescription('Determines the transmit window size. At the source side, it defines the window for packets transmitted to the source interface. At the destination side, it defines the window for packets received from the destination interface. This overrides the default settings for the SAP. Range of Values: 1 - 7 for modulo 8 1 - 127 for modulo 128 Default Value: 7 Related Objects: x25SapModulo Configuration Changed: administrative')
x25PvcRxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 15), ThruputClass().clone('bps9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcRxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcRxThruputClass.setDescription('Determines the receive throughput class for the external link. At the source side, it defines the throughput class used for packets received from the source interface. At the destination side, it defines the throughput class used for packets transmitted to the destination interface. This overrides the default settings for the SAP. Options: bps75 (3) bps150 (4) bps300 (5) bps600 (6) bps1200 (7) bps2400 (8) bps4800 (9) bps9600 (10) bps19200 (11) bps48000 (12) bps64000 (13) Default Value: bps9600 (10) Configuration Changed: administrative')
x25PvcTxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 16), ThruputClass().clone('bps9600')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcTxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcTxThruputClass.setDescription('The transmit throughput class across the line. At the source side, it defines the throughput class used for packets transmitted to the source interface. At the destination side, it defines the throughput class used for packets received from the destination interface (service access point). This overrides the default settings for the SAP. Options: bps75 (3) bps150 (4) bps300 (5) bps600 (6) bps1200 (7) bps2400 (8) bps4800 (9) bps9600 (10) bps19200 (11) bps48000 (12) bps64000 (13) Default Value: bps9600 (10) Configuration Changed: administrative')
x25PvcBilling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcBilling.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcBilling.setDescription('Determines if billing information is collected for this PVC. Billing information can only be collected for lower SAPs (service access points). If both sides of a PVC are lower SAPs, each side can collect its own information. The x25SapPvcBillingTimer determines when billing information is generated. Options: false (1): Not subscribed. true (2): Subscribed. Default Value: false (1) Related Objects: x25BillingSegmentSize x25Billing x25SapPvcBillingTimer x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication Configuration Changed: administrative')
x25PvcSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 18), X25Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcSrcAddress.setDescription('Determines the X.121 address that is associated with the source side for billing purposes only. Range of Values: DTE address enclosed in quotes (up to 15 numeric characters in length) Default Value: none Related Objects: x25BillingSegmentSize x25Billing x25SapPvcBillingTimer x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcDstAddress x25BillingIndication Configuration Changed: administrative')
x25PvcDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 19), X25Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: x25PvcDstAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcDstAddress.setDescription('Determines the X.121 address that is associated with the destination side for billing purposes only. Range of Values: DTE address enclosed in quotes (up to 15 characters in length) Default Value: none Related Objects: x25BillingSegmentSize x25Billing x25SapPvcBillingTimer x25SapSbscrChargingInformation x25SapSbscrNetworkUserId x25PvcBilling x25PvcSrcAddress x25PvcDstAddress x25BillingIndication Configuration Changed: administrative')
x25PvcEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 27, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("offLine", 1), ("onLine", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25PvcEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: x25PvcEntryState.setDescription('Determines the state of this PVC entry. Options: offLine (1): Indicates this PVC entry has not been configured. onLine (2): Indicates that this PVC entry has been configured.')
x25LcnStatusTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28), )
if mibBuilder.loadTexts: x25LcnStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnStatusTable.setDescription('A table containing current information about established virtual circuits (permanent or switched) within the layer.')
x25LcnStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1), ).setIndexNames((0, "CXX25-MIB", "x25LcnSrcSap"), (0, "CXX25-MIB", "x25LcnSrcCes"), (0, "CXX25-MIB", "x25LcnSrcLcn"))
if mibBuilder.loadTexts: x25LcnStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnStatusEntry.setDescription('The current information for a specific and currently established virtual circuit (permanent or switched) within the layer.')
x25LcnSrcSap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 1), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnSrcSap.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnSrcSap.setDescription('Identifies the source side SAP (service access point) this entry is associated with. This is the first half of the SAP identification. The second half is specified by object x25LcnSrcCes.')
x25LcnSrcCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 2), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnSrcCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnSrcCes.setDescription('Identifies the source side CES (connection endpoint suffix) this entry is associated with. This is the second half of the SAP identification. The first half is specified by object x25LcnSrcSap.')
x25LcnSrcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 3), Lcn()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnSrcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnSrcLcn.setDescription('Identifies the source side logical channel number this entry is associated with.')
x25LcnDstSap = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 4), SapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnDstSap.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnDstSap.setDescription('Identifies the destination side SAP (service access point) this entry is associated with. This is the first half of the SAP identification. The second half is specified by object x25LcnSrcCes.')
x25LcnDstCes = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 5), Ces()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnDstCes.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnDstCes.setDescription('Identifies the destination side CES (connection endpoint suffix) this entry is associated with. This is the second half of the SAP identification. The first half is specified by object x25LcnSrcSap.')
x25LcnDstLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 6), Lcn()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnDstLcn.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnDstLcn.setDescription('Indicates the destination side logical channel number this entry is associated with.')
x25LcnDBitCall = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnDBitCall.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnDBitCall.setDescription('Indicates if this virtual circuit was established using a D-bit call. Options: false (1): Not established using a D- bit call. true (2): Established using a D-bit call.')
x25LcnPvc = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnPvc.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnPvc.setDescription('Indicates the virtual circuit type. Options: false (1): SVC (switched virtual circuit). true (2): PVC (permanent virtual circuit). ')
x25LcnModulo = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("modulo8", 1), ("modulo128", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnModulo.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnModulo.setDescription('Indicates the modulus in use on this side of the virtual circuit. Modulus determines the range of sequence numbers available for packet numbering. Options: modulo8 (1): Sequence numbers range from 0 to 7, supporting a maximum window size of 8. modulo128 (2): Sequence numbers range from 0 to 128, supporting a maximum window size of 128.')
x25LcnState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("stateReady", 1), ("stateConnecting", 2), ("stateDataTransfer", 3), ("stateDisconnecting", 4), ("stateResettingCgSide", 5), ("stateResettingCdSide", 6), ("stateResettingBoth", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnState.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnState.setDescription("Indicates the current state at this side of the virtual circuit. Options: stateReady (1): SVC: Does not apply. PVC: The PVC is configured. It remains in this state until a Restart Request or Restart Confirm is received. This means that the PVC is in limbo and cannot initiate its reset procedure until the restart procedure has completed. The restart procedure brings up the packet level at the port where the PVC exists. stateConnecting (2) SVC: The SAP has sent out a call and is waiting for a reply, or has received a call and is routing that call out to another SAP (lower or upper), and is also waiting for a reply. PVC: Does not apply. stateDataTransfer (3) SVC: A connection has been accepted. PVC: Reset procedure has been successful. stateDisconnecting (4) SVC: The SAP has sent out a clear and is waiting for a reply, or has received a clear and is routing that clear out to another SAP (lower or upper), and is also waiting for a reply. This state is only possible if the previous state was 'stateDataTransfer'. PVC: Does not apply. This following paragraph applies to the next three states: When a connection is established (SVC or PVC), a 'connection block' is assigned to each side of the connection. One side is always termed as the 'called' side and the other the 'calling' side. For a PVC, the source side is always the 'calling' and the destination side is always the 'called'. For an SVC, the side that receives the call is the 'calling' side, and the other is the 'called'. This makes sense since we are routing the call towards the called user. stateResettingCgSide (5) SVC/PVC: A reset was received at the called side. The called side confirms the reset at its side, and a reset is also sent to the calling side. Both sides enter this state awaiting a confirmation at the calling side. state ResettingCdSide (6) SVC/PVC: A reset is received at the calling side. The calling side confirms the reset at its side, and a reset is also sent to the called side. Both sides enter this state awaiting a confirmation at the 'called' side. stateResettingBoth (7) SVC/PVC: This state is entered when a reset is generated internally at both the calling and called sides. Both sides enter the this state, each while waiting for a confirmation.")
x25LcnTxRnr = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnTxRnr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnTxRnr.setDescription('Indicates if this side of the virtual circuit has initiated flow control by sending an RNR. Options: false (1): An RNR was not sent. true (2): An RNR was sent.')
x25LcnRxRnr = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnRxRnr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnRxRnr.setDescription('Indicates if this side of the virtual circuit has received an RNR. Options: false (1): An RNR was not received. true (2): An RNR was received.')
x25LcnTxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnTxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnTxWindowSize.setDescription('Indicates the transmit window size in use at this side of the virtual circuit.')
x25LcnRxWindowSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnRxWindowSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnRxWindowSize.setDescription('Indicates the receive window size in use at this side of the virtual circuit.')
x25LcnTxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnTxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnTxPacketSize.setDescription('Indicates the transmit packet size (in bytes) in use at this side of the virtual circuit.')
x25LcnRxPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnRxPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnRxPacketSize.setDescription('Indicates the receive packet size (in bytes) in use at this side of the virtual circuit.')
x25LcnTxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(75, 64000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnTxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnTxThruputClass.setDescription('Indicates the transmit throughput class (in bps) in use at this side of the virtual circuit.')
x25LcnRxThruputClass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(75, 64000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnRxThruputClass.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnRxThruputClass.setDescription('Indicates the receive throughput class (in bps) in use at this side of the virtual circuit.')
x25LcnSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 50), X25Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnSrcAddress.setDescription('Indicates the calling address specified when this virtual circuit was established.')
x25LcnDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 51), X25Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnDstAddress.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnDstAddress.setDescription('Indicates the called address specified when this virtual circuit was established.')
x25LcnTxQLength = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnTxQLength.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnTxQLength.setDescription('Indicates the current number of outbound queued frames at this side of the virtual circuit.')
x25LcnNextTransmitPs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnNextTransmitPs.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnNextTransmitPs.setDescription('Indicates the next P(s) to be used at this side of the virtual circuit.')
x25LcnNextExpectedPs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnNextExpectedPs.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnNextExpectedPs.setDescription('Indicates the next expected P(s) at this side of the virtual circuit.')
x25LcnLastTransmittedPr = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnLastTransmittedPr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnLastTransmittedPr.setDescription('Indicates the last transmitted P(r) at this side of the virtual circuit.')
x25LcnLastReceivedPr = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnLastReceivedPr.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnLastReceivedPr.setDescription('Indicates the last received P(r) on this side of the virtual circuit.')
x25LcnFCTimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnFCTimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnFCTimerRunning.setDescription('Indicates if the flow control timer (object x25SapFlowControlTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapFlowControlTimer is not running. true (2): x25SapFlowControlTimer is running.')
x25LcnT24TimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnT24TimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnT24TimerRunning.setDescription('Indicates if the window status timer (object x25SapWindowStatusTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapWindowStatusTimer is not running. true (2): x25SapWindowStatusTimer is running.')
x25LcnInacTimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 82), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnInacTimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnInacTimerRunning.setDescription('Indicates if the inactivity timer (object x25SapInactivityTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapInactivityTimer is not running. true (2): x25SapInactivityTimer is running.')
x25LcnCalTimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 83), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnCalTimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnCalTimerRunning.setDescription('Indicates if the call request timer (object x25SapCallTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapCallTimer is not running. true (2): x25SapCallTimer is running.')
x25LcnClrTimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnClrTimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnClrTimerRunning.setDescription('Indicates if the clear timer (object x25SapClearTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapClearTimer is not running. true (2): x25SapClearTimer is running.')
x25LcnResTimerRunning = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 28, 1, 85), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25LcnResTimerRunning.setStatus('mandatory')
if mibBuilder.loadTexts: x25LcnResTimerRunning.setDescription('Indicates if the reset timer (object x25SapResetTimer) is currently running on this side of the virtual circuit. Options: false (1): x25SapResetTimer is not running. true (2): x25SapResetTimer is running.')
x25MibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: x25MibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: x25MibLevel.setDescription('Used to determine current MIB module release supported by the agent. Object is in decimal.')
x25SapAlarm = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29) + (0,1)).setObjects(("CXX25-MIB", "x25SapNumber"), ("CXX25-MIB", "x25SapCes"), ("CXX25-MIB", "x25SapStatusEvent"))
if mibBuilder.loadTexts: x25SapAlarm.setDescription("For future use. Identifies the x25SapStatusEvent trap which has occurred. This trap is only generated when global object x25Alarms is set to value 'enabled'. Options: x25SapNumber: The services access point this trap applies to. x25SapCes: The CES this trap applies to. x25SapStatusEvent: The event which triggered the trap (see object x25SapStatusEvent).")
x25ConfigErrorIndication = NotificationType((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 29) + (0,2)).setObjects(("CXX25-MIB", "x25SapNumber"), ("CXX25-MIB", "x25SapCes"), ("CXX25-MIB", "x25ConfigErrorEvent"))
if mibBuilder.loadTexts: x25ConfigErrorIndication.setDescription('For future use. Identifies the x25ConfigErrorEvent trap which has occurred. This trap can always be generated. Options: x25SapNumber: The services access point this trap applies to. x25SapCes: The CES this trap applies to. x25ConfigErrorEvent: The event which triggered the trap (see object x25ConfigErrorEvent).')
mibBuilder.exportSymbols("CXX25-MIB", x25CugIndex=x25CugIndex, x25PvcSrcLcn=x25PvcSrcLcn, x25SapStatsTxRNRPkts=x25SapStatsTxRNRPkts, x25LcnSrcSap=x25LcnSrcSap, Lcn=Lcn, x25SapStatsActiveLcns=x25SapStatsActiveLcns, x25LLEntryState=x25LLEntryState, x25LcnPvc=x25LcnPvc, x25SapLtcLcn=x25SapLtcLcn, x25SapStatsTxRRPkts=x25SapStatsTxRRPkts, x25SapTxPacketSize=x25SapTxPacketSize, x25HGSapCes=x25HGSapCes, x25LcnT24TimerRunning=x25LcnT24TimerRunning, x25SapSbscrChargingInformation=x25SapSbscrChargingInformation, x25SapSbscrPktRetransmission=x25SapSbscrPktRetransmission, x25CugSbscrOutCallsBarred=x25CugSbscrOutCallsBarred, x25RouteMask=x25RouteMask, x25CugTable=x25CugTable, x25PvcRowStatus=x25PvcRowStatus, x25PvcDstAddress=x25PvcDstAddress, x25RouteId=x25RouteId, x25SapInactivityTimer=x25SapInactivityTimer, RouteIndex=RouteIndex, x25RouteType=x25RouteType, SapType=SapType, x25SapStatsTxResPkts=x25SapStatsTxResPkts, x25PvcSrcTxPacketSize=x25PvcSrcTxPacketSize, x25HuntGroupEntry=x25HuntGroupEntry, x25SapCallTimer=x25SapCallTimer, x25SapStatsTxDataChars=x25SapStatsTxDataChars, x25SapStatsRxRNRPkts=x25SapStatsRxRNRPkts, x25LcnModulo=x25LcnModulo, x25SapConnectTimer=x25SapConnectTimer, x25PvcDstCes=x25PvcDstCes, x25SapStatsTxClrPkts=x25SapStatsTxClrPkts, x25SapStatsDiscs=x25SapStatsDiscs, x25SapStatsRxDataPkts=x25SapStatsRxDataPkts, x25SapHtcLcn=x25SapHtcLcn, x25LLSapNumber=x25LLSapNumber, x25NetworkType=x25NetworkType, x25LcnClrTimerRunning=x25LcnClrTimerRunning, x25RouteEntryState=x25RouteEntryState, x25SapModulo=x25SapModulo, x25SapType=x25SapType, x25CugSapCes=x25CugSapCes, x25PvcDstLcn=x25PvcDstLcn, x25LcnCalTimerRunning=x25LcnCalTimerRunning, HGIndex=HGIndex, x25LcnStatusEntry=x25LcnStatusEntry, x25LcnInacTimerRunning=x25LcnInacTimerRunning, x25PvcSrcSap=x25PvcSrcSap, x25SapStatsTxDiagPkts=x25SapStatsTxDiagPkts, x25HGId=x25HGId, x25SapSbscrCallingAddressValidation=x25SapSbscrCallingAddressValidation, x25PvcSrcAddress=x25PvcSrcAddress, x25SapAlias=x25SapAlias, x25LLRouteAlgorithm=x25LLRouteAlgorithm, x25LcnTxWindowSize=x25LcnTxWindowSize, x25SapTxThruputClass=x25SapTxThruputClass, x25SapActivation=x25SapActivation, x25SapCompanionAlias=x25SapCompanionAlias, x25LcnResTimerRunning=x25LcnResTimerRunning, x25PvcEntry=x25PvcEntry, x25PvcTxThruputClass=x25PvcTxThruputClass, x25SapInterfaceType=x25SapInterfaceType, x25SapLicLcn=x25SapLicLcn, x25SapStatsTable=x25SapStatsTable, x25SapStatsRxClrPkts=x25SapStatsRxClrPkts, x25PvcRxWindow=x25PvcRxWindow, x25SapSbscrCallingAddressInsertion=x25SapSbscrCallingAddressInsertion, x25LcnDstCes=x25LcnDstCes, CugIndex=CugIndex, x25LcnLastReceivedPr=x25LcnLastReceivedPr, x25SapClearTimer=x25SapClearTimer, x25SapSbscrLocalChargingPrevention=x25SapSbscrLocalChargingPrevention, x25LcnSrcLcn=x25LcnSrcLcn, x25SapStatsRxQDataPkts=x25SapStatsRxQDataPkts, x25CugRowStatus=x25CugRowStatus, x25LcnDstSap=x25LcnDstSap, x25LcnRxRnr=x25LcnRxRnr, x25SapStatsLastDiagCode=x25SapStatsLastDiagCode, x25SapSbscrCugIncomingAccess=x25SapSbscrCugIncomingAccess, x25LLNumber=x25LLNumber, x25LcnStatusTable=x25LcnStatusTable, x25ConfigErrorIndication=x25ConfigErrorIndication, x25SapRowStatus=x25SapRowStatus, x25SapSbscrOutAccessBarred=x25SapSbscrOutAccessBarred, x25SapRoutePartition=x25SapRoutePartition, x25PvcTable=x25PvcTable, x25LcnDBitCall=x25LcnDBitCall, x25SapStatsRxQDataChars=x25SapStatsRxQDataChars, CugIC=CugIC, x25SapPreferentialCugIndex=x25SapPreferentialCugIndex, x25LLSapCes=x25LLSapCes, x25SapHpvcLcn=x25SapHpvcLcn, x25HGRowStatus=x25HGRowStatus, x25HGOperMemberIndex=x25HGOperMemberIndex, x25SapSourceAddress=x25SapSourceAddress, x25PvcTxWindow=x25PvcTxWindow, x25LcnRxWindowSize=x25LcnRxWindowSize, x25LcnDstLcn=x25LcnDstLcn, x25Alarms=x25Alarms, x25HuntGroupRotation=x25HuntGroupRotation, x25SapResetTimer=x25SapResetTimer, x25SapSbscrFastSelect=x25SapSbscrFastSelect, x25SapStatsTxDataPkts=x25SapStatsTxDataPkts, x25RouteRowStatus=x25RouteRowStatus, x25SapSbscrCalledAddressInsertion=x25SapSbscrCalledAddressInsertion, x25SapLpvcLcn=x25SapLpvcLcn, x25LLRowStatus=x25LLRowStatus, x25RoutePartition=x25RoutePartition, x25UpperPoolThreshold=x25UpperPoolThreshold, x25BillingSegmentSize=x25BillingSegmentSize, x25SapControl=x25SapControl, x25SapTable=x25SapTable, x25SapStatsTxCallPkts=x25SapStatsTxCallPkts, x25SapFlowControlTimer=x25SapFlowControlTimer, x25SapWildCardRouting=x25SapWildCardRouting, x25SapLinkType=x25SapLinkType, x25SapStatsRxCallPkts=x25SapStatsRxCallPkts, x25SapStatsTxQDataChars=x25SapStatsTxQDataChars, x25SapRxWindowSize=x25SapRxWindowSize, x25SapStatsRxRstPkts=x25SapStatsRxRstPkts, x25LcnState=x25LcnState, x25SapRxThruputClass=x25SapRxThruputClass, x25LcnTxThruputClass=x25LcnTxThruputClass, x25HuntGroupOperEntry=x25HuntGroupOperEntry, x25LcnNextExpectedPs=x25LcnNextExpectedPs, x25SoftwareVersions=x25SoftwareVersions, x25Billing=x25Billing, x25SapStatsSapCes=x25SapStatsSapCes, x25HGMemberIndex=x25HGMemberIndex, x25RouteEntry=x25RouteEntry, x25HGOperSapCes=x25HGOperSapCes, x25LogicalLinkEntry=x25LogicalLinkEntry, x25SapEntry=x25SapEntry, x25PvcDstSap=x25PvcDstSap, x25SapStatsEntry=x25SapStatsEntry, x25SapSbscrFlowCntrlParamNegotiation=x25SapSbscrFlowCntrlParamNegotiation, x25CugEntry=x25CugEntry, x25HGOperId=x25HGOperId, x25SapFlowControlState=x25SapFlowControlState, Ces=Ces, x25RouteAddress=x25RouteAddress, x25LcnRxThruputClass=x25LcnRxThruputClass, x25SapRxWindowThreshold=x25SapRxWindowThreshold, x25SapSbscrReverseChargingAcceptance=x25SapSbscrReverseChargingAcceptance, x25LcnLastTransmittedPr=x25LcnLastTransmittedPr, x25SapTransitDelay=x25SapTransitDelay, x25SapRestartTimer=x25SapRestartTimer, x25HGSapNumber=x25HGSapNumber, x25SapSbscrPermissionToRedirect=x25SapSbscrPermissionToRedirect, x25SapSbscrFastSelectAcceptance=x25SapSbscrFastSelectAcceptance, x25SapStatsRxDiagPkts=x25SapStatsRxDiagPkts, x25SapRouteDirection=x25SapRouteDirection, x25MibLevel=x25MibLevel, x25SapNumber=x25SapNumber, x25SapAlarm=x25SapAlarm, x25SapDisconnectTimer=x25SapDisconnectTimer, x25PvcRxThruputClass=x25PvcRxThruputClass, x25PvcDstTxPacketSize=x25PvcDstTxPacketSize, x25SapStatsTxQDataPkts=x25SapStatsTxQDataPkts, X25Address=X25Address, x25SapRedirectionAddress=x25SapRedirectionAddress, x25CugSapNumber=x25CugSapNumber, x25SapTxWindowSize=x25SapTxWindowSize, x25RouteTable=x25RouteTable, x25SapStatsRxRRPkts=x25SapStatsRxRRPkts, x25CugEntryState=x25CugEntryState, x25CugInterlockCode=x25CugInterlockCode, x25SapStatsRxDataChars=x25SapStatsRxDataChars, x25PvcSrcRxPacketSize=x25PvcSrcRxPacketSize, x25ConfigErrorEvent=x25ConfigErrorEvent, x25LcnTxRnr=x25LcnTxRnr, x25HuntGroupOperTable=x25HuntGroupOperTable, x25HGOperSapNumber=x25HGOperSapNumber, x25SapSbscrRouteUsingCAE=x25SapSbscrRouteUsingCAE, x25SapStatsLastCauseCode=x25SapStatsLastCauseCode, x25SapSbscrTransitDelay=x25SapSbscrTransitDelay, x25LcnTxPacketSize=x25LcnTxPacketSize, x25PvcEntryState=x25PvcEntryState, x25SapSbscrRouteUsingCUDF=x25SapSbscrRouteUsingCUDF, x25RouteSapCes=x25RouteSapCes, x25HuntGroupTable=x25HuntGroupTable, x25LowerPoolThreshold=x25LowerPoolThreshold, x25LcnSrcCes=x25LcnSrcCes, x25LcnFCTimerRunning=x25LcnFCTimerRunning, x25SapHocLcn=x25SapHocLcn, x25SapRxPacketSize=x25SapRxPacketSize, x25SapSbscrCallRedirection=x25SapSbscrCallRedirection, x25SapRouteAddressLength=x25SapRouteAddressLength, x25SapHicLcn=x25SapHicLcn, x25SapWildCardRoutingMask=x25SapWildCardRoutingMask, x25SapCes=x25SapCes, x25LcnDstAddress=x25LcnDstAddress, x25LcnNextTransmitPs=x25LcnNextTransmitPs, x25SapStatsCons=x25SapStatsCons, x25SapLcnAllocation=x25SapLcnAllocation, x25SapSbscrNetworkUserId=x25SapSbscrNetworkUserId, x25SapStatsTxIntPkts=x25SapStatsTxIntPkts, PacketSize=PacketSize, x25PvcId=x25PvcId, x25LcnSrcAddress=x25LcnSrcAddress, x25SapSbscrRouteUsingSubAddress=x25SapSbscrRouteUsingSubAddress, x25SapStatsRxIntPkts=x25SapStatsRxIntPkts, x25PvcDstRxPacketSize=x25PvcDstRxPacketSize, x25PvcSrcCes=x25PvcSrcCes, x25SapStatsRxInvPkts=x25SapStatsRxInvPkts, x25PvcBilling=x25PvcBilling, x25SapStatsSapNumber=x25SapStatsSapNumber, RoutePartition=RoutePartition, x25SapSbscrCugOutgoingAccess=x25SapSbscrCugOutgoingAccess, x25RouteSLHNumber=x25RouteSLHNumber, x25SapLinkState=x25SapLinkState, x25SapStatusEvent=x25SapStatusEvent, x25SapSbscrInAccessBarred=x25SapSbscrInAccessBarred, x25SapStatsRxResPkts=x25SapStatsRxResPkts, x25SapWindowStatusTimer=x25SapWindowStatusTimer, x25SapStatsTxRstPkts=x25SapStatsTxRstPkts, x25LcnTxQLength=x25LcnTxQLength, x25LcnRxPacketSize=x25LcnRxPacketSize, x25LogicalLinkTable=x25LogicalLinkTable, x25SapLocLcn=x25SapLocLcn, PvcIndex=PvcIndex, x25CugSbscrInCallsBarred=x25CugSbscrInCallsBarred, x25SapPvcBillingTimer=x25SapPvcBillingTimer, x25SapSbscrThruputClassNegotiation=x25SapSbscrThruputClassNegotiation)

#
# PySNMP MIB module CTATM-CONFIG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CTATM-CONFIG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:44:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
atmTrafficDescrParamIndex, atmVclVpi, atmVclVci = mibBuilder.importSymbols("ATM-MIB", "atmTrafficDescrParamIndex", "atmVclVpi", "atmVclVci")
AtmTrafficDescrParamIndex, = mibBuilder.importSymbols("ATM-TC-MIB", "AtmTrafficDescrParamIndex")
ctATMConfig, = mibBuilder.importSymbols("CTRON-MIB-NAMES", "ctATMConfig")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
leArpMacAddress, lecIndex = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "leArpMacAddress", "lecIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Integer32, Counter32, Counter64, NotificationType, ObjectIdentity, iso, MibIdentifier, ModuleIdentity, Unsigned32, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Integer32", "Counter32", "Counter64", "NotificationType", "ObjectIdentity", "iso", "MibIdentifier", "ModuleIdentity", "Unsigned32", "Bits", "Gauge32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class AtmAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

ctATMBaseConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1))
ctATMPhysicalRedundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2))
ctATMPhysicalRedundancyInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1))
ctATMIlmi = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3))
ctATMSignalConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4))
ctATMLANEServices = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 5))
ctATMLANEInfoExtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6))
ctATMTrafficManagementGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7))
ctATMPvcIfDef = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPvcIfDef.setStatus('deprecated')
if mibBuilder.loadTexts: ctATMPvcIfDef.setDescription('This object is the MIB-II interface on which the next Permanent Virtual Circuit (PVC) will be created. It is an error to set an interface number which is not an ATM interface (physical or virtual). This object is persistent. However, during reinitialization of the device if it is found that the interface no longer supports ATM, then a new MIB-II interface will be created for the next PVC. The special value of 0 causes a new MIB-II interface to be created for the next PVC.')
ctATMLecIfDef = MibScalar((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMLecIfDef.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMLecIfDef.setDescription('This object is the physical interface on which _all_ LAN Emulation Clients (LECs) will be created. It is an error to set an interface number which does not support ATM. This object is persistent. However, during reinitialization of the device if it is found that the interface no longer supports ATM, then the first ATM interface for the device will be used as the value for this object.')
ctATMDefApplicationTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 3), )
if mibBuilder.loadTexts: ctATMDefApplicationTable.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMDefApplicationTable.setDescription('A list of Default Application objects for this interface.')
ctATMDefApplicationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMDefApplicationEntry.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMDefApplicationEntry.setDescription('An entry containing objects pertaining to the default application on a physical interface.')
ctATMDefApplicationIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMDefApplicationIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMDefApplicationIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMDefApplication = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lane04", 1), ("lane", 2))).clone('lane')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMDefApplication.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMDefApplication.setDescription('The default application to be run on this physical ATM interface. Selecting lane04 will cause the application known as FORE LAN Emulation 0.4 to be the default application on this interface using the spans signalling stack. This will also cause ILMI to be disabled. i.e., a read on ctATMSignalType will return spans; and a read on ctATMIlmiStatus will return disable. It is an error to set ctATMSignalType to a value other than spans when this object is set to lane04. It is an error to set ctATMIlmiStatus to a value other than disable when this object is set to spans. Selecting lane will cause the application known as ATM Forum LAN emulation version 2.0 to be the default application on this physical interface. If an attempt to be operational using LANE 2.0 is unsuccessful because of a bad-version error, then ATM Forum LANE 1.0 will be the default application. Selecting this also enables ILMI in autoconfigure mode. i.e., a read on ctATMIlmiStatus will return the value enableAutoConfigure). It is an error to set ctATMSignalType to the value spans when this object is set to lane. This object is persistent.')
ctATMFramerStatusTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 4), )
if mibBuilder.loadTexts: ctATMFramerStatusTable.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMFramerStatusTable.setDescription('A list of framer status objects for this interface.')
ctATMFramerStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMFramerStatusEntry.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMFramerStatusEntry.setDescription('An entry containing objects pertaining to status of the framer on a physical interface.')
ctATMFramerStatusIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMFramerStatusIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMFramerStatusIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMFramerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMFramerStatus.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMFramerStatus.setDescription('Setting this object to on will activate the Framer MIBs as specified by either RFC-1595 or RFC-1407 depending on whether the interface uses SONET framing or DS3 framing respectively. i.e., setting it to on will permit gathering of framer statistics at the expense of processing time. However it might be a valuable debugging aid to turn on the framer MIB. Setting this object to off will not activate the respective framer MIBS. Thus saving processing time. It is emphasised that collection of statistics for the framer is resource (processor, memory) intensive. This object is persistent.')
ctATMLecArpMacTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5), )
if mibBuilder.loadTexts: ctATMLecArpMacTable.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacTable.setDescription('A list of LEC-Index, MAC-address, associated with a particular VPI, VCI and ATM-address objects on this device.')
ctATMLecArpMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "LAN-EMULATION-CLIENT-MIB", "leArpMacAddress"))
if mibBuilder.loadTexts: ctATMLecArpMacEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacEntry.setDescription('An entry containing objects pertaining to LEC Index, MAC-address, associated with a particular VPI, VCI and and ATM-address on this device.')
ctATMLecArpMacLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacLecIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMLecArpMacLecIndex.setDescription('The lecIndex of the LEC which has learned the MAC-address given by ctATMLecArpMacAddress.')
ctATMLecArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacAddress.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMLecArpMacAddress.setDescription('The MAC-address which is learned by this LEC.')
ctATMLecArpMacElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacElanName.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacElanName.setDescription('The name of the ELAN which is joined by this LEC.')
ctATMLecArpMacVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacVpi.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacVpi.setDescription('The data-direct VPI over which traffic destined for the MAC-address ctATMLecArpMacAddress is sent.')
ctATMLecArpMacVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacVci.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacVci.setDescription('The data-direct VCI over which traffic destined for the MAC-address ctATMLecArpMacAddress is sent.')
ctATMLecArpMacATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLecArpMacATMAddress.setStatus('current')
if mibBuilder.loadTexts: ctATMLecArpMacATMAddress.setDescription('The ATM-address of the destination end-station which is the logical destination of the MAC-address ctATMLecArpMacAddress. The ATM address is returned in a form suitable for printing. The format (separators etc.) is implementation dependent. However, it is recommended that the same format be used consistently by all agents that return similar information.')
ctATMPvcBwAllocTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 6), )
if mibBuilder.loadTexts: ctATMPvcBwAllocTable.setStatus('current')
if mibBuilder.loadTexts: ctATMPvcBwAllocTable.setDescription('A list of PvcBwAllocEntries for this physical interface.')
ctATMPvcBwAllocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMPvcBwAllocEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMPvcBwAllocEntry.setDescription('An entry containing objects pertaining to Bandwidth Allocation.')
ctATMPvcBwAllocPhysIface = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMPvcBwAllocPhysIface.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMPvcBwAllocPhysIface.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMPvcBwAllocStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("notSupported", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPvcBwAllocStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMPvcBwAllocStatus.setDescription('The values on and off can be written to this object. Selecting on will enable bandwidth allocation mode on this interface. When this mode is enabled all LECs and PVCs currently configured on this interface will be deleted, UNI and ILMI will be disabled, and this module will reboot. Selecing off will disable bandwidth allocation mode on this interface. When this mode is disabled all PVCs currently configured on this interface will be deleted, UNI and ILMI will revert to their former status, and this module will reboot. If bandwidth allocation mode is not supported by this module the value notSupported will be returned by this object. This value can not be set by the network administrator. This object is persistent.')
ctATMPvcBwAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMPvcBwAllocBandwidth.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMPvcBwAllocBandwidth.setDescription('Returns the amount of bandwidth in use on this ATM interface in bits per second.')
ctATMDiscoveryElanTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7), )
if mibBuilder.loadTexts: ctATMDiscoveryElanTable.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanTable.setDescription('A list of DiscoveryElanEntries for this physical interface.')
ctATMDiscoveryElanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CTATM-CONFIG-MIB", "ctATMDiscoveryElanIndex"))
if mibBuilder.loadTexts: ctATMDiscoveryElanEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanEntry.setDescription('An entry containing objects pertaining to discovering elans.')
ctATMDiscoveryElanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMDiscoveryElanIndex.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanIndex.setDescription('There are a fixed number of elans (1 - MAX_ELANS) per physical interface to initiate the discovery process on. This is the index for these elans. This is NOT related to the LEC Index.')
ctATMDiscoveryElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMDiscoveryElanName.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanName.setDescription('The device will try to discover, on this named elan, any other devices out in the atm cloud that it should set up an svc with. This allows flexibility in the number and location of other switches this particular physical interface should know about and talk with.')
ctATMDiscoveryElanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ctATMDiscoveryElanMaster", 1), ("ctATMDiscoveryElanSlave", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMDiscoveryElanMode.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanMode.setDescription('Master indicates other elans may discover this elan whereas slave elans may only discover other elans.')
ctATMDiscoveryElanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ctATMDiscoveryElanEnabled", 1), ("ctATmDiscoveryElanDisabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMDiscoveryElanStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMDiscoveryElanStatus.setDescription('Enabled indicates this elan should be used in the discovery process whereas disabled elans are not.')
ctATMDiscoveryElanPhysIface = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMDiscoveryElanPhysIface.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMDiscoveryElanPhysIface.setDescription('The physical interface number on which to initiate the discovery processes.')
ctATMVclTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8), )
if mibBuilder.loadTexts: ctATMVclTable.setStatus('current')
if mibBuilder.loadTexts: ctATMVclTable.setDescription('A list of physical interface number, VPI, VCI, associated with a virtual ifIndex, application port, ATM Address, and Encapsulation type on this device.')
ctATMVclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ATM-MIB", "atmVclVpi"), (0, "ATM-MIB", "atmVclVci"))
if mibBuilder.loadTexts: ctATMVclEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMVclEntry.setDescription('An entry containing objects pertaining to physical interface number, VPI, VCI, associated with a particular virtual ifIndex, application port, ATM Address, and Encapsulation type on this device.')
ctATMVclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMVclIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMVclVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclVpi.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMVclVpi.setDescription('The VPI value of the VCL.')
ctATMVclVci = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclVci.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMVclVci.setDescription('The VCI value of the VCL.')
ctATMVclVirtualIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclVirtualIfIndex.setStatus('current')
if mibBuilder.loadTexts: ctATMVclVirtualIfIndex.setDescription('Returns an index for the virtual interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMVclApplicationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclApplicationPort.setStatus('current')
if mibBuilder.loadTexts: ctATMVclApplicationPort.setDescription('Returns an index for the application port to which the information in this table pertains.')
ctATMVclATMAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 6), AtmAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclATMAddress.setStatus('current')
if mibBuilder.loadTexts: ctATMVclATMAddress.setDescription('The ATM-address of the channel entry defined by ctATMVclEntry. The ATM address is returned in a form suitable for printing. The format (separators etc.) is implementation dependent. However, it is recommended that the same format be used consistently by all agents that return similar information.')
ctATMVclEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 1, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("vcMultiplexRoutedProtocol", 1), ("vcMultiplexBridgedProtocol8023", 2), ("vcMultiplexBridgedProtocol8025", 3), ("vcMultiplexBridgedProtocol8026", 4), ("vcMultiplexLANemulation8023", 5), ("vcMultiplexLANemulation8025", 6), ("llcEncapsulation", 7), ("multiprotocolFrameRelaySscs", 8), ("other", 9), ("unknown", 10), ("ilmi", 11), ("uni", 12), ("lanEmulationData", 13), ("lanEmulationControl", 14), ("atmVcSvcApp", 15), ("multiProtocolOverATMData", 16), ("multiProtocolOverATMControl", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMVclEncapsulationType.setStatus('current')
if mibBuilder.loadTexts: ctATMVclEncapsulationType.setDescription("An instance of this object only exists when the local VCL end-point is also the VCC end-point, and AAL5 is in use. The type of data encapsulation used over the AAL5 SSCS layer. The definitions reference RFC 1483 Multiprotocol Encapsulation over ATM AAL5 and to the ATM Forum LAN Emulation specification, and additional definitions previously categorized as 'other'. This object mirrors the atmVccAal5EncapsType described in RFC1695, up to the 'unknown' value. 'LANemulation' protocols were branched into two categories 'Data' and 'Control', and ILMI, UNI, and 'atm_vc_svc_app' were added as expansions from 'other'.")
ctATMPhyRedundTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1), )
if mibBuilder.loadTexts: ctATMPhyRedundTable.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundTable.setDescription('A list of redundancy objects for this physical interface.')
ctATMPhyRedundEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMPhyRedundEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundEntry.setDescription('An entry containing objects pertaining to ATM physical redundancy for a physical interface.')
ctATMPhyRedundIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMPhyRedundIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMPhyRedundIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II ifIndex.')
ctATMPhyRedundPrimaryPort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundPrimaryPort.setDescription('The physical port number to be used as the primary port. The primary port is the default port to become active and the port of priority, i.e. regardless of the status of the current active port, if the primary can be used (and Redundancy is set up to activate it when it becomes available--see ctATMPhyRedundPrimaryRevert), it will be. The write will NOT take effect immediately. It will wait until the NEXT time that the redundancy algorithm determines that the primary port should be used. This object is persistent. i.e., it will retain its value between powerdowns.')
ctATMPhyRedundActivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundActivePort.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundActivePort.setDescription("The physical port number to be used as the active port. The primary port defaults as the active port if this object is not set. Rules: - This object can always be set when ctATMPhyRedundStatus (q.v.) is set to disable(2). - It cannot be set when ctATMPhyRedundStatus is set to enable(1), ctATMPhyRedundPrimaryRevert (q.v.) is set to automatic(1), and the primary port is deemed good (and therefore usable) by redundancy. Under these conditions, it is meaningless to attempt to manually set the Active Port, as Redundancy would simply reset the active port to the primary again immediately after the set takes place. - If the primary port has failed, or ctATMPhyRedundPrimaryRevert is set to manual(2), then this object can be set; however, the behaviour of redundancy as a result of the set will depend on the status of ctATMPhyRedundActivation (q.v.) and whether or not the port being set active is good. If RedundActivation is enabled, the set may be countermanded immediately if at any time the port being set is found to be bad (and therefore not usable by Redundancy) and another (good) redundant port is available. If RedundActivation is set to manual(2), then the set will take place, regardless of the status of the port being set. Naturally, if the primary port is restored, the behaviour of Redundancy will depend on whether RedundPrimaryRevert is automatic; if it is, the active port will immediately switch over; otherwise it will remain as-is. There is a precisely defined relationship between ctATMPhyRedundActivePort, ctATMPhyRedundStatus, ctATMPhyRedundPrimaryRevert, and ctATMPhyRedundActivation. If RedundStatus is disabled, then PrimaryRevert and RedundActivation have no functional meaning and ActivePort becomes the only means by which the redundant ports can be switched. Likewise, if RedundStatus is enabled and PrimaryRevert is automatic, a set of the ActivePort has no functional meaning for as long as the primary port is deemed usable by redundancy. If RedundStatus is enabled but PrimaryRevert is manual, the active port will only be changed through ActivePort or the exercise of RedundActivation. The line of precedence, therefore, fully depends upon the status of Redundancy; if RedundStatus is disabled, then precedence lies with ActivePort by virtue of the fact that there are no other competing methods to switch the active port among the redundant ports. If RedundStatus is enabled, however, PrimaryRevert (an active switching method) and RedundActivation (a passive switching method) have precedence over ActivePort; if PrimaryRevert is set to automatic, then the active port is immediately switched to the primary as soon as it's deemed usable by Redundancy; likewise, if RedundActivation is set to automatic, the currently active port will be switched immediately in the event of port failure. Clearly, then, ActivePort cannot guarantee a set for as long as any automatic part of Redundancy is enabled. This object is persistent.")
ctATMPhyRedundStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundStatus.setDescription('If this object is set to enable, then redundancy for this interface is enabled. If this object is set to disable, redundancy is disabled. If redundancy is disabled, then automatic switching to backup ports will not be available. Periodic testing of ports is independent of ctATMPhyRedundStatus and is controlled by ctATMPhyRedundPerformTest. See ctATMPhyRedundActivePort for a description of the relationships between this object, ctATMPhyRedundActivePort, ctATMPhyRedundActivation, and ctATMPhyRedundPrimaryRevert. This object is persistent.')
ctATMPhyRedundActivation = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundActivation.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundActivation.setDescription('If this object is set to automatic, a backup port will automatically be activated upon failure of the active port. If this object is set to manual, it will require the manual setting of ctATMPhyRedundActivePort to activate a port upon failure of the currently active port. See ctATMPhyRedundActivePort for a description of the relationships between this object, ctATMPhyRedundStatus, ctATMPhyRedundActivePort, and ctATMPhyRedundPrimaryRevert. This object is persistent.')
ctATMPhyRedundPrimaryRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2))).clone('automatic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundPrimaryRevert.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundPrimaryRevert.setDescription('If this object is set to automatic, the primary port will automatically be activated upon identifying it to be valid at any time. If this object is set to manual, then the currently active port will not change despite identifying the primary port to be valid. See ctATMPhyRedundActivePort for a description of the relationships between this object, ctATMPhyRedundStatus, ctATMPhyRedundActivePort, and ctATMPhyRedundActivation. This object is persistent.')
ctATMPhyRedundPerformTest = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("immediate", 3))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundPerformTest.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundPerformTest.setDescription('If this object is set to enable, then the automatic test (at the time given by ctATMPhyRedundTestTOD) is enabled. The test is periodic with a period of 24 hours. If this object is set to disable, then the automatic test is disabled. However, one can still test the ports by setting this object to immediate. If this object is set to immediate it will cause a test for validity of each redundant port for this interface to be performed immediately. The result of the test shall be available by reading the object ctATMPhyRedundTestResult. This object is persistent. However, the special value immediate is not persistent.')
ctATMPhyRedundTestTOD = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundTestTOD.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundTestTOD.setDescription('Setting this object will set the time of day at which each redundant port of this interface will be tested for validity. The value is a null terminated string in either hh:mm:ss or hh.mm.ss or hh:mm.ss or hh.mm:ss format (24 hour format). The seconds(ss) and minutes(mm) components are optional and default to 00. The value of this object will be used only if ctATMPhyRedundPerformTest is set to enable. This object is persistent.')
ctATMPhyRedundTestResult = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 101, 102, 103, 200, 201, 202, 203))).clone(namedValues=NamedValues(("manualAllPortsGood", 100), ("manualPrimaryBadOthersGood", 101), ("manualPrimaryGoodOthersBad", 102), ("manualPrimaryBadOthersBad", 103), ("automaticAllPortsGood", 200), ("automaticPrimaryBadOthersGood", 201), ("automaticPrimaryGoodOthersBad", 202), ("automaticPrimaryBadOthersBad", 203)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMPhyRedundTestResult.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundTestResult.setDescription('This object returns the status of the last test performed on all the ports. If the test was performed as a result of ctATMPhyRedundPerformTest.immediate, then the value of this object is of the form 1xx. If the test was performed as a result of setting ctATMPhyRedundTestTOD, then the result is of the form 2xx. The meaning of xx is the same in both cases and is explained below: 00 All ports involved in redundancy are good. 01 Primary port (as identified by ctATMPhyRedundPrimaryPort) is bad, but all other non-primary ports are good. 02 Primary port is good, but one or more non-primary ports are bad. 03 Primary port and one or more non-primary ports are bad. Any other value for this object may be interpreted to mean that no test has been performed on the ports involved in redundancy since system startup. This object is NOT persistent.')
ctATMPhyRedundReset = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 2, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMPhyRedundReset.setStatus('current')
if mibBuilder.loadTexts: ctATMPhyRedundReset.setDescription('If this object is set to reset, the state of redundancy on this interface will be reset to factory defaults. When read this object will always return 1.')
ctATMIlmiTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1), )
if mibBuilder.loadTexts: ctATMIlmiTable.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiTable.setDescription('A list of ILMI objects for this physical ATM interface.')
ctATMIlmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMIlmiEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiEntry.setDescription('An entry containing objects pertaining to ILMI for this physical ATM interface.')
ctATMIlmiIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMIlmiIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMIlmiIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to the MIB-II interface number for this interface.')
ctATMIlmiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enableAutoConfigure", 1), ("enable", 2), ("disable", 3))).clone('enableAutoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMIlmiStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiStatus.setDescription('If this object is set to enableAutoConfigure, then ILMI on this interface will attempt to automatically configure the version of UNI to use on this interface. After the auto configure process has completed, the version of UNI this interface is running can be obtained by reading the ctATMSignalType object. If this object is set to enable, the ILMI for this interface is enabled. If enabled (with or without auto-configure), ILMI on this interface will attempt address registration. If this object is set to disable, auto-configure and address registration are both disabled. The signalling to use on this interface is then dictated by the value of ctATMSignalType. If disabled, the ILMI channel (0/16) will not be created. It is an error to set a value other than disable to this object when ctATMDefApplication is set to lane04. It is an error to write to ctATMSignalType when this object is set to enableAutoConfigure. This object is persistent, i.e, it will retain its value between powerdowns.')
ctATMIlmiAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1, 3), AtmAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMIlmiAtmAddress.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiAtmAddress.setDescription('This object is used as the ATM address of this interface if ILMI on this interface is disabled i.e, the value of IlmiStatus is set to disable. If ILMI address registration is successful (ctATMIlmiState is up) then a read on this object will return the ATM Address in use at this interface. It is an error to write to this object when the value of ctATMIlmiStatus is other than disable. This object is persistent. However, enabling ILMI after writing to this object will cause ILMI to ignore the persistent value.')
ctATMIlmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("unknown", 1), ("up", 2), ("addressRegistration", 3), ("autoconfigure", 4), ("down", 5), ("estabConnectivity", 6), ("noLink", 7), ("obtainLECS", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMIlmiState.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiState.setDescription("This object describes the current state of ILMI on this interface. The meaning of the various values returned is as follows: unknown -ILMI is in the process of becoming operational. up -ILMI is operational and is doing keep alives. addressRegistration -ILMI is attempting address registration. autoconfigure -ILMI is attempting to automatically configure UNI version, provided ctATMIlmiStatus is enableAutoConfigure. down -ILMI is down either because it is disabled or failed to become operational. estabConnectivity -ILMI is waiting to hear an answer from the other side. noLink -ILMI has not been told that it's physical interface has link integrity. obtainLECS -ILMI is requesting the LECS registration table from the switch.")
ctATMIlmiRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("restart", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMIlmiRestart.setStatus('current')
if mibBuilder.loadTexts: ctATMIlmiRestart.setDescription('Setting this object to restart will restart ILMI on this interface. Reading this object always returns a 1.')
ctATMSignalTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1), )
if mibBuilder.loadTexts: ctATMSignalTable.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalTable.setDescription('A list of signaling object for this interface.')
ctATMSignalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMSignalEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalEntry.setDescription('An entry containing objects pertaining to ATM signaling on a physical interface.')
ctATMSignalIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMSignalIfIndex.setStatus('obsolete')
if mibBuilder.loadTexts: ctATMSignalIfIndex.setDescription('Returns an index for the physical interface to which the information in this table pertains. It is equal to ifIndex.')
ctATMSignalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMSignalStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalStatus.setDescription('If this object is set to enable, the signalling for this interface is enabled. If this object is set to disable, signalling is disabled. When read, this object returns the state of the object based on the last request made. This object is persistent.')
ctATMSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("spans", 2), ("uni30", 3), ("uni31", 4), ("uni40", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMSignalType.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalType.setDescription('The type of signalling to be used on this interface. Setting this object to spans will cause the FORE SPANS protocol to be used for signalling on this interface. Setting this object to any other value will cause the appropriate version of ATM FORUM UNI to be used for signalling on this interface. A read on this object will return the signalling stack in use at this interface. When read, the special value of unknown indicates that ILMI is in the process of autoconfiguring and the value of UNI on this interface is yet unknown. A subsequent read sometime later will yield the correct value. When read, any value other than spans (and unknown) indicates the version of signalling stack in use at this interface. This value is obtained either as a result of a prior write to this object or ILMI autoconfigure. It is an error to set this object to any value other than spans when ctATMDefApplication is lane04. It is an error to write to this object when ctATMIlmiStatus is set to enableAutoConfigure or enable. It is an error to write the special value unknown. This object is persistent. But, the special value unknown is not persistent.')
ctATMSignalQ93Status = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMSignalQ93Status.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalQ93Status.setDescription('If ctATMSignalType is other than spans, then the value of this object is the state of the layer 3 signalling stack on this interface.')
ctATMSignalQsaalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMSignalQsaalStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalQsaalStatus.setDescription('If ctATMSignalType is other than spans, then the value of this object is the state of the layer-2 signalling stack (Q.SAAL) on this interface. ')
ctATMSignalRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("restart", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMSignalRestart.setStatus('current')
if mibBuilder.loadTexts: ctATMSignalRestart.setDescription('Setting this object to restart will restart signalling on this interface. Reading this object always returns a 1.')
ctATMLANEInfoExtStatusTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1), )
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusTable.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusTable.setDescription("Defines extentions to the lecConfigTable and the lecStatusTable in the ATM Forum's LANE MIB.")
ctATMLANEInfoExtStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"))
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusEntry.setDescription("An entry containing objects describing information about an LEC (LAN Emulation Client). It is instanced by lecIndex which is the same as what is defined in the ATM Forum's LAN Emulation MIB.")
ctATMLANEInfoExtStatusUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusUpTime.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusUpTime.setDescription('The amount of time in milliseconds since the LEC has reached the operational state. It will read 0 if the LEC is not operational.')
ctATMLANEInfoExtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lecactive", 1), ("lecnotInService", 2), ("lecnoLink", 3), ("lecnoATMaddrnoUNI", 4), ("lecnoATMaddr", 5), ("lecnoUNI", 6), ("lecmemError", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatus.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatus.setDescription("LEC_active - The LEC is actually trying to become or is operational. See lecInterfaceState in the ATM Forum's LAN Emulation MIB to see which state the LEC is in. LEC_notInService - The LEC is not trying to become operational because the MIB read so. LEC_noLink - The LEC is not trying to become operational because the physical interface does not have link. LEC_noATMaddrnoUNI - The LEC is not trying to become operational because there isn't an ATM address and UNI is not operational. LEC_noATMaddr - The LEC is not trying to become operational because there isn't an ATM address. LEC_noUNI - The LEC is not trying to become operational because UNI is not operational. LEC_memError - The LEC is not trying to become operational because it was not able to allocate memory in order to do so.")
ctATMLANEInfoExtStatusSendTopo = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusSendTopo.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusSendTopo.setDescription('This configuration value is used to define whether or not this LEC should send a LE_TOPOLOGY_CHANGE message when the situation presents itself.')
ctATMLANEInfoExtStatusTimeLeft = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusTimeLeft.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusTimeLeft.setDescription('A string used to describe the amount of time left in a certain LEC state before the LEC will try again in that state. This will read NULL if the LEC is operational.')
ctATMLANEInfoExtStatusNumQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusNumQueues.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusNumQueues.setDescription("This configuration value is used to define the number of traffic descriptors used by this LEC to implement Traffic Mangement. It's value ranges from 1 to ctATMLANEInfoExtStatusMaxNumQueues.")
ctATMLANEInfoExtStatusMaxNumQueues = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusMaxNumQueues.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtStatusMaxNumQueues.setDescription('Defines the maximum number that ctATMLANEInfoExtNumQueues can be set to.')
ctATMLANEInfoExtTMTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 2), )
if mibBuilder.loadTexts: ctATMLANEInfoExtTMTable.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtTMTable.setDescription('Defines a list, of length ctATMLANEInfoExtStatusNumQueues, of traffic descriptor indexes matching atmTrafficDescrParamIndex in the atmTrafficDescrParamTable defined in the RFC 1695.')
ctATMLANEInfoExtTMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 2, 1), ).setIndexNames((0, "LAN-EMULATION-CLIENT-MIB", "lecIndex"), (0, "CTATM-CONFIG-MIB", "ctATMLANEInfoExtTMIndex"))
if mibBuilder.loadTexts: ctATMLANEInfoExtTMEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtTMEntry.setDescription("An entry containing OBJECTS describing information about an LEC's (LAN Emulation Client) Traffic Management parameters. It is instanced by lecIndex, which is the same as what is defined in the ATM Forum's LAN Emulation MIB, and by a list index which ranges from 1 to ctATMLANEInfoExtStatusNumQueues.")
ctATMLANEInfoExtTMIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMLANEInfoExtTMIndex.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtTMIndex.setDescription('Defines the list index and will range from 1 to ctATMLANEInfoExtStatusNumQueues.')
ctATMLANEInfoExtTMTrafficDescrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 6, 2, 1, 2), AtmTrafficDescrParamIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMLANEInfoExtTMTrafficDescrIndex.setStatus('current')
if mibBuilder.loadTexts: ctATMLANEInfoExtTMTrafficDescrIndex.setDescription("Defines a traffic descriptor index that matches the index atmTrafficDescrParamIndex in the atmTrafficDescrParamTable defined in the RFC 1695. NOTE: This table will always be at least of length 1. In this case it will define the traffic descriptor that will be used for every data SVC for this LAN Emulation Client. NOTE: When this is set it will cause the LAN Emulation Client to restart it's state machine, thus loosing operational status temporarily, thus loosing LAN connectivity temporarily.")
ctATMTrafficDescrNameTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 1), )
if mibBuilder.loadTexts: ctATMTrafficDescrNameTable.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficDescrNameTable.setDescription('An association between a string describing a traffic descriptor and a traffic descriptor index into the atmTrafficDescrParamTable in RFC 1695.')
ctATMTrafficDescrNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 1, 1), ).setIndexNames((0, "ATM-MIB", "atmTrafficDescrParamIndex"))
if mibBuilder.loadTexts: ctATMTrafficDescrNameEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficDescrNameEntry.setDescription('An entry containing objects associating a string describing a traffic descriptor on this device and a traffic descriptor index into the atmTrafficDescrParamTable in RFC 1695.')
ctATMTrafficDescrName = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ctATMTrafficDescrName.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficDescrName.setDescription('The name of the traffic descriptor.')
ctATMTrafficServiceCategoriesSupportedTable = MibTable((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 2), )
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedTable.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedTable.setDescription('A table related to traffic management service categories supported.')
ctATMTrafficServiceCategoriesSupportedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedEntry.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedEntry.setDescription('A table entry containing information related to the traffic management service categories that are supported for a certain physical interface.')
ctATMTrafficServiceCategoriesSupportedBitMask = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 2, 1, 1), Bits().clone(namedValues=NamedValues(("other", 0), ("pvcBandwidthAllocation", 1), ("cbr", 2), ("vbrnrt", 3), ("ubr", 4), ("abr", 5), ("vbrrt", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedBitMask.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficServiceCategoriesSupportedBitMask.setDescription('This indicates the traffic service categories supported by this physical interface. other(0) Undefined, or service category unknown PVC Bandwidth Allocation(1) Proprietary bandwidth allocation on PVCs only - to set in this mode please use ctATMPvcBwAllocStatus CBR(2) Constant Bit Rate VBR-nrt(3) Variable Bit Rate - non real time UBR(4) Unspecified Bit Rate ABR(5) Avalilable Bit Rate VBR-rt(6) Variable Bit Rate - real time ')
ctATMTrafficManagementAllocBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 52, 4, 1, 2, 10, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ctATMTrafficManagementAllocBandwidth.setStatus('current')
if mibBuilder.loadTexts: ctATMTrafficManagementAllocBandwidth.setDescription('Returns the amount of bandwidth in use on this ATM interface in bits per second. Value only valid when running more than just UBR traffic.')
mibBuilder.exportSymbols("CTATM-CONFIG-MIB", ctATMTrafficServiceCategoriesSupportedEntry=ctATMTrafficServiceCategoriesSupportedEntry, ctATMVclVci=ctATMVclVci, ctATMDiscoveryElanMode=ctATMDiscoveryElanMode, ctATMLANEInfoExtStatusUpTime=ctATMLANEInfoExtStatusUpTime, ctATMIlmiIfIndex=ctATMIlmiIfIndex, ctATMDiscoveryElanEntry=ctATMDiscoveryElanEntry, ctATMLANEInfoExtTMEntry=ctATMLANEInfoExtTMEntry, ctATMVclIfIndex=ctATMVclIfIndex, ctATMLecArpMacVpi=ctATMLecArpMacVpi, ctATMDiscoveryElanIndex=ctATMDiscoveryElanIndex, ctATMVclTable=ctATMVclTable, ctATMPhyRedundTable=ctATMPhyRedundTable, ctATMLANEInfoExtStatusTimeLeft=ctATMLANEInfoExtStatusTimeLeft, ctATMPvcBwAllocPhysIface=ctATMPvcBwAllocPhysIface, ctATMFramerStatusTable=ctATMFramerStatusTable, ctATMLecIfDef=ctATMLecIfDef, ctATMPhyRedundIfIndex=ctATMPhyRedundIfIndex, ctATMDiscoveryElanPhysIface=ctATMDiscoveryElanPhysIface, ctATMVclEncapsulationType=ctATMVclEncapsulationType, ctATMFramerStatus=ctATMFramerStatus, ctATMSignalQsaalStatus=ctATMSignalQsaalStatus, ctATMDefApplicationEntry=ctATMDefApplicationEntry, ctATMPvcBwAllocTable=ctATMPvcBwAllocTable, ctATMPvcBwAllocEntry=ctATMPvcBwAllocEntry, ctATMSignalType=ctATMSignalType, ctATMLANEInfoExtTMTrafficDescrIndex=ctATMLANEInfoExtTMTrafficDescrIndex, ctATMVclATMAddress=ctATMVclATMAddress, ctATMTrafficDescrName=ctATMTrafficDescrName, ctATMPvcBwAllocStatus=ctATMPvcBwAllocStatus, ctATMLecArpMacLecIndex=ctATMLecArpMacLecIndex, ctATMLecArpMacATMAddress=ctATMLecArpMacATMAddress, ctATMLANEInfoExtGroup=ctATMLANEInfoExtGroup, ctATMLANEServices=ctATMLANEServices, ctATMIlmiEntry=ctATMIlmiEntry, ctATMBaseConfig=ctATMBaseConfig, ctATMSignalConfig=ctATMSignalConfig, ctATMLecArpMacElanName=ctATMLecArpMacElanName, ctATMPhyRedundReset=ctATMPhyRedundReset, ctATMSignalQ93Status=ctATMSignalQ93Status, ctATMPhyRedundEntry=ctATMPhyRedundEntry, ctATMIlmiRestart=ctATMIlmiRestart, ctATMLANEInfoExtStatusNumQueues=ctATMLANEInfoExtStatusNumQueues, ctATMLecArpMacEntry=ctATMLecArpMacEntry, ctATMPhyRedundActivePort=ctATMPhyRedundActivePort, ctATMDefApplication=ctATMDefApplication, ctATMSignalIfIndex=ctATMSignalIfIndex, ctATMTrafficDescrNameTable=ctATMTrafficDescrNameTable, ctATMLecArpMacTable=ctATMLecArpMacTable, ctATMDiscoveryElanTable=ctATMDiscoveryElanTable, ctATMPhyRedundActivation=ctATMPhyRedundActivation, ctATMDefApplicationTable=ctATMDefApplicationTable, ctATMPhyRedundTestResult=ctATMPhyRedundTestResult, ctATMPhyRedundPrimaryRevert=ctATMPhyRedundPrimaryRevert, ctATMIlmiState=ctATMIlmiState, ctATMPvcBwAllocBandwidth=ctATMPvcBwAllocBandwidth, ctATMSignalStatus=ctATMSignalStatus, ctATMLANEInfoExtStatusMaxNumQueues=ctATMLANEInfoExtStatusMaxNumQueues, ctATMTrafficManagementAllocBandwidth=ctATMTrafficManagementAllocBandwidth, ctATMLANEInfoExtTMTable=ctATMLANEInfoExtTMTable, ctATMIlmi=ctATMIlmi, ctATMIlmiTable=ctATMIlmiTable, ctATMLANEInfoExtStatusEntry=ctATMLANEInfoExtStatusEntry, ctATMSignalEntry=ctATMSignalEntry, ctATMLecArpMacVci=ctATMLecArpMacVci, ctATMPvcIfDef=ctATMPvcIfDef, ctATMPhyRedundTestTOD=ctATMPhyRedundTestTOD, ctATMPhysicalRedundancy=ctATMPhysicalRedundancy, ctATMIlmiAtmAddress=ctATMIlmiAtmAddress, ctATMLANEInfoExtStatus=ctATMLANEInfoExtStatus, ctATMTrafficDescrNameEntry=ctATMTrafficDescrNameEntry, ctATMFramerStatusEntry=ctATMFramerStatusEntry, ctATMLecArpMacAddress=ctATMLecArpMacAddress, ctATMTrafficServiceCategoriesSupportedBitMask=ctATMTrafficServiceCategoriesSupportedBitMask, ctATMDefApplicationIfIndex=ctATMDefApplicationIfIndex, ctATMLANEInfoExtStatusTable=ctATMLANEInfoExtStatusTable, ctATMDiscoveryElanName=ctATMDiscoveryElanName, ctATMSignalRestart=ctATMSignalRestart, ctATMVclEntry=ctATMVclEntry, ctATMTrafficManagementGroup=ctATMTrafficManagementGroup, ctATMSignalTable=ctATMSignalTable, ctATMTrafficServiceCategoriesSupportedTable=ctATMTrafficServiceCategoriesSupportedTable, ctATMPhyRedundStatus=ctATMPhyRedundStatus, ctATMVclVirtualIfIndex=ctATMVclVirtualIfIndex, ctATMFramerStatusIfIndex=ctATMFramerStatusIfIndex, ctATMLANEInfoExtStatusSendTopo=ctATMLANEInfoExtStatusSendTopo, ctATMIlmiStatus=ctATMIlmiStatus, ctATMDiscoveryElanStatus=ctATMDiscoveryElanStatus, ctATMPhyRedundPerformTest=ctATMPhyRedundPerformTest, ctATMPhyRedundPrimaryPort=ctATMPhyRedundPrimaryPort, ctATMVclApplicationPort=ctATMVclApplicationPort, ctATMLANEInfoExtTMIndex=ctATMLANEInfoExtTMIndex, ctATMPhysicalRedundancyInterface=ctATMPhysicalRedundancyInterface, AtmAddress=AtmAddress, ctATMVclVpi=ctATMVclVpi)

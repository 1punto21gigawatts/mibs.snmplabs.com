#
# PySNMP MIB module NTN-QOS-POLICY-AUX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NTN-QOS-POLICY-AUX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
ntnQosIfParametersExt, = mibBuilder.importSymbols("NTN-QOS-POLICY-EXT-PIB", "ntnQosIfParametersExt")
PolicyInstanceId, RoleCombination = mibBuilder.importSymbols("POLICY-FRAMEWORK-PIB", "PolicyInstanceId", "RoleCombination")
qosTargetEntry, = mibBuilder.importSymbols("QOS-POLICY-IP-PIB", "qosTargetEntry")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, Gauge32, iso, NotificationType, MibIdentifier, Bits, ModuleIdentity, Counter64, ObjectIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "Gauge32", "iso", "NotificationType", "MibIdentifier", "Bits", "ModuleIdentity", "Counter64", "ObjectIdentity", "Integer32")
RowStatus, StorageType, TruthValue, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TruthValue", "DisplayString", "TextualConvention")
policy, = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "policy")
ntnQosPolicyAuxMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 4, 5))
ntnQosPolicyAuxMib.setRevisions(('2004-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ntnQosPolicyAuxMib.setRevisionsDescriptions(('Version 3: Added version info',))
if mibBuilder.loadTexts: ntnQosPolicyAuxMib.setLastUpdated('200407200000Z')
if mibBuilder.loadTexts: ntnQosPolicyAuxMib.setOrganization('Nortel Networks, Inc.')
if mibBuilder.loadTexts: ntnQosPolicyAuxMib.setContactInfo('Editor: John Seligson Nortel Networks, Inc. Postal: 4401 Great America Parkway Santa Clara, CA USA 95054 Tel: +1 408 495-2992 E-mail: jseligso@nortelnetworks.com')
if mibBuilder.loadTexts: ntnQosPolicyAuxMib.setDescription('This module defines an infrastructure used for support of policy-based traffic processing in a network device.')
ntnQosPolicyAuxObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 1))
ntnQosPolicyAuxConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 2))
ntnQosConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1))
ntnQosStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2))
ntnQosConfigDynamicMgmt = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDynamicMgmt.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDynamicMgmt.setDescription("Specifies whether dynamic management (e.g., COPS-PR) is currently enabled. Devices may limit support for dynamic management by providing read-only access to this object. If enabled, dynamic management always takes precedence over static management such that static management may only be used for monitoring of objects that have a POLICY-ACCESS clause of 'install' or 'install-notify' in the respective PIB module. Disabling dynamic management causes Delete Request State (DRQ) and Client Close (CC) messages to be generated if a connection between the PEP and a PDP is currently established. Installed policies are not automatically deleted. Enabling dynamic management will initiate the COPS-PR connect sequence and, potentailly, the loading of policy information.")
ntnQosConfigQpaState = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("running", 1), ("initializing", 2), ("resetToDefault", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigQpaState.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigQpaState.setDescription("The state of the QoS Policy Agent (QPA). A state of 'running(1)' indicates that the QPA is in a stable state and can process messages. A state of 'initializing(2)' indicates that the agent is currently unable to process messages. Either 'running(1)' or 'initializing(2)' will be returned when querying this object. These values can not be set. All installed state can be deleted and reset to the device's default state by setting the value of this object to 'resetToDefault(3)'. This is the only value that will be accepted when setting this object. The 'resetToDefault(3)' value will never be returned in response to a query.")
ntnQosConfigQpaRetryTimer = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(1, 86400), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigQpaRetryTimer.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigQpaRetryTimer.setDescription('The number of seconds between the receipt of a connection termination/rejection indication and the initiation of a new connection request. A value of -1 indicates that a connection retry should not be attempted after a failed attempt.')
ntnQosConfigAllowPacketReordering = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 4), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigAllowPacketReordering.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigAllowPacketReordering.setDescription("Support for certain Per-Hop-Behaviors (PHBs) requires that packets within a flow not be reordered upon transmission. Packet reordering may not be an issue for other PHBs. Setting this object to 'true(1)' allows full flexibility in terms of the egress queue to which a packet is assigned. A value of 'false(2)' causes the agent to verify that in-profile and out-of-profile actions associated with a flow will not cause packets from the same flow to be assigned to different egress queues.")
ntnQosConfigMaintainPolicingStats = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 5), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigMaintainPolicingStats.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigMaintainPolicingStats.setDescription("Policing statistics, such as in-profile and out-of-profile octets, are often an important mechanism for evaluating the effectiveness of installed policies. In order to track these statistics, additional system resources are consumed meaning that the amount of filters available for classification purposes is limited. Setting this object to 'true(1)' causes statistics to be tracked by default for all metered policies defined after this attribute is set. A value of 'false(2)' means that new metered policies will not track statistics. Note that this attribute specifies the default behavior. Statistics maintenance may be enabled and disabled on a per policy basis via an attribute in the ntnQosTargetStatsTable. If a value for that attribute is not provided, the value of this object determines the behavior.")
ntnQosConfigIfcClassRestrictions = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unrestrictedOnly", 1), ("unrestrictedAndTrusted", 2), ("allowAllIfcClasses", 3))).clone('allowAllIfcClasses')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigIfcClassRestrictions.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigIfcClassRestrictions.setDescription('Specifies which interface class types can be defined by the user. Default filters are installed to support the different interface classes. Limiting the classes that can be used reduces, or eliminates entirely, the default filter resources that must be consumed, making these resources available for administrator use. Modifications to this attribute require a system initialization before they take effect.')
ntnQosConfigDefaultOutOfProfileAction = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 7), PolicyInstanceId()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigDefaultOutOfProfileAction.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigDefaultOutOfProfileAction.setDescription("This attribute identifies the action that is to be initiated for flows that are determined to be out-of-profile and are being metered using the 'committedRestricted' type of meter. Actions must be defined in the qosActionTable prior to being referenced by this attribute. The value of this attribute may not be changed while meters of this type are currently associated with a policy.")
ntnQosConfigPolicyCfgRestrictionMode = MibScalar((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPolicyRestrictions", 1), ("l3PolicyRestrictions", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosConfigPolicyCfgRestrictionMode.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigPolicyCfgRestrictionMode.setDescription("Specifies whether policies referencing IP filter criteria can be defined by the user. The value of this attribute determines if new IP filter-based policies can be installed. If the value of this attribute is 'noPolicyRestrictions(1)', both IP and Layer 2-based policies can be installed. If the value is 'l3PolicyRestrictions(2)', only Layer 2-based policies can be installed. This attribute is only consulted when traffic separation mode is enabled. Modification of this attribute may be restricted based on the interface used (e.g., CLI) for the modification.")
ntnQosInterfaceIdTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4), )
if mibBuilder.loadTexts: ntnQosInterfaceIdTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdTable.setDescription('Contains interface index to interface role combination associations.')
ntnQosInterfaceIdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1), ).setIndexNames((0, "NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdIfIndex"))
if mibBuilder.loadTexts: ntnQosInterfaceIdEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdEntry.setDescription('A conceptual row in the ntnQosInterfaceIdTable. Each row identifies an interface value that corresponds to an entry in the ifTable (MIB-II) and a role combination taglist with which the interface is associated.')
ntnQosInterfaceIdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ntnQosInterfaceIdIfIndex.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdIfIndex.setDescription('The ifIndex value that is associated with this instance of the ntnQosInterfaceIdEntry. The ifIndex value of this attribute must correspond to the ifTable entry with the same ifIndex value.')
ntnQosInterfaceIdRoleCombination = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1, 2), RoleCombination()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceIdRoleCombination.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdRoleCombination.setDescription('The role combination that is associated with the interface with an ifIndex value that is equal to ntnQosInterfaceIdIfIndex.')
ntnQosInterfaceIdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceIdStorageType.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdStorageType.setDescription('The storage type for this conceptual row. Conceptual rows having the value permanent(4) need not allow write-access to any columnar objects in the row. This object may not be modified if the associated ntnQosInterfaceIdStatus object is equal to active(1).')
ntnQosInterfaceIdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceIdStatus.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Row creation using only default values is supported.')
ntnQosInterfaceIdQueueSet = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 4, 1, 1, 4, 1, 5), PolicyInstanceId()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ntnQosInterfaceIdQueueSet.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdQueueSet.setDescription('The queue set associated with this interface. A queue set must be defined in the qosInterfaceQueueTable prior to being referenced by this attribute.')
ntnQosTargetStatsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1), )
if mibBuilder.loadTexts: ntnQosTargetStatsTable.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsTable.setDescription('Contains items that supplement the target group data that is specified in the qosTargetTable.')
ntnQosTargetStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1), )
qosTargetEntry.registerAugmentions(("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsEntry"))
ntnQosTargetStatsEntry.setIndexNames(*qosTargetEntry.getIndexNames())
if mibBuilder.loadTexts: ntnQosTargetStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsEntry.setDescription('A conceptual row in the ntnQosTargetStatsTable. Each row contains statistics related to the associated qosTargetTable entry. Entries will be automatically deleted from this table should the corresponding qosTargetTable entry be destroyed.')
ntnQosTargetStatsPktHits = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 1), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsPktHits.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsPktHits.setDescription('This object tracks the packet hits of this target group specification. Packet hits are defined as packets that are selected for additional processing based on target data specified in the associated qosTargetTable entry.')
ntnQosTargetStatsOverflowPktHits = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsOverflowPktHits.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsOverflowPktHits.setDescription('The number of times the associated ntnQosTargetStatsPktHits counter has overflowed.')
ntnQosTargetStatsHCPktHits = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 3), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsHCPktHits.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsHCPktHits.setDescription('This object tracks the packet hits of this target group specification. Packet hits are defined as packets that are selected for additional processing based on target data specified in the associated qosTargetTable entry.')
ntnQosTargetStatsTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 4), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsTotalOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsTotalOctets.setDescription('This object tracks the total number of octets associated with packet hits of this target group specification.')
ntnQosTargetStatsTotalOverflowOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 5), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsTotalOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsTotalOverflowOctets.setDescription('The number of times the associated ntnQosTargetStatsTotalOctets counter has overflowed.')
ntnQosTargetStatsTotalHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 6), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsTotalHCOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsTotalHCOctets.setDescription('This object tracks the total number of octets associated with packet hits of this target group specification.')
ntnQosTargetStatsInProfOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 7), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsInProfOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsInProfOctets.setDescription('This object tracks the total number of octets associated with packets considered to be in-profile based on the metering specification associated with this target group entry.')
ntnQosTargetStatsInProfOverflowOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 8), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsInProfOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsInProfOverflowOctets.setDescription('The number of times the associated ntnQosTargetStatsInProfOctets counter has overflowed.')
ntnQosTargetStatsInProfHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 9), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsInProfHCOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsInProfHCOctets.setDescription('This object tracks the total number of octets associated with packets considered to be in-profile based on the metering specification associated with this target group entry.')
ntnQosTargetStatsOutProfOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 10), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfOctets.setDescription('This object tracks the total number of octets associated with packets considered to be out-of- profile based on the metering specification associated with this target group entry.')
ntnQosTargetStatsOutProfOverflowOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 11), Counter32()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfOverflowOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfOverflowOctets.setDescription('The number of times the associated ntnQosTargetStatsOutProfOctets counter has overflowed.')
ntnQosTargetStatsOutProfHCOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 12), Counter64()).setUnits('octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfHCOctets.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsOutProfHCOctets.setDescription('This object tracks the total number of octets associated with packets considered to be out-of- profile based on the metering specification associated with this target group entry.')
ntnQosTargetStatsTrackStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 13), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ntnQosTargetStatsTrackStatistics.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsTrackStatistics.setDescription("Policing statistics, such as in-profile and out-of-profile octets, are often an important mechanism for evaluating the effectiveness of installed policies. In order to track these statistics, additional system resources are consumed meaning that the amount of filters available for classification purposes is limited. Setting this object to 'true(1)' causes statistics to be tracked for the metered policy being defined. A value of 'false(2)' means that the metered policy will not track statistics.")
ntnQosTargetStatsShapingQDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 14), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsShapingQDrops.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsShapingQDrops.setDescription('This object counts the number of packets dropped due to insufficient shaping resources. Traffic that is being shaped prior to transmission may need to be buffered temporarily to ensure conformance to the associated shaping specification. Shaping buffer resources are limited. If shaping buffer resources are exhausted, traffic that is to be shaped will be dropped, causing this counter to be incremented once per dropped packet, until resources become available.')
ntnQosTargetStatsOverflowShapingQDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 15), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsOverflowShapingQDrops.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsOverflowShapingQDrops.setDescription('The number of times the associated ntnQosTargetStatsShapingQDrops counter has overflowed.')
ntnQosTargetStatsHCShapingQDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 5, 1, 2, 1, 1, 16), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: ntnQosTargetStatsHCShapingQDrops.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsHCShapingQDrops.setDescription('This object counts the number of packets dropped due to insufficient shaping resources. Traffic that is being shaped prior to transmission may need to be buffered temporarily to ensure conformance to the associated shaping specification. Shaping buffer resources are limited. If shaping buffer resources are exhausted, traffic that is to be shaped will be dropped, causing this counter to be incremented once per dropped packet, until resources become available.')
ntnQosCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 1))
ntnQosGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 2))
ntnQosCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 1, 1)).setObjects(("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigGroup"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosCompliance = ntnQosCompliance.setStatus('current')
if mibBuilder.loadTexts: ntnQosCompliance.setDescription('Describes the requirements for conformance to the Nortel Networks QoS Policy MIB.')
ntnQosConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 2, 1)).setObjects(("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigDynamicMgmt"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigQpaState"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigQpaRetryTimer"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigAllowPacketReordering"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigMaintainPolicingStats"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigIfcClassRestrictions"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigDefaultOutOfProfileAction"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosConfigPolicyCfgRestrictionMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosConfigGroup = ntnQosConfigGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosConfigGroup.setDescription('Objects used to configure QoS Policy Agent operation.')
ntnQosInterfaceIdGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 2, 2)).setObjects(("NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdRoleCombination"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdStorageType"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdStatus"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosInterfaceIdQueueSet"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosInterfaceIdGroup = ntnQosInterfaceIdGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosInterfaceIdGroup.setDescription('Objects used to define interface (ifIndex) to interface role combination mappings.')
ntnQosTargetStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 5, 2, 2, 3)).setObjects(("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsPktHits"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsOverflowPktHits"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsHCPktHits"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsTotalOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsTotalOverflowOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsTotalHCOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsInProfOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsInProfOverflowOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsInProfHCOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsOutProfOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsOutProfOverflowOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsOutProfHCOctets"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsTrackStatistics"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsShapingQDrops"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsOverflowShapingQDrops"), ("NTN-QOS-POLICY-AUX-MIB", "ntnQosTargetStatsHCShapingQDrops"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ntnQosTargetStatsGroup = ntnQosTargetStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ntnQosTargetStatsGroup.setDescription('Objects that supplement the qosTargetTable providing per target statistics.')
mibBuilder.exportSymbols("NTN-QOS-POLICY-AUX-MIB", ntnQosStatistics=ntnQosStatistics, ntnQosTargetStatsHCPktHits=ntnQosTargetStatsHCPktHits, ntnQosTargetStatsTotalOctets=ntnQosTargetStatsTotalOctets, PYSNMP_MODULE_ID=ntnQosPolicyAuxMib, ntnQosCompliance=ntnQosCompliance, ntnQosTargetStatsInProfOverflowOctets=ntnQosTargetStatsInProfOverflowOctets, ntnQosTargetStatsOverflowPktHits=ntnQosTargetStatsOverflowPktHits, ntnQosConfigGroup=ntnQosConfigGroup, ntnQosTargetStatsOutProfHCOctets=ntnQosTargetStatsOutProfHCOctets, ntnQosTargetStatsPktHits=ntnQosTargetStatsPktHits, ntnQosTargetStatsOutProfOctets=ntnQosTargetStatsOutProfOctets, ntnQosConfigMaintainPolicingStats=ntnQosConfigMaintainPolicingStats, ntnQosCompliances=ntnQosCompliances, ntnQosConfigPolicyCfgRestrictionMode=ntnQosConfigPolicyCfgRestrictionMode, ntnQosTargetStatsTable=ntnQosTargetStatsTable, ntnQosTargetStatsInProfOctets=ntnQosTargetStatsInProfOctets, ntnQosTargetStatsShapingQDrops=ntnQosTargetStatsShapingQDrops, ntnQosConfigQpaRetryTimer=ntnQosConfigQpaRetryTimer, ntnQosConfig=ntnQosConfig, ntnQosTargetStatsHCShapingQDrops=ntnQosTargetStatsHCShapingQDrops, ntnQosInterfaceIdRoleCombination=ntnQosInterfaceIdRoleCombination, ntnQosTargetStatsInProfHCOctets=ntnQosTargetStatsInProfHCOctets, ntnQosConfigDynamicMgmt=ntnQosConfigDynamicMgmt, ntnQosInterfaceIdEntry=ntnQosInterfaceIdEntry, ntnQosPolicyAuxConformance=ntnQosPolicyAuxConformance, ntnQosConfigDefaultOutOfProfileAction=ntnQosConfigDefaultOutOfProfileAction, ntnQosTargetStatsTotalHCOctets=ntnQosTargetStatsTotalHCOctets, ntnQosTargetStatsTrackStatistics=ntnQosTargetStatsTrackStatistics, ntnQosInterfaceIdGroup=ntnQosInterfaceIdGroup, ntnQosConfigIfcClassRestrictions=ntnQosConfigIfcClassRestrictions, ntnQosPolicyAuxObjects=ntnQosPolicyAuxObjects, ntnQosConfigQpaState=ntnQosConfigQpaState, ntnQosInterfaceIdStorageType=ntnQosInterfaceIdStorageType, ntnQosTargetStatsEntry=ntnQosTargetStatsEntry, ntnQosTargetStatsOverflowShapingQDrops=ntnQosTargetStatsOverflowShapingQDrops, ntnQosInterfaceIdQueueSet=ntnQosInterfaceIdQueueSet, ntnQosInterfaceIdTable=ntnQosInterfaceIdTable, ntnQosTargetStatsOutProfOverflowOctets=ntnQosTargetStatsOutProfOverflowOctets, ntnQosConfigAllowPacketReordering=ntnQosConfigAllowPacketReordering, ntnQosTargetStatsTotalOverflowOctets=ntnQosTargetStatsTotalOverflowOctets, ntnQosTargetStatsGroup=ntnQosTargetStatsGroup, ntnQosInterfaceIdStatus=ntnQosInterfaceIdStatus, ntnQosPolicyAuxMib=ntnQosPolicyAuxMib, ntnQosInterfaceIdIfIndex=ntnQosInterfaceIdIfIndex, ntnQosGroups=ntnQosGroups)

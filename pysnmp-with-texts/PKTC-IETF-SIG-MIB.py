#
# PySNMP MIB module PKTC-IETF-SIG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PKTC-IETF-SIG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:40:51 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
Dscp, = mibBuilder.importSymbols("DIFFSERV-DSCP-TC", "Dscp")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, InetPortNumber, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Integer32, IpAddress, mib_2, iso, TimeTicks, Counter32, Counter64, Unsigned32, NotificationType, Bits, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "IpAddress", "mib-2", "iso", "TimeTicks", "Counter32", "Counter64", "Unsigned32", "NotificationType", "Bits", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ObjectIdentity")
RowStatus, TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "TruthValue", "DisplayString")
pktcIetfSigMib = ModuleIdentity((1, 3, 6, 1, 2, 1, 169))
pktcIetfSigMib.setRevisions(('2007-12-18 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: pktcIetfSigMib.setRevisionsDescriptions(('Initial version, published as RFC 5098.',))
if mibBuilder.loadTexts: pktcIetfSigMib.setLastUpdated('200712180000Z')
if mibBuilder.loadTexts: pktcIetfSigMib.setOrganization('IETF IPCDN Working Group')
if mibBuilder.loadTexts: pktcIetfSigMib.setContactInfo('Sumanth Channabasappa Cable Television Laboratories, Inc. 858 Coal Creek Circle, Louisville, CO 80027, USA Phone: +1 303-661-3307 Email: Sumanth@cablelabs.com Gordon Beacham Motorola, Inc. 6450 Sequence Drive, Bldg. 1 San Diego, CA 92121, USA Phone: +1 858-404-2334 Email: gordon.beacham@motorola.com Satish Kumar Mudugere Eswaraiah Texas Instruments India (P) Ltd., Golf view, Wind Tunnel Road Murugesh Palya Bangalore 560 017, INDIA Phone: +91 80 5269451 Email: satish.kumar@ti.com IETF IPCDN Working Group General Discussion: ipcdn@ietf.org Subscribe: http://www.ietf.org/mailman/listinfo/ipcdn Archive: ftp://ftp.ietf.org/ietf-mail-archive/ipcdn Co-Chair: Jean-Francois Mule, jf.mule@cablelabs.com Co-Chair: Richard Woundy, Richard_Woundy@cable.comcast.com')
if mibBuilder.loadTexts: pktcIetfSigMib.setDescription('This MIB module supplies the basic management objects for the PacketCable and IPCablecom Signaling protocols. This version of the MIB includes common signaling and Network Call Signaling (NCS)-related signaling objects. Copyright (C) The IETF Trust (2008). This version of this MIB module is part of RFC 5098; see the RFC itself for full legal notices.')
class TenthdBm(TextualConvention, Integer32):
    description = 'This TEXTUAL-CONVENTION represents power levels that are normally expressed in dBm. Units are in tenths of a dBm; for example, -13.5 dBm will be represented as -135.'
    status = 'current'
    displayHint = 'd-1'

class PktcCodecType(TextualConvention, Integer32):
    description = ' This TEXTUAL-CONVENTION defines various types of codecs that MAY be supported. The description for each enumeration is listed below: Enumeration Description other a defined codec not in the enumeration unknown a codec not defined by the PacketCable Codec Specification g729 ITU-T Recommendation G.729 reserved for future use g729E ITU-T Recommendation G.729E pcmu Pulse Code Modulation u-law (PCMU) g726at32 ITU-T Recommendation G.726-32 (32 kbit/s) g728 ITU-T Recommendation G.728 pcma Pulse Code Modulation a-law (PCMA) g726at16 ITU-T Recommendation G.726-16 (16 kbit/s) g726at24 ITU-T Recommendation G.726-24 (24 kbit/s) g726at40 ITU-T Recommendation G.726-40 (40 kbit/s) ilbc IETF Internet low-bit rate codec bv16 Broadcom BroadVoice16 The list of codecs is consistent with the IETF Real-Time Transport Protocol (RTP) Profile registry and the RTP Map Parameters Table in PacketCable Audio/Video Codecs Specification [PKT-SP-CODEC]. The literal codec name for each codec is listed below: Codec Literal Codec Name g729 G729 g729E G729E pcmu PCMU g726at32 G726-32 g728 G728 pcma PCMA g726at16 G726-16 g726at24 G726-24 g726at40 G726-40 ilbc iLBC bv16 BV16 The literal codec name is the second column of the table with codec RTP Map Parameters. The Literal Codec Name Column contains the codec name used in the local connection options (LCO) of the NCS messages create connection (CRCX)/modify connection (MDCX) and is also used to identify the codec in the Call Management System (CMS) Provisioning Specification. The RTP Map Parameter column of the Table contains the string used in the media attribute line (a=) of the session description protocol (SDP) parameters in NCS messages.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("other", 1), ("unknown", 2), ("g729", 3), ("reserved", 4), ("g729E", 5), ("pcmu", 6), ("g726at32", 7), ("g728", 8), ("pcma", 9), ("g726at16", 10), ("g726at24", 11), ("g726at40", 12), ("ilbc", 13), ("bv16", 14))

class PktcRingCadence(TextualConvention, OctetString):
    description = "This object provides an encoding scheme for ring cadences, including repeatability characteristics. All fields in this object MUST be encoded in network-byte order. The first three higher-order octets are reserved. The octets that follow are used to encode a 'bit-string', with each bit corresponding to 50 milliseconds. A bit value of '1' indicates the presence of a ring-tone, and a bit value of '0' indicates the absence of a ring-tone, for that duration (50 ms) (Note: A minimum number of octets required to encode the bit-string MUST be used). The first two of the reserved octets MUST indicate the length of the encoded cadence (in bits) and MUST range between 1 and 264. (Note: The length in bits MUST also be consistent with the number of octets that encode the cadence). The MTA MUST ignore any unused bits in the last octet, but MUST reflect the value as provided on subsequent SNMP GETs. The third of the reserved octets indicates 'repeatability' and MUST be either 0x80 or 0x00 -- the former value indicating 'non-repeatability', and the latter indicating 'repeatability'. The MTA MUST reject attempts to set a value that violates any of the above requirements."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 36)

class PktcSigType(TextualConvention, Integer32):
    description = ' This object lists the various types of signaling that may be supported: other(1) - set when signaling other than NCS is used ncs(2) - Network Call Signaling is a derivation of MGCP (Media Gateway Control Protocol) defined for IPCablecom/PacketCable MTAs.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("other", 1), ("ncs", 2))

class DtmfCode(TextualConvention, Integer32):
    description = "This TEXTUAL-CONVENTION represents the Dual-Tone Multi-Frequency (DTMF) Character used to indicate the start or end of the digit transition sequence used for caller id or Visual Message Waiting Indicator (VMWI). Note: The DTMF code '*' is indicated using 'dtmfcodeStar', and the DTMF code '#' is indicated using ' dtmfcodeHash'."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
    namedValues = NamedValues(("dtmfcode0", 0), ("dtmfcode1", 1), ("dtmfcode2", 2), ("dtmfcode3", 3), ("dtmfcode4", 4), ("dtmfcode5", 5), ("dtmfcode6", 6), ("dtmfcode7", 7), ("dtmfcode8", 8), ("dtmfcode9", 9), ("dtmfcodeStar", 10), ("dtmfcodeHash", 11), ("dtmfcodeA", 12), ("dtmfcodeB", 13), ("dtmfcodeC", 14), ("dtmfcodeD", 15))

class PktcSubscriberSideSigProtocol(TextualConvention, Integer32):
    description = 'This TEXTUAL-CONVENTION represents the Signaling protocol being used for purposes such as caller id or VMWI. A value of fsk(1) indicates Frequency Shift Keying (FSK). A value of dtmf(2) indicates Dual-Tone Multi-Frequency (DTMF).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("fsk", 1), ("dtmf", 2))

pktcSigMibObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1))
pktcSigDevObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1, 1))
pktcSigEndPntConfigObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 1, 2))
pktcSigDevCodecTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 1), )
if mibBuilder.loadTexts: pktcSigDevCodecTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCodecTable.setDescription(' This table describes the MTA-supported codec types. An MTA MUST populate this table with all possible combinations of codecs it supports for simultaneous operation. For example, an MTA with two endpoints may be designed with a particular Digital Signal Processing (DSP) and memory architecture that allows it to support the following fixed combinations of codecs for simultaneous operation: Codec Type Maximum Number of Simultaneous Codecs PCMA 3 PCMA 2 PCMU 1 PCMA 1 PCMU 2 PCMU 3 PCMA 1 G729 1 G729 2 PCMU 1 G729 1 Based on this example, the entries in the codec table would be: pktcSigDev pktcSigDev pktcSigDev CodecComboIndex CodecType CodecMax 1 pcma 3 2 pcma 2 2 pcmu 1 3 pcma 1 3 pcmu 2 4 pcmu 3 5 pcma 1 5 g729 1 6 g729 2 7 pcmu 1 7 g729 1 An operator querying this table is able to determine all possible codec combinations the MTA is capable of simultaneously supporting. This table MUST NOT include non-voice codecs.')
pktcSigDevCodecEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevCodecComboIndex"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevCodecType"))
if mibBuilder.loadTexts: pktcSigDevCodecEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCodecEntry.setDescription('Each entry represents the maximum number of active connections with a particular codec the MTA is capable of supporting. Each row is indexed by a composite key consisting of a number enumerating the particular codec combination and the codec type.')
pktcSigDevCodecComboIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: pktcSigDevCodecComboIndex.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCodecComboIndex.setDescription(' The index value that enumerates a particular codec combination in the pktcSigDevCodecTable.')
pktcSigDevCodecType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 2), PktcCodecType())
if mibBuilder.loadTexts: pktcSigDevCodecType.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCodecType.setDescription(' A codec type supported by this MTA.')
pktcSigDevCodecMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevCodecMax.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCodecMax.setDescription(' The maximum number of simultaneous sessions of a particular codec that the MTA can support.')
pktcSigDevEchoCancellation = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevEchoCancellation.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevEchoCancellation.setDescription(' This object specifies if the device is capable of echo cancellation. The MTA MUST set this MIB object to a value of true(1) if it is capable of echo cancellation, and a value of false(2) if not.')
pktcSigDevSilenceSuppression = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevSilenceSuppression.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevSilenceSuppression.setDescription(' This object specifies if the device is capable of silence suppression (as a result of Voice Activity Detection). The MTA MUST set this MIB object to a value of true(1) if it is capable of silence suppression, and a value of false(2) if not.')
pktcSigDevCidSigProtocol = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 4), PktcSubscriberSideSigProtocol().clone('fsk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidSigProtocol.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevCidSigProtocol.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidSigProtocol.setDescription('This object is used to configure the subscriber-line protocol used for signaling on-hook caller id information. Different countries define different caller id signaling protocols to support caller identification. Setting this object at a value fsk(1) sets the subscriber line protocol to be Frequency Shift Keying (FSK). Setting this object at a value dtmf(2) sets the subscriber line protocol to be Dual-Tone Multi-Frequency (DTMF). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR0Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 5), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR0Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR0Cadence.setDescription(' This object specifies ring cadence 0 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR1Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 6), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR1Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR1Cadence.setDescription(' This object specifies ring cadence 1 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR2Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 7), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR2Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR2Cadence.setDescription(' This object specifies ring cadence 2 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR3Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 8), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR3Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR3Cadence.setDescription(' This object specifies ring cadence 3 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR4Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 9), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR4Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR4Cadence.setDescription(' This object specifies ring cadence 4 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR5Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 10), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR5Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR5Cadence.setDescription(' This object specifies ring cadence 5 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR6Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 11), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR6Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR6Cadence.setDescription(' This object specifies ring cadence 6 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevR7Cadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 12), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevR7Cadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevR7Cadence.setDescription(' This object specifies ring cadence 7 (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevRgCadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 13), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRgCadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRgCadence.setDescription(' This object specifies ring cadence rg (a user-defined field). The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevRsCadence = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 14), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRsCadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRsCadence.setDescription(' This object specifies ring cadence rs (a user-defined field). The MTA MUST reject any attempt to make this object repeatable. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDefCallSigDscp = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 15), Dscp()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDefCallSigDscp.setStatus('current')
if mibBuilder.loadTexts: pktcSigDefCallSigDscp.setDescription(' The default value used in the IP header for setting the Differentiated Services Code Point (DSCP) value for call signaling. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDefMediaStreamDscp = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 16), Dscp()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDefMediaStreamDscp.setStatus('current')
if mibBuilder.loadTexts: pktcSigDefMediaStreamDscp.setDescription(' This object contains the default value used in the IP header for setting the Differentiated Services Code Point (DSCP) value for media stream packets. The MTA MUST NOT update this object with the value supplied by the CMS in the NCS messages (if present). Any currently active connections are not affected by updates to this object. When the value of this object is updated by SNMP, the MTA MUST use the new value as a default starting only from new connections. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigCapabilityTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 17), )
if mibBuilder.loadTexts: pktcSigCapabilityTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityTable.setDescription(' This table describes the signaling types supported by this MTA.')
pktcSigCapabilityEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigCapabilityIndex"))
if mibBuilder.loadTexts: pktcSigCapabilityEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityEntry.setDescription(' Entries in pktcMtaDevSigCapabilityTable - list of supported signaling types, versions, and vendor extensions for this MTA. Each entry in the list provides for one signaling type and version combination. If the device supports multiple versions of the same signaling type, it will require multiple entries.')
pktcSigCapabilityIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)))
if mibBuilder.loadTexts: pktcSigCapabilityIndex.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityIndex.setDescription(' The index value that uniquely identifies an entry in the pktcSigCapabilityTable.')
pktcSigCapabilityType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 2), PktcSigType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityType.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityType.setDescription(' This object identifies the type of signaling used. This value has to be associated with a single signaling version.')
pktcSigCapabilityVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityVersion.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityVersion.setDescription(' Provides the version of the signaling type - reference pktcSigCapabilityType. Examples would be 1.0 or 2.33 etc.')
pktcSigCapabilityVendorExt = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 17, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigCapabilityVendorExt.setStatus('current')
if mibBuilder.loadTexts: pktcSigCapabilityVendorExt.setDescription(' The vendor extension allows vendors to provide a list of additional capabilities. The syntax for this MIB object in ABNF ([RFC5234]) is specified to be zero or more occurrences of vendor extensions, as follows: pktcSigCapabilityVendorExt = *(vendor-extension) vendor-extension = (ext symbol alphanum) DQUOTE ; DQUOTE ext = DQUOTE %x58 DQUOTE symbol = (DQUOTE %x2D DQUOTE)/(DQUOTE %x2D DQUOTE) alphanum = 1*6(ALPHA/DIGIT) ')
pktcSigDefNcsReceiveUdpPort = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 18), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDefNcsReceiveUdpPort.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigDefNcsReceiveUdpPort.setStatus('current')
if mibBuilder.loadTexts: pktcSigDefNcsReceiveUdpPort.setDescription(" This object contains the MTA User Datagram Protocol (UDP) receive port that is being used for NCS call signaling. This object should only be changed by the configuration file. Unless changed via configuration, this MIB object MUST reflect a value of '2427'.")
pktcSigPowerRingFrequency = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("f20Hz", 1), ("f25Hz", 2), ("f33Point33Hz", 3), ("f50Hz", 4), ("f15Hz", 5), ("f16Hz", 6), ("f22Hz", 7), ("f23Hz", 8), ("f45Hz", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigPowerRingFrequency.setReference('ETSI-EN-300-001')
if mibBuilder.loadTexts: pktcSigPowerRingFrequency.setStatus('current')
if mibBuilder.loadTexts: pktcSigPowerRingFrequency.setDescription(' This object must only be provided via the configuration file during the provisioning process. The power ring frequency is the frequency at which the sinusoidal voltage must travel down the twisted pair to make terminal equipment ring. Different countries define different electrical characteristics to make terminal equipment ring. The f20Hz setting corresponds to a power ring frequency of 20 Hertz. The f25Hz setting corresponds to a power ring frequency of 25 Hertz. The f33Point33Hz setting corresponds to a power ring frequency of 33.33 Hertz. The f50Hz setting corresponds to a power ring frequency of 50 Hertz. The f15Hz setting corresponds to a power ring frequency of 15 Hertz. The f16Hz setting corresponds to a power ring frequency of 16 Hertz. The f22Hz setting corresponds to a power ring frequency of 22 Hertz. The f23Hz setting corresponds to a power ring frequency of 23 Hertz. The f45Hz setting corresponds to a power ring frequency of 45 Hertz.')
pktcSigPulseSignalTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 20), )
if mibBuilder.loadTexts: pktcSigPulseSignalTable.setReference('ETSI-TS-101-909-4 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalTable.setDescription(' The Pulse signal table defines the pulse signal operation. There are nine types of international pulse signals, with each signal having a set of provisionable parameters. The values of the MIB objects in this table take effect only if these parameters are not defined via signaling, in which case, the latter determines the values of the parameters. The MIB objects in this table do not persist across MTA reboots.')
pktcSigPulseSignalEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigPulseSignalType"))
if mibBuilder.loadTexts: pktcSigPulseSignalEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalEntry.setDescription(' This object defines the set of parameters associated with each particular value of pktcSigPulseSignalType. Each entry in the pktcSigPulseSignalTable is indexed by the pktcSigPulseSignalType object. The conceptual rows MUST NOT persist across MTA reboots.')
pktcSigPulseSignalType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("initialRing", 1), ("pulseLoopClose", 2), ("pulseLoopOpen", 3), ("enableMeterPulse", 4), ("meterPulseBurst", 5), ("pulseNoBattery", 6), ("pulseNormalPolarity", 7), ("pulseReducedBattery", 8), ("pulseReversePolarity", 9))))
if mibBuilder.loadTexts: pktcSigPulseSignalType.setReference('ETSI-EN-300-324-1 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalType.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalType.setDescription('There are nine types of international pulse signals. These signals are defined as follows: initial ring pulse loop close pulse loop open enable meter pulse meter pulse burst pulse no battery pulse normal polarity pulse reduced battery pulse reverse polarity')
pktcSigPulseSignalFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("twentyfive", 1), ("twelvethousand", 2), ("sixteenthousand", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalFrequency.setReference('ETSI-EN-300-001 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalFrequency.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalFrequency.setDescription(" This object is only applicable to the initialRing, enableMeterPulse, and meterPulseBurst signal types. This object identifies the frequency of the generated signal. The following table defines the default values for this object depending on signal type: pktcSigPulseSignalType Default initialRing 25 enableMeterPulse 16000 meterPulseBurst 16000 The value of twentyfive MUST only be used for the initialRing signal type. The values of twelvethousand and sixteenthousand MUST only be used for enableMeterPulse and meterPulseBurst signal types. An attempt to set this object while the value of pktcSigPulseSignalType is not initialRing, enableMeterPulse, or meterPulseBurst will result in an 'inconsistentValue' error.")
pktcSigPulseSignalDbLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 3), TenthdBm().subtype(subtypeSpec=ValueRangeConstraint(-350, 0)).clone(-135)).setUnits('1/10 of a dBm').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalDbLevel.setReference('ETSI-EN-300-001 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalDbLevel.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalDbLevel.setDescription(" This object is only applicable to the enableMeterPulse and meterPulseBurst signal types. This is the decibel level for each frequency at which tones could be generated at the a and b terminals (TE connection point). An attempt to set this object while the value of pktcSigPulseSignalType is not enableMeterPulse or meterPulseBurst will result in an 'inconsistentValue' error.")
pktcSigPulseSignalDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalDuration.setReference('ETSI-EN-300-324-1 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalDuration.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalDuration.setDescription(" This object specifies the pulse duration for each signal type. In addition, the MTA must accept the values in the incremental steps specific for each signal type. The following table defines the default values and the incremental steps for this object depending on the signal type: pktcSigPulseSignaltype Default (ms) Increment (ms) initialRing 200 50 pulseLoopClose 200 10 pulseLoopOpen 200 10 enableMeterPulse 150 10 meterPulseBurst 150 10 pulseNoBattery 200 10 pulseNormalPolarity 200 10 pulseReducedBattery 200 10 pulseReversePolarity 200 10 An attempt to set this object to a value that does not fall on one of the increment boundaries, or on the wrong increment boundary for the specific signal type, will result in an 'inconsistentValue' error.")
pktcSigPulseSignalPulseInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalPulseInterval.setReference('ETSI-EN-300-324-1 Specification')
if mibBuilder.loadTexts: pktcSigPulseSignalPulseInterval.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalPulseInterval.setDescription(" This object specifies the repeat interval, or the period, for each signal type. In addition, the MTA must accept the values in the incremental steps specific for each signal type. The following table defines the default values and the incremental steps for this object, depending on the signal type: pktcSigPulseSignaltype Default (ms) Increment (ms) initialRing 200 50 pulseLoopClose 1000 10 pulseLoopOpen 1000 10 enableMeterPulse 1000 10 meterPulseBurst 1000 10 pulseNoBattery 1000 10 pulseNormalPolarity 1000 10 pulseReducedBattery 1000 10 pulseReversePolarity 1000 10 An attempt to set this object to a value that does not fall on one of the increment boundaries, or on the wrong increment boundary for the specific signal type, will result in an 'inconsistentValue' error.")
pktcSigPulseSignalRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigPulseSignalRepeatCount.setStatus('current')
if mibBuilder.loadTexts: pktcSigPulseSignalRepeatCount.setDescription(" This object specifies how many times to repeat a pulse. This object is not used by the enableMeterPulse signal type, and in that case, the value is irrelevant. The following table defines the default values and the valid ranges for this object, depending on the signal type: pktcSigPulseSignaltype Default Range initialRing 1 1-5 pulseLoopClose 1 1-50 pulseLoopOpen 1 1-50 enableMeterPulse (any value)(but not used) meterPulseBurst 1 1-50 pulseNoBattery 1 1-50 pulseNormalPolarity 1 1-50 pulseReducedBattery 1 1-50 pulseReversePolarity 1 1-50 An attempt to set this object to a value that does not fall within the range for the specific signal type will result in an 'inconsistentValue' error.")
pktcSigDevCidMode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("duringRingingETS", 1), ("dtAsETS", 2), ("rpAsETS", 3), ("lrAsETS", 4), ("lrETS", 5))).clone('rpAsETS')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidMode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidMode.setDescription(' For on-hook caller id, pktcSigDevCidMode selects the method for representing and signaling caller identification. For the duringRingingETS method, the Frequency Shift Keying (FSK) or the Dual-Tone Multi-Frequency (DTMF) containing the caller identification information is sent between the first and second ring pattern. For the dtAsETS,rpAsETS, lrAsETS and lrETS methods, the FSK or DTMF containing the caller id information is sent before the first ring pattern. For the dtAsETS method, the FSK or DTMF is sent after the Dual Tone Alert Signal. For the rpAsETS method, the FSK or DTMF is sent after a Ring Pulse. For the lrAsETS method, the Line Reversal occurs first, then the Dual Tone Alert Signal, and, finally, the FSK or DTMF is sent. For the lrETS method, the Line Reversal occurs first, then the FSK or DTMF is sent. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevCidAfterRing = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 2000), )).clone(550)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidAfterRing.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevCidAfterRing.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidAfterRing.setDescription(" This object specifies the delay between the end of first ringing pattern and the start of the transmission of the FSK or DTMF containing the caller id information. It is only used when pktcSigDevCidMode is set to a value of 'duringRingingETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS 550 ms dtAsETS any value (not used) rpAsETS any value (not used) lrAsETS any value (not used) lrETS any value (not used) An attempt to set this object while the value of pktcSigDevCidMode is not duringringingETS will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevCidAfterDTAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(45, 500), )).clone(50)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidAfterDTAS.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevCidAfterDTAS.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidAfterDTAS.setDescription(" This object specifies the delay between the end of the Dual Tone Alert Signal (DT-AS) and the start of the transmission of the FSK or DTMF containing the caller id information. This object is only used when pktcSigDevCidMode is set to a value of 'dtAsETS' or 'lrAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS 50 ms rpAsETS any value (not used) lrAsETS 50 ms lrETS any value (not used) An attempt to set this object while the value of pktcSigDevCidMode is not 'dtAsETS' or 'lrAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevCidAfterRPAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 24), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(500, 800), )).clone(650)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidAfterRPAS.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevCidAfterRPAS.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidAfterRPAS.setDescription(" This object specifies the delay between the end of the Ring Pulse Alert Signal (RP-AS) and the start of the transmission of the FSK or DTMF containing the caller id information. This MIB object is only used when pktcSigDevCidMode is set to a value of 'rpAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS any value (not used) rpAsETS 650 ms lrAsETS any value (not used) lrETS any value (not used) An attempt to set this object while the value of pktcSigDevCidMode is not 'rpAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevRingAfterCID = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 25), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 500), )).clone(250)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRingAfterCID.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevRingAfterCID.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRingAfterCID.setDescription(" This object specifies the delay between the end of the complete transmission of the FSK or DTMF containing the caller id information and the start of the first ring pattern. It is only used when pktcSigDevCidMode is set to a value of 'dtAsETS', 'rpAsETS', 'lrAsETS' or 'lrETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS 250 ms rpAsETS 250 ms lrAsETS 250 ms lrETS 250 ms An attempt to set this object while the value of pktcSigDevCidMode is not 'dtAsETS', 'rpAsETS', 'lrAsETS', or 'lrETS' will result in an 'inconsistent value' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevCidDTASAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 26), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(50, 655)).clone(250)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDTASAfterLR.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevCidDTASAfterLR.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidDTASAfterLR.setDescription(" This object specifies the delay between the end of the Line Reversal and the start of the Dual Tone Alert Signal (DT-AS). This object is only used when pktcSigDevCidMode is set to a value of 'lrAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS any value (not used) rpAsETS any value (not used) lrAsETS 250 ms lrETS any value (not used) An attempt to set this object while the value of pktcSigDevCidMode is not lrAsETS will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiMode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("dtAsETS", 1), ("rpAsETS", 2), ("lrAsETS", 3), ("osi", 4), ("lrETS", 5))).clone('rpAsETS')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiMode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiMode.setDescription(' For visual message waiting indicator (VMWI), pktcSigDevVmwiMode selects the alerting signal method. For the dtAsETS, rpAsETS, lrAsETS, osi, and lrETS methods, the FSK containing the VMWI information is sent after an alerting signal. For the dtAsETS method, the FSK, or DTMF is sent after the Dual Tone Alert Signal. For the rpAsETS method, the FSK or DTMF is sent after a Ring Pulse. For the lrAsETS method, the Line Reversal occurs first, then the Dual Tone Alert Signal, and, finally, the FSK or DTMF is sent. For the OSI method, the FSK or DTMF is sent after the Open Switching Interval. For the lrETS method, the Line Reversal occurs first, then the FSK or DTMF is sent. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevVmwiAfterDTAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(45, 500), )).clone(50)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiAfterDTAS.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevVmwiAfterDTAS.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiAfterDTAS.setDescription(" This object specifies the delay between the end of the Dual Tone Alert Signal (DT-AS) and the start of the transmission of the FSK or DTMF containing the VMWI information. This object is only used when pktcSigDevVmwiMode is set to a value of 'dtAsETS' or 'lrAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevVmwiMode), and MUST be followed: Value of pktcSigDevVmwiMode Default value dtAsETS 50 ms rpAsETS any value (not used) lrAsETS 50 ms lrETS any value (not used) An attempt to set this object while the value of pktcSigDevVmwiMode is not 'dtAsETS' or 'lrAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiAfterRPAS = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 29), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(500, 800), )).clone(650)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiAfterRPAS.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevVmwiAfterRPAS.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiAfterRPAS.setDescription(" This object specifies the delay between the end of the Ring Pulse Alert Signal (RP-AS) and the start of the transmission of the FSK or DTMF containing the VMWI information. This object is only used when pktcSigDevVmwiMode is set to a value of 'rpAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevVmwiMode), and MUST be followed: Value of pktcSigDevVmwiMode Default value dtAsETS any value (not used) rpAsETS 650 ms lrAsETS any value (not used) lrETS any value (not used) An attempt to set this object while the value of pktcSigDevVmwiMode is not 'rpAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiDTASAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(50, 655), )).clone(250)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDTASAfterLR.setReference('ETSI-EN-300-659-1 Specification')
if mibBuilder.loadTexts: pktcSigDevVmwiDTASAfterLR.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiDTASAfterLR.setDescription(" This object specifies the delay between the end of the Line Reversal and the start of the Dual Tone Alert Signal (DT-AS) for VMWI information. This object is only used when pktcSigDevVmwiMode is set to a value of 'lrAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevVmwiMode), and MUST be followed: Value of pktcSigDevVmwiMode Default value dtAsETS any value (not used) rpAsETS any value (not used) lrAsETS 250 ms lrETS any value (not used) An attempt to set this object while the value of pktcSigDevVmwiMode is not 'lrAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevRingCadenceTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 31), )
if mibBuilder.loadTexts: pktcSigDevRingCadenceTable.setReference('ETSI-TS-101-909-4 Specification')
if mibBuilder.loadTexts: pktcSigDevRingCadenceTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRingCadenceTable.setDescription('Cadence rings are defined by the telco governing body for each country. The MTA must be able to support various ranges of cadence patterns and cadence periods. The MTA will be able to support country-specific provisioning of the cadence and idle period. Each cadence pattern will be assigned a unique value ranging from 0-127 (inclusive) corresponding to the value of x, where x is the value sent in the cadence ringing (cr) signal cr(x), requested per the appropriate NCS message, and defined in the E package. The MTA will derive the cadence periods from the ring cadence table entry, as provisioned by the customer. The MTA is allowed to provide appropriate default values for each of the ring cadences. This table only needs to be supported when the MTA implements the E package.')
pktcSigDevRingCadenceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevRingCadenceIndex"))
if mibBuilder.loadTexts: pktcSigDevRingCadenceEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRingCadenceEntry.setDescription(' Each entry in this row corresponds to a ring cadence that is being supported by the device. The conceptual rows MUST NOT persist across MTA reboots.')
pktcSigDevRingCadenceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 127)))
if mibBuilder.loadTexts: pktcSigDevRingCadenceIndex.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRingCadenceIndex.setDescription(' A unique value ranging from 0 to 127 that corresponds to the value sent by the LE based on country-specific cadences, one row per cadence cycle. In any given system implementation for a particular country, it is anticipated that a small number of ring cadences will be in use. Thus, this table most likely will not be populated to its full size.')
pktcSigDevRingCadence = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 31, 1, 2), PktcRingCadence()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevRingCadence.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevRingCadence.setDescription('This is the Ring Cadence.')
pktcSigDevToneTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 32), )
if mibBuilder.loadTexts: pktcSigDevToneTable.setReference('PacketCable NCS Specification, ETSI-TS-101-909-4 Specification.')
if mibBuilder.loadTexts: pktcSigDevToneTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneTable.setDescription(' The Tone Table defines the composition of tones and various tone operations. The definition of the tones callWaiting1 through callWaiting4 in this table MUST only contain the audible tone itself; the delay between tones or the value of the tone repeat count are not applicable for the call waiting tones. The delay between tones or the repeat count is controlled by the objects pktcSigEndPntConfigCallWaitingDelay and pktcSigEndPntConfigCallWaitingMaxRep. If the pktcSigDevToneType is set to either of the values callWaiting1, callWaiting2, callWaiting3, or callWaiting4, then the value of the pktcSigDevToneWholeToneRepeatCount object indicates that the particular frequency group is applicable, as a repeatable part of the tone, based on the value of the MIB object pktcSigDevToneWholeToneRepeatCount. The MTA MUST make sure that, after the provisioning cycle, the table is fully populated (i.e., for each possible index, an entry MUST be defined) using reasonable defaults for each row that was not defined by the provisioning information delivered via MTA Configuration. The frequency composition of each tone is defined by the pktcSigDevMultiFreqToneTable. For each tone type defined in pktcSigDevToneTable, the MTA MUST populate at least one entry in the pktcSigDevMultiFreqToneTable. For each particular value of pktcSigDevToneType, the pktcSigDevToneTable table can define non-repeating and repeating groups of the frequencies defined by the pktcSigDevMultiFreqToneTable, such that each group is represented by the set of the consecutive rows (frequency group) in the pktcSigDevMultiFreqToneTable. Objects in this table do not persist across MTA reboots. For tones with multiple frequencies refer to the MIB table pktcSigDevMultiFreqToneTable.')
pktcSigDevToneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneType"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqGroup"))
if mibBuilder.loadTexts: pktcSigDevToneEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneEntry.setDescription(' The different tone types that can be provisioned based on country-specific needs. Each entry contains the tone generation parameters for a specific frequency group of the specific Tone Type. The different parameters can be provisioned via MTA configuration based on country specific needs. An MTA MUST populate all entries of this table for each tone type.')
pktcSigDevToneType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))).clone(namedValues=NamedValues(("busy", 1), ("confirmation", 2), ("dial", 3), ("messageWaiting", 4), ("offHookWarning", 5), ("ringBack", 6), ("reOrder", 7), ("stutterdial", 8), ("callWaiting1", 9), ("callWaiting2", 10), ("callWaiting3", 11), ("callWaiting4", 12), ("alertingSignal", 13), ("specialDial", 14), ("specialInfo", 15), ("release", 16), ("congestion", 17), ("userDefined1", 18), ("userDefined2", 19), ("userDefined3", 20), ("userDefined4", 21))))
if mibBuilder.loadTexts: pktcSigDevToneType.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneType.setDescription('A unique value that will correspond to the different tone types. These tones can be provisioned based on country-specific needs. This object defines the type of tone being accessed. The alertingSignal, specialDial, specialInfo, release, congestion, userDefined1, userDefined2, userDefined3, and userDefined4 tone types are used in the E line package.')
pktcSigDevToneFreqGroup = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: pktcSigDevToneFreqGroup.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqGroup.setDescription('This MIB object represents the Tone Sequence reference of a multi-sequence tone.')
pktcSigDevToneFreqCounter = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqCounter.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqCounter.setDescription('This MIB object represents the number of consecutive multi-frequency tones for the particular tone type in the multi-frequency table (pktcSigDevMultiFreqToneTable). Such a sequence of the consecutive multi-frequency tones forms the tone group for the particular tone type in the pktcSigDevToneTable.')
pktcSigDevToneWholeToneRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneWholeToneRepeatCount.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneWholeToneRepeatCount.setDescription('This is the repeat count, which signifies how many times to repeat the entire on-off cadence sequence. Setting this object may result in a cadence duration longer or shorter than the overall signal duration specified by the time out (TO) object for a particular signal. If the repeat count results in a longer tone duration than the signal duration specified by the TO, the tone duration defined by the TO object for a particular signal always represents the overall signal duration for a tone. In this case, the tone duration repeat count will not be fully exercised, and the desired tone duration will be truncated per the TO setting. If the repeat count results in a shorter tone duration than the signal duration specified by the TO, the tone duration defined by the repeat count takes precedence over the TO and will end the signal event. In this case, the TO represents a time not to be exceeded for the signal. It is recommended to ensure proper telephony signaling so that the TO duration setting should always be longer than the desired repeat count-time duration.')
pktcSigDevToneSteady = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 32, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneSteady.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneSteady.setDescription("This MIB object represents the steady tone status. A value of 'true(1)' indicates that the steady tone is applied, and a value of 'false(2)' indicates otherwise. Devices must play out the on-off cadence sequence for the number of times indicated by the MIB object 'pktcSigDevToneWholeToneRepeatCount' prior to applying the last tone steadily, indefinitely. If the MIB table 'pktcSigDevToneTable' contains multiple rows with this Object set to a value of 'true(1)', the steady tone is applied to the last repeating frequency group of the tone. Setting this MIB object may result in a tone duration that is longer or shorter than the overall signal duration specified by the time out (TO) MIB object for a particular signal. If the repeat count results in a longer tone duration than the signal duration specified by the TO, the tone duration defined by the TO object for a particular signal always represents the overall signal duration for a tone. In this case, the tone duration repeat count will not be fully exercised, and the desired tone duration will be truncated per the TO setting. If the repeat count results in a shorter tone duration than the signal duration specified by the TO, the tone duration defined by the repeat count takes precedence over the TO and will end the signal event. In this case, the TO represents a time not to be exceeded for the signal. It is recommended to ensure proper telephony signaling that The TO duration setting should always be longer than the desired repeat count-time duration, plus the desired maximum steady tone period.")
pktcSigDevMultiFreqToneTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 1, 33), )
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneTable.setReference('PacketCable NCS Specification, ETSI-TS-101-909-4 Specification.')
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneTable.setDescription(' This MIB table defines the characteristics of tones with multiple frequencies. The constraints imposed on the tones by the MIB table pktcSigDevToneTable need to be considered for MIB objects in this table as well. The MTA MUST populate the corresponding row(s) of the pktcSigDevMultiFreqToneTable for each tone defined in the pktcSigDevToneTable. The contents of the table may be provisioned via MTA configuration.')
pktcSigDevMultiFreqToneEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1), ).setIndexNames((0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneType"), (0, "PKTC-IETF-SIG-MIB", "pktcSigDevToneNumber"))
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevMultiFreqToneEntry.setDescription(' The different tone types with multiple frequencies that can be provisioned based on country-specific needs.')
pktcSigDevToneNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)))
if mibBuilder.loadTexts: pktcSigDevToneNumber.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneNumber.setDescription('This MIB object represents the frequency reference of a multi-frequency tone.')
pktcSigDevToneFirstFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFirstFreqValue.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFirstFreqValue.setDescription('This MIB object represents the value of the first frequency of a tone type. A value of zero implies absence of the referenced frequency.')
pktcSigDevToneSecondFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneSecondFreqValue.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneSecondFreqValue.setDescription('This MIB object represents the value of the second frequency of a tone type. A value of zero implies absence of the referenced frequency.')
pktcSigDevToneThirdFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneThirdFreqValue.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneThirdFreqValue.setDescription('This MIB object represents the value of the third frequency of a tone type. A value of zero implies absence of the referenced frequency.')
pktcSigDevToneFourthFreqValue = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFourthFreqValue.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFourthFreqValue.setDescription('This MIB object represents the value of the fourth frequency of a tone type. A value of zero implies absence of the referenced frequency.')
pktcSigDevToneFreqMode = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("firstModulatedBySecond", 1), ("summation", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqMode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqMode.setDescription("This MIB object provides directive on the modulation or summation of the frequencies involved in the tone. It is to be noted that while summation can be done without any constraint on the number of frequencies, the modulation (amplitude) holds good only when there are two frequencies (first and second). Thus: - If the mode is set to a value of 'firstModulatedBySecond(1)', the first frequency MUST be modulated by the second, and the remaining frequencies (third and fourth) ignored. The percentage of amplitude modulation to be applied is defined by the MIB object pktcSigDevToneFreqAmpModePrtg. - If the mode is set to a value of 'summation(2)', all the frequencies MUST be summed without any modulation. ")
pktcSigDevToneFreqAmpModePrtg = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqAmpModePrtg.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqAmpModePrtg.setDescription("This MIB object represents the percentage of amplitude modulation applied to the second frequency when the MIB object pktcSigDevToneFreqMode is set to a value of 'firstModulatedBySecond (1)'. If the MIB object pktcSigDevToneFreqMode is set to value of 'summation (2)', then this MIB object MUST be ignored.")
pktcSigDevToneDbLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 8), TenthdBm().subtype(subtypeSpec=ValueRangeConstraint(-250, -110)).clone(-120)).setUnits('1/10 of a dBm').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneDbLevel.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneDbLevel.setDescription('This MIB object contains the decibel level for each analog signal (tone) that is locally generated (versus in-band supervisory tones) and sourced to the a-b terminals (TE connection point). Each tone in itself may consist of multiple frequencies, as defined by the MIB table pktcSigDevMultiFreqToneTable. This MIB object reflects the desired level at the Telco (POTS) a-b (T/R) terminals, including the effect of any MTA receiver gain (loss). This is required so that locally generated tones are consistent with remotely generated in-band tones at the a-b terminals, consistent with user expectations. This MIB object must be set for each tone. When tones are formed by combining multi-frequencies, the level of each frequency shall be set so as to result in the tone level specified in this object at the a-b (T/R) terminals. The wide range of levels for this Object is required to provide signal-generator levels across the wide range of gains (losses) -- but does not imply the entire range is to be achievable given the range of gains (losses) in the MTA.')
pktcSigDevToneFreqOnDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqOnDuration.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqOnDuration.setDescription('This MIB object represents the duration for which the frequency reference corresponding to the tone type is turned on.')
pktcSigDevToneFreqOffDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqOffDuration.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqOffDuration.setDescription('This MIB object represents the duration for which the frequency reference corresponding to the tone type is turned off.')
pktcSigDevToneFreqRepeatCount = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 1, 33, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigDevToneFreqRepeatCount.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevToneFreqRepeatCount.setDescription('This MIB object indicates the number of times to repeat the cadence cycle represented by the on/off durations (refer to the MIB objects pktcSigDevToneFreqOnDuration and pktcSigDevToneFreqOffDuration). Setting this object may result in a tone duration that is longer or shorter than the overall signal duration specified by the time out (TO) object for the corresponding tone type. If the value of this MIB Object indicates a longer duration than that specified by the TO, the latter overrules the former, and the desired tone duration will be truncated according to the TO. However, if the repeat count results in a shorter tone duration than the signal duration specified by the TO, the tone duration defined by the repeat count takes precedence over the TO and will end the signal event. In this case, the TO represents a time not to be exceeded for the signal. It is recommended, to ensure proper telephony signaling, that the TO duration setting should always be longer than the desired repeat count-time duration. A value of zero means the tone sequence is to be played once but not repeated.')
pktcSigDevCidDelayAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(300, 800)).clone(400)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDelayAfterLR.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidDelayAfterLR.setDescription("This object specifies the delay between the end of the Line Reversal and the start of the FSK or DTMF signal. This MIB object is used only when pktcSigDevCidMode is set to a value of 'lrETS'. This timing has a range of 300 to 800 ms. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS any value (not used) rpAsETS any value (not used) lrAsETS any value (not used) lrETS 400 An attempt to set this object while the value of pktcSigDevCidMode is not set to a value of 'lrETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevCidDtmfStartCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 35), DtmfCode().clone('dtmfcodeA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDtmfStartCode.setReference('ETSI-EN-300-659-1 specification')
if mibBuilder.loadTexts: pktcSigDevCidDtmfStartCode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidDtmfStartCode.setDescription("This object identifies optional start codes used when the MIB object pktcSigDevCidSigProtocol is set to a value of 'dtmf(2)'. Different countries define different caller id signaling codes to support caller identification. When Dual-Tone Multi-Frequency (DTMF) is used, the caller id digits are preceded by a 'start code' digit, followed by the digit transmission sequence <S1>...<Sn> (where Sx represents the digits 0-9), and terminated by the 'end code' digit. For example, <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>. The start code for calling number delivery may be DTMF 'A' or 'D'. The start code for redirecting a number may be DTMF 'D'. The DTMF code 'B' may be sent by the network as a start code for the transfer of information values, through which special events can be indicated to the user. In some countries, the '*' or '#' may be used instead of 'A', 'B', 'C', or 'D'. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevCidDtmfEndCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 36), DtmfCode().clone('dtmfcodeC')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevCidDtmfEndCode.setReference('ETSI-EN-300-659-1 specification')
if mibBuilder.loadTexts: pktcSigDevCidDtmfEndCode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevCidDtmfEndCode.setDescription("This object identifies optional end codes used when the pktcSigDevCidSigProtocol is set to a value of 'dtmf(2)'. Different countries define different caller id signaling protocols to support caller identification. When Dual-Tone Multi-Frequency (DTMF) is used, the caller id digits are preceded by a 'start code' digit, followed by the digit transmission sequence <S1>...<Sn> (where Sx represents the digits 0-9), and terminated by the 'end code' digit. For example, <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>. The DTMF code 'C' may be sent by the network as an end code for the transfer of information values, through which special events can be indicated to the user. In some countries, the '*' or '#' may be used instead of 'A', 'B', 'C', or 'D'. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiSigProtocol = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 37), PktcSubscriberSideSigProtocol().clone('fsk')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiSigProtocol.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiSigProtocol.setDescription('This object identifies the subscriber line protocol used for signaling the information on Visual Message Waiting Indicator (VMWI). Different countries define different VMWI signaling protocols to support VMWI service. Frequency shift keying (FSK) is most commonly used. DTMF is an alternative. The value of this MIB object MUST NOT persist across MTA reboots.')
pktcSigDevVmwiDelayAfterLR = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 38), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(300, 800), )).clone(400)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDelayAfterLR.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiDelayAfterLR.setDescription("This object specifies the delay between the end of the Line Reversal and the start of the FSK or DTMF signal. This object is only used when pktcSigDevVmwiMode is set to a value of 'lrETS'. This timing has a range of 300 to 800 ms. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevVmwiMode), and MUST be followed: Value of pktcSigDevVmwiMode Default value duringringingETS any value (not used) dtAsETS any value (not used) rpAsETS any value (not used) lrAsETS any value (not used) lrETS 400 An attempt to set this object while the value of pktcSigDevVmwiMode is not 'lrETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiDtmfStartCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 39), DtmfCode().clone('dtmfcodeA')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfStartCode.setReference('ETSI-EN-300-659-1 specification')
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfStartCode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfStartCode.setDescription("This object identifies optional start codes used when the pktcSigDevVmwiSigProtocol is set to a value of 'dtmf(2)'. Different countries define different On Hook Data Transmission Protocol signaling codes to support VMWI. When Dual-Tone Multi-Frequency (DTMF) is used, the VMWI digits are preceded by a 'start code' digit, followed by the digit transmission sequence <S1>...<Sn> (where Sx represents the digits 0-9), and terminated by the 'end code' digit. For example, <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>. The start code for redirecting VMWI may be DTMF 'D' The DTMF code 'B' may be sent by the network as a start code for the transfer of information values, through which special events can be indicated to the user. In some countries, the '*' or '#' may be used instead of 'A', 'B', 'C', or 'D'. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevVmwiDtmfEndCode = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 40), DtmfCode().clone('dtmfcodeC')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfEndCode.setReference('ETSI-EN-300-659-1 specification')
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfEndCode.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevVmwiDtmfEndCode.setDescription("This object identifies an optional end code used when the pktcSigDevVmwiSigProtocol is set to a value of 'dtmf(2)'. Different countries define different on-hook Data Transmission Protocol signaling codes to support VMWI. When Dual-Tone Multi-Frequency (DTMF) is used, the VMWI digits are preceded by a 'start code' digit, followed by the digit transmission sequence <S1>...<Sn> (where Sx represents the digits 0-9), and terminated by the 'end code' digit. For example, <A><S1>...<Sn> <D><S1>...<Sn> <B><S1>...<Sn> <C>. The DTMF code 'C' may be sent by the network as an end code for the transfer of information values, through which special events can be indicated to the user. In some countries, the '*' or '#' may be used instead of 'A', 'B', 'C', or 'D'. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigDevrpAsDtsDuration = MibScalar((1, 3, 6, 1, 2, 1, 169, 1, 1, 41), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(200, 500), )).clone(250)).setUnits('Milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: pktcSigDevrpAsDtsDuration.setReference('ETSI-EN-300-659-1 Specification and Belgacom BGC_D_48_9811_30_09_EDOC version 3.3')
if mibBuilder.loadTexts: pktcSigDevrpAsDtsDuration.setStatus('current')
if mibBuilder.loadTexts: pktcSigDevrpAsDtsDuration.setDescription(" This object specifies the duration of the rpASDTS ring pulse prior to the start of the transmission of the FSK or DTMF containing the caller id information. It is only used when pktcSigDevCidMode is set to a value of 'rpAsETS'. The following table defines the default values for this MIB object, depending on the signal type (pktcSigDevCidMode), and MUST be followed: Value of pktcSigDevCidMode Default value duringringingETS any value (not used) dtAsETS any value (not used) rpAsETS 250 lrAsETS any value (not used) lrETS any value (not used) An attempt to set this object while the value of pktcSigDevCidMode is not 'rpAsETS' will result in an 'inconsistentValue' error. The value of this MIB object MUST NOT persist across MTA reboots.")
pktcSigEndPntConfigTable = MibTable((1, 3, 6, 1, 2, 1, 169, 1, 2, 1), )
if mibBuilder.loadTexts: pktcSigEndPntConfigTable.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigTable.setDescription(' This table describes the information pertaining to each endpoint of the MTA. All entries in this table represent the provisioned endpoints provisioned with the information required by the MTA to maintain the NCS protocol communication with the CMS. Each endpoint can be assigned to its own CMS. If the specific endpoint does not have the corresponding CMS information in this table, the endpoint is considered as not provisioned with voice services. Objects in this table do not persist across MTA reboots.')
pktcSigEndPntConfigEntry = MibTableRow((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: pktcSigEndPntConfigEntry.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigEntry.setDescription('Each entry in the pktcSigEndPntConfigTable represents required signaling parameters for the specific endpoint provisioned with voice services. The conceptual rows MUST NOT persist across MTA reboots.')
pktcSigEndPntConfigCallAgentId = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(3, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentId.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentId.setDescription(" This object contains a string indicating the call agent name (e.g., ca@example.com). The call agent name, after the character '@', MUST be a fully qualified domain name (FQDN) and MUST have a corresponding pktcMtaDevCmsFqdn entry in the pktcMtaDevCmsTable. The object pktcMtaDevCmsFqdn is defined in the PacketCable MIBMTA Specification. For each particular endpoint, the MTA MUST use the current value of this object to communicate with the corresponding CMS. The MTA MUST update this object with the value of the 'Notified Entity' parameter of the NCS message. Because of the high importance of this object to the ability of the MTA to maintain reliable NCS communication with the CMS, it is highly recommended not to change this object's value using SNMP during normal operation.")
pktcSigEndPntConfigCallAgentUdpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 2), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1025, 65535)).clone(2727)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentUdpPort.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentUdpPort.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigCallAgentUdpPort.setDescription(" This object contains the current value of the User Datagram Protocol (UDP) receive port on which the call agent will receive NCS from the endpoint. For each particular endpoint, the MTA MUST use the current value of this object to communicate with the corresponding CMS. The MTA MUST update this object with the value of the 'Notified Entity' parameter of the NCS message. If the Notified Entity parameter does not contain a CallAgent port, the MTA MUST update this object with the default value of 2727. Because of the high importance of this object to the ability of the MTA to maintain reliable NCS communication with the CMS, it is highly recommended not to change this object's value using SNMP during normal operation.")
pktcSigEndPntConfigPartialDialTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 3), Unsigned32().clone(16)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigPartialDialTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigPartialDialTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPartialDialTO.setDescription("This object contains the value of the partial dial time out. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigCriticalDialTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 4), Unsigned32().clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCriticalDialTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigCriticalDialTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigCriticalDialTO.setDescription("This object contains the value of the critical dial time out. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigBusyToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 5), Unsigned32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigBusyToneTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigBusyToneTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigBusyToneTO.setDescription(" This object contains the default time out value for busy tone. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigDialToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 6), Unsigned32().clone(16)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigDialToneTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigDialToneTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigDialToneTO.setDescription(" This object contains the default time out value for dial tone. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigMessageWaitingTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 7), Unsigned32().clone(16)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMessageWaitingTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigMessageWaitingTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMessageWaitingTO.setDescription(" This object contains the default time out value for message waiting indicator. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Manager application, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigOffHookWarnToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigOffHookWarnToneTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigOffHookWarnToneTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigOffHookWarnToneTO.setDescription(" This object contains the default time out value for the off-hook warning tone. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Manager application, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigRingingTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 9), Unsigned32().clone(180)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRingingTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigRingingTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigRingingTO.setDescription(" This object contains the default time out value for ringing. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigRingBackTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 10), Unsigned32().clone(180)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRingBackTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigRingBackTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigRingBackTO.setDescription(" This object contains the default time out value for ring back. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigReorderToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 11), Unsigned32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigReorderToneTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigReorderToneTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigReorderToneTO.setDescription(" This object contains the default time out value for reorder tone. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigStutterDialToneTO = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 12), Unsigned32().clone(16)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigStutterDialToneTO.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigStutterDialToneTO.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigStutterDialToneTO.setDescription(" This object contains the default time out value for stutter dial tone. The MTA MUST NOT update this object with the value provided in the NCS message (if present). If the value of the object is modified by the SNMP Management Station, the MTA MUST use the new value as a default only for a new signal requested by the NCS message. The time out (TO) elements are intended to limit the time a tone or frequency is generated. When this MIB object is set to a value of '0', the MTA MUST NOT generate the corresponding frequency or tone, regardless of the definitions pertaining to frequency, tone duration, or cadence.")
pktcSigEndPntConfigTSMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 13), Unsigned32().clone(20)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTSMax.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigTSMax.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigTSMax.setDescription('This MIB object is used as part of an NCS retransmission algorithm. Prior to any retransmission, the MTA must check to make sure that the time elapsed since the sending of the initial datagram does not exceed the value specified by this MIB object. If more than Tsmax time has elapsed, then the retransmissions MUST cease. Refer to the MIB object pktcSigEndPntConfigThist for information on when the endpoint becomes disconnected.')
pktcSigEndPntConfigMax1 = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 14), Unsigned32().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1.setDescription('This object contains the suspicious error threshold for signaling messages. The pktcSigEndPntConfigMax1 object indicates the retransmission threshold at which the MTA MAY actively query the domain name server (DNS) in order to detect the possible change of call agent interfaces.')
pktcSigEndPntConfigMax2 = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 15), Unsigned32().clone(7)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2.setDescription('This object contains the disconnect error threshold for signaling messages. The pktcSigEndPntConfigMax2 object indicates the retransmission threshold at which the MTA SHOULD contact the DNS one more time to see if any other interfaces to the call agent have become available.')
pktcSigEndPntConfigMax1QEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1QEnable.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax1QEnable.setDescription('This object enables/disables the Max1 domain name server (DNS) query operation when the pktcSigEndPntConfigMax1 threshold has been reached. A value of true(1) indicates enabling, and a value of false(2) indicates disabling.')
pktcSigEndPntConfigMax2QEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 17), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2QEnable.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMax2QEnable.setDescription('This object enables/disables the Max2 domain name server (DNS) query operation when the pktcSigEndPntConfigMax2 threshold has been reached. A value of true(1) indicates enabling, and a value of false(2) indicates disabling.')
pktcSigEndPntConfigMWD = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 18), Unsigned32().clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigMWD.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigMWD.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMWD.setDescription('Maximum Waiting Delay (MWD) contains the maximum number of seconds an MTA waits, after powering on, before initiating the restart procedure with the call agent.')
pktcSigEndPntConfigTdinit = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 19), Unsigned32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdinit.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdinit.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdinit.setDescription("This MIB object represents the 'disconnected' initial waiting delay within the context of an MTA's 'disconnected procedure'. The 'disconnected procedure' is initiated when an endpoint becomes 'disconnected' while attempting to communicate with a call agent. The 'disconnected timer' associated with the 'disconnected Procedure' is initialized to a random value, uniformly distributed between zero and the value contained in this MIB object. For more information on the usage of this timer, please refer to the PacketCable NCS Specification.")
pktcSigEndPntConfigTdmin = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 20), Unsigned32().clone(15)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmin.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmin.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmin.setDescription("This MIB object represents the 'disconnected' minimum waiting delay within the context of an MTA's 'disconnected procedure', specifically when local user activity is detected. The 'disconnected procedure' is initiated when an endpoint becomes 'disconnected' while attempting to communicate with a call agent. For more information on the usage of this timer, please refer to the PacketCable NCS Specification.")
pktcSigEndPntConfigTdmax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 21), Unsigned32().clone(600)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmax.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmax.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigTdmax.setDescription(' This object contains the maximum number of seconds the MTA waits, after a disconnect, before initiating the disconnected procedure with the call agent. ')
pktcSigEndPntConfigRtoMax = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 22), Unsigned32().clone(4)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoMax.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoMax.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoMax.setDescription('This object specifies the maximum number of seconds the MTA waits for a response to an NCS message before initiating a retransmission.')
pktcSigEndPntConfigRtoInit = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 23), Unsigned32().clone(200)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoInit.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoInit.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigRtoInit.setDescription(' This object contains the initial number of seconds for the retransmission timer.')
pktcSigEndPntConfigLongDurationKeepAlive = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 24), Unsigned32().clone(60)).setUnits('minutes').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigLongDurationKeepAlive.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigLongDurationKeepAlive.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigLongDurationKeepAlive.setDescription(' Specifies a time out value, in minutes, for sending long duration call notification messages.')
pktcSigEndPntConfigThist = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 25), Unsigned32().clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigThist.setReference('PacketCable NCS Specification')
if mibBuilder.loadTexts: pktcSigEndPntConfigThist.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigThist.setDescription(' Time out period, in seconds, before no response is declared.')
pktcSigEndPntConfigStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigStatus.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigStatus.setDescription(" This object contains the Row Status associated with the pktcSigEndPntConfigTable. There are no restrictions or dependencies amidst the columnar objects before this row can be activated or for modifications of the columnar objects when this object is set to a value of 'active(1).")
pktcSigEndPntConfigCallWaitingMaxRep = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingMaxRep.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingMaxRep.setDescription(' This object contains the default value of the maximum number of repetitions of the Call Waiting tone that the MTA will play from a single CMS request. The MTA MUST NOT update this object with the information provided in the NCS message (if present). If the value of the object is modified by the SNMP Manager application, the MTA MUST use the new value as a default only for a new signal requested by the NCS message.')
pktcSigEndPntConfigCallWaitingDelay = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingDelay.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigCallWaitingDelay.setDescription(' This object contains the delay between repetitions of the Call Waiting tone that the MTA will play from a single CMS request.')
pktcSigEndPntStatusCallIpAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 29), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddressType.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddressType.setDescription(" This object contains the type of Internet address contained in the MIB object 'pktcSigEndPntStatusCallIpAddress'. Since pktcSigEndPntStatusCallIpAddress is expected to contain an IP address, a value of dns(16) is disallowed.")
pktcSigEndPntStatusCallIpAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 30), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddress.setReference('PacketCable NCS Specification; PacketCable Security specification, [PKT-SP-SEC].')
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddress.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntStatusCallIpAddress.setDescription(" This MIB object contains the chosen IP address of the CMS currently being used for the corresponding endpoint. The device determines the IP address by using DNS to resolve the IP address of the CMS from the FQDN stored in the MIB object 'pktcSigEndPntConfigCallAgentId'. The processes are outlined in the PacketCable NCS and Security specifications, and MUST be followed by the MTA. The IP address type contained in this MIB object is indicated by pktcSigEndPntStatusCallIpAddressType.")
pktcSigEndPntStatusError = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("noSecurityAssociation", 2), ("disconnected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntStatusError.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntStatusError.setDescription(' This object contains the error status for this interface. The operational status indicates that all operations necessary to put the line in service have occurred, and the CMS has acknowledged the Restart In Progress (RSIP) message successfully. If pktcMtaDevCmsIpsecCtrl is enabled for the associated call agent, the noSecurityAssociation status indicates that no Security Association (SA) yet exists for this endpoint. If pktcMtaDevCmsIpsecCtrl is disabled for the associated call agent, the noSecurityAssociation status is not applicable and should not be used by the MTA. The disconnected status indicates one of the following two: If pktcMtaDevCmsIpsecCtrl is disabled, then no security association is involved with this endpoint. The NCS signaling software is in process of establishing the NCS signaling link via an RSIP exchange. Otherwise, when pktcMtaDevCmsIpsecCtrl is enabled, security Association has been established, and the NCS signaling software is in process of establishing the NCS signaling link via an RSIP exchange.')
pktcSigEndPntConfigMinHookFlash = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 1550)).clone(300)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigMinHookFlash.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMinHookFlash.setDescription(" This is the minimum time a line needs to be on-hook for a valid hook flash. The value of this object MUST be greater than the value of pktcSigEndPntConfigPulseDialMaxBreakTime. The value of pktcSigEndPntConfigMinHookFlash MUST be less than pktcSigEndPntConfigMaxHookFlash. This object MUST only be set via the MTA configuration during the provisioning process. Furthermore, given the possibility for the 'pulse dial' and 'hook flash' to overlap, the value of this object MUST be greater than the value contained by the MIB Object 'pktcSigEndPntConfigPulseDialMaxMakeTime'.")
pktcSigEndPntConfigMaxHookFlash = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 1550)).clone(800)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigMaxHookFlash.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigMaxHookFlash.setDescription(' This is the maximum time a line needs to be on-hook for a valid hook flash. The value of pktcSigEndPntConfigMaxHookFlash MUST be greater than pktcSigEndPntConfigMinHookFlash. This object MUST only be set via the MTA configuration during the provisioning process.')
pktcSigEndPntConfigPulseDialInterdigitTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 34), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1500)).clone(100)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialInterdigitTime.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialInterdigitTime.setDescription(' This is the pulse dial inter-digit time out. This object MUST only be set via the MTA configuration during the provisioning process.')
pktcSigEndPntConfigPulseDialMinMakeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 35), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(25)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinMakeTime.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinMakeTime.setDescription(' This is the minimum make pulse width for the dial pulse. The value of pktcSigEndPntConfigPulseDialMinMakeTime MUST be less than pktcSigEndPntConfigPulseDialMaxMakeTime. This object MUST only be set via the MTA configuration during the provisioning process.')
pktcSigEndPntConfigPulseDialMaxMakeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(55)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxMakeTime.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxMakeTime.setDescription(" This is the maximum make pulse width for the dial pulse. The value of pktcSigEndPntConfigPulseDialMaxMakeTime MUST be greater than pktcSigEndPntConfigPulseDialMinMakeTime. This object MUST only be provided via the configuration file during the provisioning process. Furthermore, given the possibility for the 'pulse dial' and 'hook flash' to overlap, the value of this object MUST be less than the value contained by the MIB object pktcSigEndPntConfigMinHookFlash.")
pktcSigEndPntConfigPulseDialMinBreakTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 37), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(45)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinBreakTime.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMinBreakTime.setDescription(' This is the minimum break pulse width for the dial pulse. The value of pktcSigEndPntConfigPulseDialMinBreakTime MUST be less than pktcSigEndPntConfigPulseDialMaxBreakTime. This object must only be provided via the configuration file during the provisioning process.')
pktcSigEndPntConfigPulseDialMaxBreakTime = MibTableColumn((1, 3, 6, 1, 2, 1, 169, 1, 2, 1, 1, 38), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(20, 200)).clone(75)).setUnits('Milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxBreakTime.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndPntConfigPulseDialMaxBreakTime.setDescription(' This is the maximum break pulse width for the dial pulse. The value of pktcSigEndPntConfigPulseDialMaxBreakTime MUST be greater than pktcSigEndPntConfigPulseDialMinBreakTime. This object MUST only be provided via the configuration file during the provisioning process.')
pktcSigNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 0))
pktcSigConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2))
pktcSigCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2, 1))
pktcSigGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 169, 2, 2))
pktcSigBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 169, 2, 1, 1)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigDeviceGroup"), ("PKTC-IETF-SIG-MIB", "pktcSigEndpointGroup"), ("PKTC-IETF-SIG-MIB", "pktcInternationalGroup"), ("PKTC-IETF-SIG-MIB", "pktcLLinePackageGroup"), ("PKTC-IETF-SIG-MIB", "pktcELinePackageGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcSigBasicCompliance = pktcSigBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: pktcSigBasicCompliance.setDescription(' The compliance statement for MTAs that implement NCS signaling.')
pktcSigDeviceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 1)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigDevCodecMax"), ("PKTC-IETF-SIG-MIB", "pktcSigDevEchoCancellation"), ("PKTC-IETF-SIG-MIB", "pktcSigDevSilenceSuppression"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDefCallSigDscp"), ("PKTC-IETF-SIG-MIB", "pktcSigDefMediaStreamDscp"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiMode"), ("PKTC-IETF-SIG-MIB", "pktcSigCapabilityType"), ("PKTC-IETF-SIG-MIB", "pktcSigCapabilityVersion"), ("PKTC-IETF-SIG-MIB", "pktcSigCapabilityVendorExt"), ("PKTC-IETF-SIG-MIB", "pktcSigDefNcsReceiveUdpPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcSigDeviceGroup = pktcSigDeviceGroup.setStatus('current')
if mibBuilder.loadTexts: pktcSigDeviceGroup.setDescription('Group of MIB objects containing signaling configuration information that is applicable per-device.')
pktcSigEndpointGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 2)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallAgentId"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallAgentUdpPort"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPartialDialTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCriticalDialTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigBusyToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigDialToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMessageWaitingTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigOffHookWarnToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRingingTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRingBackTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigReorderToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigStutterDialToneTO"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTSMax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax1"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax2"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax1QEnable"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMax2QEnable"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMWD"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdinit"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdmin"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigTdmax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRtoMax"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigRtoInit"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigLongDurationKeepAlive"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigThist"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigStatus"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallWaitingMaxRep"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigCallWaitingDelay"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusCallIpAddressType"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusCallIpAddress"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntStatusError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcSigEndpointGroup = pktcSigEndpointGroup.setStatus('current')
if mibBuilder.loadTexts: pktcSigEndpointGroup.setDescription('Group of MIB objects containing signaling configuration information that is applicable per-endpoint.')
pktcInternationalGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 3)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMinHookFlash"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigMaxHookFlash"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialInterdigitTime"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMinMakeTime"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMaxMakeTime"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMinBreakTime"), ("PKTC-IETF-SIG-MIB", "pktcSigEndPntConfigPulseDialMaxBreakTime"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidSigProtocol"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDelayAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDtmfStartCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDtmfEndCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiSigProtocol"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDelayAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDtmfStartCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDtmfEndCode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevrpAsDtsDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidMode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterRing"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterDTAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidAfterRPAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingAfterCID"), ("PKTC-IETF-SIG-MIB", "pktcSigDevCidDTASAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiMode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiAfterDTAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiAfterRPAS"), ("PKTC-IETF-SIG-MIB", "pktcSigDevVmwiDTASAfterLR"), ("PKTC-IETF-SIG-MIB", "pktcSigPowerRingFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalPulseInterval"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqCounter"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneWholeToneRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneSteady"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFirstFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneSecondFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneThirdFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFourthFreqValue"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqMode"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqAmpModePrtg"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqOnDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqOffDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigDevToneFreqRepeatCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcInternationalGroup = pktcInternationalGroup.setStatus('current')
if mibBuilder.loadTexts: pktcInternationalGroup.setDescription(' Group of objects that extend the behavior of existing objects to support operations in the widest possible set of international marketplaces. Note that many of these objects represent a superset of behaviors described in other objects within this MIB module.')
pktcLLinePackageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 4)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcLLinePackageGroup = pktcLLinePackageGroup.setStatus('current')
if mibBuilder.loadTexts: pktcLLinePackageGroup.setDescription('Group of Objects to support the L line package.')
pktcELinePackageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 169, 2, 2, 5)).setObjects(("PKTC-IETF-SIG-MIB", "pktcSigDevR0Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR1Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR2Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR3Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR4Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR5Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR6Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevR7Cadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRgCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRsCadence"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalFrequency"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDbLevel"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalDuration"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalPulseInterval"), ("PKTC-IETF-SIG-MIB", "pktcSigPulseSignalRepeatCount"), ("PKTC-IETF-SIG-MIB", "pktcSigDevRingCadence"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pktcELinePackageGroup = pktcELinePackageGroup.setStatus('current')
if mibBuilder.loadTexts: pktcELinePackageGroup.setDescription('Group of Objects to support the E line package.')
mibBuilder.exportSymbols("PKTC-IETF-SIG-MIB", pktcSigDevR1Cadence=pktcSigDevR1Cadence, pktcSigEndPntConfigPulseDialMinMakeTime=pktcSigEndPntConfigPulseDialMinMakeTime, pktcSigDevR0Cadence=pktcSigDevR0Cadence, pktcSigEndPntConfigThist=pktcSigEndPntConfigThist, pktcSigCapabilityVersion=pktcSigCapabilityVersion, pktcSigPulseSignalPulseInterval=pktcSigPulseSignalPulseInterval, pktcSigDevRgCadence=pktcSigDevRgCadence, pktcSigPulseSignalFrequency=pktcSigPulseSignalFrequency, pktcSigConformance=pktcSigConformance, pktcSigDevCodecComboIndex=pktcSigDevCodecComboIndex, pktcSigEndPntConfigMax1QEnable=pktcSigEndPntConfigMax1QEnable, pktcSigDefCallSigDscp=pktcSigDefCallSigDscp, pktcSigEndPntConfigTable=pktcSigEndPntConfigTable, pktcSigDevCidDelayAfterLR=pktcSigDevCidDelayAfterLR, pktcSigEndPntConfigPulseDialInterdigitTime=pktcSigEndPntConfigPulseDialInterdigitTime, pktcSigDevVmwiDelayAfterLR=pktcSigDevVmwiDelayAfterLR, pktcSigEndPntStatusCallIpAddress=pktcSigEndPntStatusCallIpAddress, pktcSigEndPntConfigMessageWaitingTO=pktcSigEndPntConfigMessageWaitingTO, pktcSigPulseSignalDbLevel=pktcSigPulseSignalDbLevel, pktcSigDevCidDTASAfterLR=pktcSigDevCidDTASAfterLR, pktcSigDevToneWholeToneRepeatCount=pktcSigDevToneWholeToneRepeatCount, pktcSigDevRingCadenceTable=pktcSigDevRingCadenceTable, pktcSigEndPntConfigMax2QEnable=pktcSigEndPntConfigMax2QEnable, pktcSigDevR7Cadence=pktcSigDevR7Cadence, pktcSigCapabilityType=pktcSigCapabilityType, pktcSigEndPntConfigMWD=pktcSigEndPntConfigMWD, pktcSigPulseSignalEntry=pktcSigPulseSignalEntry, pktcSigCapabilityIndex=pktcSigCapabilityIndex, pktcSigGroups=pktcSigGroups, TenthdBm=TenthdBm, pktcSigCapabilityEntry=pktcSigCapabilityEntry, pktcSigDevCidDtmfStartCode=pktcSigDevCidDtmfStartCode, pktcSigDevVmwiDtmfStartCode=pktcSigDevVmwiDtmfStartCode, pktcSigDefNcsReceiveUdpPort=pktcSigDefNcsReceiveUdpPort, pktcSigEndPntConfigCriticalDialTO=pktcSigEndPntConfigCriticalDialTO, pktcInternationalGroup=pktcInternationalGroup, pktcSigBasicCompliance=pktcSigBasicCompliance, pktcSigDevR2Cadence=pktcSigDevR2Cadence, pktcSigCapabilityVendorExt=pktcSigCapabilityVendorExt, pktcSigEndPntConfigRingingTO=pktcSigEndPntConfigRingingTO, pktcSigEndPntConfigTdmin=pktcSigEndPntConfigTdmin, pktcSigEndPntConfigBusyToneTO=pktcSigEndPntConfigBusyToneTO, pktcSigEndPntStatusError=pktcSigEndPntStatusError, pktcSigEndPntConfigPulseDialMinBreakTime=pktcSigEndPntConfigPulseDialMinBreakTime, pktcSigDevRingAfterCID=pktcSigDevRingAfterCID, pktcSigDevVmwiDtmfEndCode=pktcSigDevVmwiDtmfEndCode, pktcSigDevCidSigProtocol=pktcSigDevCidSigProtocol, pktcSigDevMultiFreqToneEntry=pktcSigDevMultiFreqToneEntry, PktcRingCadence=PktcRingCadence, pktcSigDevCidAfterRing=pktcSigDevCidAfterRing, pktcSigEndPntConfigTSMax=pktcSigEndPntConfigTSMax, pktcSigDevCidMode=pktcSigDevCidMode, pktcSigEndPntConfigDialToneTO=pktcSigEndPntConfigDialToneTO, pktcSigEndPntConfigPulseDialMaxBreakTime=pktcSigEndPntConfigPulseDialMaxBreakTime, pktcSigCompliances=pktcSigCompliances, pktcSigDevToneFreqMode=pktcSigDevToneFreqMode, pktcELinePackageGroup=pktcELinePackageGroup, pktcSigDevToneFirstFreqValue=pktcSigDevToneFirstFreqValue, pktcSigDevToneSteady=pktcSigDevToneSteady, pktcSigDevVmwiAfterRPAS=pktcSigDevVmwiAfterRPAS, pktcSigEndPntConfigOffHookWarnToneTO=pktcSigEndPntConfigOffHookWarnToneTO, PYSNMP_MODULE_ID=pktcIetfSigMib, pktcSigPulseSignalType=pktcSigPulseSignalType, pktcSigDevCodecTable=pktcSigDevCodecTable, pktcSigEndPntConfigTdinit=pktcSigEndPntConfigTdinit, pktcSigEndPntConfigMaxHookFlash=pktcSigEndPntConfigMaxHookFlash, pktcSigDevObjects=pktcSigDevObjects, pktcSigPulseSignalDuration=pktcSigPulseSignalDuration, pktcSigPulseSignalRepeatCount=pktcSigPulseSignalRepeatCount, pktcSigDevToneSecondFreqValue=pktcSigDevToneSecondFreqValue, pktcSigDevCodecEntry=pktcSigDevCodecEntry, pktcSigEndPntStatusCallIpAddressType=pktcSigEndPntStatusCallIpAddressType, pktcIetfSigMib=pktcIetfSigMib, pktcSigEndPntConfigStatus=pktcSigEndPntConfigStatus, pktcSigDevToneFreqOnDuration=pktcSigDevToneFreqOnDuration, pktcSigDevRsCadence=pktcSigDevRsCadence, pktcSigDevMultiFreqToneTable=pktcSigDevMultiFreqToneTable, pktcSigDevToneFreqCounter=pktcSigDevToneFreqCounter, pktcLLinePackageGroup=pktcLLinePackageGroup, pktcSigDevCodecType=pktcSigDevCodecType, pktcSigDevToneFreqRepeatCount=pktcSigDevToneFreqRepeatCount, pktcSigDevCodecMax=pktcSigDevCodecMax, pktcSigDevSilenceSuppression=pktcSigDevSilenceSuppression, pktcSigDevToneTable=pktcSigDevToneTable, pktcSigEndPntConfigStutterDialToneTO=pktcSigEndPntConfigStutterDialToneTO, pktcSigEndPntConfigRtoInit=pktcSigEndPntConfigRtoInit, pktcSigDevVmwiAfterDTAS=pktcSigDevVmwiAfterDTAS, pktcSigDevToneNumber=pktcSigDevToneNumber, pktcSigEndPntConfigEntry=pktcSigEndPntConfigEntry, pktcSigEndPntConfigMinHookFlash=pktcSigEndPntConfigMinHookFlash, pktcSigDeviceGroup=pktcSigDeviceGroup, pktcSigEndPntConfigRingBackTO=pktcSigEndPntConfigRingBackTO, pktcSigDevCidAfterDTAS=pktcSigDevCidAfterDTAS, pktcSigDevRingCadence=pktcSigDevRingCadence, pktcSigPowerRingFrequency=pktcSigPowerRingFrequency, PktcSigType=PktcSigType, pktcSigDevR5Cadence=pktcSigDevR5Cadence, pktcSigCapabilityTable=pktcSigCapabilityTable, pktcSigPulseSignalTable=pktcSigPulseSignalTable, pktcSigDevToneThirdFreqValue=pktcSigDevToneThirdFreqValue, PktcCodecType=PktcCodecType, pktcSigDevToneType=pktcSigDevToneType, pktcSigEndPntConfigLongDurationKeepAlive=pktcSigEndPntConfigLongDurationKeepAlive, pktcSigEndPntConfigMax1=pktcSigEndPntConfigMax1, pktcSigDevCidAfterRPAS=pktcSigDevCidAfterRPAS, pktcSigEndPntConfigMax2=pktcSigEndPntConfigMax2, pktcSigDevToneFreqGroup=pktcSigDevToneFreqGroup, pktcSigDevVmwiSigProtocol=pktcSigDevVmwiSigProtocol, pktcSigDevVmwiMode=pktcSigDevVmwiMode, pktcSigDevrpAsDtsDuration=pktcSigDevrpAsDtsDuration, pktcSigEndPntConfigCallWaitingMaxRep=pktcSigEndPntConfigCallWaitingMaxRep, pktcSigEndPntConfigObjects=pktcSigEndPntConfigObjects, DtmfCode=DtmfCode, pktcSigDevR6Cadence=pktcSigDevR6Cadence, pktcSigDevEchoCancellation=pktcSigDevEchoCancellation, pktcSigDevToneFreqOffDuration=pktcSigDevToneFreqOffDuration, pktcSigDevToneFreqAmpModePrtg=pktcSigDevToneFreqAmpModePrtg, PktcSubscriberSideSigProtocol=PktcSubscriberSideSigProtocol, pktcSigEndPntConfigTdmax=pktcSigEndPntConfigTdmax, pktcSigDevRingCadenceEntry=pktcSigDevRingCadenceEntry, pktcSigDevR3Cadence=pktcSigDevR3Cadence, pktcSigDevToneDbLevel=pktcSigDevToneDbLevel, pktcSigMibObjects=pktcSigMibObjects, pktcSigEndPntConfigReorderToneTO=pktcSigEndPntConfigReorderToneTO, pktcSigDevToneFourthFreqValue=pktcSigDevToneFourthFreqValue, pktcSigDevVmwiDTASAfterLR=pktcSigDevVmwiDTASAfterLR, pktcSigEndPntConfigPulseDialMaxMakeTime=pktcSigEndPntConfigPulseDialMaxMakeTime, pktcSigEndPntConfigRtoMax=pktcSigEndPntConfigRtoMax, pktcSigEndPntConfigPartialDialTO=pktcSigEndPntConfigPartialDialTO, pktcSigDefMediaStreamDscp=pktcSigDefMediaStreamDscp, pktcSigDevToneEntry=pktcSigDevToneEntry, pktcSigDevCidDtmfEndCode=pktcSigDevCidDtmfEndCode, pktcSigEndPntConfigCallAgentId=pktcSigEndPntConfigCallAgentId, pktcSigEndPntConfigCallAgentUdpPort=pktcSigEndPntConfigCallAgentUdpPort, pktcSigDevR4Cadence=pktcSigDevR4Cadence, pktcSigDevRingCadenceIndex=pktcSigDevRingCadenceIndex, pktcSigNotification=pktcSigNotification, pktcSigEndPntConfigCallWaitingDelay=pktcSigEndPntConfigCallWaitingDelay, pktcSigEndpointGroup=pktcSigEndpointGroup)

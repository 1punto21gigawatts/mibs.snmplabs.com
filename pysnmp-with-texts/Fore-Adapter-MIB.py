#
# PySNMP MIB module Fore-Adapter-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Fore-Adapter-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:16:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
systems, SpansAddress, NsapAddr, EntryStatus = mibBuilder.importSymbols("Fore-Common-MIB", "systems", "SpansAddress", "NsapAddr", "EntryStatus")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, Unsigned32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, NotificationType, iso, Bits, ObjectIdentity, MibIdentifier, Integer32, Counter32, TimeTicks, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Unsigned32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "NotificationType", "iso", "Bits", "ObjectIdentity", "MibIdentifier", "Integer32", "Counter32", "TimeTicks", "Gauge32")
DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "RowStatus")
atmAdapter = ModuleIdentity((1, 3, 6, 1, 4, 1, 326, 2, 1))
if mibBuilder.loadTexts: atmAdapter.setLastUpdated('9911050000Z')
if mibBuilder.loadTexts: atmAdapter.setOrganization('FORE')
if mibBuilder.loadTexts: atmAdapter.setContactInfo(' Postal: FORE Systems Inc. 1000 FORE Drive Warrendale, PA 15086-7502 Tel: +1 724 742 6900 Email: nm_mibs@fore.com Web: http://www.fore.com')
if mibBuilder.loadTexts: atmAdapter.setDescription('Fore Atm Adapter MIB')
adapterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 1))
phyLayerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 2))
atmLayerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 3))
aalGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 4))
connGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 5))
sonetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 6))
sonetAdapterConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 6, 1))
sonetAdapterStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 6, 2))
statsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 7))
atmIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8))
atmarpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1))
classicalIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2))
ipFilterGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3))
ipFilterConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1))
ipFilterStatsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2))
adapterTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1), )
if mibBuilder.loadTexts: adapterTable.setStatus('current')
if mibBuilder.loadTexts: adapterTable.setDescription('A table of adapter information.')
adapterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "adapterInterface"))
if mibBuilder.loadTexts: adapterEntry.setStatus('current')
if mibBuilder.loadTexts: adapterEntry.setDescription('A table entry containing adapter information.')
adapterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterInterface.setStatus('current')
if mibBuilder.loadTexts: adapterInterface.setDescription('The ifIndex corresponding to this ATM adapter.')
adapterSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterSerialNumber.setStatus('current')
if mibBuilder.loadTexts: adapterSerialNumber.setDescription('The serial number of the ATM adapter hardware.')
adapterHardwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: adapterHardwareVersion.setDescription('The version of the ATM adapter hardware. The version number is encoded into 6 hex digits. For example, version 1.1 is encoded as 0x010100.')
adapterHardwareSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterHardwareSpeed.setStatus('current')
if mibBuilder.loadTexts: adapterHardwareSpeed.setDescription('The speed of the ATM adapter hardware.')
adapterFirmwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: adapterFirmwareVersion.setDescription('The version of the ATM adapter firmware. The version number is encoded into 6 hex digits. For example, version 1.1 is encoded as 0x010100.')
adapterSoftwareVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterSoftwareVersion.setStatus('current')
if mibBuilder.loadTexts: adapterSoftwareVersion.setDescription('The version of the ATM adapter software. The version number is encoded into 6 hex digits. For example, version 2.2.0 is encoded as 0x020200.')
adapterTransmitBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterTransmitBufferSize.setStatus('current')
if mibBuilder.loadTexts: adapterTransmitBufferSize.setDescription('The size of the transmit buffer, in cells.')
adapterTransmitQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterTransmitQueueLength.setStatus('current')
if mibBuilder.loadTexts: adapterTransmitQueueLength.setDescription('The number of cells in the transmit buffer.')
adapterReceiveBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterReceiveBufferSize.setStatus('current')
if mibBuilder.loadTexts: adapterReceiveBufferSize.setDescription('The size of the receive buffer, in cells.')
adapterReceiveQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterReceiveQueueLength.setStatus('current')
if mibBuilder.loadTexts: adapterReceiveQueueLength.setDescription('The number of cells in the receive buffer.')
adapterOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("enabled", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterOperStatus.setStatus('current')
if mibBuilder.loadTexts: adapterOperStatus.setDescription('The current operational state of the adapter.')
adapterCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("carrier", 1), ("noCarrier", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterCarrier.setStatus('current')
if mibBuilder.loadTexts: adapterCarrier.setDescription('The presence or absence of carrier on the link.')
adapterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 13), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterAddress.setStatus('current')
if mibBuilder.loadTexts: adapterAddress.setDescription('The address of this ATM adapter.')
adapterUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterUptime.setStatus('current')
if mibBuilder.loadTexts: adapterUptime.setDescription('The length of time this ATM adapter has been up, in hundredths of a second.')
adapterPhyLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("phy-4B5B-MMODE-100", 1), ("phy-4B5B-MMODE-140", 2), ("phy-ASX-100", 3), ("phy-OC3-MMODE-ST", 4), ("phy-OC3-MMODE-SC", 5), ("phy-4B5B-SMODE-100", 6), ("phy-4B5B-SMODE-140", 7), ("phy-OC3-SMODE-SHORT", 8), ("phy-OC3-SMODE-LONG", 9), ("phy-UTP5-SONET", 10), ("phy-STP1-SONET", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterPhyLayer.setStatus('current')
if mibBuilder.loadTexts: adapterPhyLayer.setDescription('The physical layer of the adapter.')
adapterType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("type-SBA-100", 1), ("type-GIA-100", 2), ("type-TCA-100", 3), ("type-NXA-100", 4), ("type-ASX-100", 5), ("type-SBA-200", 6), ("type-VMA-200", 7), ("type-ESA-200", 8), ("type-MCA-200", 9), ("type-ASX-200", 10), ("type-HPA-200", 11), ("type-ESA-200PC", 12), ("type-NBA-200", 13), ("type-PCA-200", 14), ("type-GIA-200", 15), ("type-SBA-200e", 16), ("type-ESA-200e", 17), ("type-GIA-200e", 18), ("type-PCA-200e", 19), ("type-LANNET", 20), ("type-VMA-200e", 21), ("type-MCA-200e", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterType.setStatus('current')
if mibBuilder.loadTexts: adapterType.setDescription('The hardware type of the adapter.')
adapterFirmwareVersionText = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterFirmwareVersionText.setStatus('current')
if mibBuilder.loadTexts: adapterFirmwareVersionText.setDescription('The version of the ATM adapter firmware. This object provides text information about the internal software configuration that was used when the firmware was built.')
adapterSoftwareVersionText = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 1, 1, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: adapterSoftwareVersionText.setStatus('current')
if mibBuilder.loadTexts: adapterSoftwareVersionText.setDescription('The version of the ATM adapter software. This object provides text information about the internal software configuration that was used when the ATM adapter software was built.')
phyLayerTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 2, 1), )
if mibBuilder.loadTexts: phyLayerTable.setStatus('current')
if mibBuilder.loadTexts: phyLayerTable.setDescription('A table of adapter physical layer information.')
phyLayerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 2, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "phyLayerInterface"))
if mibBuilder.loadTexts: phyLayerEntry.setStatus('current')
if mibBuilder.loadTexts: phyLayerEntry.setDescription('A table entry containing adapter physical layer information.')
phyLayerInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLayerInterface.setStatus('current')
if mibBuilder.loadTexts: phyLayerInterface.setDescription('This object identifies the ATM adapter.')
phyLayerFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLayerFramingErrors.setStatus('current')
if mibBuilder.loadTexts: phyLayerFramingErrors.setDescription('The number of ATM cells received with incorrect physical layer framing.')
phyLayerHeaderCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: phyLayerHeaderCRCErrors.setStatus('current')
if mibBuilder.loadTexts: phyLayerHeaderCRCErrors.setDescription('The number of ATM cells received with bad header CRCs.')
atmLayerTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1), )
if mibBuilder.loadTexts: atmLayerTable.setStatus('current')
if mibBuilder.loadTexts: atmLayerTable.setDescription('A table of ATM layer information.')
atmLayerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "atmInterface"))
if mibBuilder.loadTexts: atmLayerEntry.setStatus('current')
if mibBuilder.loadTexts: atmLayerEntry.setDescription('A table entry containing ATM layer information.')
atmInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmInterface.setStatus('current')
if mibBuilder.loadTexts: atmInterface.setDescription('This object identifies the ATM interface.')
atmTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmTransmittedCells.setStatus('current')
if mibBuilder.loadTexts: atmTransmittedCells.setDescription('The number of ATM cells transmitted.')
atmReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmReceivedCells.setStatus('current')
if mibBuilder.loadTexts: atmReceivedCells.setDescription('The number of ATM cells received.')
atmOutOfRangeVPIs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOutOfRangeVPIs.setStatus('current')
if mibBuilder.loadTexts: atmOutOfRangeVPIs.setDescription('The number of ATM cells received with VPI values that were out of range.')
atmUnconnectedVPIs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmUnconnectedVPIs.setStatus('current')
if mibBuilder.loadTexts: atmUnconnectedVPIs.setDescription('The number of ATM cells received with VPI values that were in range but did not correspond to active connections.')
atmOutOfRangeVCIs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmOutOfRangeVCIs.setStatus('current')
if mibBuilder.loadTexts: atmOutOfRangeVCIs.setDescription('The number of ATM cells received with VCI values that were out of range.')
atmUnconnectedVCIs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmUnconnectedVCIs.setStatus('current')
if mibBuilder.loadTexts: atmUnconnectedVCIs.setDescription('The number of ATM cells received with VCI values that were in range but did not correspond to active connections.')
aal4Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1), )
if mibBuilder.loadTexts: aal4Table.setStatus('current')
if mibBuilder.loadTexts: aal4Table.setDescription('A table of ATM adaptation layer type 3/4 information.')
aal4Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "aal4Interface"))
if mibBuilder.loadTexts: aal4Entry.setStatus('current')
if mibBuilder.loadTexts: aal4Entry.setDescription('A table entry containing ATM adaptation layer type 3/4 information.')
aal4Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4Interface.setStatus('current')
if mibBuilder.loadTexts: aal4Interface.setDescription('This object identifies the ATM interface.')
aal4TransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4TransmittedCells.setStatus('current')
if mibBuilder.loadTexts: aal4TransmittedCells.setDescription('The number of AAL type 4 cells transmitted.')
aal4ReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4ReceivedCells.setStatus('current')
if mibBuilder.loadTexts: aal4ReceivedCells.setDescription('The number of AAL type 4 cells received.')
aal4TransmittedPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4TransmittedPDUs.setStatus('current')
if mibBuilder.loadTexts: aal4TransmittedPDUs.setDescription('The number of AAL type 4 protocol data units (PDUs) transmitted.')
aal4ReceivedPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4ReceivedPDUs.setStatus('current')
if mibBuilder.loadTexts: aal4ReceivedPDUs.setDescription('The number of AAL type 4 protocol data units (PDUs) received.')
aal4PayloadCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4PayloadCRCErrors.setStatus('current')
if mibBuilder.loadTexts: aal4PayloadCRCErrors.setDescription('The number of ATM cells received with payload CRC errors.')
aal4SARProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4SARProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: aal4SARProtocolErrors.setDescription('The number of ATM cells that the adaptation layer rejected due to SAR layer protocol errors.')
aal4CSProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4CSProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: aal4CSProtocolErrors.setDescription('The number of ATM cells that the adaptation layer rejected due to CS layer protocol errors.')
aal4CellsDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4CellsDiscards.setStatus('current')
if mibBuilder.loadTexts: aal4CellsDiscards.setDescription('The number of ATM cells that the adaptation layer discarded in the course of dropping partially reassembled PDUs.')
aal4PDUsDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal4PDUsDiscards.setStatus('current')
if mibBuilder.loadTexts: aal4PDUsDiscards.setDescription('The number of CS-PDUs that the adaptation layer discarded due to queue overflows.')
aal5Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2), )
if mibBuilder.loadTexts: aal5Table.setStatus('current')
if mibBuilder.loadTexts: aal5Table.setDescription('A table of ATM adaptation layer type 5 information.')
aal5Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "aal5Interface"))
if mibBuilder.loadTexts: aal5Entry.setStatus('current')
if mibBuilder.loadTexts: aal5Entry.setDescription('A table entry containing ATM adaptation layer type 5 information.')
aal5Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5Interface.setStatus('current')
if mibBuilder.loadTexts: aal5Interface.setDescription('This object identifies the ATM interface.')
aal5TransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5TransmittedCells.setStatus('current')
if mibBuilder.loadTexts: aal5TransmittedCells.setDescription('The number of AAL type 5 cells transmitted.')
aal5ReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5ReceivedCells.setStatus('current')
if mibBuilder.loadTexts: aal5ReceivedCells.setDescription('The number of AAL type 5 cells received.')
aal5TransmittedPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5TransmittedPDUs.setStatus('current')
if mibBuilder.loadTexts: aal5TransmittedPDUs.setDescription('The number of AAL type 5 protocol data units (PDUs) transmitted.')
aal5ReceivedPDUs = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5ReceivedPDUs.setStatus('current')
if mibBuilder.loadTexts: aal5ReceivedPDUs.setDescription('The number of AAL type 5 protocol data units received.')
aal5CRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5CRCErrors.setStatus('current')
if mibBuilder.loadTexts: aal5CRCErrors.setDescription('The number of CS-PDUs received with protocol data unit CRC errors.')
aal5CSProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5CSProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: aal5CSProtocolErrors.setDescription('The number of CS-PDUs that the adaptation layer rejected due to CS layer protocol errors.')
aal5CellsDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5CellsDiscards.setStatus('current')
if mibBuilder.loadTexts: aal5CellsDiscards.setDescription('The number of ATM cells that the adaptation layer discarded in the course of dropping partially reassembled PDUs.')
aal5PDUsDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal5PDUsDiscards.setStatus('current')
if mibBuilder.loadTexts: aal5PDUsDiscards.setDescription('The number of CS-PDUs that the adaptation layer discarded.')
aal0Table = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3), )
if mibBuilder.loadTexts: aal0Table.setStatus('current')
if mibBuilder.loadTexts: aal0Table.setDescription('A table of ATM adaptation layer type 0 (user defined adaptation layer) information.')
aal0Entry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "aal0Interface"))
if mibBuilder.loadTexts: aal0Entry.setStatus('current')
if mibBuilder.loadTexts: aal0Entry.setDescription('A table entry containing ATM adaptation layer type 0 (user defined adaptation layer) information.')
aal0Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal0Interface.setStatus('current')
if mibBuilder.loadTexts: aal0Interface.setDescription('This object identifies the ATM interface.')
aal0TransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal0TransmittedCells.setStatus('current')
if mibBuilder.loadTexts: aal0TransmittedCells.setDescription('The number of AAL type 0 cells transmitted.')
aal0ReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal0ReceivedCells.setStatus('current')
if mibBuilder.loadTexts: aal0ReceivedCells.setDescription('The number of AAL type 0 cells received.')
aal0CellsDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aal0CellsDiscards.setStatus('current')
if mibBuilder.loadTexts: aal0CellsDiscards.setDescription('The number of ATM cells that the adaptation layer discarded in the course of dropping partially reassembled PDUs.')
connTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1), )
if mibBuilder.loadTexts: connTable.setStatus('current')
if mibBuilder.loadTexts: connTable.setDescription('A table of information about ATM connections.')
connEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "connInterface"), (0, "Fore-Adapter-MIB", "connDirection"), (0, "Fore-Adapter-MIB", "connVPI"), (0, "Fore-Adapter-MIB", "connVCI"))
if mibBuilder.loadTexts: connEntry.setStatus('current')
if mibBuilder.loadTexts: connEntry.setDescription('A table entry containing information about an ATM connection.')
connInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connInterface.setStatus('current')
if mibBuilder.loadTexts: connInterface.setDescription('This object identifies the ATM interface.')
connDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("incoming", 1), ("outgoing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: connDirection.setStatus('current')
if mibBuilder.loadTexts: connDirection.setDescription('The direction of this connection.')
connVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connVPI.setStatus('current')
if mibBuilder.loadTexts: connVPI.setDescription('The Virtual Path Identifier for this connection.')
connVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connVCI.setStatus('current')
if mibBuilder.loadTexts: connVCI.setDescription('The Virtual Channel Identifier for this connection.')
connLocalSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connLocalSAP.setStatus('current')
if mibBuilder.loadTexts: connLocalSAP.setDescription('The local SAP for this connection.')
connRemoteSAP = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteSAP.setStatus('current')
if mibBuilder.loadTexts: connRemoteSAP.setDescription('The remote SAP for this connection.')
connRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 7), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: connRemoteAddress.setDescription('The ATM address of the remote end of this connection.')
connPeakBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connPeakBandwidth.setStatus('current')
if mibBuilder.loadTexts: connPeakBandwidth.setDescription('The peak bandwidth for this connection, in kilobits per second.')
connMeanBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMeanBandwidth.setStatus('current')
if mibBuilder.loadTexts: connMeanBandwidth.setDescription('The mean bandwidth for this connection, in kilobits per second.')
connMeanBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connMeanBurst.setStatus('current')
if mibBuilder.loadTexts: connMeanBurst.setDescription('The mean burst length for this connection, in kilobits.')
connUptime = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 5, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: connUptime.setStatus('current')
if mibBuilder.loadTexts: connUptime.setDescription('The length of time since this connection was created, in hundredths of a second.')
atmarpFlushTable = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpFlushTable.setStatus('current')
if mibBuilder.loadTexts: atmarpFlushTable.setDescription('A SNMP agent will flush the ATM ARP table when this variable is set to enable(2). After the operation is done, the value of this object is disable(1).')
atmarpTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2), )
if mibBuilder.loadTexts: atmarpTable.setStatus('current')
if mibBuilder.loadTexts: atmarpTable.setDescription('A table for ATM ARP information.')
atmarpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "atmarpIpAddress"))
if mibBuilder.loadTexts: atmarpEntry.setStatus('current')
if mibBuilder.loadTexts: atmarpEntry.setDescription('A table entry containing information about an ATM ARP connection.')
atmarpIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmarpIpAddress.setStatus('current')
if mibBuilder.loadTexts: atmarpIpAddress.setDescription('This object identifies the remote IP address for this ATM ARP entry.')
atmarpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpInterface.setStatus('current')
if mibBuilder.loadTexts: atmarpInterface.setDescription('This object identifies the ATM IP interface (ifIndex) on which this mapping is effective.')
atmarpSpansAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 3), SpansAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmarpSpansAddress.setStatus('current')
if mibBuilder.loadTexts: atmarpSpansAddress.setDescription('This object identifies the remote SPANS address for this ATM ARP entry.')
atmarpNsapAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 4), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpNsapAddress.setStatus('current')
if mibBuilder.loadTexts: atmarpNsapAddress.setDescription('This object identifies the remote NSAP (Network Service Access Point) for this ATM ARP entry. This object can be used for manually editing the ARP table to include IP to NSAP address mapping for devices that do not support Classical IP ARP.')
atmarpVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpVPI.setStatus('current')
if mibBuilder.loadTexts: atmarpVPI.setDescription('The Virtual Path Identifier for this connection.')
atmarpVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpVCI.setStatus('current')
if mibBuilder.loadTexts: atmarpVCI.setDescription('The Virtual Channel Identifier for this connection.')
atmarpConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("foreIpPVC", 1), ("foreIpSVC", 2), ("classicalIpPVC", 3), ("classicalIpSVC", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpConnType.setStatus('current')
if mibBuilder.loadTexts: atmarpConnType.setDescription("The type of the connection by which the IP address can be reached. The value foreIpPVC(1) indicates the connection is a FORE IP Permanent Virtual Circuit, foreIpSVC(2) indicates it's a FORE IP Switched Virtual Circuit. The value classicalIpPVC(3) indicates the connection is a Classical IP Permanent Virtual Circuit, and the value classicalIpSVC(4) indicates the connection is a Classical IP Switched Virtual Circuit.")
atmarpAALType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("aal34", 1), ("aal5", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpAALType.setStatus('current')
if mibBuilder.loadTexts: atmarpAALType.setDescription('The type of the AAL (ATM Adaptation Layer) of this connection.')
atmarpPeakBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpPeakBandwidth.setStatus('current')
if mibBuilder.loadTexts: atmarpPeakBandwidth.setDescription('The peak bandwidth for this connection, in kilobits per second.')
atmarpConnDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("outgoing", 1), ("bidirectional", 2), ("pending", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmarpConnDirection.setStatus('current')
if mibBuilder.loadTexts: atmarpConnDirection.setDescription('The direction of this connection. The value pending(3) is used for an ATM ARP entry that does not have a connection associated with it.')
atmarpEntryValidity = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmarpEntryValidity.setStatus('current')
if mibBuilder.loadTexts: atmarpEntryValidity.setDescription('The validity of this ATM ARP entry. A Classical IP connection entry may be invalid(2) if the remote end of the connection does not answer ARP requests for a while. The entry still exists, but the host is not allowed to send data across it when the entry is in the invalid(2) state.')
atmarpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmarpEntryType.setStatus('current')
if mibBuilder.loadTexts: atmarpEntryType.setDescription('This object indicates the type of mapping. Dynamic entries are learned from Fore IP or Classical IP mechanisms. Static entries are created manually.')
atmarpEntryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 1, 2, 1, 13), EntryStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmarpEntryStatus.setStatus('current')
if mibBuilder.loadTexts: atmarpEntryStatus.setDescription('The status of this ATM ARP entry.')
classicalIpArpTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1), )
if mibBuilder.loadTexts: classicalIpArpTable.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpTable.setDescription('A table for Classical IP ARP information.')
classicalIpArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "classicalIpArpIfIndex"), (0, "Fore-Adapter-MIB", "classicalIpArpServerIndex"))
if mibBuilder.loadTexts: classicalIpArpEntry.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpEntry.setDescription('A table entry containing information about Classical IP ARP configuration.')
classicalIpArpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classicalIpArpIfIndex.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpIfIndex.setDescription('The ifIndex corresponding to the ATM interface on which the following classical IP information is configured.')
classicalIpArpServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classicalIpArpServerIndex.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpServerIndex.setDescription('The index of the ARP server.')
classicalIpArpServer = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classicalIpArpServer.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpServer.setDescription('An SNMP agent will configure this virtual interface as a Classical IP ARP Server when this variable is set to enable(2).')
classicalIpArpServerConfigType = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manualConfig", 1), ("wellKnown", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classicalIpArpServerConfigType.setStatus('current')
if mibBuilder.loadTexts: classicalIpArpServerConfigType.setDescription('This object identifies the way in which the NSAP (Network Service Access Point) address of the ARP server is determined. When the value of this object is wellKnown(2), the NSAP address of the ARP server is taken from the classicalIpWellKNownArpServerAddr object. When the value of this object is set to manualConfig(1), the NSAP address of the ARP server is read from the classicalIpManualConfigArpServerAddr object.')
classicalIpWellKnownArpServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 5), NsapAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: classicalIpWellKnownArpServerAddr.setStatus('current')
if mibBuilder.loadTexts: classicalIpWellKnownArpServerAddr.setDescription('This variable holds the well known NSAP (Network Service Access Point) address of the ARP server for this interface.')
classicalIpManualConfigArpServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 2, 1, 1, 6), NsapAddr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: classicalIpManualConfigArpServerAddr.setStatus('current')
if mibBuilder.loadTexts: classicalIpManualConfigArpServerAddr.setDescription('This variable holds the manually configured NSAP (Network Service Access Point) address of the ARP server for this interface. By default this object is set to all zero.')
class IpHeader(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(64, 64)
    fixedLength = 64

ipFilterTable = MibTable((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 1), )
if mibBuilder.loadTexts: ipFilterTable.setStatus('current')
if mibBuilder.loadTexts: ipFilterTable.setDescription('A table of authorized ip addresses from which the switch can receive IP packets.')
ipFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 1, 1), ).setIndexNames((0, "Fore-Adapter-MIB", "ipFilterIpAddress"), (0, "Fore-Adapter-MIB", "ipFilterMask"))
if mibBuilder.loadTexts: ipFilterEntry.setStatus('current')
if mibBuilder.loadTexts: ipFilterEntry.setDescription('A table entry containing ip filter information.')
ipFilterIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 1, 1, 1), IpAddress())
if mibBuilder.loadTexts: ipFilterIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipFilterIpAddress.setDescription('The authorized IP Address, in the inbound direction.')
ipFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 1, 1, 2), IpAddress())
if mibBuilder.loadTexts: ipFilterMask.setStatus('current')
if mibBuilder.loadTexts: ipFilterMask.setDescription('Indicates the mask to be logical-ANDed with the ipFilterIpAddress to find matching addresses. A mask of 0.0.0.0 is a wild card and matches all addresses. A valid mask is one which has contiguous higher order 1 bits set. That is, mask 255.255.0.128 is not valid while 255.255.0.0 is valid. Example matches: IpAddress Mask means 163.26.54.6 255.255.255.255 Allow address 163.26.54.6 163.54.7.21 255.255.0.0 Allow addresses 163.54.*.*')
ipFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipFilterRowStatus.setDescription('The status of this ipFilter entry.')
ipFilterNoSSR = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFilterNoSSR.setStatus('current')
if mibBuilder.loadTexts: ipFilterNoSSR.setDescription('NoStrictSourceRoute Flag. On implies that IP packets with Strict Source Routed Option set will be dropped. Off implies that these packets will be allowed to pass through, provided they meet with all the other requirements.')
ipFilterNoLSR = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFilterNoLSR.setStatus('current')
if mibBuilder.loadTexts: ipFilterNoLSR.setDescription('NoLooseSourceRoute Flag. On implies that IP packets with Loose Source Routed Option set will be dropped. Off implies that these packets will be allowed to pass through, provided they meet with all the other requirements.')
ipFilterNoInBand = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipFilterNoInBand.setStatus('current')
if mibBuilder.loadTexts: ipFilterNoInBand.setDescription('NoInBand Flag. On implies that ALL IP packets from the ATM network will be dropped. Off implies that these packets will be allowed to pass through, provided they meet with all the other requirements.')
ipFilterStatsIpHeader = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 1), IpHeader()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsIpHeader.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsIpHeader.setDescription('The first 64 bytes of the IP packet which was last dropped.')
ipFilterStatsTimeOccured = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsTimeOccured.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsTimeOccured.setDescription('The sysUptime at which the last IP packet was dropped.')
ipFilterStatsViolations = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsViolations.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsViolations.setDescription('The number of IP packets dropped till the current time.')
ipFilterStatsVPI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsVPI.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsVPI.setDescription('The Virtual Path Identifier corresponding to the connection on which the last IP packet was dropped.')
ipFilterStatsVCI = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsVCI.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsVCI.setDescription('The Virtual Channel Identifier corresponding to the connection on which the last IP packet was dropped.')
ipFilterStatsIfName = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsIfName.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsIfName.setDescription('Name of the interface on which the last dropped IP packet was received')
ipFilterStatsReasonText = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsReasonText.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsReasonText.setDescription('The reason for dropping the last IP packet to be dropped')
ipFilterStatsSrcIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 326, 2, 1, 8, 3, 2, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipFilterStatsSrcIpAddr.setStatus('current')
if mibBuilder.loadTexts: ipFilterStatsSrcIpAddr.setDescription('The IP address contained in the source field of the header of the last IP packet to be dropped')
mibBuilder.exportSymbols("Fore-Adapter-MIB", atmOutOfRangeVCIs=atmOutOfRangeVCIs, classicalIpArpServerIndex=classicalIpArpServerIndex, atmarpEntryStatus=atmarpEntryStatus, IpHeader=IpHeader, ipFilterConfGroup=ipFilterConfGroup, adapterUptime=adapterUptime, adapterEntry=adapterEntry, phyLayerInterface=phyLayerInterface, ipFilterStatsSrcIpAddr=ipFilterStatsSrcIpAddr, aal4CellsDiscards=aal4CellsDiscards, atmarpIpAddress=atmarpIpAddress, atmLayerTable=atmLayerTable, aal4Interface=aal4Interface, aal4CSProtocolErrors=aal4CSProtocolErrors, adapterTransmitBufferSize=adapterTransmitBufferSize, ipFilterStatsVPI=ipFilterStatsVPI, ipFilterMask=ipFilterMask, aal5Entry=aal5Entry, classicalIpArpServerConfigType=classicalIpArpServerConfigType, connEntry=connEntry, aal4SARProtocolErrors=aal4SARProtocolErrors, connInterface=connInterface, aal5ReceivedCells=aal5ReceivedCells, adapterAddress=adapterAddress, connVPI=connVPI, phyLayerHeaderCRCErrors=phyLayerHeaderCRCErrors, atmUnconnectedVPIs=atmUnconnectedVPIs, aal0Table=aal0Table, adapterFirmwareVersionText=adapterFirmwareVersionText, ipFilterStatsTimeOccured=ipFilterStatsTimeOccured, PYSNMP_MODULE_ID=atmAdapter, adapterCarrier=adapterCarrier, ipFilterGroup=ipFilterGroup, adapterInterface=adapterInterface, atmLayerGroup=atmLayerGroup, atmarpPeakBandwidth=atmarpPeakBandwidth, ipFilterNoInBand=ipFilterNoInBand, aal4PDUsDiscards=aal4PDUsDiscards, atmarpInterface=atmarpInterface, connMeanBurst=connMeanBurst, aal4TransmittedPDUs=aal4TransmittedPDUs, adapterHardwareSpeed=adapterHardwareSpeed, atmarpGroup=atmarpGroup, classicalIpGroup=classicalIpGroup, aal4PayloadCRCErrors=aal4PayloadCRCErrors, adapterGroup=adapterGroup, classicalIpArpEntry=classicalIpArpEntry, adapterPhyLayer=adapterPhyLayer, adapterReceiveBufferSize=adapterReceiveBufferSize, atmarpEntry=atmarpEntry, ipFilterIpAddress=ipFilterIpAddress, phyLayerEntry=phyLayerEntry, atmInterface=atmInterface, aal0Interface=aal0Interface, aal5ReceivedPDUs=aal5ReceivedPDUs, adapterReceiveQueueLength=adapterReceiveQueueLength, atmarpSpansAddress=atmarpSpansAddress, connMeanBandwidth=connMeanBandwidth, connUptime=connUptime, adapterSerialNumber=adapterSerialNumber, atmarpEntryValidity=atmarpEntryValidity, classicalIpArpIfIndex=classicalIpArpIfIndex, connRemoteSAP=connRemoteSAP, connVCI=connVCI, ipFilterStatsVCI=ipFilterStatsVCI, ipFilterNoSSR=ipFilterNoSSR, sonetAdapterConfGroup=sonetAdapterConfGroup, statsGroup=statsGroup, adapterSoftwareVersion=adapterSoftwareVersion, ipFilterStatsIpHeader=ipFilterStatsIpHeader, atmTransmittedCells=atmTransmittedCells, ipFilterStatsReasonText=ipFilterStatsReasonText, connPeakBandwidth=connPeakBandwidth, aal4ReceivedCells=aal4ReceivedCells, ipFilterTable=ipFilterTable, atmarpConnDirection=atmarpConnDirection, adapterOperStatus=adapterOperStatus, aal4Entry=aal4Entry, adapterTable=adapterTable, adapterFirmwareVersion=adapterFirmwareVersion, adapterType=adapterType, atmarpVPI=atmarpVPI, connGroup=connGroup, aal0Entry=aal0Entry, atmIpGroup=atmIpGroup, aal0ReceivedCells=aal0ReceivedCells, connRemoteAddress=connRemoteAddress, aal5CellsDiscards=aal5CellsDiscards, classicalIpManualConfigArpServerAddr=classicalIpManualConfigArpServerAddr, aal5Interface=aal5Interface, phyLayerFramingErrors=phyLayerFramingErrors, atmOutOfRangeVPIs=atmOutOfRangeVPIs, ipFilterNoLSR=ipFilterNoLSR, aal5Table=aal5Table, phyLayerGroup=phyLayerGroup, classicalIpArpTable=classicalIpArpTable, atmarpEntryType=atmarpEntryType, aal4Table=aal4Table, aal5CSProtocolErrors=aal5CSProtocolErrors, atmarpFlushTable=atmarpFlushTable, aalGroup=aalGroup, connLocalSAP=connLocalSAP, aal5TransmittedPDUs=aal5TransmittedPDUs, atmAdapter=atmAdapter, atmUnconnectedVCIs=atmUnconnectedVCIs, aal4TransmittedCells=aal4TransmittedCells, aal0CellsDiscards=aal0CellsDiscards, atmLayerEntry=atmLayerEntry, connTable=connTable, atmarpTable=atmarpTable, aal5TransmittedCells=aal5TransmittedCells, aal5CRCErrors=aal5CRCErrors, aal4ReceivedPDUs=aal4ReceivedPDUs, sonetGroup=sonetGroup, aal5PDUsDiscards=aal5PDUsDiscards, atmarpVCI=atmarpVCI, ipFilterRowStatus=ipFilterRowStatus, phyLayerTable=phyLayerTable, ipFilterStatsGroup=ipFilterStatsGroup, aal0TransmittedCells=aal0TransmittedCells, atmarpNsapAddress=atmarpNsapAddress, ipFilterEntry=ipFilterEntry, ipFilterStatsViolations=ipFilterStatsViolations, classicalIpWellKnownArpServerAddr=classicalIpWellKnownArpServerAddr, connDirection=connDirection, classicalIpArpServer=classicalIpArpServer, adapterHardwareVersion=adapterHardwareVersion, atmReceivedCells=atmReceivedCells, ipFilterStatsIfName=ipFilterStatsIfName, adapterSoftwareVersionText=adapterSoftwareVersionText, sonetAdapterStatsGroup=sonetAdapterStatsGroup, atmarpAALType=atmarpAALType, adapterTransmitQueueLength=adapterTransmitQueueLength, atmarpConnType=atmarpConnType)

#
# PySNMP MIB module PCC-PCEDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PCC-PCEDP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:37:47 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
IANAipRouteProtocol, = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
Ipv6Address, = mibBuilder.importSymbols("IPV6-TC", "Ipv6Address")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ObjectIdentity, NotificationType, Integer32, iso, Bits, Counter64, Gauge32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, experimental, Counter32, Unsigned32, MibIdentifier, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "NotificationType", "Integer32", "iso", "Bits", "Counter64", "Gauge32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "experimental", "Counter32", "Unsigned32", "MibIdentifier", "IpAddress", "TimeTicks")
TruthValue, TimeStamp, TextualConvention, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "TimeStamp", "TextualConvention", "DisplayString", "RowStatus")
pccPcedpMIB = ModuleIdentity((1, 3, 6, 1, 3, 10000))
if mibBuilder.loadTexts: pccPcedpMIB.setLastUpdated('200606150000Z')
if mibBuilder.loadTexts: pccPcedpMIB.setOrganization('PCE Working Group')
if mibBuilder.loadTexts: pccPcedpMIB.setContactInfo('WG-email: pce@ietf.org WG-URL: http://www.ietf.org/html.charters/pce-charter.html TODO: This section has to be completed with chairs and authors addresses ')
if mibBuilder.loadTexts: pccPcedpMIB.setDescription('This MIB module defines a collection of objects for managing Path Computation Elements (PCEs) Discovery Protocol inside a Path Computation Client (PCC) application.')
class PccPceDpRoutingDomainID(TextualConvention, OctetString):
    description = 'A PCE-DOMAINS information element or a A PCE-DEST-DOMAINS information element carries the identifier of a routing domain (area,as) which type depends on both the routing protocol and on the version of Internet protocol in use in this routing domain. This TC defines a common SMI type for the different kinds of routing domain identifiers. An PccPceDpRoutingDomainID value is always interpreted within the context of an AddressFamilyNumbers value. Every usage of the PccPceDpRoutingDomainID textual convention is required to specify the AddressFamilyNumbers object which provides the context. The value of an PccPceDpRoutingDomainID object must always be consistent with the value of the associated AddressFamilyNumbers object. Following is the mapping between AddressFamilyNumbers type and PccPceDpRoutingDomainID size: ipV4(1): PccPceDpRoutingDomainID is an InetAddressIPv4 corresponding to the name of an OSPF area; ipV6(2): PccPceDpRoutingDomainID is an InetAddressIPv6 corresponding to the name of an OSPF area; nsap(3): PccPceDpRoutingDomainID type is OCTET STRING (SIZE (0..20)), corresponding to the name of an ISIS area (see RFC 1195); asNumber(18) PccPceDpRoutingDomainID type is OCTET STRING (SIZE (2)) corresponding to the name of an Autonomous System. '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 20)

pccPcedpNotifications = MibIdentifier((1, 3, 6, 1, 3, 10000, 0))
pccPcedpMIBObjects = MibIdentifier((1, 3, 6, 1, 3, 10000, 1))
pccPcedpDiscoveryObjects = MibIdentifier((1, 3, 6, 1, 3, 10000, 1, 1))
pccPcedpDiscAdminStatus = MibScalar((1, 3, 6, 1, 3, 10000, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pccPcedpDiscAdminStatus.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscAdminStatus.setDescription('Setting this object to disabled(2) disables the discovery of PCEs. Once disabled, The discovery must be explicitly enabled to restore discovery of PCEs. Setting this object to enabled(1) enables the discovery of PCEs.')
pccPcedpDiscKnowPCEs = MibScalar((1, 3, 6, 1, 3, 10000, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscKnowPCEs.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscKnowPCEs.setDescription('The number of PCEs the PCC is potentially in relation with. This includes PCE manually declared and active PCEs')
pccPcedpDiscActivePCEs = MibScalar((1, 3, 6, 1, 3, 10000, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscActivePCEs.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscActivePCEs.setDescription('The number of active PCEs. The detection of the activity a a PCE depends on the nature discovery mechanism. PCE discovered using PCED information received: The relation between the PCC and a PCE is active while the PCE discovery protocol maintains a communication between the PCC and this PCE. PCE Manually declared: The relation between the PCC and a PCE is active and the discovery mechanism is implementation specific; ')
pccPcedpDiscPceTable = MibTable((1, 3, 6, 1, 3, 10000, 1, 1, 4), )
if mibBuilder.loadTexts: pccPcedpDiscPceTable.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceTable.setDescription('Information describing the PCEs discovered by the PCC.')
pccPcedpDiscPceEntry = MibTableRow((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1), ).setIndexNames((0, "PCC-PCEDP-MIB", "pccPcedpDiscPceIndex"))
if mibBuilder.loadTexts: pccPcedpDiscPceEntry.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceEntry.setDescription('Information describing the general information of each PCE discovered by the PCC. ')
pccPcedpDiscPceIndex = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pccPcedpDiscPceIndex.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceIndex.setDescription('This object identifies locally the PCE for which this entry contains information.')
pccPcedpDiscMechanism = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 2), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscMechanism.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscMechanism.setDescription('This object identifies the type of discovery mechanism used by PCC to discover the PCE. The acceptable value are : local (2), -- local interface isIs (9), -- Dual IS-IS ospf (13), -- Open Shortest Path First bgp (14), -- Border Gateway Protocol ')
pccPcedpDiscPceIPv4Address = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscPceIPv4Address.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceIPv4Address.setDescription('This object is the IP address to be used to reach the PCE. It corresponds to the PCED PCE-ADDRESS. . A value of 0.0.0.0 indicates the absence of this address.')
pccPcedpDiscPceIPv6Address = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 4), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscPceIPv6Address.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceIPv6Address.setDescription('This object is the IPv6 address to be used to reach the PCE. It corresponds to the PCED PCE-ADDRESS. A value of ::0 indicates the absence of this address.')
pccPcedpDiscPceTime = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscPceTime.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceTime.setDescription('The value of sysUpTime at the time this entry was created. local entry: the value of sysUpTime at the time PCC restarted.')
pccPcedpDiscPceLastUpdated = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 4, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscPceLastUpdated.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscPceLastUpdated.setDescription('The value of sysUpTime at the time this entry was last updated. Static entry: if the entry values keep unchanged since the re- initialization of the PCC then this object contains a zero value.')
pccPcedpDiscActTable = MibTable((1, 3, 6, 1, 3, 10000, 1, 1, 5), )
if mibBuilder.loadTexts: pccPcedpDiscActTable.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscActTable.setDescription('Information describing for each PCE the activity of the discovery mechanism.')
pccPcedpDiscActEntry = MibTableRow((1, 3, 6, 1, 3, 10000, 1, 1, 5, 1), ).setIndexNames((0, "PCC-PCEDP-MIB", "pccPcedpDiscPceIndex"))
if mibBuilder.loadTexts: pccPcedpDiscActEntry.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscActEntry.setDescription('Information describing the activity of the discovery mechanism of a PCE discovered by the PCC.')
pccPcedpDiscActCongestion = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 5, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscActCongestion.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscActCongestion.setDescription('This object indicates whether a PCE experiences a processing congestion state or not. ')
pccPcedpDiscActCongestionDuration = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 1, 5, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpDiscActCongestionDuration.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDiscActCongestionDuration.setDescription("This object specifies, in seconds, the congestion duration. When the value of pccPcedpDiscActCongestion is 'false' then this objet MUST be to '0'")
pccPcedpCapabilityObjects = MibIdentifier((1, 3, 6, 1, 3, 10000, 1, 2))
pccPcedpCapPathScopeTable = MibTable((1, 3, 6, 1, 3, 10000, 1, 2, 1), )
if mibBuilder.loadTexts: pccPcedpCapPathScopeTable.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeTable.setDescription('Information describing the capacity of the PCEs discovered by the PCC.')
pccPcedpCapPathScopeEntry = MibTableRow((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1), ).setIndexNames((0, "PCC-PCEDP-MIB", "pccPcedpDiscPceIndex"))
if mibBuilder.loadTexts: pccPcedpCapPathScopeEntry.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeEntry.setDescription('Information describing the capacity of each PCE discovered by the PCC.')
pccPcedpCapPathScopeIntraArea = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeIntraArea.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeIntraArea.setDescription("Indicates whether the PCE supports the L option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can compute intra-area path.")
pccPcedpCapPathScopeInterArea = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterArea.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterArea.setDescription("Indicates whether the PCE supports the R option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can act as PCE for inter-area TE LSPs computation.")
pccPcedpCapPathScopeDefaultInterArea = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeDefaultInterArea.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeDefaultInterArea.setDescription("Indicates whether the PCE supports the Rd option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can act as a default PCE for inter-area TE LSPs computation.")
pccPcedpCapPathScopeInterAS = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterAS.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterAS.setDescription("Indicates whether the PCE supports the S option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can act as PCE for inter-AS TE LSPs computation.")
pccPcedpCapPathScopeDefaultInterAS = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeDefaultInterAS.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeDefaultInterAS.setDescription("Indicates whether the PCE supports the Sd option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can act as a default PCE for inter-AS TE LSPs computation.")
pccPcedpCapPathScopeInterLayer = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterLayer.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopeInterLayer.setDescription("Indicates whether the PCE supports the Y option of the PATH- SCOPE sub TLV: The value is 'true' if the PCE can compute or take part into the computation of paths across layers.")
pccPcedpCapPathScopePrefIntraArea = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefIntraArea.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefIntraArea.setDescription("Indicates the level of preference of the option of computation 'L' compared to other computation options: A value of 7 reflects the highest preference. When the value of PccPcedpCapCompIntraArea is 'false' then this objet MUST be to '0'.")
pccPcedpCapPathScopePrefInterArea = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterArea.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterArea.setDescription("Indicates the level of preference of the option of computation 'R' compared to other computation options: A value of 7 reflects the highest preference. When the value of PccPcedpCapCompInterArea is 'false' then this objet MUST be to '0'.")
pccPcedpCapPathScopePrefInterAS = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterAS.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterAS.setDescription("Indicates the level of preference of the option of computation 'S' compared to other computation options: A value of 7 reflects the highest preference. When the value of PccPcedpCapCompInterAS is 'false' then this objet MUST be to '0'.")
pccPcedpCapPathScopePrefInterLayer = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterLayer.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapPathScopePrefInterLayer.setDescription("Indicates the level of preference of the option of computation 'Y' compared to other computation options: A value of 7 reflects the highest preference. When the value of PccPcedpCapCompInterLayer is 'false' then this objet MUST be to '0'.")
pccPcedpCapDomainTable = MibTable((1, 3, 6, 1, 3, 10000, 1, 2, 2), )
if mibBuilder.loadTexts: pccPcedpCapDomainTable.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDomainTable.setDescription('Information describing the set of domains where the PCE has topology visibility and can compute paths.')
pccPcedpCapDomainEntry = MibTableRow((1, 3, 6, 1, 3, 10000, 1, 2, 2, 1), ).setIndexNames((0, "PCC-PCEDP-MIB", "pccPcedpDiscPceIndex"), (0, "PCC-PCEDP-MIB", "pccPcedpCapDomainIndex"))
if mibBuilder.loadTexts: pccPcedpCapDomainEntry.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDomainEntry.setDescription('Information describing the domains of each PCE discovered by the PCC.')
pccPcedpCapDomainIndex = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pccPcedpCapDomainIndex.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDomainIndex.setDescription('This object identifies locally a domain for which the PCE identified by pccPcedpDiscPceIndex has topology visibility and can compute paths.')
pccPcedpCapDomainIDType = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 2, 1, 2), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapDomainIDType.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDomainIDType.setDescription('This object identifies the type of the domainID of a PCE- DOMAIN SUB TLV. Acceptable types are : ipV4(1) and ipV6(2) for an OSPF area ID; nsap(3) for and ISIS area ID; asNumber(18) for an BGP AS number')
pccPcedpCapDomainID = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 2, 1, 3), PccPceDpRoutingDomainID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapDomainID.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDomainID.setDescription('The ID (area,AS) of the routing domain for which this entry contains information.')
pccPcedpCapDestDomainTable = MibTable((1, 3, 6, 1, 3, 10000, 1, 2, 3), )
if mibBuilder.loadTexts: pccPcedpCapDestDomainTable.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDestDomainTable.setDescription('Information describing the set of destination domains toward which a PCE can compute path.')
pccPcedpCapDestDomainEntry = MibTableRow((1, 3, 6, 1, 3, 10000, 1, 2, 3, 1), ).setIndexNames((0, "PCC-PCEDP-MIB", "pccPcedpDiscPceIndex"), (0, "PCC-PCEDP-MIB", "pccPcedpCapDestDomainIndex"))
if mibBuilder.loadTexts: pccPcedpCapDestDomainEntry.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDestDomainEntry.setDescription('Information describing the destination domains of each PCE.')
pccPcedpCapDestDomainIndex = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: pccPcedpCapDestDomainIndex.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDestDomainIndex.setDescription('This object identifies locally a destination domain toward which a PCE identified by pccPcedpDiscPceIndex can compute path.')
pccPcedpCapDestDomainIDType = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 3, 1, 2), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapDestDomainIDType.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDestDomainIDType.setDescription('This object identifies the type of the routing domain. Acceptable types are : ipV4(1) and ipV6(2) for an OSPF area ID; nsap(3) for and ISIS area ID; asNumber(18) for an BGP AS number')
pccPcedpCapDestDomainID = MibTableColumn((1, 3, 6, 1, 3, 10000, 1, 2, 3, 1, 3), PccPceDpRoutingDomainID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pccPcedpCapDestDomainID.setStatus('current')
if mibBuilder.loadTexts: pccPcedpCapDestDomainID.setDescription('The ID (area,AS) of the routing domain for which this entry contains information.')
pccPcedpPceActivityGroup = MibIdentifier((1, 3, 6, 1, 3, 10000, 1, 3))
pccPcedpConformance = MibIdentifier((1, 3, 6, 1, 3, 10000, 2))
pccPcedpGroups = MibIdentifier((1, 3, 6, 1, 3, 10000, 2, 1))
pccPcedpCompliances = MibIdentifier((1, 3, 6, 1, 3, 10000, 2, 2))
pccPcedpGeneralPceInformation = ModuleCompliance((1, 3, 6, 1, 3, 10000, 2, 2, 1)).setObjects()

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pccPcedpGeneralPceInformation = pccPcedpGeneralPceInformation.setStatus('current')
if mibBuilder.loadTexts: pccPcedpGeneralPceInformation.setDescription('The compliance statement for SNMP entities that implement only general information monitoring as proposed in the 2nd S. of the section 6.1 of [I-D.ietf-pce-discovery-reqs].')
pccPcedpDetailledPceInformation = ModuleCompliance((1, 3, 6, 1, 3, 10000, 2, 2, 2)).setObjects()

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    pccPcedpDetailledPceInformation = pccPcedpDetailledPceInformation.setStatus('current')
if mibBuilder.loadTexts: pccPcedpDetailledPceInformation.setDescription('The compliance statement for SNMP entities that implement detailled monitoring as proposed in the 3rd S. of the section 6.1 of [I-D.ietf-pce-discovery-reqs].')
mibBuilder.exportSymbols("PCC-PCEDP-MIB", pccPcedpDiscMechanism=pccPcedpDiscMechanism, pccPcedpGroups=pccPcedpGroups, pccPcedpDiscPceTime=pccPcedpDiscPceTime, pccPcedpCapPathScopePrefInterLayer=pccPcedpCapPathScopePrefInterLayer, pccPcedpMIB=pccPcedpMIB, pccPcedpDiscPceIPv4Address=pccPcedpDiscPceIPv4Address, pccPcedpCompliances=pccPcedpCompliances, pccPcedpDiscActCongestion=pccPcedpDiscActCongestion, pccPcedpDiscActEntry=pccPcedpDiscActEntry, pccPcedpDiscAdminStatus=pccPcedpDiscAdminStatus, pccPcedpDiscPceIPv6Address=pccPcedpDiscPceIPv6Address, pccPcedpDiscoveryObjects=pccPcedpDiscoveryObjects, pccPcedpCapPathScopeEntry=pccPcedpCapPathScopeEntry, pccPcedpDiscActTable=pccPcedpDiscActTable, pccPcedpCapabilityObjects=pccPcedpCapabilityObjects, pccPcedpCapDomainTable=pccPcedpCapDomainTable, pccPcedpDiscPceEntry=pccPcedpDiscPceEntry, pccPcedpDiscPceIndex=pccPcedpDiscPceIndex, pccPcedpDiscPceTable=pccPcedpDiscPceTable, pccPcedpMIBObjects=pccPcedpMIBObjects, pccPcedpConformance=pccPcedpConformance, pccPcedpCapPathScopePrefInterArea=pccPcedpCapPathScopePrefInterArea, pccPcedpCapPathScopeInterAS=pccPcedpCapPathScopeInterAS, pccPcedpDiscPceLastUpdated=pccPcedpDiscPceLastUpdated, pccPcedpCapPathScopePrefIntraArea=pccPcedpCapPathScopePrefIntraArea, PYSNMP_MODULE_ID=pccPcedpMIB, pccPcedpNotifications=pccPcedpNotifications, pccPcedpCapDestDomainEntry=pccPcedpCapDestDomainEntry, PccPceDpRoutingDomainID=PccPceDpRoutingDomainID, pccPcedpDiscActCongestionDuration=pccPcedpDiscActCongestionDuration, pccPcedpCapPathScopeDefaultInterAS=pccPcedpCapPathScopeDefaultInterAS, pccPcedpCapPathScopeDefaultInterArea=pccPcedpCapPathScopeDefaultInterArea, pccPcedpCapDestDomainID=pccPcedpCapDestDomainID, pccPcedpCapDestDomainIDType=pccPcedpCapDestDomainIDType, pccPcedpCapDomainEntry=pccPcedpCapDomainEntry, pccPcedpDiscActivePCEs=pccPcedpDiscActivePCEs, pccPcedpDiscKnowPCEs=pccPcedpDiscKnowPCEs, pccPcedpCapPathScopeIntraArea=pccPcedpCapPathScopeIntraArea, pccPcedpGeneralPceInformation=pccPcedpGeneralPceInformation, pccPcedpCapDomainIDType=pccPcedpCapDomainIDType, pccPcedpDetailledPceInformation=pccPcedpDetailledPceInformation, pccPcedpCapPathScopePrefInterAS=pccPcedpCapPathScopePrefInterAS, pccPcedpCapDomainIndex=pccPcedpCapDomainIndex, pccPcedpCapDestDomainIndex=pccPcedpCapDestDomainIndex, pccPcedpCapPathScopeInterArea=pccPcedpCapPathScopeInterArea, pccPcedpCapDestDomainTable=pccPcedpCapDestDomainTable, pccPcedpPceActivityGroup=pccPcedpPceActivityGroup, pccPcedpCapPathScopeInterLayer=pccPcedpCapPathScopeInterLayer, pccPcedpCapPathScopeTable=pccPcedpCapPathScopeTable, pccPcedpCapDomainID=pccPcedpCapDomainID)

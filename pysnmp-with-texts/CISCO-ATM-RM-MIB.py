#
# PySNMP MIB module CISCO-ATM-RM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ATM-RM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:50:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
IpAddress, Counter32, iso, ObjectIdentity, Bits, Integer32, Unsigned32, MibIdentifier, Gauge32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter32", "iso", "ObjectIdentity", "Bits", "Integer32", "Unsigned32", "MibIdentifier", "Gauge32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "NotificationType")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
ciscoAtmRmMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 10))
ciscoAtmRmMIB.setRevisions(('2002-06-03 00:00', '2001-01-29 00:00', '1999-12-22 00:00', '1999-07-27 00:00', '1999-04-30 00:00', '1999-04-14 00:00', '1999-03-11 00:00', '1998-11-24 00:00', '1998-11-03 00:00', '1998-07-26 00:00', '1997-12-03 00:00', '1997-05-26 00:00', '1996-11-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoAtmRmMIB.setRevisionsDescriptions(('Added objects to support Per Class Overbooking for ATM interfaces.', 'Added a table that contains objects to manage ATM Traffic Shaper configuration and state information for ATM interfaces.', 'Fix the errors in the definition of cgrPerVcqAtmRmGroup.', 'Added object to support overbooking of equivalent bandwidth of an ATM interface.', ' Added objects for the IMA interface support.', 'Added objects to instruct Connection Admission Control to include framing overhead in the calculation of maximum cell rate of an ATM interface.', 'Clarified the description for some of the objects that they are applicable to logical port ATM interfaces too and made appropriate changes to the Compliance section.', 'Added a table to manage global resources on the Catalyst8540MSR platform. This was necessary because the Catalyst8540MSR, has 8 switching modules internally, with each switching module having its own independent cell memory. Each switching module performs per-VC queueing for a specific (fixed in hardware) group of ports, independent of any other switching module. The Lightstream 1010 had only one global cell memory for the entire device. ', 'Specify a range limiting Link Distance object.', 'Added an object to enable Hierarchical Scheduling.', 'Added object to configure Service Category support on an interface.', 'Added objects for management of new features made possible on the LS1010 by the Feature Card Plus. This includes support for per-VC queueing hardware structures, enhanced UPC, non-zero MCR for ABR, and UBR+.', 'Added objects for management of Cell Loss Ratio for CLP0+1 cell-streams. Added table for default tolerance.',))
if mibBuilder.loadTexts: ciscoAtmRmMIB.setLastUpdated('200206030000Z')
if mibBuilder.loadTexts: ciscoAtmRmMIB.setOrganization('Cisco System Inc.')
if mibBuilder.loadTexts: ciscoAtmRmMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-atm@cisco.com')
if mibBuilder.loadTexts: ciscoAtmRmMIB.setDescription('The MIB module which complements standard ATM MIBs for Cisco devices, for Resource Management.')
ciscoAtmRmMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1))
class ForceValue(TextualConvention, Integer32):
    description = 'This data type is used to provide a standard mechanism for providing protection on writing to objects. An object of type ForceValue is associated with the protected object. If an set request is made for the protected object, the state of the system or the value to be set may violate the intended protection. The value of the associated object of type ForceValue is then used to determine whether the set request succeeds or fails: - value is forceChange, request succeeds. - value is noForceChange, request fails. An additional characteristic of the ForceValue type is that the setting of the protected object resets the value of the protection object to noForceChange. As an example, take an object limiting the number of network connections on an interface (named maxNetConn). If maxNetConn is set below the number of currently active connections, some of those connections will be cleared. An associated protection object of type ForceValue (named maxNetConnForce) is used to protect the setting of maxNetConn. If the setting of maxNetConn would cause the clearing of connections, maxNetConnForce must be set to forceChange. Whenever maxNetConn is successfully set, maxNetConnForce assumes the value noForceChange.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("forceChange", 1), ("noForceChange", 2))

class FineQueueThreshold(TextualConvention, Integer32):
    description = 'This data type is used to represent thresholds for output-queues on a shared memory ATM switch.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("percent12", 1), ("percent25", 2), ("percent37", 3), ("percent50", 4), ("percent62", 5), ("percent75", 6), ("percent87", 7), ("percent100", 8))

class LsPerVcqServiceClass(TextualConvention, Integer32):
    description = 'This data type is used to represent one of the Service Classes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("c1", 1), ("c2", 2), ("c3", 3), ("c4", 4), ("c5", 5), ("c6", 6), ("c7", 7), ("c8", 8))

class LsPerVcqServiceClassNoC1(TextualConvention, Integer32):
    description = 'This data type is used to represent one of the Service Classes, omitting c1.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("c2", 2), ("c3", 3), ("c4", 4), ("c5", 5), ("c6", 6), ("c7", 7), ("c8", 8))

class LsPerVcqThresholdGroup(TextualConvention, Integer32):
    description = 'This data type is used to represent one of the Threshold Groups.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))
    namedValues = NamedValues(("tg1", 1), ("tg2", 2), ("tg3", 3), ("tg4", 4), ("tg5", 5), ("tg6", 6), ("tg7", 7), ("tg8", 8), ("tg9", 9), ("tg10", 10), ("tg11", 11), ("tg12", 12), ("tg13", 13), ("tg14", 14), ("tg15", 15), ("tg16", 16))

class LsPerVcqThresholdGroupService(TextualConvention, Integer32):
    description = 'This data type is used to specify how VC/VP queues are assigned to Threshold Groups.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("cbr", 1), ("vbrRt", 2), ("vbrNrt", 3), ("abr", 4), ("ubr", 5))

class CgrPerVcqModuleId(TextualConvention, Integer32):
    description = 'The Catalyst8540MSR has 8 switching modules. Each module has its own cell memory, and performs its own congestion control, independent of the other switching modules.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("module1", 1), ("module2", 2), ("module3", 3), ("module4", 4), ("module5", 5), ("module6", 6), ("module7", 7), ("module8", 8))

ciscoAtmRmSwitchCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1))
ciscoAtmRmSwitchSharedMem = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2))
ciscoAtmRmIfCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3))
ciscoAtmRmIfState = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4))
ciscoAtmRmIfStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5))
ciscoAtmRmIfSharedMem = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6))
ciscoLsPerVcqAtmRmSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7))
ciscoLsPerVcqAtmRmIf = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8))
ciscoCgrPerVcqAtmRmSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9))
ciscoAtmRmTrafShaperIf = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10))
rmSwitchOverSubFactor = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmSwitchOverSubFactor.setStatus('current')
if mibBuilder.loadTexts: rmSwitchOverSubFactor.setDescription('The Over Subscription Factor (OSF) is used on switch startup/OIR to determine the maximum sizes of VBR-NRT and ABR/UBR queues. In general, the larger the value of OSF specified, the larger the queues are made at startup. Denoting the maximum sizes of CBR,VBR-RT, VBR-NRT, and ABR/UBR output queues for a physical interface as L1, L2, L3, and L4, respectively, an example algorithm is: L3 = .25 * (OSF*(2048-L1 -L2) L4 = .75 * (OSF*(2048-L1 -L2)')
rmSwitchScrMarginFactor = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmSwitchScrMarginFactor.setStatus('current')
if mibBuilder.loadTexts: rmSwitchScrMarginFactor.setDescription('The Sustained Cell Rate Margin Factor (SCRMF) is used in Connection Admission Control (CAC) of VBR connections to vary the weight given to the difference between Sustained Cell Rate (scr) and Peak Cell Rate (pcr) specified in the traffic contract. When calculating the equivalent bandwidth offered by a connection, SCRMF is used as follows: eqBw = scr + ((pcr - scr) * rcacVbrScrmf) / 100')
rmSwitchAbrCongNotify = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("relativeRate", 1), ("efci", 2), ("efciAndRelativeRate", 3))).clone('relativeRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmSwitchAbrCongNotify.setStatus('current')
if mibBuilder.loadTexts: rmSwitchAbrCongNotify.setDescription('The ABR Congestion Notification object determines the type of congestion notification used on ABR connections in the switch. This notification can be done either via relative-rate or Explicit Forward Congestion Indication marking in ATM cells, or both.')
rmDefaultQosObjectiveTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4), )
if mibBuilder.loadTexts: rmDefaultQosObjectiveTable.setStatus('current')
if mibBuilder.loadTexts: rmDefaultQosObjectiveTable.setDescription('The (conceptual) table containing Resource Management configuration information for default Quality of Service objective values used when a signalling request is received on a UNI interface.')
rmDefaultQosObjectiveEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "rmDefaultQosServiceCategory"))
if mibBuilder.loadTexts: rmDefaultQosObjectiveEntry.setStatus('current')
if mibBuilder.loadTexts: rmDefaultQosObjectiveEntry.setDescription('An entry (conceptual row) in the rmDefaultQosObjectiveTable containing Resource Management configuration for the default UNI QOS objectives. Rows are identified by Service Category.')
rmDefaultQosServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cbr", 1), ("vbrRt", 2), ("vbrNrt", 3))))
if mibBuilder.loadTexts: rmDefaultQosServiceCategory.setStatus('current')
if mibBuilder.loadTexts: rmDefaultQosServiceCategory.setDescription('The Service Category to which the row applies.')
rmScDefaultQosMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setUnits('microseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmScDefaultQosMaxCtd.setStatus('current')
if mibBuilder.loadTexts: rmScDefaultQosMaxCtd.setDescription('The default Maximum Cell Transfer Delay (ctd) for the Service Category. It applies only to cbr and vbr-rt Service Categories. Specifying a value of 16777215 signifies that this parameter should not be checked during connection setup. The units of this object are microseconds.')
rmScDefaultQosPeakToPeakCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setUnits('microseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmScDefaultQosPeakToPeakCdv.setStatus('current')
if mibBuilder.loadTexts: rmScDefaultQosPeakToPeakCdv.setDescription('The default Peak-to-peak cell delay variation (cdv) for the Service Category. It applies only to cbr and vbr-rt Service Categories. Specifying a value of 16777215 signifies that this parameter should not be checked during connection setup. The units of this object are microseconds.')
rmScDefaultQosClr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmScDefaultQosClr.setStatus('current')
if mibBuilder.loadTexts: rmScDefaultQosClr.setDescription('The default cell-loss-ratio for the Service Category (for CLP=0 cells only). Specifying a value of 0 signifies that this parameter should not be checked during connection setup. The units of this object are negative powers of ten (so an object value of 8 means 10**(-8)).')
rmScDefaultQosClrClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmScDefaultQosClrClp01.setStatus('current')
if mibBuilder.loadTexts: rmScDefaultQosClrClp01.setDescription('The default cell-loss-ratio for the Service Category for CLP=0+1 cells. Specifying a value of 0 signifies that this parameter should not be checked during connection setup. The units of this object are negative powers of ten (so an object value of 8 means 10**(-8)).')
sharedMemRmSwitchQueuedCellTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2, 1), )
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellTable.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellTable.setDescription('The (conceptual) table containing Resource Management information on the cells in the output queues of a shared-memory output-queued ATM switch.')
sharedMemRmSwitchQueuedCellEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "sharedMemRmCellPriority"))
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellEntry.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellEntry.setDescription('An entry (conceptual row) in the sharedMemRmSwitchQueuedCellTable containing Resource Management information on the cells in the output queues of a shared-memory switch. Rows are indexed by priority.')
sharedMemRmCellPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("p1", 1), ("p2", 2), ("p3", 3), ("p4", 4))))
if mibBuilder.loadTexts: sharedMemRmCellPriority.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmCellPriority.setDescription('The cell priority. The cell priority maps one-to-one to the per-interface queues specified by the sharedMemRmIfOutputQ object. All cells of a connection of a particular Service Category are given a fixed priority. The Service Categories allocated to a priority can be determined by querying the sharedMemRmIfOutputQServCategory object for any physical interface on the switch.')
sharedMemRmSwitchQueuedCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellLimit.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellLimit.setDescription('Configured limit on the number of cells on all output queues of the switch at any time of a particular priority.')
sharedMemRmSwitchQueuedCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 2, 1, 1, 3), Gauge32()).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellCount.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmSwitchQueuedCellCount.setDescription('Count of the number of cells on all output queues of the switch at any time of a particular priority.')
rmIfCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3), )
if mibBuilder.loadTexts: rmIfCfgTable.setStatus('current')
if mibBuilder.loadTexts: rmIfCfgTable.setDescription('The (conceptual) table containing Resource Management configuration information for whole ATM interfaces.')
rmIfCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rmIfCfgEntry.setStatus('current')
if mibBuilder.loadTexts: rmIfCfgEntry.setDescription("An entry (conceptual row) in the rmIfCfgTable containing Resource Management configuration for an ATM interface. The particular interface is identified by the value of MIB-II's ifIndex.")
rmIfOutPacingRateRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 1), Unsigned32()).setUnits('kilobits-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfOutPacingRateRequested.setStatus('current')
if mibBuilder.loadTexts: rmIfOutPacingRateRequested.setDescription('This object reflects an explicit configuration of the state of pacing for this interface. If the value of this object is 0, pacing is disabled on this interface. Prior to any user configuration, the value of this object is 0. If the value not 0, it represents the output pacing value, in kilobits per second. The hardware is not capable of providing all possible rates. The rate in place is available in rmIfOutPacingRateInstalled. If the value specified would reduce the port rate below that currently allocated to Guaranteed Service bandwidth for the output flow, the rmIfOutPacingForce object must be set in conjunction with this object in order to cause the change to take effect.')
rmIfOutPacingRateInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 2), Unsigned32()).setUnits('kilobits-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfOutPacingRateInstalled.setStatus('current')
if mibBuilder.loadTexts: rmIfOutPacingRateInstalled.setDescription('The output pacing value, in kilobits per second, in effect. A value of 0 indicates output pacing is disabled. This object is not instantiated for interfaces to which it cannot be applied.')
rmIfOutPacingForce = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 3), ForceValue().clone('noForceChange')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfOutPacingForce.setStatus('current')
if mibBuilder.loadTexts: rmIfOutPacingForce.setDescription('A Set Request for rmIfOutPacingRateRequested that does not reduce the port rate below the currently allocated bandwidth guarantees for the output flow always succeeds irrespective of the value of rmIfOutPacingForce. But a Set Request for rmIfOutPacingRateRequested that does reduce the port rate below the currently allocated bandwidth guarantees for the output flow will succeed only if rmIfOutPacingForce object is also set to the value forceChange. In either of the above cases, once rmIfOutPacingRateRequested object is set to the appropriate value, rmIfOutPacingForce object assumes the noForceChange value. This object is not instantiated for interfaces to which it cannot be applied.')
rmIfLinkDistance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('kilometers').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfLinkDistance.setStatus('current')
if mibBuilder.loadTexts: rmIfLinkDistance.setDescription('The link distance defined for the interface, expressed in kilometers. This is then divided by the speed of light to determine a propagation delay.')
rmIfBestEffortLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 5), Unsigned32().clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfBestEffortLimit.setStatus('current')
if mibBuilder.loadTexts: rmIfBestEffortLimit.setDescription('The limit on the number of Best Effort connections that can be established on this interface. Note that a change to this value affects subsequent connection setup, not existing connections. A value of 4294967295 disables best-effort limits.')
rmIfCbrDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 6), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfCbrDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfCbrDefaultRxUpcTolerance.setDescription('Specifies the GCRA limit parameter used for policing of a receive cell-stream of a CBR connection on an interface, if the limit parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfVbrRtDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 7), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrRtDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrRtDefaultRxUpcTolerance.setDescription('Specifies the maximum burst size parameter used for policing of a receive cell-stream of a VBR-RT connection on an interface, if this parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfVbrNrtDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 8), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrNrtDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrNrtDefaultRxUpcTolerance.setDescription('Specifies the maximum burst size parameter used for policing of a receive cell-stream of a VBR-NRT connection on an interface, if this parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfAbrDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 9), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfAbrDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfAbrDefaultRxUpcTolerance.setDescription('Specifies the GCRA limit parameter used for policing of a receive cell-stream of an ABR connection on an interface, if the limit parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfUbrDefaultRxUpcTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 10), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfUbrDefaultRxUpcTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfUbrDefaultRxUpcTolerance.setDescription('Specifies the GCRA limit parameter used for policing of a receive cell-stream of a UBR connection on an interface, if the limit parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfVbrRtDefaultRxUpcCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 11), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrRtDefaultRxUpcCdvt.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrRtDefaultRxUpcCdvt.setDescription('Specifies the GCRA limit parameter used for peak-rate policing of a receive cell-stream of a VBR-RT connection on an interface, if the CDVT parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfVbrNrtDefaultRxUpcCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 12), Unsigned32().clone(1024)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrNrtDefaultRxUpcCdvt.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrNrtDefaultRxUpcCdvt.setDescription('Specifies the GCRA limit parameter used for peak-rate policing of a receive cell-stream of a VBR-NRT connection on an interface, if the CDVT parameter is not specified explicitly in the connection setup request. It is specified in cell-times. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfServCategorySupport = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfServCategorySupport.setStatus('current')
if mibBuilder.loadTexts: rmIfServCategorySupport.setDescription('The value of this object controls and reflects the Service Category(s) supported on this ATM interface. If a bit is set, the corresponding Service Category is supported on the interface, and CAC will allow such connections. If a bit is reset, the corresponding Service Category is not supported on the interface, and CAC will reject such connections. Write access may not be supported on all interfaces. Not all Service Categories may be supported on an interface. For example, mixing of Service Categories may not be allowed on a VP tunnel interface. The various bit positions are: 1 constant bit rate (cbr) 2 variable bit rate-real time (vbr-rt) 4 variable bit rate-non real time (vbr-nrt) 8 available bit rate (abr) 16 unspecified bit rate (ubr)')
rmIfFramingOverhead = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfFramingOverhead.setStatus('current')
if mibBuilder.loadTexts: rmIfFramingOverhead.setDescription('If this object is set to true, framing overhead will be taken into account in determining the Maximum Cell Rate that is possible on this interface. If this object is set to false, framing overhead will not figure in the determination of the Maximum Cell Rate that is possible on this interface. If setting the value of this object to true results in reducing the Maximum Guaranteed Services Bandwidth of this interface below the currently allocated bandwidth guarantees on this interface, the object rmIfFramingOverheadForce must also be set in order to cause the change to take effect. This object is not instantiated for interfaces to which it cannot be applied.')
rmIfFramingOverheadForce = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 15), ForceValue().clone('noForceChange')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfFramingOverheadForce.setStatus('current')
if mibBuilder.loadTexts: rmIfFramingOverheadForce.setDescription('A Set Request for rmIfFramingOverhead that does not reduce the Maximum Guaranteed Services Bandwidth of this interface below the currently allocated bandwidth guarantees always succeeds irrespective of the value of rmIfFramingOverheadForce. But a Set Request for rmIfFramingOverhead that does reduce the Maximum Guaranteed Services Bandwidth of this interface below the currently allocated bandwidth guarantees will succeed only if rmIfFramingOverheadForce object is also set to the value forceChange. In either of the above cases, once the rmIfFramingOverhead object is set to the appropriate value, rmIfFramingOverheadForce object assumes the noForceChange value. This object is not instantiated for interfaces to which it cannot be applied.')
rmIfOverBooking = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(100)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfOverBooking.setStatus('current')
if mibBuilder.loadTexts: rmIfOverBooking.setDescription("This object specifies overbooking on this interface as a percentage of the Maximum Cell Rate that is possible on this interface. If the value of this object is 100, overbooking is disabled on this interface. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down'. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfVbrRtPerClassOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 3200)).clone(100)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrRtPerClassOverbooking.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrRtPerClassOverbooking.setDescription("This object specifies the Per Class Overbooking percentage for VBR-rt service category on this interface. If the value of this object is 100, Per Class Overbooking for VBR-rt is disabled on this interface. Specifying a value that is greater than 100 causes the CAC to scale down the bandwidth allocated to a VBR-rt VC on this interface by a factor that is equal to the inverse of the overbooking percentage specified by this object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down' and Interface overbooking (rmIfOverBooking object) is disabled. A set request for this object will not succeed if it specifies a value that would cause the current bandwidth guarantees on this interface to exceed the maximum bandwidth available for guaranteed services on this interface.")
rmIfVbrNrtPerClassOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 3200)).clone(100)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfVbrNrtPerClassOverbooking.setStatus('current')
if mibBuilder.loadTexts: rmIfVbrNrtPerClassOverbooking.setDescription("This object specifies the Per Class Overbooking percentage for VBR-Nrt service category on this interface. If the value of this object is 100, Per Class Overbooking for VBR-Nrt is disabled on this interface. Specifying a value that is greater than 100 causes the CAC to scale down the bandwidth allocated to a VBR-Nrt VC on this interface by a factor that is equal to the inverse of the overbooking percentage specified by this object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down' and Interface overbooking (rmIfOverBooking object) is disabled. A set request for this object will not succeed if it specifies a value that would cause the current bandwidth guarantees on this interface to exceed the maximum bandwidth available for guaranteed services on this interface.")
rmIfAbrPerClassOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 3200)).clone(100)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfAbrPerClassOverbooking.setStatus('current')
if mibBuilder.loadTexts: rmIfAbrPerClassOverbooking.setDescription("This object specifies the Per Class Overbooking percentage for ABR service category on this interface. If the value of this object is 100, Per Class Overbooking for ABR is disabled on this interface. Specifying a value that is greater than 100 causes the CAC to scale down the bandwidth allocated to a ABR VC on this interface by a factor that is equal to the inverse of the overbooking percentage specified by this object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down' and Interface overbooking (rmIfOverBooking object) is disabled. A set request for this object will not succeed if it specifies a value that would cause the current bandwidth guarantees on this interface to exceed the maximum bandwidth available for guaranteed services on this interface.")
rmIfUbrPerClassOverbooking = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 3, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(100, 3200)).clone(100)).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfUbrPerClassOverbooking.setStatus('current')
if mibBuilder.loadTexts: rmIfUbrPerClassOverbooking.setDescription("This object specifies the Per Class Overbooking percentage for UBR service category on this interface. If the value of this object is 100, Per Class Overbooking for UBR is disabled on this interface. Specifying a value that is greater than 100 causes the CAC to scale down the bandwidth allocated to a UBR VC on this interface by a factor that is equal to the inverse of the overbooking percentage specified by this object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down' and Interface overbooking (rmIfOverBooking object) is disabled. A set request for this object will not succeed if it specifies a value that would cause the current bandwidth guarantees on this interface to exceed the maximum bandwidth available for guaranteed services on this interface.")
rmIfDirectionCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4), )
if mibBuilder.loadTexts: rmIfDirectionCfgTable.setStatus('current')
if mibBuilder.loadTexts: rmIfDirectionCfgTable.setDescription('The (conceptual) table containing Resource Management configuration information for a single direction of traffic flow on ATM interfaces.')
rmIfDirectionCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "rmIfDirection"))
if mibBuilder.loadTexts: rmIfDirectionCfgEntry.setStatus('current')
if mibBuilder.loadTexts: rmIfDirectionCfgEntry.setDescription("An entry (conceptual row) in the rmIfInOutCfgTable containing Resource Management configuration for a traffic direction on an ATM interface. The particular interface is identified by the value of MIB-II's ifIndex, and the direction of flow.")
rmIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("receive", 1), ("transmit", 2))))
if mibBuilder.loadTexts: rmIfDirection.setStatus('current')
if mibBuilder.loadTexts: rmIfDirection.setDescription('Selects the traffic direction for which subsequent row parameters are read or written. In is received from the port(into the device), Out is transmitted to the port (from the device).')
rmIfDirControlLinkShareMaxAgg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxAgg.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxAgg.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies the maximum aggregate Guaranteed Service (CBR or VBR) traffic that can be allocated in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MaxVbr (if specified) such that MaxVbr <= MaxAgg. This object interacts with MaxCbr (if specified) such that MaxCbr <= MaxAgg. This object interacts with MaxAbr (if specified) such that MaxAbr <= MaxAgg. This object interacts with MaxUbr (if specified) such that MaxUbr <= MaxAgg. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMinCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinCbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinCbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies a minimum amount of CBR traffic that can be reserved in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinVbr, MinAbr, MinUbr (if specified) such that MinVbr + MinCbr + MinAbr + MinUbr <= 95%. This object interacts with MaxCbr (if specified) such that MinCbr < MaxCbr. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMaxCbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxCbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxCbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies the maximum CBR traffic that can be allocated in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinCbr (if specified) such that MinCbr <= MaxCbr. This object interacts with MaxAgg (if specified) such that MaxCbr <= MaxAgg. Note that a change to this value affects subsequent connection setup, not existing connections. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMinVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinVbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinVbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies a minimum amount of VBR traffic that can be reserved in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinCbr, MinAbr, and MinUbr (if specified), such that MinVbr + MinCbr + MinAbr + MinUbr <= 95%. This object interacts with MaxVbr (if specified) such that MinVbr <= MaxVbr. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMaxVbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxVbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxVbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies the maximum VBR traffic that can be allocated in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinVbr (if specified) such that MinVbr <= MaxVbr. This object interacts with MaxAgg (if specified) such that MaxVbr <= MaxAgg. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirMaxCbrPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 7), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxCbrPcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxCbrPcr.setDescription('Specifies the maximum Peak-cell-rate (pcr) traffic parameter that can be specified for CBR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxCbrTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 8), Unsigned32().clone(4294967295)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxCbrTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxCbrTolerance.setDescription('Specifies the maximum limit parameter used in the GCRA algorithm for traffic policing that can be specified for CBR connections in a traffic direction on an interface. It is specified in cell-times. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxVbrPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 9), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxVbrPcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxVbrPcr.setDescription('Specifies the maximum Peak-cell-rate (pcr) traffic parameter that can be specified for VBR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxVbrScr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 10), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxVbrScr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxVbrScr.setDescription('Specifies the maximum Sustained-cell-rate (scr) traffic parameter that can be specified for VBR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxVbrTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 11), Unsigned32().clone(4294967295)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxVbrTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxVbrTolerance.setDescription('Specifies the maximum limit parameter used in the GCRA algorithm for traffic policing that can be specified for VBR connections in a traffic direction on an interface. It is specified in cell-times. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxAbrPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 12), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxAbrPcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxAbrPcr.setDescription('Specifies the maximum Peak-cell-rate (pcr) traffic parameter that can be specified for ABR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxAbrTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 13), Unsigned32().clone(4294967295)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxAbrTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxAbrTolerance.setDescription('Specifies the maximum limit parameter used in the GCRA algorithm for traffic policing that can be specified for ABR connections in a traffic direction on an interface. It is specified in cell-times. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxUbrPcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 14), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxUbrPcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxUbrPcr.setDescription('Specifies the maximum Peak-cell-rate (pcr) traffic parameter that can be specified for UBR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxUbrTolerance = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 15), Unsigned32().clone(4294967295)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxUbrTolerance.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxUbrTolerance.setDescription('Specifies the maximum limit parameter used in the GCRA algorithm for traffic policing that can be specified for UBR connections in a traffic direction on an interface. It is specified in cell-times. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxAbrMcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 16), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxAbrMcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxAbrMcr.setDescription('Specifies the maximum Minimum-cell-rate (mcr) traffic parameter that can be specified for ABR connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxUbrMcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 17), Unsigned32().clone(4294967295)).setUnits('cells-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxUbrMcr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxUbrMcr.setDescription('Specifies the maximum Minimum-cell-rate (mcr) traffic parameter that can be specified for UBR plus (UBR with an mcr guaranteed) connections in a traffic direction on an interface. It is specified in cells-per-second. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirMaxVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 18), Unsigned32().clone(4294967295)).setUnits('cell-times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirMaxVbrCdvt.setStatus('current')
if mibBuilder.loadTexts: rmIfDirMaxVbrCdvt.setDescription('Specifies the maximum peak-rate CDVT parameter used in the GCRA algorithm for traffic policing that can be specified for VBR connections in a traffic direction on an interface. It is specified in cell-times. A value of 4294967295 disables checking of this parameter limit. Note that a change to this value affects subsequent connection setup, not existing connections.')
rmIfDirControlLinkShareMinAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinAbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinAbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies a minimum amount of ABR traffic that can be reserved in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinVbr, MinCbr, and MinUbr (if specified) such that: MinVbr + MinCbr + MinAbr + MinUbr <= 95%. This object interacts with MaxAbr (if specified) such that MinAbr < MaxAbr. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMaxAbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxAbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxAbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies the maximum ABR traffic that can be allocated in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinAbr (if specified) such that MinAbr <= MaxAbr. This object interacts with MaxAgg (if specified) such that MaxAbr <= MaxAgg. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMinUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinUbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMinUbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies a minimum amount of UBR plus (UBR with an mcr guaranteed) traffic that can be reserved in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinVbr, MinCbr, and MinAbr (if specified) such that: MinVbr + MinCbr + MinAbr + MinUbr <= 95%. This object interacts with MaxUbr (if specified) such that MinUbr < MaxUbr. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfDirControlLinkShareMaxUbr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 3, 4, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 95)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxUbr.setStatus('current')
if mibBuilder.loadTexts: rmIfDirControlLinkShareMaxUbr.setDescription("Configuration in the Controller Link Sharing (CLS) scheme. Specifies the maximum UBR plus traffic that can be allocated in a traffic direction on an interface. It is expressed as a percentage of the maximum traffic direction's bandwidth (applies after output pacing, for example). This object interacts with MinUbr (if specified) such that MinUbr <= MaxUbr. This object interacts with MaxAgg (if specified) such that MaxUbr <= MaxAgg. Note that a change to this value affects subsequent connection setup, not existing connections. If the object is set to -1, the object is considered to be unspecified. This object is not instantiated for interfaces to which it cannot be applied.")
rmIfServiceCategoryStateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1), )
if mibBuilder.loadTexts: rmIfServiceCategoryStateTable.setStatus('current')
if mibBuilder.loadTexts: rmIfServiceCategoryStateTable.setDescription('The (conceptual) table containing Resource Management state information for ATM interfaces by Service Category.')
rmIfServiceCategoryStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "rmIfSc"))
if mibBuilder.loadTexts: rmIfServiceCategoryStateEntry.setStatus('current')
if mibBuilder.loadTexts: rmIfServiceCategoryStateEntry.setDescription("An entry (conceptual row) in the rmIfServiceCategoryStateTable containing Resource Management configuration for an ATM interface. Rows are identified by the value of MIB-II's ifIndex, and the Service Category.")
rmIfSc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("cbr", 1), ("vbrRt", 2), ("vbrNrt", 3), ("abr", 4), ("ubr", 5))))
if mibBuilder.loadTexts: rmIfSc.setStatus('current')
if mibBuilder.loadTexts: rmIfSc.setDescription('The Service Category to which the row applies.')
rmIfScRxAcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 2), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRxAcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScRxAcr.setDescription('The Available Cell Rate (specified in cells per second) for traffic received on the interface for this Service Category. This is the bandwidth available for connections. For CBR and VBR Service Categories, this value decreases as a result of connection setup and increases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified..')
rmIfScTxAcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 3), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxAcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxAcr.setDescription('The Available Cell Rate (specified in cells per second) for traffic sent out the interface for this Service Category. This is the bandwidth available for connections. For CBR and VBR Service Categories, this value decreases as a result of connection setup and increases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified.')
rmIfScRxAlcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 4), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRxAlcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScRxAlcr.setDescription('The Allocated Cell Rate (specified in cells per second) for traffic received on the interface for this Service Category. This is the bandwidth allocated-to connections. For CBR and VBR Service Categories, this value increases as a result of connection setup and decreases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified.')
rmIfScTxAlcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 5), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxAlcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxAlcr.setDescription('The Allocated Cell Rate (specified in cells per second) for traffic sent out the interface for this Service Category. This is the bandwidth allocated-to connections. For Guaranteed Service Categories, this value increases as a result of connection setup and decreases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified.')
rmIfScNumSvxConns = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 6), Gauge32()).setUnits('number of connections').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScNumSvxConns.setStatus('current')
if mibBuilder.loadTexts: rmIfScNumSvxConns.setDescription('The number of signalled connections (VC or VP) of this Service Category currently allocated on the interface.')
rmIfScNumPvxConns = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 7), Gauge32()).setUnits('number of connections').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScNumPvxConns.setStatus('current')
if mibBuilder.loadTexts: rmIfScNumPvxConns.setDescription('The number of permanent connections (VC or VP) of this Service Category currently allocated on the interface.')
rmIfScTxMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 8), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxMaxCtd.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxMaxCtd.setDescription('The maximum Cell Transfer Delay estimated to be experienced by cells of connections transmitted out this interface of this Service Category. This is estimate does not distinguish between clp0 and clp1 cells. This object is valid for Service Category cbr and vbr-rt. For other Service Categories, the object is not defined.')
rmIfScTxP2PeakCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 9), Gauge32()).setUnits('microseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxP2PeakCdv.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxP2PeakCdv.setDescription('The Peak-to-Peak Cell Delay Variation estimated to be experienced by cells of connections transmitted out this interface of this Service Category. This estimate does not distinguish between clp0 and clp1 cells. This object is valid for Service Categories cbr and vbr-rt. For other Service Categories, the object is not defined.')
rmIfScTxClr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxClr.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxClr.setDescription('The Cell Loss Ratio estimated to be experienced by cells of connections transmitted out this interface of this Service Category. This is an estimate for clp0 cells only. The unit of this object is negative power of ten (so an object value of 8 means 10**(-8)). This object is valid for Service Categories cbr, vbr-rt, and vbr-nrt. For other Service Categories, the object is not defined.')
rmIfScTxClrClp01 = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxClrClp01.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxClrClp01.setDescription('The Cell Loss Ratio estimated to be experienced by cells of connections transmitted out this interface of this Service Category. This is an estimate for clp0+1 cells. The unit of this object is negative power of ten (so an object value of 8 means 10**(-8)). This object is valid for Service Categories cbr, vbr-rt, and vbr-nrt. For other Service Categories, the object is not defined.')
rmIfScRxDynBwSvcAcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 12), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRxDynBwSvcAcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScRxDynBwSvcAcr.setDescription('The Available Cell Rate (specified in cells per second) for traffic received on the interface for this Service Category. This object is valid only for IMA physical interfaces. This is the bandwidth available for SVC connections. For CBR and VBR Service Categories, this value decreases as a result of connection setup and increases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified')
rmIfScTxDynBwSvcAcr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 4, 1, 1, 13), Gauge32()).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScTxDynBwSvcAcr.setStatus('current')
if mibBuilder.loadTexts: rmIfScTxDynBwSvcAcr.setDescription('The Available Cell Rate (specified in cells per second) for traffic transmitted on the interface for this Service Category. This object is valid only for IMA physical interfaces. This is the bandwidth available for SVC connections on physical interfaces. For CBR and VBR Service Categories, this value decreases as a result of connection setup and increases as a result of connection release. For ABR and UBR Service Categories, this value changes as a result of connection setup and teardown only if non-zero mcr is specified')
rmIfServiceCategoryStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1), )
if mibBuilder.loadTexts: rmIfServiceCategoryStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: rmIfServiceCategoryStatisticsTable.setDescription('The (conceptual) table containing Resource Management statistics information for ATM interfaces by Service Category.')
rmIfServiceCategoryStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "rmIfSc"))
if mibBuilder.loadTexts: rmIfServiceCategoryStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: rmIfServiceCategoryStatisticsEntry.setDescription("An entry (conceptual row) in the rmIfServiceCategoryStatisticsTable containing Resource Management configuration for an ATM interface. Rows are identified by the value of MIB-II's ifIndex, and the Service Category.")
rmIfScRcacResultNumAdmit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumAdmit.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumAdmit.setDescription('The number of successful resource allocation requests for this interface.')
rmIfScRcacResultNumTotalRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumTotalRequests.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumTotalRequests.setDescription('The total number of resource allocation requests for this interface.')
rmIfScRcacResultNumFailTraffComb = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailTraffComb.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailTraffComb.setDescription('The number of resource allocation requests which are considered to be in error due to an unsupported combination of traffic parameters. An example of this would be, for a VBR connection, a zero maximum burst-size given a non-zero sustainable-cell-rate.')
rmIfScRcacResultNumFailBw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailBw.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailBw.setDescription('The number of resource allocation requests which are considered to be in error due to a lack of bandwidth. This will never occur for Best Effort Service Categories.')
rmIfScRcacResultNumFailLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailLoss.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailLoss.setDescription('The number of resource allocation requests which are considered to be in error due to exceeding cell loss criterion.')
rmIfScRcacResultNumFailDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailDelay.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailDelay.setDescription('The number of resource allocation requests which are considered to be in error due to exceeding maximum delay criterion.')
rmIfScRcacResultNumFailCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailCdv.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailCdv.setDescription('The number of resource allocation requests which are considered to be in error due to exceeding cell delay variation criterion.')
rmIfScRcacResultNumFailBeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailBeLimit.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailBeLimit.setDescription('The number of resource allocation requests which are considered to be in error due to exceeding a limit on the number of Best-Effort connections.')
rmIfScRcacResultNumFailParmLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailParmLimit.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailParmLimit.setDescription('The number of resource allocation requests which are considered to be in error due to exceeding a traffic parameter limit criterion.')
rmIfScRcacResultNumFailOther = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 5, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmIfScRcacResultNumFailOther.setStatus('current')
if mibBuilder.loadTexts: rmIfScRcacResultNumFailOther.setDescription('The number of resource allocation requests which are considered to be in error for a reason not enumerated by other counter objects.')
sharedMemRmIfOutputQCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1), )
if mibBuilder.loadTexts: sharedMemRmIfOutputQCfgTable.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQCfgTable.setDescription('The (conceptual) table containing configuration information for ATM physical interface output queues. This table is not instantiated for interfaces to which it cannot be applied.')
sharedMemRmIfOutputQCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQ"))
if mibBuilder.loadTexts: sharedMemRmIfOutputQCfgEntry.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQCfgEntry.setDescription("An entry (conceptual row) in the sharedMemRmIfOutputQCfgTable containing Resource Management configuration for an ATM interface. A particular row is identified by the value of MIB-II's ifIndex, and the output queue.")
sharedMemRmIfOutputQ = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("q1", 1), ("q2", 2), ("q3", 3), ("q4", 4))))
if mibBuilder.loadTexts: sharedMemRmIfOutputQ.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQ.setDescription('The output queue on this ATM interface.')
sharedMemRmIfOutputQServCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sharedMemRmIfOutputQServCategory.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQServCategory.setDescription('The service category(s) sharing this output queue on this ATM interface. The various bit positions are: 1 constant bit rate (cbr) 2 variable bit rate-real time (vbr-rt) 4 variable bit rate-non real time (vbr-nrt) 8 available bit rate (abr) 16 unspecified bit rate (ubr)')
sharedMemRmIfOutputQRequestedMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65504))).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmIfOutputQRequestedMaxSize.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQRequestedMaxSize.setDescription("This object reflects an explicit configuration of the maximum number of cells that may occupy this queue. If the value of this object is 0, the maximum size in effect is a default value calculated by software. Prior to any user configuration, the value of this object is 0. The actual maximum size is reflected in the object sharedMemRmIfOutputQInstalledMaxSize (and is a default value calculated by software). Setting this value to 0 causes the size to assume it's default value. When changing a port that is up, must be set in conjunction with the force object (sharedMemRmIfOutputQMaxSizeForce) to take effect.")
sharedMemRmIfOutputQInstalledMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32, 65504))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: sharedMemRmIfOutputQInstalledMaxSize.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQInstalledMaxSize.setDescription('The maximum number of cells that may occupy this queue. Will be a multiple of 32. Explicit configuration of maximum size are made via the object sharedMemrmIfOutputQRequestedMaxSize. Such requests are rounded up to the nearest multiple of 32 prior to installation.')
sharedMemRmIfOutputQMaxSizeForce = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 5), ForceValue().clone('noForceChange')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmIfOutputQMaxSizeForce.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQMaxSizeForce.setDescription("Must be set to forceChange to allow changing of sharedMemRmIfOutputQRequestedMaxSize for a queue on an interface that is 'up'. This is because such a change causes the interface to lose data while the size is changed. Once the change takes place, the force object assumes the noForceChange value.")
sharedMemRmIfOutputQCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 1, 1, 6), Gauge32()).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: sharedMemRmIfOutputQCellCount.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfOutputQCellCount.setDescription('Count of the number of cells in the output queue.')
sharedMemRmIfThresholdCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 2), )
if mibBuilder.loadTexts: sharedMemRmIfThresholdCfgTable.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfThresholdCfgTable.setDescription('The (conceptual) table containing the output queue thresholds used on ATM physical interface output queues. These are specified per Service Category. This table is not instantiated for interfaces to which it cannot be applied.')
sharedMemRmIfThresholdCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "rmIfSc"))
if mibBuilder.loadTexts: sharedMemRmIfThresholdCfgEntry.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfThresholdCfgEntry.setDescription("An entry (conceptual row) in the sharedMemRmIfThresholdCfgTable containing Resource Management configuration for an ATM interface. A particular row is identified by the value of MIB-II's ifIndex, and the Service Category.")
sharedMemRmIfDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 2, 1, 1), FineQueueThreshold().clone('percent50')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmIfDiscardThreshold.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfDiscardThreshold.setDescription('The output queue CLP/EPD threshold for this Service Category on this ATM interface. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold.')
sharedMemRmIfEfciThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("percent12", 1), ("percent25", 2), ("percent50", 3), ("percent100", 4))).clone('percent25')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmIfEfciThreshold.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfEfciThreshold.setDescription('The output queue EFCI marking threshold for this Service Category on this ATM interface. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold.')
sharedMemRmIfAbrRelativeRateThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 6, 2, 1, 3), FineQueueThreshold().clone('percent25')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sharedMemRmIfAbrRelativeRateThreshold.setStatus('current')
if mibBuilder.loadTexts: sharedMemRmIfAbrRelativeRateThreshold.setDescription('The ABR Relative-rate marking queue congestion threshold for the ABR queue on this ATM interface. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold. This object is only defined for the abr service category.')
lsPerVcqRmThreshGrpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1), )
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpTable.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpTable.setDescription('The (conceptual) table containing information for Switch Threshold Groups. When cells are queued in the switch for a direction of cell traffic on an ATM connection (VC or VP), several functions related to queueing are dictated by the congestion state (fullness) of the Threshold Group. Each connection queue is a member of a Threshold Group. These functions include: - The limit on the number of cells that can be queued. Cells exceeding this limit are discarded. - The discard threshold, used for CLP/EPD discard when the fullness of the queue exceeds the threshold. - The marking threshold, used for EFCI and ABR-RR marking. Each Threshold Group has a maximum number of cells that can be resident in it at any one time. The number of cells in a Group consists of the number of cells in all the queues that are a member of the Group. As the number of cells in a Group approaches the maximum number for the Group, the queue limits may be decreased. This limits the share of buffering available to each connection as cell-memory is used.')
lsPerVcqRmThreshGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrp"))
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpEntry.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpEntry.setDescription('An entry (conceptual row) in the lsPerVcqRmThreshGrpTable containing Resource Management configuration for a Threshold Group. All entries ever in the table are present at startup, none are created dynamically.')
lsPerVcqRmThreshGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 1), LsPerVcqThresholdGroup())
if mibBuilder.loadTexts: lsPerVcqRmThreshGrp.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrp.setDescription('The Threshold Group specified by this entry.')
lsPerVcqRmThreshGrpMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(65535)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpMaxSize.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpMaxSize.setDescription('This object specifies the maximum number of cells that may occupy this Threshold Group. While any integer in the range can be set, the hardware granularity is in 64-cell units. Therefore, the value installed is [(value / 64) * 64] + 63. If the value of this object is set to -1, the default value for the threshold-group is restored.')
lsPerVcqRmThreshGrpQMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(31, 16383))).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpQMaxSize.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpQMaxSize.setDescription('This object reflects an explicit configuration of the maximum limit on the number of cells that may occupy connection queues that are a member of this Threshold Group. A connection queue that is a member of this Threshold Group will never have more cells resident in it than this limit. This is the queue limit applied when the Threshold Group is uncongested. The QMaxSize must be greater than or equal to the Threshold Group QMinSize. QMaxSize should be less than MaxSize for the Threshold Group. While any integer in the range can be set, the hardware granularity is in 16-cell units. Therefore, the largest possible queue size installed is: [(value / 16) * 16]+15')
lsPerVcqRmThreshGrpQMinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpQMinSize.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpQMinSize.setDescription("This object reflects an explicit configuration of the minimum limit on the number of cells that may occupy connection queues that are a member of this Threshold Group. The Threshold Group at it's most congested will not limit a connection queue to fewer than this number of cells. The QMinSize must be less than or equal to the Threshold Group QMaxSize. The hardware granularity is in units of one cell.")
lsPerVcqRmThreshGrpDiscThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpDiscThreshold.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpDiscThreshold.setDescription('The output queue CLP/EPD threshold for this Threshold Group. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold. Setting this object to -1 restores the default value for the Threshold Group. The granularity of the fill-level of a queue installed in hardware is the same as that for queue limits.')
lsPerVcqRmThreshGrpMarkThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpMarkThreshold.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpMarkThreshold.setDescription('The output queue EFCI/ABR-RR marking threshold for this Threshold Group. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold. Setting this object to -1 restores the default value for the Threshold Group. The granularity of the fill-level of a queue installed in hardware is the same as that for queue limits.')
lsPerVcqRmThreshGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpName.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpName.setDescription('The name associated with the threshold-group. If this is set to the null-string, the default name for the Threshold Group is assigned.')
lsPerVcqRmThreshGrpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 1, 1, 8), Gauge32()).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpCellCount.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpCellCount.setDescription('Count of the number of cells in the Threshold Group.')
lsPerVcqRmThreshGrpServiceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 2), )
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServiceTable.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServiceTable.setDescription('The (conceptual) table specifying which VC or VP queues are assigned to a Threshold Group.')
lsPerVcqRmThreshGrpServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 2, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpService"))
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServiceEntry.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServiceEntry.setDescription('An entry (conceptual row) in the lsPerVcqRmThreshGrpServiceTable. All entries ever in the table are present at startup, none are created dynamically.')
lsPerVcqRmThreshGrpService = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 2, 1, 1), LsPerVcqThresholdGroupService())
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpService.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpService.setDescription('The Service specified by this entry.')
lsPerVcqRmThreshGrpServGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 2, 1, 2), LsPerVcqThresholdGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServGroup.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmThreshGrpServGroup.setDescription('The Threshold Group to which VC/VP queues specified by the service are assigned. Changing the assignment of service to Threshold Group does not alter the assignment for connections currently installed in hardware, but those connections that are subsequently installed.')
lsPerVcqRmHierarchicalSchedulingMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmHierarchicalSchedulingMode.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmHierarchicalSchedulingMode.setDescription('On a LS1010 equipped with the Lightstream per-VC queueing chipset, the user can define Hierarchical VP-Tunnels. Each such tunnel has its own dedicated scheduler, programmed to output data at a configurable maximum rate. Therefore, the overall output of the Hierarchical VP-tunnel is rate-limited. In addition, Virtual Circuits of different service categories can traverse through such a tunnel, and each of these Virtual Circuits are guaranteed their individual contracted bandwidth agreement. This object must be set to enabled before any Hierarchical VP-tunnels can be defined on the device. Any setting of this variable requires a reload of the device to be effective. Setting this object to enabled will cause the software to initialize the additional schedulers needed by the Hierarchical VP-Tunnels. Other limited scheduler resources are therefore used by a larger number of schedulers (as compared to the case when Hierarchical Scheduling is disabled on the device). This may result in fewer number of connections passing Connection Admission Control. This object is therefore provided so that the user can make an informed decision as to whether Hierarchical Scheduling is to be used. This object is defined on a LS1010 only when the switch is equipped with the Lightstream per-VC queueing chipset.')
cgrPerVcqRmThreshGrpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1), )
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpTable.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpTable.setDescription('The (conceptual) table containing information for Switch Threshold Groups. When cells are queued in the switch for a direction of cell traffic on an ATM connection (VC or VP), several functions related to queueing are dictated by the congestion state (fullness) of the Threshold Group. Each connection queue is a member of a Threshold Group. These functions include: - The limit on the number of cells that can be queued. Cells exceeding this limit are discarded. - The discard threshold, used for CLP/EPD discard when the fullness of the queue exceeds the threshold. - The marking threshold, used for EFCI marking. Each Threshold Group has a maximum number of cells that can be resident in it at any one time. The number of cells in a Group consists of the number of cells in all the queues that are a member of the Group. As the number of cells in a Group approaches the maximum number for the Group, the queue limits may be decreased. This limits the share of buffering available to each connection as cell-memory is used. On the Catalyst8540MSR platform, there are a maximum of 8 switching modules. Each switching module services a certain group of ports (this mapping is fixed in hardware). Each module also has its own cell memory (for per VC queueing), and hence performs its own congestion control, independent of any other switching module. Each switching module has its own set of Switch Threshold Groups, which are independently programmable and readable. This table is supported only on the Catalyst8540MSR platform.')
cgrPerVcqRmThreshGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "cgrPerVcqModuleId"), (0, "CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrp"))
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpEntry.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpEntry.setDescription('An entry (conceptual row) in the cgrPerVcqRmThreshGrpTable containing Resource Management configuration for a Threshold Group. All entries ever in the table are present at startup, none are created dynamically.')
cgrPerVcqModuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 1), CgrPerVcqModuleId())
if mibBuilder.loadTexts: cgrPerVcqModuleId.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqModuleId.setDescription('The switching module specified by this entry.')
cgrPerVcqRmThreshGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 2), LsPerVcqThresholdGroup())
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrp.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrp.setDescription('The Threshold Group specified by this entry.')
cgrPerVcqRmThreshGrpMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 131071)).clone(131071)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpMaxSize.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpMaxSize.setDescription('This object specifies the maximum number of cells that may occupy this Threshold Group. While any integer in the range can be set, the hardware granularity is in 64-cell units. Therefore, the value installed is [(value / 64) * 64] + 63. Even though the maximum value for this object is 131071, the cell memory actually present in hardware can be less. The agent will allow values for this object not exceeding the actual cell memory present in hardware. If the value of this object is set to -1, the default value for the threshold-group is restored.')
cgrPerVcqRmThreshGrpQMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(31, 16383))).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpQMaxSize.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpQMaxSize.setDescription('This object reflects an explicit configuration of the maximum limit on the number of cells that may occupy connection queues that are a member of this Threshold Group. A connection queue that is a member of this Threshold Group will never have more cells resident in it than this limit. This is the queue limit applied when the Threshold Group is uncongested. The QMaxSize must be greater than or equal to the Threshold Group QMinSize. QMaxSize should be less than MaxSize for the Threshold Group. While any integer in the range can be set, the hardware granularity is in 16-cell units. Therefore, the largest possible queue size installed is: [(value / 16) * 16]+15')
cgrPerVcqRmThreshGrpQMinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpQMinSize.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpQMinSize.setDescription("This object reflects an explicit configuration of the minimum limit on the number of cells that may occupy connection queues that are a member of this Threshold Group. The Threshold Group at it's most congested will not limit a connection queue to fewer than this number of cells. The QMinSize must be less than or equal to the Threshold Group QMaxSize. The hardware granularity is in units of one cell.")
cgrPerVcqRmThreshGrpDiscThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpDiscThreshold.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpDiscThreshold.setDescription('The output queue CLP/EPD threshold for this Threshold Group. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold. Setting this object to -1 restores the default value for the Threshold Group. The granularity of the fill-level of a queue installed in hardware is the same as that for queue limits.')
cgrPerVcqRmThreshGrpMarkThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 100))).setUnits('percentage').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpMarkThreshold.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpMarkThreshold.setDescription('The output queue EFCI/ABR-RR marking threshold for this Threshold Group. This is expressed in percent-of-full. Note that 100% full effectively turns off the threshold. Setting this object to -1 restores the default value for the Threshold Group. The granularity of the fill-level of a queue installed in hardware is the same as that for queue limits.')
cgrPerVcqRmThreshGrpName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpName.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpName.setDescription('The name associated with the threshold-group. If this is set to the null-string, the default name for the Threshold Group is assigned.')
cgrPerVcqRmThreshGrpCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 1, 1, 9), Gauge32()).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpCellCount.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpCellCount.setDescription('Count of the number of cells in the Threshold Group.')
cgrPerVcqRmThreshGrpServiceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 2), )
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServiceTable.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServiceTable.setDescription('The (conceptual) table specifying which VC or VP queues are assigned to a Threshold Group. This table is supported only on the Catalyst8540MSR Platform.')
cgrPerVcqRmThreshGrpServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 2, 1), ).setIndexNames((0, "CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpService"))
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServiceEntry.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServiceEntry.setDescription('An entry (conceptual row) in the cgrPerVcqRmThreshGrpServiceTable. All entries ever in the table are present at startup, none are created dynamically.')
cgrPerVcqRmThreshGrpService = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 2, 1, 1), LsPerVcqThresholdGroupService())
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpService.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpService.setDescription('The Service specified by this entry.')
cgrPerVcqRmThreshGrpServGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 2, 1, 2), LsPerVcqThresholdGroup()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServGroup.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmThreshGrpServGroup.setDescription('The Threshold Group to which VC/VP queues specified by the service are assigned. Changing the assignment of service to Threshold Group does not alter the assignment for connections currently installed in hardware, but those connections that are subsequently installed.')
cgrPerVcqRmHierarchicalSchedulingMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cgrPerVcqRmHierarchicalSchedulingMode.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqRmHierarchicalSchedulingMode.setDescription('On a Catalyst8540 MSR, the user can define Hierarchical VP-Tunnels. Each such tunnel has its own dedicated scheduler, programmed to output data at a configurable maximum rate. Therefore, the overall output of the Hierarchical VP-tunnel is rate-limited. In addition, Virtual Circuits of different service categories can traverse through such a tunnel, and each of these Virtual Circuits are guaranteed their individual contracted bandwidth agreement. This object must be set to enabled before any Hierarchical VP-tunnels can be defined on the device. Any setting of this variable requires a reload of the device to be effective. Setting this object to enabled will cause the software to initialize the additional schedulers needed by the Hierarchical VP-Tunnels. Other limited scheduler resources are therefore used by a larger number of schedulers (as compared to the case when Hierarchical Scheduling is disabled on the device). This may result in fewer number of connections passing Connection Admission Control. This object is therefore provided so that the user can make an informed decision as to whether Hierarchical Scheduling is to be used. This object is supported only on the Catalyst8540MSR platform.')
lsPerVcqRmIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 1), )
if mibBuilder.loadTexts: lsPerVcqRmIfTable.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfTable.setDescription('The (conceptual) table containing configuration information for ATM physical interfaces.')
lsPerVcqRmIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: lsPerVcqRmIfEntry.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfEntry.setDescription('An entry (conceptual row) in the lsPerVcqRmIfTable containing Resource Management configuration for an ATM interface. An entry in the table is present when an entry in the ifTable is created for an ATM interface that uses the Lighstream per-VC queueing chipset.')
lsPerVcqRmIfMinWrrServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 1, 1, 1), LsPerVcqServiceClass()).setUnits('service class').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmIfMinWrrServiceClass.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfMinWrrServiceClass.setDescription("The service classes on an interface are partitioned into two subsets, dictating how a service class with a cell ready to transmit is chosen (subsequently a connection is chosen within the selected service class). There are two subsets: Strict Priority (SP), and Weighted Round Robin (WRR). The SP subset service classes are selected by strict priority (highest priority with available cell wins). If there are any SP service classes, they take precedence over any WRR classes. A WRR subset service class is chosen from among the WRR service classes with an available cell using a WRR algorithm. The SP service classes (if any) include a contiguous range of classes, starting with c2 (c1 is dedicated to CBR, which doesn't use SP/WRR). The WRR service classes (if any) include a contiguous range of classes, ending with c5. This object specifies the break-point between SP and WRR service classes. Note that (assuming all service classes are used) specifying c2 indicates all service classes are WRR, and specifying c5 indicates all service classes are SP.")
lsPerVcqRmIfServiceClassTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 2), )
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClassTable.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClassTable.setDescription('The (conceptual) table containing configuration information for ATM physical interface Service Classes (not logical port ATM interfaces). An ATM connection (VC or VP) on an interface is a member of a Service Class. The Service Class is used in the scheduling discipline that determines which cell is next transmitted on the interface. If the rate scheduler has no cell to be sent in the guaranteed cell-flow on an interface, a decision is made between all Service Classes with VCs with cells ready for transmit.')
lsPerVcqRmIfServiceClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CISCO-ATM-RM-MIB", "lsPerVcqRmIfServiceClass"))
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClassEntry.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClassEntry.setDescription("An entry (conceptual row) in the lsPerVcqRmIfServiceClassTable containing Resource Management configuration for an ATM interface. A particular row is identified by the value of MIB-II's ifIndex, and the output queue. An entry in the table is present when an entry in the ifTable is created for an ATM interface that uses the Lighstream per-VC queueing chipset.")
lsPerVcqRmIfServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 2, 1, 1), LsPerVcqServiceClass())
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClass.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfServiceClass.setDescription('The service class on this ATM interface.')
lsPerVcqRmIfServClassConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsPerVcqRmIfServClassConnType.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfServClassConnType.setDescription('The types of connections using this service class on this ATM interface. The various bit positions are: 1 constant bit rate (cbr) 2 variable bit rate-real time (vbr-rt) 4 variable bit rate-non real time (vbr-nrt) 8 available bit rate (abr) 16 unspecified bit rate (ubr)')
lsPerVcqRmIfServClassWrrWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setUnits('weight').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lsPerVcqRmIfServClassWrrWeight.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqRmIfServClassWrrWeight.setDescription('Configure the weighting specified for a service class to make the scheduling decision among active service classes in the WRR subset.')
rmTrafficShaperIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1), )
if mibBuilder.loadTexts: rmTrafficShaperIfTable.setStatus('current')
if mibBuilder.loadTexts: rmTrafficShaperIfTable.setDescription('The (conceptual) table containing ATM Traffic Shaper configuration and state information for ATM interfaces.')
rmTrafficShaperIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: rmTrafficShaperIfEntry.setStatus('current')
if mibBuilder.loadTexts: rmTrafficShaperIfEntry.setDescription("An entry (conceptual row) in the rmTrafficShaperIfTable containing Traffic Shaper configuration and state information for an ATM interface. The particular interface is identified by the value of MIB-II's ifIndex.")
rtsIfMaxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfMaxThreshold.setStatus('current')
if mibBuilder.loadTexts: rtsIfMaxThreshold.setDescription('This object reflects the value of the Maximum Threshold installed in the traffic shaper hardware for this interface. This object is expressed in number of cell buffers. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 2), Gauge32()).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfCellCount.setStatus('current')
if mibBuilder.loadTexts: rtsIfCellCount.setDescription('This object contains the count of cells queued to this interface in the traffic shaping hardware. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfVbrCfgRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("shapingDisable", 1), ("shapeToPcr", 2), ("shapeToScrAndPcr", 3))).clone('shapingDisable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfVbrCfgRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrCfgRequested.setDescription("If this object is set to the value 'shapingDisable', VBR connections(VC or VP) on this interface will not be shaped. If the object is set to the value 'shapeToScrAndPcr', the VBR (VC or VP) connections on this interface will be shaped to conform to their respective SCR, PCR and MBS traffic parameters. If this object is set to the value 'shapeToPcr', the VBR (VC or VP) connections on this interface will be shaped to conform to their respective PCR traffic parameter. Depending on the capabilities of the traffic shaping hardware, the changes to the traffic shaping configuration may or may not take effect immediately and may require that the traffic shaping hardware be reset to effect the change. The value of the object rtsIfVbrCfgInstalled will reflect the actual VBR Traffic Shaping configuration installed in the hardware currently. Depending on the capabilities of the traffic shaping hardware, the value of this object may or may not apply to terminating VBR VPs on this interface. This object is not instantiated for interfaces to which it cannot be applied.")
rtsIfVbrCfgInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("shapingDisable", 1), ("shapeToPcr", 2), ("shapeToScrAndPcr", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfVbrCfgInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrCfgInstalled.setDescription('This object reflects the current VBR Traffic Shaping configuration installed in the hardware. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfBeCfgRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shapingDisable", 1), ("shapeToPcr", 2))).clone('shapingDisable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfBeCfgRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeCfgRequested.setDescription("This object reflects the traffic shaping configuration applied to Best-Effort Connections(VC or VP) belonging to UBR and ABR service categories on this interface. If this object is set to the value 'shapingDisable', best-effort connections(VC or VP) on this interface will not be shaped. If this object is set to the value 'shapeToPcr', the best-effort connections(VC or VP) on this interface will be shaped to conform to their respective PCR traffic parameter. Depending on the capabilities of the traffic shaping hardware, the changes to the traffic shaping configuration may or may not take effect immediately and may require that the traffic shaping hardware be reset to effect the change. The object rtsIfBeCfgInstalled will reflect the actual best-effort Traffic Shaping configuration installed in the hardware currently. Depending on the capabilities of the traffic shaping hardware, the value of this object may or may not apply to terminating best-effort VPs on this interface. This object is not instantiated for interfaces to which it cannot be applied.")
rtsIfBeCfgInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shapingDisable", 1), ("shapeToPcr", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfBeCfgInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeCfgInstalled.setDescription('This object reflects the current Best-Effort Traffic Shaping configuration installed in the hardware. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfVbrClassMaxThrshRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 95))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfVbrClassMaxThrshRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrClassMaxThrshRequested.setDescription("This object specifies the Traffic Shaper Maximum Cell Buffer Threshold for the VBR Traffic Class. The value of this object is expressed as a percent of the value of rtsIfMaxThreshold object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down'. The Traffic Shaping hardware may not have the support to represent all the values and hence the value installed in hardware could be different. And the value installed in hardware will be available through the object rtsIfVbrClassMaxThrshInstalled. This object is not instantiated for interfaces to which it cannot be applied.")
rtsIfVbrClassMaxThrshInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfVbrClassMaxThrshInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrClassMaxThrshInstalled.setDescription('This object reflects the value of Maximum Class Threshold for VBR Traffic Class, in number of cell buffers, that is installed in the Traffic Shaping hardware. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfBeClassMaxThrshRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 95))).setUnits('percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfBeClassMaxThrshRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeClassMaxThrshRequested.setDescription("This object specifies the Traffic Shaper Maximum Cell Buffer Threshold for the Best-Effort Traffic Class. The value of this object is expressed as a percent of the value of rtsIfMaxThreshold object. A set request for this object will succeed only if the value of the ifAdminStatus object for this interface is 'down'. The Traffic Shaping hardware may not have the support to represent all the values and hence the value installed in hardware could be different. And this installed value will be available through the object rtsIfBeClassMaxThrshInstalled. This object is not instantiated for interfaces to which it cannot be applied.")
rtsIfBeClassMaxThrshInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfBeClassMaxThrshInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeClassMaxThrshInstalled.setDescription('This object reflects the value of Maximum Class Threshold for Best-Effort Traffic Class, in number of cell buffers, that is installed in the Traffic Shaping hardware. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfVbrVcMaxThrshRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(512)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfVbrVcMaxThrshRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrVcMaxThrshRequested.setDescription('This object reflects the Maximum Threshold of the per-connection queues of VBR connections(VCs or VPs) in the traffic shaping hardware. The value of this object is expressed in number of cell buffers. Any change made to the value of this object will only effect subsequently established VBR connections and will not impact already existing VBR connections. The Traffic Shaping hardware may not have the support to represent all the values and hence the value installed in hardware could be different. And the value installed in hardware will be available through the object rtsIfVbrVcMaxThrshInstalled. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfVbrVcMaxThrshInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfVbrVcMaxThrshInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfVbrVcMaxThrshInstalled.setDescription('This object reflects the Maximum Threshold for the per-connection queues of VBR connections(VCs or VPs) that is installed in the Traffic Shaping hardware. The value of this object is expressed in number of cell buffers. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfBeVcMaxThrshRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1024)).setUnits('cells').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rtsIfBeVcMaxThrshRequested.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeVcMaxThrshRequested.setDescription('This object reflects the Maximum Threshold of the per-connection queues of best-effort connections(VCs or VPs) in the traffic shaping hardware. The value of this object is expressed in number of cell buffers. Any change made to the value of this object will only effect subsequently established best-effort connections and will not impact already existing best-effort connections. The Traffic Shaping hardware may not have the support to represent all the values and hence the value installed in hardware could be different. And the value installed in hardware will be available through the object rtsIfBeVcMaxThrshInstalled. This object is not instantiated for interfaces to which it cannot be applied.')
rtsIfBeVcMaxThrshInstalled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 10, 1, 10, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('cells').setMaxAccess("readonly")
if mibBuilder.loadTexts: rtsIfBeVcMaxThrshInstalled.setStatus('current')
if mibBuilder.loadTexts: rtsIfBeVcMaxThrshInstalled.setDescription('This object reflects the Maximum Threshold for the per-connection queues of Best-Effort connections(VCs or VPs) that is installed in the Traffic Shaping hardware. The value of this object is expressed in number of cell buffers. This object is not instantiated for interfaces to which it cannot be applied.')
ciscoAtmRmMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 3))
ciscoAtmRmMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1))
ciscoAtmRmMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2))
ciscoAtmRmMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 1)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance = ciscoAtmRmMIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 2)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance2 = ciscoAtmRmMIBCompliance2.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance2.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 3)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance3 = ciscoAtmRmMIBCompliance3.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance3.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance4 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 4)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance4 = ciscoAtmRmMIBCompliance4.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance4.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance5 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 5)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance5 = ciscoAtmRmMIBCompliance5.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance5.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance6 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 6)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance6 = ciscoAtmRmMIBCompliance6.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance6.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance7 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 7)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup4"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup4"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance7 = ciscoAtmRmMIBCompliance7.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance7.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance8 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 8)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup4"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance8 = ciscoAtmRmMIBCompliance8.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance8.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance9 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 9)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup4"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance9 = ciscoAtmRmMIBCompliance9.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance9.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance10 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 10)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance10 = ciscoAtmRmMIBCompliance10.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance10.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance11 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 11)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance11 = ciscoAtmRmMIBCompliance11.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance11.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance12 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 12)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "atmRmTrafficShaperIfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance12 = ciscoAtmRmMIBCompliance12.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance12.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
ciscoAtmRmMIBCompliance13 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 1, 13)).setObjects(("CISCO-ATM-RM-MIB", "atmRmSwitchCfgMIBGroup2"), ("CISCO-ATM-RM-MIB", "atmRmPhyIfCfgMIBGroup5"), ("CISCO-ATM-RM-MIB", "atmRmAllIfCfgMIBGroup6"), ("CISCO-ATM-RM-MIB", "atmRmIfAllStateMIBGroup3"), ("CISCO-ATM-RM-MIB", "atmRmIfStatsMIBGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "cgrPerVcqAtmRmGroup2"), ("CISCO-ATM-RM-MIB", "atmRmTrafficShaperIfGroup"), ("CISCO-ATM-RM-MIB", "sharedMemAtmRmSwitchMIBGroup"), ("CISCO-ATM-RM-MIB", "sharedMemAtmRmPhyIfMIBGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoAtmRmMIBCompliance13 = ciscoAtmRmMIBCompliance13.setStatus('current')
if mibBuilder.loadTexts: ciscoAtmRmMIBCompliance13.setDescription('The compliance statement for the Cisco ATM Resource Management MIB.')
atmRmSwitchCfgMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 1)).setObjects(("CISCO-ATM-RM-MIB", "rmSwitchOverSubFactor"), ("CISCO-ATM-RM-MIB", "rmSwitchScrMarginFactor"), ("CISCO-ATM-RM-MIB", "rmSwitchAbrCongNotify"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosMaxCtd"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosPeakToPeakCdv"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosClr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmSwitchCfgMIBGroup = atmRmSwitchCfgMIBGroup.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmSwitchCfgMIBGroup.setDescription('A collection of objects which provide ATM Switch Resource Management configuration.')
sharedMemAtmRmSwitchMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 2)).setObjects(("CISCO-ATM-RM-MIB", "sharedMemRmSwitchQueuedCellLimit"), ("CISCO-ATM-RM-MIB", "sharedMemRmSwitchQueuedCellCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sharedMemAtmRmSwitchMIBGroup = sharedMemAtmRmSwitchMIBGroup.setStatus('current')
if mibBuilder.loadTexts: sharedMemAtmRmSwitchMIBGroup.setDescription('A collection of objects which provide ATM Switch Resource Management information global to a shared-memory ATM switch.')
atmRmPhyIfCfgMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 3)).setObjects(("CISCO-ATM-RM-MIB", "rmIfOutPacingRateRequested"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingRateInstalled"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingForce"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAgg"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxVbr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmPhyIfCfgMIBGroup = atmRmPhyIfCfgMIBGroup.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmPhyIfCfgMIBGroup.setDescription('A collection of objects which provide ATM interface Resource Management configuration for physical interfaces.')
atmRmAllIfCfgMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 4)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup = atmRmAllIfCfgMIBGroup.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
atmRmIfAllStateMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 5)).setObjects(("CISCO-ATM-RM-MIB", "rmIfScRxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScRxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScNumSvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScNumPvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScTxMaxCtd"), ("CISCO-ATM-RM-MIB", "rmIfScTxP2PeakCdv"), ("CISCO-ATM-RM-MIB", "rmIfScTxClr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmIfAllStateMIBGroup = atmRmIfAllStateMIBGroup.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmIfAllStateMIBGroup.setDescription('A collection of objects which provide ATM interface Resource Management status for all interfaces.')
atmRmIfStatsMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 6)).setObjects(("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumAdmit"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumTotalRequests"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailTraffComb"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailBw"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailLoss"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailDelay"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailCdv"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailBeLimit"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailParmLimit"), ("CISCO-ATM-RM-MIB", "rmIfScRcacResultNumFailOther"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmIfStatsMIBGroup = atmRmIfStatsMIBGroup.setStatus('current')
if mibBuilder.loadTexts: atmRmIfStatsMIBGroup.setDescription('A collection of objects which provide ATM Switch Resource Management statistics.')
sharedMemAtmRmPhyIfMIBGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 7)).setObjects(("CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQServCategory"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQRequestedMaxSize"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQInstalledMaxSize"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQMaxSizeForce"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfOutputQCellCount"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfDiscardThreshold"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfEfciThreshold"), ("CISCO-ATM-RM-MIB", "sharedMemRmIfAbrRelativeRateThreshold"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    sharedMemAtmRmPhyIfMIBGroup = sharedMemAtmRmPhyIfMIBGroup.setStatus('current')
if mibBuilder.loadTexts: sharedMemAtmRmPhyIfMIBGroup.setDescription('A collection of objects which provide ATM interface Resource Management information for physical interfaces of a shared-memory ATM switch.')
atmRmSwitchCfgMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 8)).setObjects(("CISCO-ATM-RM-MIB", "rmSwitchOverSubFactor"), ("CISCO-ATM-RM-MIB", "rmSwitchScrMarginFactor"), ("CISCO-ATM-RM-MIB", "rmSwitchAbrCongNotify"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosMaxCtd"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosPeakToPeakCdv"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosClr"), ("CISCO-ATM-RM-MIB", "rmScDefaultQosClrClp01"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmSwitchCfgMIBGroup2 = atmRmSwitchCfgMIBGroup2.setStatus('current')
if mibBuilder.loadTexts: atmRmSwitchCfgMIBGroup2.setDescription('A collection of objects which provide ATM Switch Resource Management configuration.')
atmRmPhyIfCfgMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 9)).setObjects(("CISCO-ATM-RM-MIB", "rmIfOutPacingRateRequested"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingRateInstalled"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingForce"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAgg"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxVbr"), ("CISCO-ATM-RM-MIB", "rmIfCbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfAbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfUbrDefaultRxUpcTolerance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmPhyIfCfgMIBGroup2 = atmRmPhyIfCfgMIBGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmPhyIfCfgMIBGroup2.setDescription('A collection of objects which provide ATM interface Resource Management configuration for physical interfaces.')
atmRmIfAllStateMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 10)).setObjects(("CISCO-ATM-RM-MIB", "rmIfScRxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScRxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScNumSvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScNumPvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScTxMaxCtd"), ("CISCO-ATM-RM-MIB", "rmIfScTxP2PeakCdv"), ("CISCO-ATM-RM-MIB", "rmIfScTxClr"), ("CISCO-ATM-RM-MIB", "rmIfScTxClrClp01"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmIfAllStateMIBGroup2 = atmRmIfAllStateMIBGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmIfAllStateMIBGroup2.setDescription('A collection of objects which provide ATM interface Resource Management status for all interfaces.')
lsPerVcqAtmRmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 11)).setObjects(("CISCO-ATM-RM-MIB", "lsPerVcqRmIfMinWrrServiceClass"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmIfServClassConnType"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmIfServClassWrrWeight"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpMaxSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpQMaxSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpQMinSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpDiscThreshold"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpMarkThreshold"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpName"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpCellCount"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpServGroup"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lsPerVcqAtmRmGroup = lsPerVcqAtmRmGroup.setStatus('obsolete')
if mibBuilder.loadTexts: lsPerVcqAtmRmGroup.setDescription('A collection of objects which provide ATM Resource Management status on platforms using the Lightstream per-VC queueing chipset.')
atmRmPhyIfCfgMIBGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 12)).setObjects(("CISCO-ATM-RM-MIB", "rmIfOutPacingRateRequested"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingRateInstalled"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingForce"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAgg"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxVbr"), ("CISCO-ATM-RM-MIB", "rmIfCbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfAbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfUbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinUbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxUbr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmPhyIfCfgMIBGroup3 = atmRmPhyIfCfgMIBGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmPhyIfCfgMIBGroup3.setDescription('A collection of objects which provide ATM interface Resource Management configuration for physical interfaces.')
atmRmAllIfCfgMIBGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 13)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrCdvt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup2 = atmRmAllIfCfgMIBGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup2.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
atmRmAllIfCfgMIBGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 14)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrCdvt"), ("CISCO-ATM-RM-MIB", "rmIfServCategorySupport"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup3 = atmRmAllIfCfgMIBGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup3.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
lsPerVcqAtmRmGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 15)).setObjects(("CISCO-ATM-RM-MIB", "lsPerVcqRmIfMinWrrServiceClass"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmIfServClassConnType"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmIfServClassWrrWeight"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpMaxSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpQMaxSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpQMinSize"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpDiscThreshold"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpMarkThreshold"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpName"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpCellCount"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmThreshGrpServGroup"), ("CISCO-ATM-RM-MIB", "lsPerVcqRmHierarchicalSchedulingMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    lsPerVcqAtmRmGroup2 = lsPerVcqAtmRmGroup2.setStatus('current')
if mibBuilder.loadTexts: lsPerVcqAtmRmGroup2.setDescription('A collection of objects which provide ATM Resource Management status on platforms using the Lightstream per-VC queueing chipset.')
cgrPerVcqAtmRmGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 16)).setObjects(("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpQMaxSize"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpQMinSize"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpDiscThreshold"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpMarkThreshold"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpName"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpCellCount"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpServGroup"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmHierarchicalSchedulingMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cgrPerVcqAtmRmGroup = cgrPerVcqAtmRmGroup.setStatus('obsolete')
if mibBuilder.loadTexts: cgrPerVcqAtmRmGroup.setDescription('A collection of objects which provide ATM Resource Management status on the Catalyst8540MSR platform.')
atmRmAllIfCfgMIBGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 17)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrCdvt"), ("CISCO-ATM-RM-MIB", "rmIfServCategorySupport"), ("CISCO-ATM-RM-MIB", "rmIfCbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfAbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfUbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcCdvt"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup4 = atmRmAllIfCfgMIBGroup4.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup4.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
atmRmPhyIfCfgMIBGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 18)).setObjects(("CISCO-ATM-RM-MIB", "rmIfOutPacingRateRequested"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingRateInstalled"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingForce"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAgg"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinUbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxUbr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmPhyIfCfgMIBGroup4 = atmRmPhyIfCfgMIBGroup4.setStatus('obsolete')
if mibBuilder.loadTexts: atmRmPhyIfCfgMIBGroup4.setDescription('A collection of objects which provide ATM interface Resource Management configuration for physical interfaces.')
atmRmPhyIfCfgMIBGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 19)).setObjects(("CISCO-ATM-RM-MIB", "rmIfOutPacingRateRequested"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingRateInstalled"), ("CISCO-ATM-RM-MIB", "rmIfOutPacingForce"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAgg"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxCbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxVbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxAbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMinUbr"), ("CISCO-ATM-RM-MIB", "rmIfDirControlLinkShareMaxUbr"), ("CISCO-ATM-RM-MIB", "rmIfFramingOverhead"), ("CISCO-ATM-RM-MIB", "rmIfFramingOverheadForce"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmPhyIfCfgMIBGroup5 = atmRmPhyIfCfgMIBGroup5.setStatus('current')
if mibBuilder.loadTexts: atmRmPhyIfCfgMIBGroup5.setDescription('A collection of objects which provide ATM interface Resource Management configuration for physical interfaces.')
atmRmIfAllStateMIBGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 20)).setObjects(("CISCO-ATM-RM-MIB", "rmIfScRxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAcr"), ("CISCO-ATM-RM-MIB", "rmIfScRxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxAlcr"), ("CISCO-ATM-RM-MIB", "rmIfScNumSvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScNumPvxConns"), ("CISCO-ATM-RM-MIB", "rmIfScTxMaxCtd"), ("CISCO-ATM-RM-MIB", "rmIfScTxP2PeakCdv"), ("CISCO-ATM-RM-MIB", "rmIfScTxClr"), ("CISCO-ATM-RM-MIB", "rmIfScTxClrClp01"), ("CISCO-ATM-RM-MIB", "rmIfScRxDynBwSvcAcr"), ("CISCO-ATM-RM-MIB", "rmIfScTxDynBwSvcAcr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmIfAllStateMIBGroup3 = atmRmIfAllStateMIBGroup3.setStatus('current')
if mibBuilder.loadTexts: atmRmIfAllStateMIBGroup3.setDescription('A collection of objects which provide ATM interface Resource Management status for all interfaces.')
atmRmAllIfCfgMIBGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 21)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrCdvt"), ("CISCO-ATM-RM-MIB", "rmIfServCategorySupport"), ("CISCO-ATM-RM-MIB", "rmIfCbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfAbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfUbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfOverBooking"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup5 = atmRmAllIfCfgMIBGroup5.setStatus('deprecated')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup5.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
cgrPerVcqAtmRmGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 22)).setObjects(("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpQMaxSize"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpQMinSize"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpDiscThreshold"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpMaxSize"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpMarkThreshold"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpName"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpCellCount"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmThreshGrpServGroup"), ("CISCO-ATM-RM-MIB", "cgrPerVcqRmHierarchicalSchedulingMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cgrPerVcqAtmRmGroup2 = cgrPerVcqAtmRmGroup2.setStatus('current')
if mibBuilder.loadTexts: cgrPerVcqAtmRmGroup2.setDescription('A collection of objects which provide ATM Resource Management status on the Catalyst8540MSR platform.')
atmRmTrafficShaperIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 23)).setObjects(("CISCO-ATM-RM-MIB", "rtsIfMaxThreshold"), ("CISCO-ATM-RM-MIB", "rtsIfCellCount"), ("CISCO-ATM-RM-MIB", "rtsIfVbrCfgRequested"), ("CISCO-ATM-RM-MIB", "rtsIfVbrCfgInstalled"), ("CISCO-ATM-RM-MIB", "rtsIfBeCfgRequested"), ("CISCO-ATM-RM-MIB", "rtsIfBeCfgInstalled"), ("CISCO-ATM-RM-MIB", "rtsIfVbrClassMaxThrshRequested"), ("CISCO-ATM-RM-MIB", "rtsIfVbrClassMaxThrshInstalled"), ("CISCO-ATM-RM-MIB", "rtsIfBeClassMaxThrshRequested"), ("CISCO-ATM-RM-MIB", "rtsIfBeClassMaxThrshInstalled"), ("CISCO-ATM-RM-MIB", "rtsIfVbrVcMaxThrshRequested"), ("CISCO-ATM-RM-MIB", "rtsIfVbrVcMaxThrshInstalled"), ("CISCO-ATM-RM-MIB", "rtsIfBeVcMaxThrshRequested"), ("CISCO-ATM-RM-MIB", "rtsIfBeVcMaxThrshInstalled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmTrafficShaperIfGroup = atmRmTrafficShaperIfGroup.setStatus('current')
if mibBuilder.loadTexts: atmRmTrafficShaperIfGroup.setDescription('A collection of objects which provide ATM Traffic Shaper configuration and state information for ATM interfaces.')
atmRmAllIfCfgMIBGroup6 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 10, 3, 2, 24)).setObjects(("CISCO-ATM-RM-MIB", "rmIfLinkDistance"), ("CISCO-ATM-RM-MIB", "rmIfBestEffortLimit"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxCbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrScr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrPcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrTolerance"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxAbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxUbrMcr"), ("CISCO-ATM-RM-MIB", "rmIfDirMaxVbrCdvt"), ("CISCO-ATM-RM-MIB", "rmIfServCategorySupport"), ("CISCO-ATM-RM-MIB", "rmIfCbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfAbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfUbrDefaultRxUpcTolerance"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtDefaultRxUpcCdvt"), ("CISCO-ATM-RM-MIB", "rmIfOverBooking"), ("CISCO-ATM-RM-MIB", "rmIfVbrRtPerClassOverbooking"), ("CISCO-ATM-RM-MIB", "rmIfVbrNrtPerClassOverbooking"), ("CISCO-ATM-RM-MIB", "rmIfAbrPerClassOverbooking"), ("CISCO-ATM-RM-MIB", "rmIfUbrPerClassOverbooking"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmAllIfCfgMIBGroup6 = atmRmAllIfCfgMIBGroup6.setStatus('current')
if mibBuilder.loadTexts: atmRmAllIfCfgMIBGroup6.setDescription('A collection of objects which provide ATM interface Resource Management configuration for all interfaces.')
mibBuilder.exportSymbols("CISCO-ATM-RM-MIB", rmScDefaultQosClr=rmScDefaultQosClr, ciscoAtmRmMIBCompliance3=ciscoAtmRmMIBCompliance3, atmRmAllIfCfgMIBGroup5=atmRmAllIfCfgMIBGroup5, rmIfAbrPerClassOverbooking=rmIfAbrPerClassOverbooking, ciscoAtmRmMIB=ciscoAtmRmMIB, atmRmIfAllStateMIBGroup3=atmRmIfAllStateMIBGroup3, sharedMemRmSwitchQueuedCellLimit=sharedMemRmSwitchQueuedCellLimit, LsPerVcqThresholdGroupService=LsPerVcqThresholdGroupService, ciscoAtmRmMIBCompliance10=ciscoAtmRmMIBCompliance10, rmIfServiceCategoryStateEntry=rmIfServiceCategoryStateEntry, cgrPerVcqRmThreshGrpDiscThreshold=cgrPerVcqRmThreshGrpDiscThreshold, rmIfDirControlLinkShareMinVbr=rmIfDirControlLinkShareMinVbr, sharedMemRmCellPriority=sharedMemRmCellPriority, ciscoAtmRmSwitchSharedMem=ciscoAtmRmSwitchSharedMem, rmIfCfgTable=rmIfCfgTable, ciscoAtmRmIfState=ciscoAtmRmIfState, ciscoAtmRmSwitchCfg=ciscoAtmRmSwitchCfg, lsPerVcqRmHierarchicalSchedulingMode=lsPerVcqRmHierarchicalSchedulingMode, atmRmAllIfCfgMIBGroup3=atmRmAllIfCfgMIBGroup3, sharedMemRmSwitchQueuedCellCount=sharedMemRmSwitchQueuedCellCount, atmRmPhyIfCfgMIBGroup3=atmRmPhyIfCfgMIBGroup3, lsPerVcqRmThreshGrpTable=lsPerVcqRmThreshGrpTable, rtsIfBeClassMaxThrshInstalled=rtsIfBeClassMaxThrshInstalled, rmScDefaultQosMaxCtd=rmScDefaultQosMaxCtd, lsPerVcqRmThreshGrpMaxSize=lsPerVcqRmThreshGrpMaxSize, LsPerVcqServiceClassNoC1=LsPerVcqServiceClassNoC1, rmDefaultQosObjectiveEntry=rmDefaultQosObjectiveEntry, cgrPerVcqRmThreshGrpName=cgrPerVcqRmThreshGrpName, rmTrafficShaperIfEntry=rmTrafficShaperIfEntry, rmIfCfgEntry=rmIfCfgEntry, rmIfVbrNrtPerClassOverbooking=rmIfVbrNrtPerClassOverbooking, atmRmAllIfCfgMIBGroup2=atmRmAllIfCfgMIBGroup2, rtsIfCellCount=rtsIfCellCount, rmIfDirection=rmIfDirection, cgrPerVcqRmThreshGrpMarkThreshold=cgrPerVcqRmThreshGrpMarkThreshold, rmIfServCategorySupport=rmIfServCategorySupport, sharedMemRmIfOutputQMaxSizeForce=sharedMemRmIfOutputQMaxSizeForce, rmIfScNumSvxConns=rmIfScNumSvxConns, cgrPerVcqRmThreshGrpTable=cgrPerVcqRmThreshGrpTable, FineQueueThreshold=FineQueueThreshold, rmIfVbrRtDefaultRxUpcTolerance=rmIfVbrRtDefaultRxUpcTolerance, rmIfLinkDistance=rmIfLinkDistance, LsPerVcqServiceClass=LsPerVcqServiceClass, rmIfAbrDefaultRxUpcTolerance=rmIfAbrDefaultRxUpcTolerance, sharedMemRmIfOutputQRequestedMaxSize=sharedMemRmIfOutputQRequestedMaxSize, rtsIfBeCfgRequested=rtsIfBeCfgRequested, rmIfServiceCategoryStatisticsTable=rmIfServiceCategoryStatisticsTable, rmIfDirControlLinkShareMaxVbr=rmIfDirControlLinkShareMaxVbr, lsPerVcqRmIfTable=lsPerVcqRmIfTable, atmRmAllIfCfgMIBGroup=atmRmAllIfCfgMIBGroup, rmIfScRcacResultNumFailBeLimit=rmIfScRcacResultNumFailBeLimit, rtsIfVbrVcMaxThrshInstalled=rtsIfVbrVcMaxThrshInstalled, atmRmSwitchCfgMIBGroup=atmRmSwitchCfgMIBGroup, ciscoAtmRmMIBCompliance5=ciscoAtmRmMIBCompliance5, lsPerVcqRmIfServiceClassTable=lsPerVcqRmIfServiceClassTable, rmIfScRcacResultNumTotalRequests=rmIfScRcacResultNumTotalRequests, atmRmPhyIfCfgMIBGroup2=atmRmPhyIfCfgMIBGroup2, rmIfFramingOverheadForce=rmIfFramingOverheadForce, cgrPerVcqRmThreshGrp=cgrPerVcqRmThreshGrp, rmIfScRcacResultNumFailCdv=rmIfScRcacResultNumFailCdv, rmIfScRcacResultNumFailOther=rmIfScRcacResultNumFailOther, rmIfServiceCategoryStateTable=rmIfServiceCategoryStateTable, cgrPerVcqRmThreshGrpMaxSize=cgrPerVcqRmThreshGrpMaxSize, rmIfVbrRtDefaultRxUpcCdvt=rmIfVbrRtDefaultRxUpcCdvt, rmIfUbrPerClassOverbooking=rmIfUbrPerClassOverbooking, ciscoAtmRmMIBCompliance2=ciscoAtmRmMIBCompliance2, ciscoAtmRmMIBGroups=ciscoAtmRmMIBGroups, ciscoAtmRmMIBCompliance4=ciscoAtmRmMIBCompliance4, rmIfDirMaxAbrTolerance=rmIfDirMaxAbrTolerance, rmIfScTxMaxCtd=rmIfScTxMaxCtd, lsPerVcqRmThreshGrpDiscThreshold=lsPerVcqRmThreshGrpDiscThreshold, ciscoLsPerVcqAtmRmSwitch=ciscoLsPerVcqAtmRmSwitch, atmRmAllIfCfgMIBGroup4=atmRmAllIfCfgMIBGroup4, ciscoAtmRmMIBCompliance=ciscoAtmRmMIBCompliance, rmIfDirControlLinkShareMaxAgg=rmIfDirControlLinkShareMaxAgg, rmIfDirControlLinkShareMaxUbr=rmIfDirControlLinkShareMaxUbr, rmIfDirMaxUbrPcr=rmIfDirMaxUbrPcr, sharedMemAtmRmPhyIfMIBGroup=sharedMemAtmRmPhyIfMIBGroup, ciscoAtmRmIfSharedMem=ciscoAtmRmIfSharedMem, cgrPerVcqRmThreshGrpServiceTable=cgrPerVcqRmThreshGrpServiceTable, ciscoAtmRmMIBCompliance8=ciscoAtmRmMIBCompliance8, rmIfScTxP2PeakCdv=rmIfScTxP2PeakCdv, rmDefaultQosObjectiveTable=rmDefaultQosObjectiveTable, rmDefaultQosServiceCategory=rmDefaultQosServiceCategory, ciscoAtmRmMIBCompliance7=ciscoAtmRmMIBCompliance7, rmIfScRcacResultNumFailLoss=rmIfScRcacResultNumFailLoss, rtsIfBeCfgInstalled=rtsIfBeCfgInstalled, atmRmPhyIfCfgMIBGroup=atmRmPhyIfCfgMIBGroup, rtsIfBeVcMaxThrshRequested=rtsIfBeVcMaxThrshRequested, ciscoAtmRmMIBConformance=ciscoAtmRmMIBConformance, rmIfSc=rmIfSc, rmIfDirMaxUbrMcr=rmIfDirMaxUbrMcr, rmIfScNumPvxConns=rmIfScNumPvxConns, lsPerVcqRmIfServiceClass=lsPerVcqRmIfServiceClass, rmIfOutPacingRateInstalled=rmIfOutPacingRateInstalled, lsPerVcqRmIfServClassWrrWeight=lsPerVcqRmIfServClassWrrWeight, lsPerVcqRmThreshGrpServiceTable=lsPerVcqRmThreshGrpServiceTable, rmIfVbrRtPerClassOverbooking=rmIfVbrRtPerClassOverbooking, CgrPerVcqModuleId=CgrPerVcqModuleId, rmIfDirMaxVbrPcr=rmIfDirMaxVbrPcr, rtsIfVbrCfgRequested=rtsIfVbrCfgRequested, rmIfScRcacResultNumFailParmLimit=rmIfScRcacResultNumFailParmLimit, atmRmIfAllStateMIBGroup2=atmRmIfAllStateMIBGroup2, ciscoAtmRmIfCfg=ciscoAtmRmIfCfg, cgrPerVcqAtmRmGroup2=cgrPerVcqAtmRmGroup2, PYSNMP_MODULE_ID=ciscoAtmRmMIB, sharedMemRmIfOutputQCfgTable=sharedMemRmIfOutputQCfgTable, atmRmPhyIfCfgMIBGroup4=atmRmPhyIfCfgMIBGroup4, rmIfOverBooking=rmIfOverBooking, rmIfScTxAcr=rmIfScTxAcr, rmIfDirMaxVbrScr=rmIfDirMaxVbrScr, rmIfScTxDynBwSvcAcr=rmIfScTxDynBwSvcAcr, rmIfScRcacResultNumFailDelay=rmIfScRcacResultNumFailDelay, lsPerVcqRmThreshGrpCellCount=lsPerVcqRmThreshGrpCellCount, rmIfDirectionCfgTable=rmIfDirectionCfgTable, rmIfBestEffortLimit=rmIfBestEffortLimit, rmSwitchOverSubFactor=rmSwitchOverSubFactor, rmIfDirMaxVbrTolerance=rmIfDirMaxVbrTolerance, sharedMemRmIfOutputQ=sharedMemRmIfOutputQ, rtsIfBeClassMaxThrshRequested=rtsIfBeClassMaxThrshRequested, atmRmIfStatsMIBGroup=atmRmIfStatsMIBGroup, lsPerVcqAtmRmGroup=lsPerVcqAtmRmGroup, ciscoCgrPerVcqAtmRmSwitch=ciscoCgrPerVcqAtmRmSwitch, lsPerVcqRmIfServClassConnType=lsPerVcqRmIfServClassConnType, rmIfDirMaxVbrCdvt=rmIfDirMaxVbrCdvt, rmIfOutPacingForce=rmIfOutPacingForce, lsPerVcqRmIfEntry=lsPerVcqRmIfEntry, cgrPerVcqRmThreshGrpCellCount=cgrPerVcqRmThreshGrpCellCount, lsPerVcqAtmRmGroup2=lsPerVcqAtmRmGroup2, ForceValue=ForceValue, sharedMemRmIfThresholdCfgTable=sharedMemRmIfThresholdCfgTable, lsPerVcqRmThreshGrpServGroup=lsPerVcqRmThreshGrpServGroup, lsPerVcqRmThreshGrp=lsPerVcqRmThreshGrp, lsPerVcqRmThreshGrpService=lsPerVcqRmThreshGrpService, ciscoLsPerVcqAtmRmIf=ciscoLsPerVcqAtmRmIf, rmIfDirectionCfgEntry=rmIfDirectionCfgEntry, rmIfScRcacResultNumFailTraffComb=rmIfScRcacResultNumFailTraffComb, rmIfFramingOverhead=rmIfFramingOverhead, sharedMemRmIfOutputQInstalledMaxSize=sharedMemRmIfOutputQInstalledMaxSize, rmIfDirMaxAbrMcr=rmIfDirMaxAbrMcr, sharedMemRmIfAbrRelativeRateThreshold=sharedMemRmIfAbrRelativeRateThreshold, rmScDefaultQosPeakToPeakCdv=rmScDefaultQosPeakToPeakCdv, ciscoAtmRmMIBCompliance13=ciscoAtmRmMIBCompliance13, rmIfDirControlLinkShareMaxCbr=rmIfDirControlLinkShareMaxCbr, sharedMemRmIfOutputQServCategory=sharedMemRmIfOutputQServCategory, rmIfScRxDynBwSvcAcr=rmIfScRxDynBwSvcAcr, rmIfScRxAlcr=rmIfScRxAlcr, lsPerVcqRmThreshGrpName=lsPerVcqRmThreshGrpName, rmTrafficShaperIfTable=rmTrafficShaperIfTable, sharedMemRmIfDiscardThreshold=sharedMemRmIfDiscardThreshold, rmIfDirControlLinkShareMinAbr=rmIfDirControlLinkShareMinAbr, rmIfDirMaxAbrPcr=rmIfDirMaxAbrPcr, LsPerVcqThresholdGroup=LsPerVcqThresholdGroup, sharedMemAtmRmSwitchMIBGroup=sharedMemAtmRmSwitchMIBGroup, sharedMemRmSwitchQueuedCellTable=sharedMemRmSwitchQueuedCellTable, rmIfOutPacingRateRequested=rmIfOutPacingRateRequested, cgrPerVcqRmHierarchicalSchedulingMode=cgrPerVcqRmHierarchicalSchedulingMode, rtsIfMaxThreshold=rtsIfMaxThreshold, cgrPerVcqRmThreshGrpServGroup=cgrPerVcqRmThreshGrpServGroup, cgrPerVcqAtmRmGroup=cgrPerVcqAtmRmGroup, rmIfScRcacResultNumAdmit=rmIfScRcacResultNumAdmit, rmIfCbrDefaultRxUpcTolerance=rmIfCbrDefaultRxUpcTolerance, rmIfVbrNrtDefaultRxUpcTolerance=rmIfVbrNrtDefaultRxUpcTolerance, ciscoAtmRmIfStatistics=ciscoAtmRmIfStatistics, ciscoAtmRmMIBCompliance11=ciscoAtmRmMIBCompliance11, sharedMemRmSwitchQueuedCellEntry=sharedMemRmSwitchQueuedCellEntry, atmRmIfAllStateMIBGroup=atmRmIfAllStateMIBGroup, rmIfScTxClrClp01=rmIfScTxClrClp01, cgrPerVcqRmThreshGrpQMinSize=cgrPerVcqRmThreshGrpQMinSize, lsPerVcqRmThreshGrpQMaxSize=lsPerVcqRmThreshGrpQMaxSize, lsPerVcqRmIfServiceClassEntry=lsPerVcqRmIfServiceClassEntry, rtsIfVbrCfgInstalled=rtsIfVbrCfgInstalled, sharedMemRmIfThresholdCfgEntry=sharedMemRmIfThresholdCfgEntry, rmIfDirMaxCbrPcr=rmIfDirMaxCbrPcr, rtsIfBeVcMaxThrshInstalled=rtsIfBeVcMaxThrshInstalled, ciscoAtmRmTrafShaperIf=ciscoAtmRmTrafShaperIf, cgrPerVcqRmThreshGrpService=cgrPerVcqRmThreshGrpService, ciscoAtmRmMIBCompliance6=ciscoAtmRmMIBCompliance6, cgrPerVcqRmThreshGrpQMaxSize=cgrPerVcqRmThreshGrpQMaxSize, rmIfScTxAlcr=rmIfScTxAlcr, rmIfDirMaxUbrTolerance=rmIfDirMaxUbrTolerance, rmIfVbrNrtDefaultRxUpcCdvt=rmIfVbrNrtDefaultRxUpcCdvt, ciscoAtmRmMIBCompliance12=ciscoAtmRmMIBCompliance12, rmIfDirMaxCbrTolerance=rmIfDirMaxCbrTolerance, rtsIfVbrClassMaxThrshRequested=rtsIfVbrClassMaxThrshRequested, rmIfDirControlLinkShareMinUbr=rmIfDirControlLinkShareMinUbr, rmIfScRcacResultNumFailBw=rmIfScRcacResultNumFailBw, rmIfDirControlLinkShareMinCbr=rmIfDirControlLinkShareMinCbr, sharedMemRmIfOutputQCellCount=sharedMemRmIfOutputQCellCount, rmScDefaultQosClrClp01=rmScDefaultQosClrClp01, lsPerVcqRmThreshGrpMarkThreshold=lsPerVcqRmThreshGrpMarkThreshold, lsPerVcqRmIfMinWrrServiceClass=lsPerVcqRmIfMinWrrServiceClass, rmIfDirControlLinkShareMaxAbr=rmIfDirControlLinkShareMaxAbr, cgrPerVcqRmThreshGrpServiceEntry=cgrPerVcqRmThreshGrpServiceEntry, rmSwitchScrMarginFactor=rmSwitchScrMarginFactor, cgrPerVcqModuleId=cgrPerVcqModuleId, rtsIfVbrClassMaxThrshInstalled=rtsIfVbrClassMaxThrshInstalled, cgrPerVcqRmThreshGrpEntry=cgrPerVcqRmThreshGrpEntry, lsPerVcqRmThreshGrpServiceEntry=lsPerVcqRmThreshGrpServiceEntry, atmRmTrafficShaperIfGroup=atmRmTrafficShaperIfGroup, sharedMemRmIfEfciThreshold=sharedMemRmIfEfciThreshold, lsPerVcqRmThreshGrpQMinSize=lsPerVcqRmThreshGrpQMinSize, atmRmSwitchCfgMIBGroup2=atmRmSwitchCfgMIBGroup2, ciscoAtmRmMIBObjects=ciscoAtmRmMIBObjects, rmIfUbrDefaultRxUpcTolerance=rmIfUbrDefaultRxUpcTolerance, atmRmAllIfCfgMIBGroup6=atmRmAllIfCfgMIBGroup6, sharedMemRmIfOutputQCfgEntry=sharedMemRmIfOutputQCfgEntry, lsPerVcqRmThreshGrpEntry=lsPerVcqRmThreshGrpEntry, rmIfScTxClr=rmIfScTxClr, rmIfScRxAcr=rmIfScRxAcr, ciscoAtmRmMIBCompliance9=ciscoAtmRmMIBCompliance9, rmSwitchAbrCongNotify=rmSwitchAbrCongNotify, ciscoAtmRmMIBCompliances=ciscoAtmRmMIBCompliances, atmRmPhyIfCfgMIBGroup5=atmRmPhyIfCfgMIBGroup5, rmIfServiceCategoryStatisticsEntry=rmIfServiceCategoryStatisticsEntry, rtsIfVbrVcMaxThrshRequested=rtsIfVbrVcMaxThrshRequested)

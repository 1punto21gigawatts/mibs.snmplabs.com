#
# PySNMP MIB module GDCUAS7022-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCUAS7022-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, Counter64, iso, enterprises, Integer32, NotificationType, ModuleIdentity, TimeTicks, Unsigned32, MibIdentifier, Counter32, Bits, Gauge32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Counter64", "iso", "enterprises", "Integer32", "NotificationType", "ModuleIdentity", "TimeTicks", "Unsigned32", "MibIdentifier", "Counter32", "Bits", "Gauge32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
uas7022 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13))
uas7022Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 1))
uas7022Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 2))
uas7022Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 3))
uas7022Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 4))
uas7022Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 5))
uas7022Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6))
uas7022AlarmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 7))
uas7022MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
uas7022VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2), )
if mibBuilder.loadTexts: uas7022VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022VersionTable.setDescription('The 7022 version table ')
uas7022VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022VersionIndex"))
if mibBuilder.loadTexts: uas7022VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022VersionEntry.setDescription('An entry in the GDC uas7022 Version Table.')
uas7022VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022VersionIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (00)')
uas7022ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) Valid [i]nterface = 0')
uas7022StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) Valid [i]nterface = 0')
uas7022StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6), ("statDownloadAborted", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set uas7022SwitchActiveFirmware to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress statDownloadAborted(7) Download aborted by user Valid [i]nterface = 0')
uas7022SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in uas7022ActiveFirmwareRev to the version in uas7022StoredFirmwareRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set uas7022StoredStatus object to indicate results 5) If succesfull: update uas7022ActiveFirmwareRev and uas7022StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the uas7022StoredFirmwareStatus is not statOK(3) will result in an error. Valid [i]nterface = 0')
uas7022DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to UAS7022 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code Valid [i]nterface = 0')
uas7022MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1), )
if mibBuilder.loadTexts: uas7022MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022MaintenanceTable.setDescription('The uas7022 maintenance table.')
uas7022MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022MaintenanceLineIndex"))
if mibBuilder.loadTexts: uas7022MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022MaintenanceEntry.setDescription('An entry in the 7022 Maintenance Table.')
uas7022MaintenanceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022MaintenanceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022MaintenanceLineIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (00-02)')
uas7022SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(2), then the unit performs a soft reset, whose meaning is specific to the type of unit being managed. The value of norm(1) will be returned when the reset is complete. The value of norm(1) can not be set by management. Valid [i]nterface = 0')
uas7022SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count. Valid [i]nterface = 0')
uas7022DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("factoryDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(1) the unit will perform a reset to make the default configuration take affect. The value of normal(2) will be returned when the initialization is complete. The value of normal(2) can not be set by management. Valid [i]nterface = 0')
uas7022LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - future use bit 5 - INSV bit 4 - RSP bit 3 - TMG bit 2 - TM bit 1 - ALM bit 0 - future use Octet 2 bit 7 - not used bit 6 - future use bit 5 - NIUA AIS bit 4 - NIUA LCV bit 3 - NIUA LOS bit 2 - NIUA OOF bit 1 - future use bit 0 - future use Octet 3 bit 7 - not used bit 6 - ST- future use bit 5 - NIUB AIS bit 4 - NIUB LCV bit 3 - NIUB LOS bit 2 - NIUB OOF bit 1 - future use bit 0 - future use Valid [i]nterface = 0')
uas7022AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022AlarmStatus.setDescription('Returns a bit-wise Status of alarms Octet 1 bit 7 - not used bit 6 - NIUA_LOS bit 5 - NIUA_LOF bit 4 - NIUA_AIS bit 3 - NIUA_LCV bit 2 - NIUA TIMING LOSS bit 1 - NIUA_NE_ES bit 0 - NIUA_NE_BBE Octet 2 bit 7 - not used bit 6 - NIUA_NE_SES bit 5 - NIUA_NE_UAS bit 4 - NIUA_FE_ES bit 3 - NIUA_FE_BBE bit 2 - NIUA_FE_SES bit 1 - NIUA_FE_UAS bit 0 - NIUA_RAI Octet 3 bit 7 - not used bit 6 - NIUB_LOS bit 5 - NIUB_LOF bit 4 - NIUB_AIS bit 3 - NIUB_LCV bit 2 - NIUB TIMING LOSS bit 1 - NIUB_NE_ES bit 0 - NIUB_NE_BBE Octet 4 bit 7 - not used bit 6 - NIUB_NE_SES bit 5 - NIUB_NE_UAS bit 4 - NIUB_FE_ES bit 3 - NIUB_FE_BBE bit 2 - NIUB_FE_SES bit 1 - NIUB_FE_UAS bit 0 - NIUB_RAI Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - future use bit 1 - future use bit 0 - Power-up Alarm Valid [i]nterface = 0')
uas7022NearEndResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NearEndResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndResetStats.setDescription('Supports the action of soft resetting the uas7022NearEndValidIntervals object. When this object is set to reset(2), then the unit will reset the uas7022NearEndValidIntervals object to zero. The value of norm(1) can not be set by management. Valid [i]nterface = 1-2')
uas7022FarEndResetStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022FarEndResetStats.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndResetStats.setDescription('Supports the action of soft resetting the uas7022FarEndValidIntervals object. When this object is set to reset(2), then the unit will reset the uas7022FarEndValidIntervals object to zero. The value of norm(1) can not be set by management. Valid [i]nterface = 1-2')
uas7022NearEndStatLastInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndStatLastInit.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndStatLastInit.setDescription('Number of seconds from midnight Dec 31, 1969 up until uas7022NearEndValidIntervals was last initialized to zero Valid [i]nterface = 1-2')
uas7022FarEndStatLastInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndStatLastInit.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndStatLastInit.setDescription('Number of seconds from midnight Dec 31, 1969 up until uas7022FarEndValidIntervals was last initialized to zero Valid [i]nterface = 1-2')
uas7022NearEndValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 16 unless the interface was brought on-line within the last 4 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online. Valid [i]nterface = 1-2')
uas7022FarEndValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 16 unless the interface was brought on-line within the last 4 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online. Valid [i]nterface = 1-2')
uas7022NIUaCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NIUaCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NIUaCircuitID.setDescription('This variable is used for general purpose storage. Valid [i]nterface = 1')
uas7022SystemTimingGenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clk8khz", 2), ("clk4mhz", 3), ("clk8khzand4mhz", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022SystemTimingGenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SystemTimingGenStatus.setDescription('Indicates if the units configured for primary or secondary system clock are actually supplying clock and if it is the 8hkz, 4mhz, or both. Valid [i]nterface = 1-2')
uas7022NIUbCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 2, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NIUbCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NIUbCircuitID.setDescription('This variable is used for general purpose storage. Valid [i]nterface = 2')
uas7022ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1), )
if mibBuilder.loadTexts: uas7022ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ConfigTable.setDescription('The Configuration table.')
uas7022ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022ConfigIndex"))
if mibBuilder.loadTexts: uas7022ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ConfigEntry.setDescription('The Configuration table entry.')
uas7022ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ConfigIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022RcvrRange = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("short", 1), ("long", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022RcvrRange.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022RcvrRange.setDescription('Sets the receiver range to short (6dB) or long (36dB) Valid [i]nterface = 1-2')
uas7022Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cCSwithoutCRC4", 1), ("cASwithoutCRC4", 2), ("cCSwithCRC4", 3), ("cASwithCRC4", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022Framing.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022Framing.setDescription('Set the framing for the interface. Abbreviations are as follows: CCS - common-channel signaling CAS - channel-associated signaling Default is CAS If uas7022Framing is CAS then TimeSlot 16 contains idle code. If uas7022Framing is CCS then TimeSlot 16 contains either marks or user data. See uas7022TimeSlot16Content. Valid [i]nterface = 1-2')
uas7022SysTimingGen = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("primary", 2), ("secondary", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022SysTimingGen.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SysTimingGen.setDescription('Selects if the unit provides system timing. none(1) - does not provide Timing Generator primary(2) - unit is primary Timing Generator for the shelf. secondary(3) - unit is secondary Timing Generator for the shelf. Only 1 unit in the shelf can the primary or secondary timing generator. All other must be none. Valid [i]nterface = 1-2')
uas7022Highway = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notAssigned", 1), ("highway1", 2), ("highway2", 3), ("highway3", 4), ("highway4", 5), ("highway5", 6), ("highway6", 7), ("highway7", 8), ("highway8", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022Highway.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022Highway.setDescription('Defines the highway allocation. No two NIU interfaces in the shelf can be assigned to the same highway. Valid [i]nterface = 1-2')
uas7022TransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("recovered", 2), ("internal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022TransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TransmitClockSource.setDescription('Sets the transmit clock source. Valid [i]nterface = 1-2')
uas7022FallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("system", 1), ("recovered", 2), ("internal", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022FallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FallbackClockSource.setDescription('Identifies the fallback transmit clock source. Valid [i]nterface = 1-2')
uas7022InterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("unassigned", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022InterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022InterfaceType.setDescription('Sets the interface type. Valid [i]nterface = 1-2')
uas7022FDLMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022FDLMode.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FDLMode.setDescription('Sets the interface type. Valid [i]nterface = 1-2')
uas7022TimeSlot16Content = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("idle", 1), ("marks", 2), ("data", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022TimeSlot16Content.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TimeSlot16Content.setDescription('Selects the content for TimeSlot 16. Valid [i]nterface = 1-2')
uas7022Impedance = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("impedance120Ohm", 1), ("impedance75Ohm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022Impedance.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022Impedance.setDescription('Selects the impedance. Valid [i]nterface = 1-2')
uas7022DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1), )
if mibBuilder.loadTexts: uas7022DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DiagTable.setDescription('The Diagnostics table. Information in the entries of this table support diagnostics testing via loopbacks.')
uas7022DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022DiagIndex"))
if mibBuilder.loadTexts: uas7022DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DiagEntry.setDescription('The Diagnostics table entry.')
uas7022DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DiagIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022DiagConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLoop", 1), ("lineLoopback", 2), ("payloadLoopback", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022DiagConfig.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022DiagConfig.setDescription('Selects the test to run. noLoop(1) ends the test. Valid [i]nterface = 1-2')
uas7022TestLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("testTime10Mins", 1), ("testTime20Mins", 2), ("noLimit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022TestLimit.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TestLimit.setDescription('Selects the duration to run a diagnostic test. The value noLimit(3) signifies that the test should run indefinitely until explicitly terminated. Default value: testTime10Mins(1) Valid [i]nterface = 1-2')
uas7022TestExecutionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5))).clone(namedValues=NamedValues(("notInTest", 1), ("testInProgress", 2), ("testCompleted", 4), ("testCompletedNotInTest", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022TestExecutionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TestExecutionStatus.setDescription('This variable reports the status of a test. notInTest(1) indicates a test is not running. testInProgress(2) indicates that a test is currently running. testCompleted(4) indicates that a test has run and is completed. testCompletedNotInTest(5) indicates that a test has completed and it is no longer in test. Valid [i]nterface = 1-2')
uas7022TestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022TestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TestExceptions.setDescription('Indicates exceptions that have occurred that may affect interpretation of the test results. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 1 a timed test was preempted so the result cannot be viewed in relation to the test duration 2 the results overflowed so the result cannot be viewed as an absolute value 4 the test was performed while synchronization could not be performed so the result may not be accurate. Valid [i]nterface = 1-2')
uas7022NearEndCurrent15MinTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 1), )
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinTable.setDescription('The uas7022 Near End Current table.')
uas7022NearEndCurrent15MinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 1, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndCurrent15MinIndex"))
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinEntry.setDescription('An entry in the uas7022 Near End Current table.')
uas7022NearEndCurrent15MinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndCurrent15MinStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent15MinStat.setDescription('Returns a bitwise snapshot of the current 15Min statistics. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 Counter Overflow (>65535) LCV 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 LCV . 11.0 2^7 12.7 f/u 12.6 2^6 LCV . 12.0 2^0 Valid [i]nterface = 1-2')
uas7022NearEndIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 2), )
if mibBuilder.loadTexts: uas7022NearEndIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndIntervalTable.setDescription('The uas7022 Near End Interval table.')
uas7022NearEndIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 2, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndIntervalIndex"), (0, "GDCUAS7022-MIB", "uas7022NearEndIntervalNumber"))
if mibBuilder.loadTexts: uas7022NearEndIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndIntervalEntry.setDescription('An entry in the Near End Interval table.')
uas7022NearEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndIntervalIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndIntervalNumber.setDescription('The number of Errored Seconds encountered by an E1 interface in one of the previous 16, individual 15 minute, intervals.')
uas7022NearEndIntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndIntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndIntervalStat.setDescription('Returns a bitwise map of the interface in one of the previous 16, individual 15 minute, intervals. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 Counter Overflow (>65535) LCV 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 LCV . 11.0 2^7 12.7 f/u 12.6 2^6 LCV . 12.0 2^0 Valid [i]nterface = 1-2')
uas7022NearEndCurrent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 3), )
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrTable.setDescription('The Near End Current 24 Hr table.')
uas7022NearEndCurrent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 3, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndCurrent24HrIndex"))
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrEntry.setDescription('An entry in the Near End Current 24 hr table.')
uas7022NearEndCurrent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndCurrent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndCurrent24HrStat.setDescription('Returns a bitwise map of the current 24 hour table 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 13.7 f/u 13.6 f/u 13.5 f/u 13.4 f/u 13.3 f/u 13.2 1: Counter Overflow (>65535) LCV 13.1 2^15 13.0 2^14 14.7 f/u 14.6 2^13 LCV . 14.0 2^7 15.7 f/u 15.6 2^6 LCV . 15.0 2^0 Valid [i]nterface = 1-2')
uas7022NearEndRecent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 4), )
if mibBuilder.loadTexts: uas7022NearEndRecent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndRecent24HrTable.setDescription('The Near End Recent 24Hr table.')
uas7022NearEndRecent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 4, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndRecent24HrIndex"))
if mibBuilder.loadTexts: uas7022NearEndRecent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndRecent24HrEntry.setDescription('An entry in the E1 Total table.')
uas7022NearEndRecent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndRecent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndRecent24HrIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndRecent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(15, 15)).setFixedLength(15)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndRecent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndRecent24HrStat.setDescription('Returns a bitwise map of the current 24 hour table 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 13.7 f/u 13.6 f/u 13.5 f/u 13.4 f/u 13.3 f/u 13.2 1: Counter Overflow (>65535) LCV 13.1 2^15 13.0 2^14 14.7 f/u 14.6 2^13 LCV . 14.0 2^7 15.7 f/u 15.6 2^6 LCV . 15.0 2^0 Valid [i]nterface = 1-2')
uas7022NearEndUnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9), )
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegTable.setDescription('The uas7022 Near End Unavailable Time Register table.')
uas7022NearEndUnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndUnavailableTimeRegIndex"), (0, "GDCUAS7022-MIB", "uas7022NearEndUnavailableTimeRegNumber"))
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegEntry.setDescription('An entry in the Near End Unavailable Time Register table.')
uas7022NearEndUnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndUnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the NearEndUnavailable Time Register. Valid [i]nterface = 1-2')
uas7022NearEndUnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegStart.setDescription('Start time of one of the NearEndUnavailable Time Registers. Valid [i]nterface = 1-2')
uas7022NearEndUnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 9, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndUnavailableTimeRegStop.setDescription('Stop time of one of the NearEndUnavailable Time Registers. Valid [i]nterface = 1-2')
uas7022FarEndCurrent15MinTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 5), )
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinTable.setDescription('The uas7022 Far End Current 15 minute table.')
uas7022FarEndCurrent15MinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 5, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndCurrent15MinIndex"))
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinEntry.setDescription('An entry in the uas7022 Far End Current 15 Minute table.')
uas7022FarEndCurrent15MinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndCurrent15MinStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent15MinStat.setDescription('Returns a bitwise map of the far end interface in one of the previous 16, individual 15 minute, intervals. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 Valid [i]nterface = 1-2')
uas7022FarEndIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 6), )
if mibBuilder.loadTexts: uas7022FarEndIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndIntervalTable.setDescription('The uas7022 FarEnd Interval table.')
uas7022FarEndIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 6, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndIntervalIndex"), (0, "GDCUAS7022-MIB", "uas7022FarEndIntervalNumber"))
if mibBuilder.loadTexts: uas7022FarEndIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndIntervalEntry.setDescription('An entry in the Interval table.')
uas7022FarEndIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndIntervalIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndIntervalNumber.setDescription('A number between 1 and 16, where 1 is the most recently completed 15 minute interval and 16 is the least recently completed 15 minutes interval (assuming that all 16 intervals are valid).')
uas7022FarEndIntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(9, 9)).setFixedLength(9)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndIntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndIntervalStat.setDescription('Returns a bitwise map of statistics for the far end interface in the current 15 minute interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 2^9 ES . 1.0 2^7 2.7 f/u 2.6 2^6 . 2.0 2^0 3.7 f/u 3.6 f/u 3.5 f/u 3.4 f/u 3.3 f/u 3.2 2^9 SES . 3.0 2^7 4.7 f/u 4.6 2^6 SES . 4.0 2^0 5.7 f/u 5.6 f/u 5.5 f/u 5.4 f/u 5.3 f/u 5.2 Counter Overflow (>65535) BBE 5.1 2^15 5.0 2^14 6.7 f/u 6.6 2^13 BBE . 6.0 2^7 7.7 f/u 7.6 2^6 BBE . 7.0 2^0 8.7 f/u 8.6 f/u 8.5 f/u 8.4 f/u 8.3 f/u 8.2 2^9 UAS . 8.0 2^7 9.7 f/u 9.6 2^6 UAS . 9.0 2^0 Valid [i]nterface = 1-2')
uas7022FarEndCurrent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 7), )
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrTable.setDescription('The Far End Current 24 Hour table.')
uas7022FarEndCurrent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 7, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndCurrent24HrIndex"))
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrEntry.setDescription('An entry in the Far End Current 24 Hr table.')
uas7022FarEndCurrent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndCurrent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 7, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndCurrent24HrStat.setDescription('Returns a bitwise map of statistics for the interface in the current 24 hour interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 Valid [i]nterface = 1-2')
uas7022FarEndRecent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 8), )
if mibBuilder.loadTexts: uas7022FarEndRecent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndRecent24HrTable.setDescription('The Far End Recent 24 Hour table.')
uas7022FarEndRecent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 8, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndRecent24HrIndex"))
if mibBuilder.loadTexts: uas7022FarEndRecent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndRecent24HrEntry.setDescription('An entry in the Far End Recent 24 Hr table.')
uas7022FarEndRecent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndRecent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndRecent24HrIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndRecent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndRecent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndRecent24HrStat.setDescription('Returns a bitwise map of statistics for the interface in the Recent 24 hour interval. 1.7 f/u 1.6 f/u 1.5 f/u 1.4 f/u 1.3 f/u 1.2 1: Counter Overflow (>65535) ES 1.1 2^15 1.0 2^14 2.7 f/u 2.6 2^13 ES . 2.0 2^7 3.7 f/u 3.6 2^6 ES . 3.0 2^0 4.7 f/u 4.6 f/u 4.5 f/u 4.4 f/u 4.3 f/u 4.2 1: Counter Overflow (>65535) SES 4.1 2^15 4.0 2^14 5.7 f/u 5.6 2^13 SES . 5.0 2^7 6.7 f/u 6.6 2^6 SES . 6.0 2^0 7.7 f/u 7.6 f/u 7.5 f/u 7.4 f/u 7.3 f/u 7.2 1: Counter Overflow (>65535) BBE 7.1 2^15 7.0 2^14 8.7 f/u 8.6 2^13 BBE . 8.0 2^7 9.7 f/u 9.6 2^6 BBE . 9.0 2^0 10.7 f/u 10.6 f/u 10.5 f/u 10.4 f/u 10.3 f/u 10.2 1: Counter Overflow (>65535) UAS 10.1 2^15 10.0 2^14 11.7 f/u 11.6 2^13 UAS . 11.0 2^7 12.7 f/u 12.6 2^6 UAS . 12.0 2^0 Valid [i]nterface = 1-2')
uas7022FarEndUnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10), )
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegTable.setDescription('The uas7022 Far End Unavailable Time Register table.')
uas7022FarEndUnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndUnavailableTimeRegIndex"), (0, "GDCUAS7022-MIB", "uas7022FarEndUnavailableTimeRegNumber"))
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegEntry.setDescription('An entry in the Far End Unavailable Time Register table.')
uas7022FarEndUnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndUnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the Unavailable Time Register. Valid [i]nterface = 1-2')
uas7022FarEndUnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegStart.setDescription('Start time of one of the Unavailable Time Registers. Valid [i]nterface = 1-2')
uas7022FarEndUnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndUnavailableTimeRegStop.setDescription('Stop time of one of the Unavailable Time Registers. Valid [i]nterface = 1-2')
uas7022NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 1))
uas7022DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 2))
uas7022PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 3))
uas7022TimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 4))
uas7022LCV = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 5))
uas7022LossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 6))
uas7022LossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 7))
uas7022AlarmIndSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 8))
uas7022NEES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 9))
uas7022NEBBE = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 10))
uas7022NESES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 11))
uas7022NEUAS = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 12))
uas7022FEES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 13))
uas7022FEBBE = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 14))
uas7022FESES = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 15))
uas7022FEUAS = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 16))
uas7022RAI = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 13, 6, 17))
uas7022NearEndAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1), )
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigTable.setDescription('The uas7022NearEndAlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface.')
uas7022NearEndAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022NearEndAlarmConfigIndex"), (0, "GDCUAS7022-MIB", "uas7022NearEndAlarmConfigIdentifier"))
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigEntry.setDescription('An entry in the Near End Alarm Configuration table.')
uas7022NearEndAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022NearEndAlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmConfigIdentifier.setDescription('format: iso.org.dod.internet.private.enterprises.gdc. dsx1.uas7022.uas7022Alarms.ALM example: 1.3.6.1.4.1.498.6.13.6.ALM where ALM = 1 for uas7022NoResponse alarm, 2 for uas7022DiagRxErr alarm, etc., as specified in the Alarm Definitions above.')
uas7022NearEndAlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last10sec", 3), ("last30sec", 4), ("last1min", 5), ("last15min", 6), ("last1hr", 7), ("last24hr", 8), ("infinite", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NearEndAlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmCountWindow.setDescription('This variable sets/reads the alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting. Default: disabled(1)')
uas7022NearEndAlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("thresGT1", 1), ("thresGT3", 2), ("thresGT10", 3), ("thresGT100", 4), ("thresGT1000", 5), ("thresGT10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NearEndAlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NearEndAlarmCountThreshold.setDescription('This function sets/reads the alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Default: thresGT1(1)')
uas7022FarEndAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2), )
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigTable.setDescription('The uas7022FarEndAlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface.')
uas7022FarEndAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022FarEndAlarmConfigIndex"), (0, "GDCUAS7022-MIB", "uas7022FarEndAlarmConfigIdentifier"))
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigEntry.setDescription('An entry in the Far End Alarm Configuration table.')
uas7022FarEndAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022FarEndAlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmConfigIdentifier.setDescription('format: iso.org.dod.internet.private.enterprises.gdc. dsx1.uas7022.uas7022Alarms.ALM example: 1.3.6.1.4.1.498.6.13.6.ALM where ALM = 1 for uas7022NoResponse alarm, 2 for uas7022DiagRxErr alarm, etc., as specified in the Alarm Definitions above.')
uas7022FarEndAlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last10sec", 3), ("last30sec", 4), ("last1min", 5), ("last15min", 6), ("last1hr", 7), ("last24hr", 8), ("infinite", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022FarEndAlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmCountWindow.setDescription('This variable sets/reads the alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting. Default: disabled(1)')
uas7022FarEndAlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("thresGT1", 1), ("thresGT3", 2), ("thresGT10", 3), ("thresGT100", 4), ("thresGT1000", 5), ("thresGT10000", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022FarEndAlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022FarEndAlarmCountThreshold.setDescription('This function sets/reads the alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Default: thresGT1(1)')
uas7022LocalAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3), )
if mibBuilder.loadTexts: uas7022LocalAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LocalAlarmConfigTable.setDescription('The uas7022LocalAlarmConfigTable contains entries that configure alarm reporting to the alarm card.')
uas7022LocalAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1), ).setIndexNames((0, "GDCUAS7022-MIB", "uas7022LocalAlarmConfigIndex"))
if mibBuilder.loadTexts: uas7022LocalAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LocalAlarmConfigEntry.setDescription('An entry in the Local Alarm Configuration table.')
uas7022LocalAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7022LocalAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LocalAlarmConfigIndex.setDescription('Integer value which uniquely identifies the UAS7022 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - interface number (01-02)')
uas7022UASNE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022UASNE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022UASNE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022SESNE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022SESNE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SESNE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022BBENE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022BBENE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022BBENE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022ESNE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022ESNE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ESNE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022UASFE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022UASFE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022UASFE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022SESFE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022SESFE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022SESFE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022BBEFE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022BBEFE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022BBEFE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022ESFE = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022ESFE.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022ESFE.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022LOS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022LOS.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LOS.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022LOF = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022LOF.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LOF.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022AIS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022AIS.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022AIS.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022TmgLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022TmgLoss.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022TmgLoss.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022LCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022LCVs.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022LCVs.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
uas7022NtwkRAI = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 13, 7, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMajor", 2), ("enabledMinor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7022NtwkRAI.setStatus('mandatory')
if mibBuilder.loadTexts: uas7022NtwkRAI.setDescription('Disables or enables the alarm on the Major buss or Minor buss. Valid [i]nterface = 1-2')
mibBuilder.exportSymbols("GDCUAS7022-MIB", uas7022NearEndUnavailableTimeRegNumber=uas7022NearEndUnavailableTimeRegNumber, uas7022NearEndRecent24HrIndex=uas7022NearEndRecent24HrIndex, uas7022NearEndIntervalNumber=uas7022NearEndIntervalNumber, uas7022NearEndUnavailableTimeRegTable=uas7022NearEndUnavailableTimeRegTable, uas7022NearEndAlarmConfigIdentifier=uas7022NearEndAlarmConfigIdentifier, uas7022Impedance=uas7022Impedance, uas7022NEBBE=uas7022NEBBE, uas7022ESNE=uas7022ESNE, uas7022FarEndUnavailableTimeRegStop=uas7022FarEndUnavailableTimeRegStop, uas7022FarEndIntervalNumber=uas7022FarEndIntervalNumber, uas7022FEUAS=uas7022FEUAS, uas7022FarEndCurrent15MinIndex=uas7022FarEndCurrent15MinIndex, uas7022FarEndAlarmConfigTable=uas7022FarEndAlarmConfigTable, uas7022NearEndIntervalStat=uas7022NearEndIntervalStat, uas7022NearEndResetStats=uas7022NearEndResetStats, uas7022NearEndCurrent15MinIndex=uas7022NearEndCurrent15MinIndex, uas7022NearEndUnavailableTimeRegEntry=uas7022NearEndUnavailableTimeRegEntry, uas7022DiagTable=uas7022DiagTable, uas7022SESFE=uas7022SESFE, uas7022FarEndIntervalEntry=uas7022FarEndIntervalEntry, uas7022NearEndAlarmCountWindow=uas7022NearEndAlarmCountWindow, uas7022LOS=uas7022LOS, uas7022LossOfFrame=uas7022LossOfFrame, uas7022FarEndAlarmConfigIndex=uas7022FarEndAlarmConfigIndex, uas7022Framing=uas7022Framing, uas7022DiagIndex=uas7022DiagIndex, uas7022NearEndIntervalTable=uas7022NearEndIntervalTable, uas7022NearEndCurrent24HrStat=uas7022NearEndCurrent24HrStat, uas7022NearEndCurrent24HrEntry=uas7022NearEndCurrent24HrEntry, uas7022LOF=uas7022LOF, uas7022NearEndUnavailableTimeRegIndex=uas7022NearEndUnavailableTimeRegIndex, uas7022FarEndRecent24HrIndex=uas7022FarEndRecent24HrIndex, uas7022TimeSlot16Content=uas7022TimeSlot16Content, uas7022NearEndCurrent15MinTable=uas7022NearEndCurrent15MinTable, uas7022NearEndUnavailableTimeRegStart=uas7022NearEndUnavailableTimeRegStart, uas7022NearEndUnavailableTimeRegStop=uas7022NearEndUnavailableTimeRegStop, uas7022FarEndCurrent15MinEntry=uas7022FarEndCurrent15MinEntry, uas7022FarEndIntervalTable=uas7022FarEndIntervalTable, uas7022AlarmConfig=uas7022AlarmConfig, uas7022NearEndAlarmConfigIndex=uas7022NearEndAlarmConfigIndex, uas7022ConfigTable=uas7022ConfigTable, uas7022NearEndCurrent24HrIndex=uas7022NearEndCurrent24HrIndex, uas7022Alarms=uas7022Alarms, uas7022TestExceptions=uas7022TestExceptions, uas7022DiagEntry=uas7022DiagEntry, uas7022NearEndCurrent15MinEntry=uas7022NearEndCurrent15MinEntry, uas7022FarEndCurrent24HrTable=uas7022FarEndCurrent24HrTable, uas7022UASFE=uas7022UASFE, uas7022NEES=uas7022NEES, uas7022FEBBE=uas7022FEBBE, uas7022FarEndCurrent15MinStat=uas7022FarEndCurrent15MinStat, uas7022FarEndUnavailableTimeRegTable=uas7022FarEndUnavailableTimeRegTable, uas7022SESNE=uas7022SESNE, uas7022Maintenance=uas7022Maintenance, uas7022SysUpTime=uas7022SysUpTime, uas7022ConfigIndex=uas7022ConfigIndex, uas7022NearEndAlarmConfigTable=uas7022NearEndAlarmConfigTable, uas7022FarEndUnavailableTimeRegStart=uas7022FarEndUnavailableTimeRegStart, uas7022NearEndRecent24HrStat=uas7022NearEndRecent24HrStat, uas7022DefaultInit=uas7022DefaultInit, uas7022SoftReset=uas7022SoftReset, uas7022NIUaCircuitID=uas7022NIUaCircuitID, uas7022NIUbCircuitID=uas7022NIUbCircuitID, uas7022VersionIndex=uas7022VersionIndex, uas7022LocalAlarmConfigIndex=uas7022LocalAlarmConfigIndex, uas7022FarEndCurrent15MinTable=uas7022FarEndCurrent15MinTable, uas7022LCV=uas7022LCV, uas7022NoResponseAlm=uas7022NoResponseAlm, uas7022NearEndCurrent15MinStat=uas7022NearEndCurrent15MinStat, uas7022Version=uas7022Version, uas7022ConfigEntry=uas7022ConfigEntry, uas7022FarEndValidIntervals=uas7022FarEndValidIntervals, uas7022FarEndAlarmCountThreshold=uas7022FarEndAlarmCountThreshold, uas7022FarEndIntervalIndex=uas7022FarEndIntervalIndex, uas7022FarEndIntervalStat=uas7022FarEndIntervalStat, uas7022NearEndAlarmCountThreshold=uas7022NearEndAlarmCountThreshold, uas7022TransmitClockSource=uas7022TransmitClockSource, uas7022NearEndAlarmConfigEntry=uas7022NearEndAlarmConfigEntry, uas7022SwitchActiveFirmware=uas7022SwitchActiveFirmware, uas7022TimingLoss=uas7022TimingLoss, uas7022LossOfSignal=uas7022LossOfSignal, uas7022FDLMode=uas7022FDLMode, uas7022DiagConfig=uas7022DiagConfig, uas7022NearEndCurrent24HrTable=uas7022NearEndCurrent24HrTable, uas7022Performance=uas7022Performance, uas7022VersionEntry=uas7022VersionEntry, uas7022TestExecutionStatus=uas7022TestExecutionStatus, uas7022RcvrRange=uas7022RcvrRange, uas7022NearEndIntervalEntry=uas7022NearEndIntervalEntry, uas7022SystemTimingGenStatus=uas7022SystemTimingGenStatus, uas7022SysTimingGen=uas7022SysTimingGen, uas7022FarEndCurrent24HrStat=uas7022FarEndCurrent24HrStat, uas7022AlarmIndSignal=uas7022AlarmIndSignal, uas7022DownloadingMode=uas7022DownloadingMode, uas7022FarEndCurrent24HrIndex=uas7022FarEndCurrent24HrIndex, uas7022LocalAlarmConfigTable=uas7022LocalAlarmConfigTable, gdc=gdc, uas7022FarEndResetStats=uas7022FarEndResetStats, uas7022LocalAlarmConfigEntry=uas7022LocalAlarmConfigEntry, uas7022FarEndAlarmConfigEntry=uas7022FarEndAlarmConfigEntry, uas7022FarEndUnavailableTimeRegNumber=uas7022FarEndUnavailableTimeRegNumber, uas7022ESFE=uas7022ESFE, uas7022NearEndStatLastInit=uas7022NearEndStatLastInit, uas7022FarEndAlarmCountWindow=uas7022FarEndAlarmCountWindow, uas7022InterfaceType=uas7022InterfaceType, uas7022FEES=uas7022FEES, uas7022TestLimit=uas7022TestLimit, uas7022FarEndRecent24HrTable=uas7022FarEndRecent24HrTable, uas7022NearEndIntervalIndex=uas7022NearEndIntervalIndex, uas7022FESES=uas7022FESES, uas7022LedStatus=uas7022LedStatus, uas7022StoredFirmwareRev=uas7022StoredFirmwareRev, uas7022FarEndRecent24HrStat=uas7022FarEndRecent24HrStat, uas7022FarEndUnavailableTimeRegIndex=uas7022FarEndUnavailableTimeRegIndex, uas7022Highway=uas7022Highway, uas7022BBEFE=uas7022BBEFE, uas7022FarEndAlarmConfigIdentifier=uas7022FarEndAlarmConfigIdentifier, uas7022Diagnostics=uas7022Diagnostics, uas7022TmgLoss=uas7022TmgLoss, uas7022PowerUpAlm=uas7022PowerUpAlm, uas7022LCVs=uas7022LCVs, uas7022NtwkRAI=uas7022NtwkRAI, uas7022FarEndUnavailableTimeRegEntry=uas7022FarEndUnavailableTimeRegEntry, uas7022MIBversion=uas7022MIBversion, uas7022NearEndRecent24HrEntry=uas7022NearEndRecent24HrEntry, uas7022=uas7022, uas7022AlarmStatus=uas7022AlarmStatus, uas7022AIS=uas7022AIS, uas7022RAI=uas7022RAI, uas7022NearEndRecent24HrTable=uas7022NearEndRecent24HrTable, uas7022Configuration=uas7022Configuration, uas7022MaintenanceEntry=uas7022MaintenanceEntry, dsx1=dsx1, uas7022NESES=uas7022NESES, uas7022UASNE=uas7022UASNE, uas7022NearEndValidIntervals=uas7022NearEndValidIntervals, uas7022MaintenanceTable=uas7022MaintenanceTable, uas7022FarEndRecent24HrEntry=uas7022FarEndRecent24HrEntry, uas7022NEUAS=uas7022NEUAS, uas7022FallbackClockSource=uas7022FallbackClockSource, uas7022ActiveFirmwareRev=uas7022ActiveFirmwareRev, uas7022FarEndStatLastInit=uas7022FarEndStatLastInit, uas7022MaintenanceLineIndex=uas7022MaintenanceLineIndex, uas7022FarEndCurrent24HrEntry=uas7022FarEndCurrent24HrEntry, uas7022DiagRxErrAlm=uas7022DiagRxErrAlm, uas7022StoredFirmwareStatus=uas7022StoredFirmwareStatus, uas7022BBENE=uas7022BBENE, uas7022VersionTable=uas7022VersionTable)

#
# PySNMP MIB module CISCO-CEF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CEF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:53:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
CefAdminStatus, CefCCAction, CefForwardingElementSpecialType, CefAdjacencySource, CefPathType, CefFailureReason, CefOperStatus, CefIpVersion, CefAdjLinkType, CefCCStatus, CefMplsLabelList, CefPrefixSearchState, CefCCType = mibBuilder.importSymbols("CISCO-CEF-TC", "CefAdminStatus", "CefCCAction", "CefForwardingElementSpecialType", "CefAdjacencySource", "CefPathType", "CefFailureReason", "CefOperStatus", "CefIpVersion", "CefAdjLinkType", "CefCCStatus", "CefMplsLabelList", "CefPrefixSearchState", "CefCCType")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
EntPhysicalIndexOrZero, = mibBuilder.importSymbols("CISCO-TC", "EntPhysicalIndexOrZero")
entPhysicalIndex, PhysicalIndex = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex", "PhysicalIndex")
CounterBasedGauge64, = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
InterfaceIndexOrZero, ifIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifIndex")
InetAddress, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType")
MplsVpnId, = mibBuilder.importSymbols("MPLS-VPN-MIB", "MplsVpnId")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
TimeTicks, IpAddress, Counter32, MibIdentifier, Counter64, Unsigned32, iso, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Integer32, ModuleIdentity, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "IpAddress", "Counter32", "MibIdentifier", "Counter64", "Unsigned32", "iso", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Integer32", "ModuleIdentity", "Bits", "Gauge32")
TimeStamp, TextualConvention, TruthValue, TestAndIncr, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "TextualConvention", "TruthValue", "TestAndIncr", "RowStatus", "DisplayString")
ciscoCefMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 492))
ciscoCefMIB.setRevisions(('2006-01-30 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCefMIB.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoCefMIB.setLastUpdated('200601300000Z')
if mibBuilder.loadTexts: ciscoCefMIB.setOrganization('Cisco System, Inc.')
if mibBuilder.loadTexts: ciscoCefMIB.setContactInfo('Postal: Cisco Systems, Inc. 170 West Tasman Drive San Jose, CA 95134-1706 USA Tel: +1 800 553-NETS E-mail: cs-cef@cisco.com')
if mibBuilder.loadTexts: ciscoCefMIB.setDescription('Cisco Express Forwarding (CEF) describes a high speed switching mechanism that a router uses to forward packets from the inbound to the outbound interface. CEF uses two sets of data structures or tables, which it stores in router memory: Forwarding information base (FIB) - Describes a database of information used to make forwarding decisions. It is conceptually similar to a routing table or route-cache, although its implementation is different. Adjacency - Two nodes in the network are said to be adjacent if they can reach each other via a single hop across a link layer. CEF path is a valid route to reach to a destination IP prefix. Multiple paths may exist out of a router to the same destination prefix. CEF Load balancing capability share the traffic to the destination IP prefix over all the active paths. After obtaining the prefix in the CEF table with the longest match, output forwarding follows the chain of forwarding elements. Forwarding element (FE) may process the packet, forward the packet, drop or punt the packet or it may also pass the packet to the next forwarding element in the chain for further processing. Forwarding Elements are of various types but this MIB only represents the forwarding elements of adjacency and label types. Hence a forwarding element chain will be represented as a list of labels and adjacency. The adjacency may point to a forwarding element list again, if it is not the last forwarding element in this chain. For the simplest IP forwarding case, the prefix entry will point at an adjacency forwarding element. The IP adjacency processing function will apply the output features, add the encapsulation (performing any required fixups), and may send the packet out. If loadbalancing is configured, the prefix entry will point to lists of forwarding elements. One of these lists will be selected to forward the packet. Each forwarding element list dictates which of a set of possible packet transformations to apply on the way to the same neighbour. The following diagram represents relationship between three of the core tables in this MIB module. cefPrefixTable cefFESelectionTable +---------------+ points +--------------+ | | | | a set +----> | | | | | |---------------| of FE | |--------------| | | | | Selection | | | | | | |---------------| Entries | |--------------| | | | |------------+ | |<----+ |---------------| |--------------| | | | +--------------| | | | | | +---------------+ | +--------------+ | | | points to an | adjacency entry | | | | cefAdjTable | | +---------------+ may point | +->| | | | to a set | |---------------| of FE | | | | | Selection | |---------------| Entries | | | | |----------------+ |---------------| | | +---------------+ Some of the Cisco series routers (e.g. 7500 & 12000) support distributed CEF (dCEF), in which the line cards (LCs) make the packet forwarding decisions using locally stored copies of the same Forwarding information base (FIB) and adjacency tables as the Routing Processor (RP). Inter-Process Communication (IPC) is the protocol used by routers that support distributed packet forwarding. CEF updates are encoded as external Data Representation (XDR) information elements inside IPC messages. This MIB reflects the distributed nature of CEF, e.g. CEF has different instances running on the RP and the line cards. There may be instances of inconsistency between the CEF forwarding databases(i.e between CEF forwarding database on line cards and the CEF forwarding database on the RP). CEF consistency checkers (CC) detects this inconsistency. When two databases are compared by a consistency checker, a set of records from the first (master) database is looked up in the second (slave). There are two types of consistency checkers, active and passive. Active consistency checkers are invoked in response to some stimulus, i.e. when a packet cannot be forwarded because the prefix is not in the forwarding table or in response to a Management Station request. Passive consistency checkers operate in the background, scanning portions of the databases on a periodic basis. The full-scan checkers are active consistency checkers which are invoked in response to a Management Station Request. If 64-bit counter objects in this MIB are supported, then their associated 32-bit counter objects must also be supported. The 32-bit counters will report the low 32-bits of the associated 64-bit counter count (e.g., cefPrefixPkts will report the least significant 32 bits of cefPrefixHCPkts). The same rule should be applied for the 64-bit gauge objects and their assocaited 32-bit gauge objects. If 64-bit counters in this MIB are not supported, then an agent MUST NOT instantiate the corresponding objects with an incorrect value; rather, it MUST respond with the appropriate error/exception condition (e.g., noSuchInstance or noSuchName). Counters related to CEF accounting (e.g., cefPrefixPkts) MUST NOT be instantiated if the corresponding accounting method has been disabled. This MIB allows configuration and monitoring of CEF related objects.')
ciscoCefMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 0))
ciscoCefMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1))
ciscoCefMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 2))
cefFIB = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1))
cefAdj = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2))
cefFE = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3))
cefGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4))
cefInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5))
cefPeer = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6))
cefCC = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7))
cefStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8))
cefNotifCntl = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9))
cefFIBSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 1))
cefFIBSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 1, 1), )
if mibBuilder.loadTexts: cefFIBSummaryTable.setStatus('current')
if mibBuilder.loadTexts: cefFIBSummaryTable.setDescription('This table contains the summary information for the cefPrefixTable.')
cefFIBSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 1, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"))
if mibBuilder.loadTexts: cefFIBSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: cefFIBSummaryEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the FIB summary related attributes for the managed entity. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefFIBIpVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 1, 1, 1, 1), CefIpVersion())
if mibBuilder.loadTexts: cefFIBIpVersion.setStatus('current')
if mibBuilder.loadTexts: cefFIBIpVersion.setDescription('The version of IP forwarding.')
cefFIBSummaryFwdPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFIBSummaryFwdPrefixes.setStatus('current')
if mibBuilder.loadTexts: cefFIBSummaryFwdPrefixes.setDescription('Total number of forwarding Prefixes in FIB for the IP version specified by cefFIBIpVersion object.')
cefPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2), )
if mibBuilder.loadTexts: cefPrefixTable.setStatus('current')
if mibBuilder.loadTexts: cefPrefixTable.setDescription('A list of CEF forwarding prefixes.')
cefPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefPrefixType"), (0, "CISCO-CEF-MIB", "cefPrefixAddr"), (0, "CISCO-CEF-MIB", "cefPrefixLen"))
if mibBuilder.loadTexts: cefPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: cefPrefixEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the forwarding prefix attributes. CEF prefix based non-recursive stats are maintained in internal and external buckets (depending upon the value of cefIntNonrecursiveAccouting object in the CefIntEntry). entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cefPrefixType.setStatus('current')
if mibBuilder.loadTexts: cefPrefixType.setDescription('The Network Prefix Type. This object specifies the address type used for cefPrefixAddr. Prefix entries are only valid for the address type of ipv4(1) and ipv6(2).')
cefPrefixAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: cefPrefixAddr.setStatus('current')
if mibBuilder.loadTexts: cefPrefixAddr.setDescription('The Network Prefix Address. The type of this address is determined by the value of the cefPrefixType object. This object is a Prefix Address containing the prefix with length specified by cefPrefixLen. Any bits beyond the length specified by cefPrefixLen are zeroed.')
cefPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: cefPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cefPrefixLen.setDescription('Length in bits of the FIB Address prefix.')
cefPrefixForwardingInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixForwardingInfo.setStatus('current')
if mibBuilder.loadTexts: cefPrefixForwardingInfo.setDescription('This object indicates the associated forwarding element selection entries in cefFESelectionTable. The value of this object is index value (cefFESelectionName) of cefFESelectionTable.')
cefPrefixPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 5), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixPkts.setDescription("If CEF accounting is set to enable per prefix accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'perPrefix' accounting), then this object represents the number of packets switched to this prefix.")
cefPrefixHCPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 6), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixHCPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixHCPkts.setDescription("If CEF accounting is set to enable per prefix accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'perPrefix' accounting), then this object represents the number of packets switched to this prefix. This object is a 64-bit version of cefPrefixPkts.")
cefPrefixBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 7), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixBytes.setDescription("If CEF accounting is set to enable per prefix accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'perPrefix' accounting), then this object represents the number of bytes switched to this prefix.")
cefPrefixHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 8), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixHCBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixHCBytes.setDescription("If CEF accounting is set to enable per prefix accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'perPrefix' accounting), then this object represents the number of bytes switched to this prefix. This object is a 64-bit version of cefPrefixBytes.")
cefPrefixInternalNRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 9), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixInternalNRPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixInternalNRPkts.setDescription("If CEF accounting is set to enable non-recursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive packets in the internal bucket switched using this prefix.")
cefPrefixInternalNRHCPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixInternalNRHCPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixInternalNRHCPkts.setDescription("If CEF accounting is set to enable non-recursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive packets in the internal bucket switched using this prefix. This object is a 64-bit version of cefPrefixInternalNRPkts.")
cefPrefixInternalNRBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 11), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixInternalNRBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixInternalNRBytes.setDescription("If CEF accounting is set to enable nonRecursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive bytes in the internal bucket switched using this prefix.")
cefPrefixInternalNRHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 12), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixInternalNRHCBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixInternalNRHCBytes.setDescription("If CEF accounting is set to enable nonRecursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive bytes in the internal bucket switched using this prefix. This object is a 64-bit version of cefPrefixInternalNRBytes.")
cefPrefixExternalNRPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 13), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixExternalNRPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixExternalNRPkts.setDescription("If CEF accounting is set to enable non-recursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive packets in the external bucket switched using this prefix.")
cefPrefixExternalNRHCPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 14), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixExternalNRHCPkts.setStatus('current')
if mibBuilder.loadTexts: cefPrefixExternalNRHCPkts.setDescription("If CEF accounting is set to enable non-recursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive packets in the external bucket switched using this prefix. This object is a 64-bit version of cefPrefixExternalNRPkts.")
cefPrefixExternalNRBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 15), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixExternalNRBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixExternalNRBytes.setDescription("If CEF accounting is set to enable nonRecursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive bytes in the external bucket switched using this prefix.")
cefPrefixExternalNRHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 2, 1, 16), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPrefixExternalNRHCBytes.setStatus('current')
if mibBuilder.loadTexts: cefPrefixExternalNRHCBytes.setDescription("If CEF accounting is set to enable nonRecursive accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'nonRecursive' accounting), then this object represents the number of non-recursive bytes in the external bucket switched using this prefix. This object is a 64-bit version of cefPrefixExternalNRBytes.")
cefLMPrefixSpinLock = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 3), TestAndIncr()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefLMPrefixSpinLock.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixSpinLock.setDescription("An advisory lock used to allow cooperating SNMP Command Generator applications to coordinate their use of the Set operation in creating Longest Match Prefix Entries in cefLMPrefixTable. When creating a new longest prefix match entry, the value of cefLMPrefixSpinLock should be retrieved. The destination address should be determined to be unique by the SNMP Command Generator application by consulting the cefLMPrefixTable. Finally, the longest prefix entry may be created (Set), including the advisory lock. If another SNMP Command Generator application has altered the longest prefix entry in the meantime, then the spin lock's value will have changed, and so this creation will fail because it will specify the wrong value for the spin lock. Since this is an advisory lock, the use of this lock is not enforced, but not using this lock may lead to conflict with the another SNMP command responder application which may also be acting on the cefLMPrefixTable.")
cefLMPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4), )
if mibBuilder.loadTexts: cefLMPrefixTable.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixTable.setDescription('A table of Longest Match Prefix Query requests. Generator application should utilize the cefLMPrefixSpinLock to try to avoid collisions. See DESCRIPTION clause of cefLMPrefixSpinLock.')
cefLMPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefLMPrefixDestAddrType"), (0, "CISCO-CEF-MIB", "cefLMPrefixDestAddr"))
if mibBuilder.loadTexts: cefLMPrefixEntry.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixEntry.setDescription("If CEF is enabled on the managed device, then each entry represents a longest Match Prefix request. A management station wishing to get the longest Match prefix for a given destination address should create the associate instance of the row status. The row status should be set to active(1) to initiate the request. Note that this entire procedure may be initiated via a single set request which specifies a row status of createAndGo(4). Once the request completes, the management station should retrieve the values of the objects of interest, and should then delete the entry. In order to prevent old entries from clogging the table, entries will be aged out, but an entry will never be deleted within 5 minutes of completion. Entries are lost after an agent restart. I.e. to find out the longest prefix match for destination address of A.B.C.D on entity whose entityPhysicalIndex is 1, the Management station will create an entry in cefLMPrefixTable with cefLMPrefixRowStatus.1(entPhysicalIndex).1(ipv4).A.B.C.D set to createAndGo(4). Management Station may query the value of objects cefLMPrefix and cefLMPrefixLen to find out the corresponding prefix entry from the cefPrefixTable once the value of cefLMPrefixState is set to matchFound(2). entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF. ")
cefLMPrefixDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cefLMPrefixDestAddrType.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixDestAddrType.setDescription('The Destination Address Type. This object specifies the address type used for cefLMPrefixDestAddr. Longest Match Prefix entries are only valid for the address type of ipv4(1) and ipv6(2).')
cefLMPrefixDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: cefLMPrefixDestAddr.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixDestAddr.setDescription('The Destination Address. The type of this address is determined by the value of the cefLMPrefixDestAddrType object.')
cefLMPrefixState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 3), CefPrefixSearchState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefLMPrefixState.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixState.setDescription('Indicates the state of this prefix search request.')
cefLMPrefixAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefLMPrefixAddr.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixAddr.setDescription('The Network Prefix Address. Index to the cefPrefixTable. The type of this address is determined by the value of the cefLMPrefixDestAddrType object.')
cefLMPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 5), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefLMPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixLen.setDescription('The Network Prefix Length. Index to the cefPrefixTable.')
cefLMPrefixRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cefLMPrefixRowStatus.setStatus('current')
if mibBuilder.loadTexts: cefLMPrefixRowStatus.setDescription('The status of this table entry. Once the entry status is set to active(1), the associated entry cannot be modified until the request completes (cefLMPrefixState transitions to matchFound(2) or noMatchFound(3)). Once the longest match request has been created (i.e. the cefLMPrefixRowStatus has been made active), the entry cannot be modified - the only operation possible after this is to delete the row.')
cefPathTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5), )
if mibBuilder.loadTexts: cefPathTable.setStatus('current')
if mibBuilder.loadTexts: cefPathTable.setDescription('CEF prefix path is a valid route to reach to a destination IP prefix. Multiple paths may exist out of a router to the same destination prefix. This table specify lists of CEF paths.')
cefPathEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefPrefixType"), (0, "CISCO-CEF-MIB", "cefPrefixAddr"), (0, "CISCO-CEF-MIB", "cefPrefixLen"), (0, "CISCO-CEF-MIB", "cefPathId"))
if mibBuilder.loadTexts: cefPathEntry.setStatus('current')
if mibBuilder.loadTexts: cefPathEntry.setDescription("If CEF is enabled on the Managed device, each entry contain a CEF prefix path. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefPathId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cefPathId.setStatus('current')
if mibBuilder.loadTexts: cefPathId.setDescription('The locally arbitrary, but unique identifier associated with this prefix path entry.')
cefPathType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1, 2), CefPathType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPathType.setStatus('current')
if mibBuilder.loadTexts: cefPathType.setDescription('Type for this CEF Path.')
cefPathInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPathInterface.setStatus('current')
if mibBuilder.loadTexts: cefPathInterface.setDescription('Interface associated with this CEF path. A value of zero for this object will indicate that no interface is associated with this path entry.')
cefPathNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPathNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: cefPathNextHopAddr.setDescription('Next hop address associated with this CEF path. The value of this object is only relevant for attached next hop and recursive next hop path types (when the object cefPathType is set to attachedNexthop(4) or recursiveNexthop(5)). and will be set to zero for other path types. The type of this address is determined by the value of the cefPrefixType object.')
cefPathRecurseVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 1, 5, 1, 5), MplsVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPathRecurseVrfName.setStatus('current')
if mibBuilder.loadTexts: cefPathRecurseVrfName.setDescription("The recursive vrf name associated with this path. The value of this object is only relevant for recursive next hop path types (when the object cefPathType is set to recursiveNexthop(5)), and '0x00' will be returned for other path types.")
cefAdjSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1))
cefAdjSummaryTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1), )
if mibBuilder.loadTexts: cefAdjSummaryTable.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryTable.setDescription('This table contains the summary information for the cefAdjTable.')
cefAdjSummaryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefAdjSummaryLinkType"))
if mibBuilder.loadTexts: cefAdjSummaryEntry.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the CEF Adjacency summary related attributes for the Managed entity. A row exists for each adjacency link type. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefAdjSummaryLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1, 1), CefAdjLinkType())
if mibBuilder.loadTexts: cefAdjSummaryLinkType.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryLinkType.setDescription('The link type of the adjacency.')
cefAdjSummaryComplete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjSummaryComplete.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryComplete.setDescription('The total number of complete adjacencies. The total number of adjacencies which can be used to switch traffic to a neighbour.')
cefAdjSummaryIncomplete = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjSummaryIncomplete.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryIncomplete.setDescription('The total number of incomplete adjacencies. The total number of adjacencies which cannot be used to switch traffic in their current state.')
cefAdjSummaryFixup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjSummaryFixup.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryFixup.setDescription('The total number of adjacencies for which the Layer 2 encapsulation string (header) may be updated (fixed up) at packet switch time.')
cefAdjSummaryRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 1, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjSummaryRedirect.setReference('1. Internet Architecture Extensions for Shared Media, RFC 1620, May 1994.')
if mibBuilder.loadTexts: cefAdjSummaryRedirect.setStatus('current')
if mibBuilder.loadTexts: cefAdjSummaryRedirect.setDescription('The total number of adjacencies for which ip redirect (or icmp redirection) is enabled. The value of this object is only relevant for ipv4 and ipv6 link type (when the index object cefAdjSummaryLinkType value is ipv4(1) or ipv6(2)) and will be set to zero for other link types. ')
cefAdjTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2), )
if mibBuilder.loadTexts: cefAdjTable.setStatus('current')
if mibBuilder.loadTexts: cefAdjTable.setDescription('A list of CEF adjacencies.')
cefAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "IF-MIB", "ifIndex"), (0, "CISCO-CEF-MIB", "cefAdjNextHopAddrType"), (0, "CISCO-CEF-MIB", "cefAdjNextHopAddr"), (0, "CISCO-CEF-MIB", "cefAdjConnId"), (0, "CISCO-CEF-MIB", "cefAdjSummaryLinkType"))
if mibBuilder.loadTexts: cefAdjEntry.setStatus('current')
if mibBuilder.loadTexts: cefAdjEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the adjacency attributes. Adjacency entries may exist for all the interfaces on which packets can be switched out of the device. The interface is instantiated by ifIndex. Therefore, the interface index must have been assigned, according to the applicable procedures, before it can be meaningfully used. Generally, this means that the interface must exist. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefAdjNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cefAdjNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: cefAdjNextHopAddrType.setDescription('Address type for the cefAdjNextHopAddr. This object specifies the address type used for cefAdjNextHopAddr. Adjacency entries are only valid for the address type of ipv4(1) and ipv6(2).')
cefAdjNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: cefAdjNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: cefAdjNextHopAddr.setDescription('The next Hop address for this adjacency. The type of this address is determined by the value of the cefAdjNextHopAddrType object.')
cefAdjConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), )))
if mibBuilder.loadTexts: cefAdjConnId.setStatus('current')
if mibBuilder.loadTexts: cefAdjConnId.setDescription('In cases where cefLinkType, interface and the next hop address are not able to uniquely define an adjacency entry (e.g. ATM and Frame Relay Bundles), this object is a unique identifier to differentiate between these adjacency entries. In all the other cases the value of this index object will be 0.')
cefAdjSource = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 4), CefAdjacencySource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjSource.setStatus('current')
if mibBuilder.loadTexts: cefAdjSource.setDescription('If the adjacency is created because some neighbour discovery mechanism has discovered a neighbour and all the information required to build a frame header to encapsulate traffic to the neighbour is available then the source of adjacency is set to the mechanism by which the adjacency is learned.')
cefAdjEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjEncap.setStatus('current')
if mibBuilder.loadTexts: cefAdjEncap.setDescription('The layer 2 encapsulation string to be used for sending the packet out using this adjacency.')
cefAdjFixup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjFixup.setStatus('current')
if mibBuilder.loadTexts: cefAdjFixup.setDescription("For the cases, where the encapsulation string is decided at packet switch time, the adjacency encapsulation string specified by object cefAdjEncap require a fixup. I.e. for the adjacencies out of IP Tunnels, the string prepended is an IP header which has fields which can only be setup at packet switch time. The value of this object represent the kind of fixup applied to the packet. If the encapsulation string doesn't require any fixup, then the value of this object will be of zero length.")
cefAdjMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjMTU.setStatus('current')
if mibBuilder.loadTexts: cefAdjMTU.setDescription('The Layer 3 MTU which can be transmitted using this adjacency.')
cefAdjForwardingInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjForwardingInfo.setStatus('current')
if mibBuilder.loadTexts: cefAdjForwardingInfo.setDescription('This object selects a forwarding info entry defined in the cefFESelectionTable. The selected target is defined by an entry in the cefFESelectionTable whose index value (cefFESelectionName) is equal to this object. The value of this object will be of zero length if this adjacency entry is the last forwarding element in the forwarding path.')
cefAdjPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 9), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjPkts.setStatus('current')
if mibBuilder.loadTexts: cefAdjPkts.setDescription('Number of pkts transmitted using this adjacency.')
cefAdjHCPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 10), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjHCPkts.setStatus('current')
if mibBuilder.loadTexts: cefAdjHCPkts.setDescription('Number of pkts transmitted using this adjacency. This object is a 64-bit version of cefAdjPkts.')
cefAdjBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 11), Counter32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjBytes.setStatus('current')
if mibBuilder.loadTexts: cefAdjBytes.setDescription('Number of bytes transmitted using this adjacency.')
cefAdjHCBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 2, 2, 1, 12), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefAdjHCBytes.setStatus('current')
if mibBuilder.loadTexts: cefAdjHCBytes.setDescription('Number of bytes transmitted using this adjacency. This object is a 64-bit version of cefAdjBytes.')
cefFESelectionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1), )
if mibBuilder.loadTexts: cefFESelectionTable.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionTable.setDescription('A list of forwarding element selection entries.')
cefFESelectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFESelectionName"), (0, "CISCO-CEF-MIB", "cefFESelectionId"))
if mibBuilder.loadTexts: cefFESelectionEntry.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionEntry.setDescription("If CEF is enabled on the Managed device, each entry contain a CEF forwarding element selection list. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefFESelectionName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: cefFESelectionName.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionName.setDescription('The locally arbitrary, but unique identifier used to select a set of forwarding element lists.')
cefFESelectionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cefFESelectionId.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionId.setDescription('Secondary index to identify a forwarding elements List in this Table.')
cefFESelectionSpecial = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 3), CefForwardingElementSpecialType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionSpecial.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionSpecial.setDescription('Special processing for a destination is indicated through the use of special forwarding element. If the forwarding element list contains the special forwarding element, then this object represents the type of special forwarding element.')
cefFESelectionLabels = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 4), CefMplsLabelList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionLabels.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionLabels.setDescription("This object represent the MPLS Labels associated with this forwarding Element List. The value of this object will be irrelevant and will be set to zero length if the forwarding element list doesn't contain a label forwarding element. A zero length label list will indicate that there is no label forwarding element associated with this selection entry.")
cefFESelectionAdjLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 5), CefAdjLinkType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionAdjLinkType.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionAdjLinkType.setDescription("This object represent the link type for the adjacency associated with this forwarding Element List. The value of this object will be irrelevant and will be set to unknown(5) if the forwarding element list doesn't contain an adjacency forwarding element.")
cefFESelectionAdjInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionAdjInterface.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionAdjInterface.setDescription("This object represent the interface for the adjacency associated with this forwarding Element List. The value of this object will be irrelevant and will be set to zero if the forwarding element list doesn't contain an adjacency forwarding element.")
cefFESelectionAdjNextHopAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 7), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionAdjNextHopAddrType.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionAdjNextHopAddrType.setDescription("This object represent the next hop address type for the adjacency associated with this forwarding Element List. The value of this object will be irrelevant and will be set to unknown(0) if the forwarding element list doesn't contain an adjacency forwarding element.")
cefFESelectionAdjNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 8), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionAdjNextHopAddr.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionAdjNextHopAddr.setDescription("This object represent the next hop address for the adjacency associated with this forwarding Element List. The value of this object will be irrelevant and will be set to zero if the forwarding element list doesn't contain an adjacency forwarding element.")
cefFESelectionAdjConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionAdjConnId.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionAdjConnId.setDescription("This object represent the connection id for the adjacency associated with this forwarding Element List. The value of this object will be irrelevant and will be set to zero if the forwarding element list doesn't contain an adjacency forwarding element. In cases where cefFESelectionAdjLinkType, interface and the next hop address are not able to uniquely define an adjacency entry (e.g. ATM and Frame Relay Bundles), this object is a unique identifier to differentiate between these adjacency entries.")
cefFESelectionVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 10), MplsVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionVrfName.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionVrfName.setDescription("This object represent the Vrf name for the lookup associated with this forwarding Element List. The value of this object will be irrelevant and will be set to a string containing the single octet 0x00 if the forwarding element list doesn't contain a lookup forwarding element.")
cefFESelectionWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefFESelectionWeight.setStatus('current')
if mibBuilder.loadTexts: cefFESelectionWeight.setDescription('This object represent the weighting for load balancing between multiple Forwarding Element Lists. The value of this object will be zero if load balancing is associated with this selection entry.')
cefCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1), )
if mibBuilder.loadTexts: cefCfgTable.setStatus('current')
if mibBuilder.loadTexts: cefCfgTable.setDescription('This table contains global config parameter of CEF on the Managed device.')
cefCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"))
if mibBuilder.loadTexts: cefCfgEntry.setStatus('current')
if mibBuilder.loadTexts: cefCfgEntry.setDescription("If the Managed device supports CEF, each entry contains the CEF config parameter for the managed entity. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefCfgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 1), CefAdminStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgAdminState.setStatus('current')
if mibBuilder.loadTexts: cefCfgAdminState.setDescription('The desired state of CEF.')
cefCfgOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 2), CefOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCfgOperState.setStatus('current')
if mibBuilder.loadTexts: cefCfgOperState.setDescription('The current operational state of CEF. If the cefCfgAdminState is disabled(2), then cefOperState will eventually go to the down(2) state unless some error has occurred. If cefCfgAdminState is changed to enabled(1) then cefCfgOperState should change to up(1) only if the CEF entity is ready to forward the packets using Cisco Express Forwarding (CEF) else it should remain in the down(2) state. The up(1) state for this object indicates that CEF entity is forwarding the packet using Cisco Express Forwarding.')
cefCfgDistributionAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 3), CefAdminStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgDistributionAdminState.setStatus('current')
if mibBuilder.loadTexts: cefCfgDistributionAdminState.setDescription('The desired state of CEF distribution.')
cefCfgDistributionOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 4), CefOperStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCfgDistributionOperState.setStatus('current')
if mibBuilder.loadTexts: cefCfgDistributionOperState.setDescription('The current operational state of CEF distribution. If the cefCfgDistributionAdminState is disabled(2), then cefDistributionOperState will eventually go to the down(2) state unless some error has occurred. If cefCfgDistributionAdminState is changed to enabled(1) then cefCfgDistributionOperState should change to up(1) only if the CEF entity is ready to forward the packets using Distributed Cisco Express Forwarding (dCEF) else it should remain in the down(2) state. The up(1) state for this object indicates that CEF entity is forwarding the packet using Distributed Cisco Express Forwarding.')
cefCfgAccountingMap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 5), Bits().clone(namedValues=NamedValues(("nonRecursive", 0), ("perPrefix", 1), ("prefixLength", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgAccountingMap.setStatus('current')
if mibBuilder.loadTexts: cefCfgAccountingMap.setDescription('This object represents a bitmap of network accounting options. CEF network accounting is disabled by default. CEF network accounting can be enabled by selecting one or more of the following CEF accounting option for the value of this object. nonRecursive(0): enables accounting through nonrecursive prefixes. perPrefix(1): enables the collection of the numbers of pkts and bytes express forwarded to a destination (prefix) prefixLength(2): enables accounting through prefixlength. Once the accounting is enabled, the corresponding stats can be retrieved from the cefPrefixTable and cefStatsPrefixLenTable. ')
cefCfgLoadSharingAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("original", 2), ("tunnel", 3), ("universal", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgLoadSharingAlgorithm.setStatus('current')
if mibBuilder.loadTexts: cefCfgLoadSharingAlgorithm.setDescription("Indicates the CEF Load balancing algorithm. Setting this object to none(1) will disable the Load sharing for the specified entry. CEF load balancing can be enabled by setting this object to one of following Algorithms: original(2) : This algorithm is based on a source and destination hash tunnel(3) : This algorithm is used in tunnels environments or in environments where there are only a few source universal(4) : This algorithm uses a source and destination and ID hash If the value of this object is set to 'tunnel' or 'universal', then the FIXED ID for these algorithms may be specified by the managed object cefLoadSharingID. ")
cefCfgLoadSharingID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgLoadSharingID.setStatus('current')
if mibBuilder.loadTexts: cefCfgLoadSharingID.setDescription('The Fixed ID associated with the managed object cefCfgLoadSharingAlgorithm. The hash of this object value may be used by the Load Sharing Algorithm. The value of this object is not relevant and will be set to zero if the value of managed object cefCfgLoadSharingAlgorithm is set to none(1) or original(2). The default value of this object is calculated by the device at the time of initialization.')
cefCfgTrafficStatsLoadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 8), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgTrafficStatsLoadInterval.setStatus('current')
if mibBuilder.loadTexts: cefCfgTrafficStatsLoadInterval.setDescription('The interval time over which the CEF traffic statistics are collected.')
cefCfgTrafficStatsUpdateRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 65535), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCfgTrafficStatsUpdateRate.setStatus('current')
if mibBuilder.loadTexts: cefCfgTrafficStatsUpdateRate.setDescription('The frequency with which the line card sends the traffic load statistics to the Router Processor. Setting the value of this object to 0 will disable the CEF traffic statistics collection.')
cefResourceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 2), )
if mibBuilder.loadTexts: cefResourceTable.setStatus('current')
if mibBuilder.loadTexts: cefResourceTable.setDescription('This table contains global resource information of CEF on the Managed device.')
cefResourceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"))
if mibBuilder.loadTexts: cefResourceEntry.setStatus('current')
if mibBuilder.loadTexts: cefResourceEntry.setDescription("If the Managed device supports CEF, each entry contains the CEF Resource parameters for the managed entity. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefResourceMemoryUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 2, 1, 1), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefResourceMemoryUsed.setStatus('current')
if mibBuilder.loadTexts: cefResourceMemoryUsed.setDescription('Indicates the number of bytes from the Processor Memory Pool that are currently in use by CEF on the managed entity.')
cefResourceFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 4, 2, 1, 2), CefFailureReason()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefResourceFailureReason.setStatus('current')
if mibBuilder.loadTexts: cefResourceFailureReason.setDescription('The CEF resource failure reason which may lead to CEF being disabled on the managed entity.')
cefIntTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5, 1), )
if mibBuilder.loadTexts: cefIntTable.setStatus('current')
if mibBuilder.loadTexts: cefIntTable.setDescription('This Table contains interface specific information of CEF on the Managed device.')
cefIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cefIntEntry.setStatus('current')
if mibBuilder.loadTexts: cefIntEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the CEF attributes associated with an interface. The interface is instantiated by ifIndex. Therefore, the interface index must have been assigned, according to the applicable procedures, before it can be meaningfully used. Generally, this means that the interface must exist. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefIntSwitchingState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("cefEnabled", 1), ("distCefEnabled", 2), ("cefDisabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefIntSwitchingState.setStatus('current')
if mibBuilder.loadTexts: cefIntSwitchingState.setDescription('The CEF switching State for the interface. If CEF is enabled but distributed CEF(dCEF) is disabled then CEF is in cefEnabled(1) state. If distributed CEF is enabled, then CEF is in distCefEnabled(2) state. The cefDisabled(3) state indicates that CEF is disabled. The CEF switching state is only applicable to the received packet on the interface.')
cefIntLoadSharing = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("perPacket", 1), ("perDestination", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefIntLoadSharing.setStatus('current')
if mibBuilder.loadTexts: cefIntLoadSharing.setDescription('The status of load sharing on the interface. perPacket(1) : Router to send data packets over successive equal-cost paths without regard to individual hosts or user sessions. perDestination(2) : Router to use multiple, equal-cost paths to achieve load sharing Load sharing is enabled by default for an interface when CEF is enabled.')
cefIntNonrecursiveAccouting = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefIntNonrecursiveAccouting.setStatus('current')
if mibBuilder.loadTexts: cefIntNonrecursiveAccouting.setDescription('The CEF accounting mode for the interface. CEF prefix based non-recursive accounting on an interface can be configured to store the stats for non-recursive prefixes in a internal or external bucket. internal(1) : Count input traffic in the nonrecursive internal bucket external(2) : Count input traffic in the nonrecursive external bucket The value of this object will only be effective if value of the object cefAccountingMap is set to enable nonRecursive(1) accounting.')
cefPeerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 1), )
if mibBuilder.loadTexts: cefPeerTable.setStatus('current')
if mibBuilder.loadTexts: cefPeerTable.setDescription('Entity acting as RP (Routing Processor) keeps the CEF states for the line card entities and communicates with the line card entities using XDR. This Table contains the CEF information related to peer entities on the managed device.')
cefPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "entPeerPhysicalIndex"))
if mibBuilder.loadTexts: cefPeerEntry.setStatus('current')
if mibBuilder.loadTexts: cefPeerEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the CEF related attributes associated with a CEF peer entity. entPhysicalIndex and entPeerPhysicalIndex are also indexes for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
entPeerPhysicalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 1, 1, 1), PhysicalIndex())
if mibBuilder.loadTexts: entPeerPhysicalIndex.setStatus('current')
if mibBuilder.loadTexts: entPeerPhysicalIndex.setDescription("The entity index for the CEF peer entity. Only the entities of 'module' entPhysicalClass are included here.")
cefPeerOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("peerDisabled", 1), ("peerUp", 2), ("peerHold", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPeerOperState.setStatus('current')
if mibBuilder.loadTexts: cefPeerOperState.setDescription('The current CEF operational state of the CEF peer entity. Cef peer entity oper state will be peerDisabled(1) in the following condition: : Cef Peer entity encounters fatal error i.e. resource allocation failure, ipc failure etc : When a reload/delete request is received from the Cef Peer Entity Once the peer entity is up and no fatal error is encountered, then the value of this object will transits to the peerUp(3) state. If the Cef Peer entity is in held stage, then the value of this object will be peerHold(3). Cef peer entity can only transit to peerDisabled(1) state from the peerHold(3) state.')
cefPeerNumberOfResets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPeerNumberOfResets.setStatus('current')
if mibBuilder.loadTexts: cefPeerNumberOfResets.setDescription('Number of times the session with CEF peer entity has been reset.')
cefPeerFIBTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 2), )
if mibBuilder.loadTexts: cefPeerFIBTable.setStatus('current')
if mibBuilder.loadTexts: cefPeerFIBTable.setDescription('Entity acting as RP (Routing Processor) keep the CEF FIB states for the line card entities and communicate with the line card entities using XDR. This Table contains the CEF FIB State related to peer entities on the managed device.')
cefPeerFIBEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "entPeerPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"))
if mibBuilder.loadTexts: cefPeerFIBEntry.setStatus('current')
if mibBuilder.loadTexts: cefPeerFIBEntry.setDescription("If CEF is enabled on the Managed device, each entry contains the CEF FIB State associated a CEF peer entity. entPhysicalIndex and entPeerPhysicalIndex are also indexes for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefPeerFIBOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("peerFIBDown", 1), ("peerFIBUp", 2), ("peerFIBReloadRequest", 3), ("peerFIBReloading", 4), ("peerFIBSynced", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefPeerFIBOperState.setStatus('current')
if mibBuilder.loadTexts: cefPeerFIBOperState.setDescription('The current CEF FIB Operational State for the CEF peer entity. ')
cefStatsPrefixLenTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1), )
if mibBuilder.loadTexts: cefStatsPrefixLenTable.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixLenTable.setDescription('This table specifies the CEF stats based on the Prefix Length.')
cefStatsPrefixLenEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"), (0, "CISCO-CEF-MIB", "cefStatsPrefixLen"))
if mibBuilder.loadTexts: cefStatsPrefixLenEntry.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixLenEntry.setDescription("If CEF is enabled on the Managed device and if CEF accounting is set to enable prefix length based accounting (value of cefCfgAccountingMap object in the cefCfgEntry is set to enable 'prefixLength' accounting), each entry contains the traffic statistics for a prefix length. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefStatsPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 1), InetAddressPrefixLength())
if mibBuilder.loadTexts: cefStatsPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixLen.setDescription('Length in bits of the Destination IP prefix. As 0.0.0.0/0 is a valid prefix, hence 0 is a valid prefix length.')
cefStatsPrefixQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixQueries.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixQueries.setDescription('Number of queries received in the FIB database for the specified IP prefix length.')
cefStatsPrefixHCQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixHCQueries.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixHCQueries.setDescription('Number of queries received in the FIB database for the specified IP prefix length. This object is a 64-bit version of cefStatsPrefixQueries.')
cefStatsPrefixInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixInserts.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixInserts.setDescription('Number of insert operations performed to the FIB database for the specified IP prefix length.')
cefStatsPrefixHCInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixHCInserts.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixHCInserts.setDescription('Number of insert operations performed to the FIB database for the specified IP prefix length. This object is a 64-bit version of cefStatsPrefixInsert.')
cefStatsPrefixDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixDeletes.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixDeletes.setDescription('Number of delete operations performed to the FIB database for the specified IP prefix length.')
cefStatsPrefixHCDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixHCDeletes.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixHCDeletes.setDescription('Number of delete operations performed to the FIB database for the specified IP prefix length. This object is a 64-bit version of cefStatsPrefixDelete.')
cefStatsPrefixElements = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixElements.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixElements.setDescription('Total number of elements in the FIB database for the specified IP prefix length.')
cefStatsPrefixHCElements = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 1, 1, 9), CounterBasedGauge64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefStatsPrefixHCElements.setStatus('current')
if mibBuilder.loadTexts: cefStatsPrefixHCElements.setDescription('Total number of elements in the FIB database for the specified IP prefix length. This object is a 64-bit version of cefStatsPrefixElements.')
cefSwitchingStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2), )
if mibBuilder.loadTexts: cefSwitchingStatsTable.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingStatsTable.setDescription('This table specifies the CEF switch stats.')
cefSwitchingStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-CEF-MIB", "cefFIBIpVersion"), (0, "CISCO-CEF-MIB", "cefSwitchingIndex"))
if mibBuilder.loadTexts: cefSwitchingStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingStatsEntry.setDescription("If CEF is enabled on the Managed device, each entry specifies the switching stats. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device. entPhysicalIndex is also an index for this table which represents entities of 'module' entPhysicalClass which are capable of running CEF.")
cefSwitchingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cefSwitchingIndex.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingIndex.setDescription('The locally arbitrary, but unique identifier associated with this switching stats entry.')
cefSwitchingPath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingPath.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingPath.setDescription('Switch path where the feature was executed. Available switch paths are platform-dependent. Following are the examples of switching paths: RIB : switching with CEF assistance Low-end switching (LES) : CEF switch path PAS : CEF turbo switch path. ')
cefSwitchingDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingDrop.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingDrop.setDescription('Number of packets dropped by CEF.')
cefSwitchingHCDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 4), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingHCDrop.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingHCDrop.setDescription('Number of packets dropped by CEF. This object is a 64-bit version of cefSwitchingDrop.')
cefSwitchingPunt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 5), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingPunt.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingPunt.setDescription('Number of packets that could not be switched in the normal path and were punted to the next-fastest switching vector.')
cefSwitchingHCPunt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 6), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingHCPunt.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingHCPunt.setDescription('Number of packets that could not be switched in the normal path and were punted to the next-fastest switching vector. This object is a 64-bit version of cefSwitchingPunt.')
cefSwitchingPunt2Host = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 7), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingPunt2Host.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingPunt2Host.setDescription('Number of packets that could not be switched in the normal path and were punted to the host (process switching path). For most of the switching paths, the value of this object may be similar to cefSwitchingPunt.')
cefSwitchingHCPunt2Host = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 8, 2, 1, 8), Counter64()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: cefSwitchingHCPunt2Host.setStatus('current')
if mibBuilder.loadTexts: cefSwitchingHCPunt2Host.setDescription('Number of packets that could not be switched in the normal path and were punted to the host (process switching path). For most of the switching paths, the value of this object may be similar to cefSwitchingPunt. This object is a 64-bit version of cefSwitchingPunt2Host.')
cefCCGlobalTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1), )
if mibBuilder.loadTexts: cefCCGlobalTable.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalTable.setDescription('This table contains CEF consistency checker (CC) global parameters for the managed device.')
cefCCGlobalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1), ).setIndexNames((0, "CISCO-CEF-MIB", "cefFIBIpVersion"))
if mibBuilder.loadTexts: cefCCGlobalEntry.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalEntry.setDescription('If the managed device supports CEF, each entry contains the global consistency checker parameter for the managed device. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device.')
cefCCGlobalAutoRepairEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCGlobalAutoRepairEnabled.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalAutoRepairEnabled.setDescription('Once an inconsistency has been detected, CEF has the ability to repair the problem. This object indicates the status of auto-repair function for the consistency checkers.')
cefCCGlobalAutoRepairDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCGlobalAutoRepairDelay.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalAutoRepairDelay.setDescription("Indiactes how long the consistency checker waits to fix an inconsistency. The value of this object has no effect when the value of object cefCCGlobalAutoRepairEnabled is 'false'.")
cefCCGlobalAutoRepairHoldDown = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 3), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCGlobalAutoRepairHoldDown.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalAutoRepairHoldDown.setDescription("Indicates how long the consistency checker waits to re-enable auto-repair after auto-repair runs. The value of this object has no effect when the value of object cefCCGlobalAutoRepairEnabled is 'false'.")
cefCCGlobalErrorMsgEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCGlobalErrorMsgEnabled.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalErrorMsgEnabled.setDescription('Enables the consistency checker to generate an error message when it detects an inconsistency.')
cefCCGlobalFullScanAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 5), CefCCAction().clone('ccActionNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCGlobalFullScanAction.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalFullScanAction.setDescription("Setting the value of this object to ccActionStart(1) will start the full scan consistency checkers. The Management station should poll the cefCCGlobalFullScanStatus object to get the state of full-scan operation. Once the full-scan operation completes (value of cefCCGlobalFullScanStatus object is ccStatusDone(3)), the Management station should retrieve the values of the related stats object from the cefCCTypeTable. Setting the value of this object to ccActionAbort(2) will abort the full-scan operation. The value of this object can't be set to ccActionStart(1), if the value of object cefCCGlobalFullScanStatus is ccStatusRunning(2). The value of this object will be set to cefActionNone(1) when the full scan consistency checkers have never been activated. A Management Station cannot set the value of this object to cefActionNone(1).")
cefCCGlobalFullScanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 1, 1, 6), CefCCStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCCGlobalFullScanStatus.setStatus('current')
if mibBuilder.loadTexts: cefCCGlobalFullScanStatus.setDescription('Indicates the status of the full scan consistency checker request.')
cefCCTypeTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2), )
if mibBuilder.loadTexts: cefCCTypeTable.setStatus('current')
if mibBuilder.loadTexts: cefCCTypeTable.setDescription('This table contains CEF consistency checker types specific parameters on the managed device. All detected inconsistency are signaled to the Management Station via cefInconsistencyDetection notification. ')
cefCCTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1), ).setIndexNames((0, "CISCO-CEF-MIB", "cefFIBIpVersion"), (0, "CISCO-CEF-MIB", "cefCCType"))
if mibBuilder.loadTexts: cefCCTypeEntry.setStatus('current')
if mibBuilder.loadTexts: cefCCTypeEntry.setDescription('If the managed device supports CEF, each entry contains the consistency checker statistics for a consistency checker type. A row may exist for each IP version type (v4 and v6) depending upon the IP version supported on the device.')
cefCCType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 1), CefCCType())
if mibBuilder.loadTexts: cefCCType.setStatus('current')
if mibBuilder.loadTexts: cefCCType.setDescription('Type of the consistency checker.')
cefCCEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCEnabled.setStatus('current')
if mibBuilder.loadTexts: cefCCEnabled.setDescription("Enables the passive consistency checker. Passive consistency checkers are disabled by default. Full-scan consistency checkers are always enabled. An attempt to set this object to 'false' for an active consistency checker will result in 'wrongValue' error.")
cefCCCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCCount.setStatus('current')
if mibBuilder.loadTexts: cefCCCount.setDescription('The maximum number of prefixes to check per scan. The default value for this object depends upon the consistency checker type. The value of this object will be irrelevant for some of the consistency checkers and will be set to 0. A Management Station cannot set the value of this object to 0.')
cefCCPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefCCPeriod.setStatus('current')
if mibBuilder.loadTexts: cefCCPeriod.setDescription('The period between scans for the consistency checker.')
cefCCQueriesSent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCCQueriesSent.setStatus('current')
if mibBuilder.loadTexts: cefCCQueriesSent.setDescription('Number of prefix consistency queries sent to CEF forwarding databases by this consistency checker.')
cefCCQueriesIgnored = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCCQueriesIgnored.setStatus('current')
if mibBuilder.loadTexts: cefCCQueriesIgnored.setDescription('Number of prefix consistency queries for which the consistency checks were not performed by this consistency checker. This may be because of some internal error or resource failure.')
cefCCQueriesChecked = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCCQueriesChecked.setStatus('current')
if mibBuilder.loadTexts: cefCCQueriesChecked.setDescription('Number of prefix consistency queries processed by this consistency checker.')
cefCCQueriesIterated = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefCCQueriesIterated.setStatus('current')
if mibBuilder.loadTexts: cefCCQueriesIterated.setDescription('Number of prefix consistency queries iterated back to the master database by this consistency checker.')
cefInconsistencyRecordTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3), )
if mibBuilder.loadTexts: cefInconsistencyRecordTable.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyRecordTable.setDescription('This table contains CEF inconsistency records.')
cefInconsistencyRecordEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1), ).setIndexNames((0, "CISCO-CEF-MIB", "cefFIBIpVersion"), (0, "CISCO-CEF-MIB", "cefInconsistencyRecId"))
if mibBuilder.loadTexts: cefInconsistencyRecordEntry.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyRecordEntry.setDescription('If the managed device supports CEF, each entry contains the inconsistency record.')
cefInconsistencyRecId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: cefInconsistencyRecId.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyRecId.setDescription('The locally arbitrary, but unique identifier associated with this inconsistency record entry.')
cefInconsistencyPrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyPrefixType.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyPrefixType.setDescription('The network prefix type associated with this inconsistency record.')
cefInconsistencyPrefixAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyPrefixAddr.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyPrefixAddr.setDescription('The network prefix address associated with this inconsistency record. The type of this address is determined by the value of the cefInconsistencyPrefixType object.')
cefInconsistencyPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 4), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyPrefixLen.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyPrefixLen.setDescription('Length in bits of the inconsistency address prefix.')
cefInconsistencyVrfName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 5), MplsVpnId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyVrfName.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyVrfName.setDescription('Vrf name associated with this inconsistency record.')
cefInconsistencyCCType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 6), CefCCType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyCCType.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyCCType.setDescription('The type of consistency checker who generated this inconsistency record.')
cefInconsistencyEntity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 7), EntPhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyEntity.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyEntity.setDescription('The entity for which this inconsistency record was generated. The value of this object will be irrelevant and will be set to 0 when the inconsisency record is applicable for all the entities.')
cefInconsistencyReason = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("missing", 1), ("checksumErr", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyReason.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyReason.setDescription('The reason for generating this inconsistency record. missing(1): the prefix is missing checksumErr(2): checksum error was found unknown(3): reason is unknown ')
entLastInconsistencyDetectTime = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 4), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: entLastInconsistencyDetectTime.setStatus('current')
if mibBuilder.loadTexts: entLastInconsistencyDetectTime.setDescription('The value of sysUpTime at the time an inconsistency is detecetd.')
cefInconsistencyReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 5), CefCCAction().clone('ccActionNone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefInconsistencyReset.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyReset.setDescription("Setting the value of this object to ccActionStart(1) will reset all the active consistency checkers. The Management station should poll the cefInconsistencyResetStatus object to get the state of inconsistency reset operation. This operation once started, cannot be aborted. Hence, the value of this object cannot be set to ccActionAbort(2). The value of this object can't be set to ccActionStart(1), if the value of object cefInconsistencyResetStatus is ccStatusRunning(2). ")
cefInconsistencyResetStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 7, 6), CefCCStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cefInconsistencyResetStatus.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyResetStatus.setDescription('Indicates the status of the consistency reset request.')
cefResourceFailureNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefResourceFailureNotifEnable.setStatus('current')
if mibBuilder.loadTexts: cefResourceFailureNotifEnable.setDescription('Indicates whether or not a notification should be generated on the detection of CEF resource Failure.')
cefPeerStateChangeNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefPeerStateChangeNotifEnable.setStatus('current')
if mibBuilder.loadTexts: cefPeerStateChangeNotifEnable.setDescription('Indicates whether or not a notification should be generated on the detection of CEF peer state change.')
cefPeerFIBStateChangeNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefPeerFIBStateChangeNotifEnable.setStatus('current')
if mibBuilder.loadTexts: cefPeerFIBStateChangeNotifEnable.setDescription('Indicates whether or not a notification should be generated on the detection of CEF FIB peer state change.')
cefNotifThrottlingInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 3600), ))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefNotifThrottlingInterval.setStatus('current')
if mibBuilder.loadTexts: cefNotifThrottlingInterval.setDescription("This object controls the generation of the cefInconsistencyDetection notification. If this object has a value of zero, then the throttle control is disabled. If this object has a non-zero value, then the agent must not generate more than one cefInconsistencyDetection 'notification-event' in the indicated period, where a 'notification-event' is the transmission of a single trap or inform PDU to a list of notification destinations. If additional inconsistency is detected within the throttling period, then notification-events for these inconsistencies should be suppressed by the agent until the current throttling period expires. At the end of a throttling period, one notification-event should be generated if any inconsistency was detected since the start of the throttling period. In such a case, another throttling period is started right away. An NMS should periodically poll cefInconsistencyRecordTable to detect any missed cefInconsistencyDetection notification-events, e.g., due to throttling or transmission loss. If cefNotifThrottlingInterval notification generation is enabled, the suggested default throttling period is 60 seconds, but generation of the cefInconsistencyDetection notification should be disabled by default. If the agent is capable of storing non-volatile configuration, then the value of this object must be restored after a re-initialization of the management system. The actual transmission of notifications is controlled via the MIB modules in RFC 3413.")
cefInconsistencyNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 492, 1, 9, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cefInconsistencyNotifEnable.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyNotifEnable.setDescription('Indicates whether cefInconsistencyDetection notification should be generated for this managed device.')
cefResourceFailure = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 492, 0, 1)).setObjects(("CISCO-CEF-MIB", "cefResourceFailureReason"))
if mibBuilder.loadTexts: cefResourceFailure.setStatus('current')
if mibBuilder.loadTexts: cefResourceFailure.setDescription('A cefResourceFailure notification is generated when CEF resource failure on the managed entity is detected. The reason for this failure is indicated by cefResourcefFailureReason.')
cefPeerStateChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 492, 0, 2)).setObjects(("CISCO-CEF-MIB", "cefPeerOperState"))
if mibBuilder.loadTexts: cefPeerStateChange.setStatus('current')
if mibBuilder.loadTexts: cefPeerStateChange.setDescription('A cefPeerStateChange notification is generated if change in cefPeerOperState is detected for the peer entity.')
cefPeerFIBStateChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 492, 0, 3)).setObjects(("CISCO-CEF-MIB", "cefPeerFIBOperState"))
if mibBuilder.loadTexts: cefPeerFIBStateChange.setStatus('current')
if mibBuilder.loadTexts: cefPeerFIBStateChange.setDescription('A cefPeerFIBStateChange notification is generated if change in cefPeerFIBOperState is detected for the peer entity.')
cefInconsistencyDetection = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 492, 0, 4)).setObjects(("CISCO-CEF-MIB", "entLastInconsistencyDetectTime"))
if mibBuilder.loadTexts: cefInconsistencyDetection.setStatus('current')
if mibBuilder.loadTexts: cefInconsistencyDetection.setDescription("A cefInconsistencyDetection notification is generated when CEF consistency checkers detects an inconsistent prefix in one of the CEF forwarding databases. Note that the generation of cefInconsistencyDetection notifications is throttled by the agent, as specified by the 'cefNotifThrottlingInterval' object.")
cefMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1))
cefMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 2))
cefMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 2, 1)).setObjects(("CISCO-CEF-MIB", "cefGroup"), ("CISCO-CEF-MIB", "cefNotifCntlGroup"), ("CISCO-CEF-MIB", "cefNotificationGroup"), ("CISCO-CEF-MIB", "cefDistributedGroup"), ("CISCO-CEF-MIB", "cefHCStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefMIBCompliance = cefMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cefMIBCompliance.setDescription('The compliance statement for SNMP Agents which implement this MIB.')
cefGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1, 1)).setObjects(("CISCO-CEF-MIB", "cefFIBSummaryFwdPrefixes"), ("CISCO-CEF-MIB", "cefPrefixForwardingInfo"), ("CISCO-CEF-MIB", "cefPrefixPkts"), ("CISCO-CEF-MIB", "cefPrefixBytes"), ("CISCO-CEF-MIB", "cefPrefixInternalNRPkts"), ("CISCO-CEF-MIB", "cefPrefixInternalNRBytes"), ("CISCO-CEF-MIB", "cefPrefixExternalNRPkts"), ("CISCO-CEF-MIB", "cefPrefixExternalNRBytes"), ("CISCO-CEF-MIB", "cefLMPrefixSpinLock"), ("CISCO-CEF-MIB", "cefLMPrefixState"), ("CISCO-CEF-MIB", "cefLMPrefixAddr"), ("CISCO-CEF-MIB", "cefLMPrefixLen"), ("CISCO-CEF-MIB", "cefLMPrefixRowStatus"), ("CISCO-CEF-MIB", "cefPathType"), ("CISCO-CEF-MIB", "cefPathInterface"), ("CISCO-CEF-MIB", "cefPathNextHopAddr"), ("CISCO-CEF-MIB", "cefPathRecurseVrfName"), ("CISCO-CEF-MIB", "cefAdjSummaryComplete"), ("CISCO-CEF-MIB", "cefAdjSummaryIncomplete"), ("CISCO-CEF-MIB", "cefAdjSummaryFixup"), ("CISCO-CEF-MIB", "cefAdjSummaryRedirect"), ("CISCO-CEF-MIB", "cefAdjSource"), ("CISCO-CEF-MIB", "cefAdjEncap"), ("CISCO-CEF-MIB", "cefAdjFixup"), ("CISCO-CEF-MIB", "cefAdjMTU"), ("CISCO-CEF-MIB", "cefAdjForwardingInfo"), ("CISCO-CEF-MIB", "cefAdjPkts"), ("CISCO-CEF-MIB", "cefAdjBytes"), ("CISCO-CEF-MIB", "cefFESelectionSpecial"), ("CISCO-CEF-MIB", "cefFESelectionLabels"), ("CISCO-CEF-MIB", "cefFESelectionAdjLinkType"), ("CISCO-CEF-MIB", "cefFESelectionAdjInterface"), ("CISCO-CEF-MIB", "cefFESelectionAdjNextHopAddrType"), ("CISCO-CEF-MIB", "cefFESelectionAdjNextHopAddr"), ("CISCO-CEF-MIB", "cefFESelectionAdjConnId"), ("CISCO-CEF-MIB", "cefFESelectionVrfName"), ("CISCO-CEF-MIB", "cefFESelectionWeight"), ("CISCO-CEF-MIB", "cefCfgAdminState"), ("CISCO-CEF-MIB", "cefCfgOperState"), ("CISCO-CEF-MIB", "cefCfgAccountingMap"), ("CISCO-CEF-MIB", "cefCfgLoadSharingAlgorithm"), ("CISCO-CEF-MIB", "cefCfgLoadSharingID"), ("CISCO-CEF-MIB", "cefCfgTrafficStatsLoadInterval"), ("CISCO-CEF-MIB", "cefCfgTrafficStatsUpdateRate"), ("CISCO-CEF-MIB", "cefResourceMemoryUsed"), ("CISCO-CEF-MIB", "cefResourceFailureReason"), ("CISCO-CEF-MIB", "cefIntSwitchingState"), ("CISCO-CEF-MIB", "cefIntLoadSharing"), ("CISCO-CEF-MIB", "cefIntNonrecursiveAccouting"), ("CISCO-CEF-MIB", "cefStatsPrefixQueries"), ("CISCO-CEF-MIB", "cefStatsPrefixInserts"), ("CISCO-CEF-MIB", "cefStatsPrefixDeletes"), ("CISCO-CEF-MIB", "cefStatsPrefixElements"), ("CISCO-CEF-MIB", "cefSwitchingPath"), ("CISCO-CEF-MIB", "cefSwitchingDrop"), ("CISCO-CEF-MIB", "cefSwitchingPunt"), ("CISCO-CEF-MIB", "cefSwitchingPunt2Host"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefGroup = cefGroup.setStatus('current')
if mibBuilder.loadTexts: cefGroup.setDescription('This group consists of all the managed objects which are applicable to CEF irrespective of the value of object cefDistributionOperState.')
cefDistributedGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1, 2)).setObjects(("CISCO-CEF-MIB", "cefCfgDistributionAdminState"), ("CISCO-CEF-MIB", "cefCfgDistributionOperState"), ("CISCO-CEF-MIB", "cefPeerOperState"), ("CISCO-CEF-MIB", "cefPeerNumberOfResets"), ("CISCO-CEF-MIB", "cefPeerFIBOperState"), ("CISCO-CEF-MIB", "cefCCGlobalAutoRepairEnabled"), ("CISCO-CEF-MIB", "cefCCGlobalAutoRepairDelay"), ("CISCO-CEF-MIB", "cefCCGlobalAutoRepairHoldDown"), ("CISCO-CEF-MIB", "cefCCGlobalErrorMsgEnabled"), ("CISCO-CEF-MIB", "cefCCGlobalFullScanStatus"), ("CISCO-CEF-MIB", "cefCCGlobalFullScanAction"), ("CISCO-CEF-MIB", "cefCCEnabled"), ("CISCO-CEF-MIB", "cefCCCount"), ("CISCO-CEF-MIB", "cefCCPeriod"), ("CISCO-CEF-MIB", "cefCCQueriesSent"), ("CISCO-CEF-MIB", "cefCCQueriesIgnored"), ("CISCO-CEF-MIB", "cefCCQueriesChecked"), ("CISCO-CEF-MIB", "cefCCQueriesIterated"), ("CISCO-CEF-MIB", "entLastInconsistencyDetectTime"), ("CISCO-CEF-MIB", "cefInconsistencyPrefixType"), ("CISCO-CEF-MIB", "cefInconsistencyPrefixAddr"), ("CISCO-CEF-MIB", "cefInconsistencyPrefixLen"), ("CISCO-CEF-MIB", "cefInconsistencyVrfName"), ("CISCO-CEF-MIB", "cefInconsistencyCCType"), ("CISCO-CEF-MIB", "cefInconsistencyEntity"), ("CISCO-CEF-MIB", "cefInconsistencyReason"), ("CISCO-CEF-MIB", "cefInconsistencyReset"), ("CISCO-CEF-MIB", "cefInconsistencyResetStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefDistributedGroup = cefDistributedGroup.setStatus('current')
if mibBuilder.loadTexts: cefDistributedGroup.setDescription("This group consists of all the Managed objects which are only applicable to CEF is the value of object cefDistributionOperState is 'up'.")
cefHCStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1, 3)).setObjects(("CISCO-CEF-MIB", "cefPrefixHCPkts"), ("CISCO-CEF-MIB", "cefPrefixHCBytes"), ("CISCO-CEF-MIB", "cefPrefixInternalNRHCPkts"), ("CISCO-CEF-MIB", "cefPrefixInternalNRHCBytes"), ("CISCO-CEF-MIB", "cefPrefixExternalNRHCPkts"), ("CISCO-CEF-MIB", "cefPrefixExternalNRHCBytes"), ("CISCO-CEF-MIB", "cefAdjHCPkts"), ("CISCO-CEF-MIB", "cefAdjHCBytes"), ("CISCO-CEF-MIB", "cefStatsPrefixHCQueries"), ("CISCO-CEF-MIB", "cefStatsPrefixHCInserts"), ("CISCO-CEF-MIB", "cefStatsPrefixHCDeletes"), ("CISCO-CEF-MIB", "cefStatsPrefixHCElements"), ("CISCO-CEF-MIB", "cefSwitchingHCDrop"), ("CISCO-CEF-MIB", "cefSwitchingHCPunt"), ("CISCO-CEF-MIB", "cefSwitchingHCPunt2Host"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefHCStatsGroup = cefHCStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cefHCStatsGroup.setDescription('This group consists of all the 64-bit counter objects which are applicable to CEF irrespective of the value of object cefDistributionOperState.')
cefNotifCntlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1, 5)).setObjects(("CISCO-CEF-MIB", "cefResourceFailureNotifEnable"), ("CISCO-CEF-MIB", "cefPeerStateChangeNotifEnable"), ("CISCO-CEF-MIB", "cefPeerFIBStateChangeNotifEnable"), ("CISCO-CEF-MIB", "cefNotifThrottlingInterval"), ("CISCO-CEF-MIB", "cefInconsistencyNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefNotifCntlGroup = cefNotifCntlGroup.setStatus('current')
if mibBuilder.loadTexts: cefNotifCntlGroup.setDescription('This group of objects controls the sending of CEF Notifications.')
cefNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 492, 2, 1, 6)).setObjects(("CISCO-CEF-MIB", "cefResourceFailure"), ("CISCO-CEF-MIB", "cefPeerStateChange"), ("CISCO-CEF-MIB", "cefPeerFIBStateChange"), ("CISCO-CEF-MIB", "cefInconsistencyDetection"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cefNotificationGroup = cefNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cefNotificationGroup.setDescription('This group contains the notifications for the CEF MIB.')
mibBuilder.exportSymbols("CISCO-CEF-MIB", ciscoCefMIBObjects=ciscoCefMIBObjects, cefInconsistencyDetection=cefInconsistencyDetection, cefAdjConnId=cefAdjConnId, cefCCQueriesIgnored=cefCCQueriesIgnored, cefFESelectionAdjConnId=cefFESelectionAdjConnId, cefFESelectionEntry=cefFESelectionEntry, cefLMPrefixLen=cefLMPrefixLen, cefResourceMemoryUsed=cefResourceMemoryUsed, cefFIBSummaryEntry=cefFIBSummaryEntry, cefCfgTable=cefCfgTable, cefCfgTrafficStatsLoadInterval=cefCfgTrafficStatsLoadInterval, ciscoCefMIBNotifs=ciscoCefMIBNotifs, cefFIBSummaryTable=cefFIBSummaryTable, cefCCCount=cefCCCount, cefInconsistencyRecordTable=cefInconsistencyRecordTable, cefCCTypeEntry=cefCCTypeEntry, cefPeerStateChange=cefPeerStateChange, cefLMPrefixDestAddrType=cefLMPrefixDestAddrType, cefPathType=cefPathType, cefAdjSource=cefAdjSource, cefSwitchingPath=cefSwitchingPath, cefAdjTable=cefAdjTable, cefCCPeriod=cefCCPeriod, cefFESelectionLabels=cefFESelectionLabels, cefStatsPrefixInserts=cefStatsPrefixInserts, cefAdjBytes=cefAdjBytes, cefIntLoadSharing=cefIntLoadSharing, cefStatsPrefixHCDeletes=cefStatsPrefixHCDeletes, cefLMPrefixTable=cefLMPrefixTable, cefSwitchingDrop=cefSwitchingDrop, entLastInconsistencyDetectTime=entLastInconsistencyDetectTime, cefInconsistencyNotifEnable=cefInconsistencyNotifEnable, cefCfgAdminState=cefCfgAdminState, cefCCGlobalAutoRepairHoldDown=cefCCGlobalAutoRepairHoldDown, cefResourceFailureNotifEnable=cefResourceFailureNotifEnable, cefFESelectionWeight=cefFESelectionWeight, cefPrefixAddr=cefPrefixAddr, cefPrefixLen=cefPrefixLen, cefCfgLoadSharingAlgorithm=cefCfgLoadSharingAlgorithm, cefInconsistencyPrefixAddr=cefInconsistencyPrefixAddr, cefSwitchingStatsEntry=cefSwitchingStatsEntry, cefPrefixType=cefPrefixType, cefPrefixInternalNRPkts=cefPrefixInternalNRPkts, cefAdjSummaryLinkType=cefAdjSummaryLinkType, cefAdjMTU=cefAdjMTU, cefPrefixExternalNRHCPkts=cefPrefixExternalNRHCPkts, cefAdjFixup=cefAdjFixup, cefFESelectionSpecial=cefFESelectionSpecial, cefFESelectionAdjLinkType=cefFESelectionAdjLinkType, cefPathRecurseVrfName=cefPathRecurseVrfName, cefNotificationGroup=cefNotificationGroup, cefCfgEntry=cefCfgEntry, cefCCQueriesSent=cefCCQueriesSent, cefPathNextHopAddr=cefPathNextHopAddr, cefLMPrefixEntry=cefLMPrefixEntry, cefPrefixEntry=cefPrefixEntry, cefPrefixInternalNRHCPkts=cefPrefixInternalNRHCPkts, cefFESelectionName=cefFESelectionName, cefInconsistencyVrfName=cefInconsistencyVrfName, cefLMPrefixRowStatus=cefLMPrefixRowStatus, cefCCType=cefCCType, cefFESelectionAdjNextHopAddrType=cefFESelectionAdjNextHopAddrType, cefMIBCompliance=cefMIBCompliance, cefPathId=cefPathId, cefPrefixHCBytes=cefPrefixHCBytes, cefSwitchingHCPunt2Host=cefSwitchingHCPunt2Host, cefPeerFIBEntry=cefPeerFIBEntry, cefInconsistencyReset=cefInconsistencyReset, cefStats=cefStats, cefResourceFailureReason=cefResourceFailureReason, cefStatsPrefixLenTable=cefStatsPrefixLenTable, cefPeer=cefPeer, cefCCEnabled=cefCCEnabled, cefAdjNextHopAddr=cefAdjNextHopAddr, cefStatsPrefixElements=cefStatsPrefixElements, cefCCGlobalErrorMsgEnabled=cefCCGlobalErrorMsgEnabled, cefFE=cefFE, cefAdjNextHopAddrType=cefAdjNextHopAddrType, cefInconsistencyResetStatus=cefInconsistencyResetStatus, cefCCQueriesChecked=cefCCQueriesChecked, cefCCGlobalAutoRepairDelay=cefCCGlobalAutoRepairDelay, cefAdjSummaryIncomplete=cefAdjSummaryIncomplete, cefAdjSummary=cefAdjSummary, cefResourceTable=cefResourceTable, cefNotifCntl=cefNotifCntl, cefFIBSummaryFwdPrefixes=cefFIBSummaryFwdPrefixes, cefPeerTable=cefPeerTable, cefGroup=cefGroup, cefAdjSummaryComplete=cefAdjSummaryComplete, cefFESelectionTable=cefFESelectionTable, cefCfgDistributionOperState=cefCfgDistributionOperState, cefInconsistencyRecordEntry=cefInconsistencyRecordEntry, cefPathTable=cefPathTable, cefPeerNumberOfResets=cefPeerNumberOfResets, cefCCGlobalFullScanAction=cefCCGlobalFullScanAction, cefFESelectionId=cefFESelectionId, cefPrefixHCPkts=cefPrefixHCPkts, cefSwitchingPunt=cefSwitchingPunt, cefIntTable=cefIntTable, cefCCGlobalFullScanStatus=cefCCGlobalFullScanStatus, cefSwitchingIndex=cefSwitchingIndex, cefSwitchingHCDrop=cefSwitchingHCDrop, cefGlobal=cefGlobal, cefCCGlobalTable=cefCCGlobalTable, cefInconsistencyPrefixType=cefInconsistencyPrefixType, cefDistributedGroup=cefDistributedGroup, cefResourceFailure=cefResourceFailure, cefAdjHCBytes=cefAdjHCBytes, cefAdjSummaryEntry=cefAdjSummaryEntry, cefAdjSummaryRedirect=cefAdjSummaryRedirect, cefPrefixBytes=cefPrefixBytes, cefInconsistencyPrefixLen=cefInconsistencyPrefixLen, cefHCStatsGroup=cefHCStatsGroup, cefFIBSummary=cefFIBSummary, cefInconsistencyCCType=cefInconsistencyCCType, cefCfgOperState=cefCfgOperState, cefIntEntry=cefIntEntry, cefPrefixForwardingInfo=cefPrefixForwardingInfo, cefInconsistencyEntity=cefInconsistencyEntity, cefCCTypeTable=cefCCTypeTable, cefCC=cefCC, cefStatsPrefixDeletes=cefStatsPrefixDeletes, cefPeerOperState=cefPeerOperState, cefStatsPrefixLenEntry=cefStatsPrefixLenEntry, cefPrefixExternalNRBytes=cefPrefixExternalNRBytes, entPeerPhysicalIndex=entPeerPhysicalIndex, cefPrefixInternalNRHCBytes=cefPrefixInternalNRHCBytes, cefCfgTrafficStatsUpdateRate=cefCfgTrafficStatsUpdateRate, ciscoCefMIB=ciscoCefMIB, cefPrefixExternalNRPkts=cefPrefixExternalNRPkts, cefAdj=cefAdj, cefAdjSummaryFixup=cefAdjSummaryFixup, cefStatsPrefixQueries=cefStatsPrefixQueries, cefMIBCompliances=cefMIBCompliances, cefFESelectionVrfName=cefFESelectionVrfName, cefLMPrefixSpinLock=cefLMPrefixSpinLock, cefPrefixTable=cefPrefixTable, cefFIB=cefFIB, cefPrefixInternalNRBytes=cefPrefixInternalNRBytes, cefLMPrefixState=cefLMPrefixState, PYSNMP_MODULE_ID=ciscoCefMIB, cefCfgAccountingMap=cefCfgAccountingMap, cefSwitchingStatsTable=cefSwitchingStatsTable, cefSwitchingPunt2Host=cefSwitchingPunt2Host, cefPrefixExternalNRHCBytes=cefPrefixExternalNRHCBytes, cefFIBIpVersion=cefFIBIpVersion, cefStatsPrefixHCQueries=cefStatsPrefixHCQueries, cefIntNonrecursiveAccouting=cefIntNonrecursiveAccouting, cefFESelectionAdjInterface=cefFESelectionAdjInterface, cefCCGlobalAutoRepairEnabled=cefCCGlobalAutoRepairEnabled, cefPathEntry=cefPathEntry, cefPathInterface=cefPathInterface, cefCCQueriesIterated=cefCCQueriesIterated, cefAdjForwardingInfo=cefAdjForwardingInfo, cefResourceEntry=cefResourceEntry, cefStatsPrefixLen=cefStatsPrefixLen, cefAdjSummaryTable=cefAdjSummaryTable, cefStatsPrefixHCElements=cefStatsPrefixHCElements, cefPeerFIBStateChange=cefPeerFIBStateChange, cefInconsistencyRecId=cefInconsistencyRecId, cefPeerStateChangeNotifEnable=cefPeerStateChangeNotifEnable, cefLMPrefixAddr=cefLMPrefixAddr, cefAdjEncap=cefAdjEncap, cefAdjEntry=cefAdjEntry, cefPeerEntry=cefPeerEntry, cefNotifCntlGroup=cefNotifCntlGroup, cefPeerFIBTable=cefPeerFIBTable, cefAdjHCPkts=cefAdjHCPkts, cefInterface=cefInterface, cefIntSwitchingState=cefIntSwitchingState, cefNotifThrottlingInterval=cefNotifThrottlingInterval, cefFESelectionAdjNextHopAddr=cefFESelectionAdjNextHopAddr, cefInconsistencyReason=cefInconsistencyReason, cefLMPrefixDestAddr=cefLMPrefixDestAddr, cefCCGlobalEntry=cefCCGlobalEntry, cefPeerFIBStateChangeNotifEnable=cefPeerFIBStateChangeNotifEnable, cefMIBGroups=cefMIBGroups, cefPeerFIBOperState=cefPeerFIBOperState, ciscoCefMIBConform=ciscoCefMIBConform, cefPrefixPkts=cefPrefixPkts, cefCfgLoadSharingID=cefCfgLoadSharingID, cefCfgDistributionAdminState=cefCfgDistributionAdminState, cefAdjPkts=cefAdjPkts, cefStatsPrefixHCInserts=cefStatsPrefixHCInserts, cefSwitchingHCPunt=cefSwitchingHCPunt)

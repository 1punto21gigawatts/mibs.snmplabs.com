#
# PySNMP MIB module CISCO-ENHANCED-MEMPOOL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-ENHANCED-MEMPOOL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:56:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
entPhysicalIndex, = mibBuilder.importSymbols("ENTITY-MIB", "entPhysicalIndex")
CounterBasedGauge64, = mibBuilder.importSymbols("HCNUM-TC", "CounterBasedGauge64")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
IpAddress, MibIdentifier, ModuleIdentity, ObjectIdentity, Unsigned32, Counter32, Bits, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Integer32, Gauge32, NotificationType, iso = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibIdentifier", "ModuleIdentity", "ObjectIdentity", "Unsigned32", "Counter32", "Bits", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Integer32", "Gauge32", "NotificationType", "iso")
DisplayString, TruthValue, TimeStamp, AutonomousType, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "TimeStamp", "AutonomousType", "TextualConvention")
ciscoEnhancedMemPoolMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 221))
ciscoEnhancedMemPoolMIB.setRevisions(('2008-12-05 00:00', '2008-05-07 00:00', '2003-02-24 00:00', '2001-06-05 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setRevisionsDescriptions(('Added the following High Capacity and Overflow objects in cempMemPoolTable. cempMemPoolUsedOvrflw, cempMemPoolHCUsed, cempMemPoolFreeOvrflw, cempMemPoolHCFree, cempMemPoolLargestFreeOvrflw, cempMemPoolHCLargestFree, cempMemPoolLowestFreeOvrflw, cempMemPoolHCLowestFree, cempMemPoolUsedLowWaterMarkOvrflw, cempMemPoolHCUsedLowWaterMark, cempMemPoolSharedOvrflw, cempMemPoolHCShared. Added couple of new groups cempMemPoolHCGroup and cempMemPoolOvrflwGroup. Added a new compliance cempMIBComplianceRev3 which deprecates cempMIBComplianceRev2.', 'Added a new object cempMemPoolShared in cempMemPoolTable. Deprecated cempMemPoolGroup OBJECT-GROUP. Added cempMemPoolGroupRev1 OBJECT-GROUP. Deprecated cempMIBComplianceRev1 MODULE-COMPLIANCE. Added cempMIBComplianceRev2 MODULE-COMPLIANCE.', 'Revised version of this MIB,added Objects to the existing cempMemPoolTable, added buffer pools. Different types of memory buffer pools may be present in a managed device. For example: 1. Public buffers, these are standard pools of packets of different sizes (eg: 104B, 600B, 1536B, 4520B, 5024B, 18024B ...). 2. Private [Interface] buffers (eg. ipc, channel ...). 3. Header pool. Pool of dynamic packet headers. Header buffers have no associated data blocks or particles. (Particles are a mechanism for representing a data packet as a collection of discontigious buffers.). The new objects added are cempMemPoolUsedLowWaterMark, cempMemPoolAllocHit, cempMemPoolAllocMiss, cempMemPoolFreeHit, cempMemPoolFreeMiss, cempMemBufferPoolTable & cempMemBufferCachePoolTable.', 'Initial version of this MIB.',))
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setLastUpdated('200812050000Z')
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-memory@cisco.com')
if mibBuilder.loadTexts: ciscoEnhancedMemPoolMIB.setDescription('New MIB module for monitoring the memory pools of all physical entities on a managed system.')
cempMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 0))
cempMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1))
cempMemPool = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1))
cempNotificationConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 2))
class CempMemPoolIndex(TextualConvention, Integer32):
    description = 'A unique value, greater than zero, for each memory pool in a particular physical entity. It is recommended that values are assigned contiguously starting from 1 such that the index will be unique within a particular physical entity.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 2147483647)

class CempMemPoolIndexOrNone(TextualConvention, Integer32):
    description = 'This textual convention is an extension of the CempMemPoolIndex. The latter defines a value greater than zero to identify a memory pool in a particular physical entity. This extension permits the additional value of zero. The value zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero might include situations where memory pool was unknown, or when none or all memory pools need to be referenced.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class CempMemPoolTypes(TextualConvention, Integer32):
    description = 'Represents the different types of memory pools that may be present in a managed device. Note that only the processor pool is required to be supported by all devices. Support for other pool types is dependent on the device being managed. processorMemory - processor associated heap memory. ioMemory - shared memory for buffer data and controller descriptor blocks. pciMemory - Peripheral Component Interconnect bus memory which is visible to all devices on the PCI buses in a platform. fastMemory - memory defined by the particular platform for speed critical applications. multibusMemory - memory present on some platforms that is used as a fallback pool. interruptStackMemory - memory for allocating interrupt stacks. It is usually allocated from heap. processStackMemory - memory for allocating process stacks. It is usually allocated from heap. localExceptionMemory - memory reserved for processing a system core dump. virtualMemory - memory used to increase available RAM. reservedMemory - memory used for packet headers, particle headers and particles. imageMemory - memory which corresponds to the image file system. asicMemory - Application Specific Integrated Circuit memory. posixMemory - Heap memory associated with posix style processes in ion.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))
    namedValues = NamedValues(("other", 1), ("processorMemory", 2), ("ioMemory", 3), ("pciMemory", 4), ("fastMemory", 5), ("multibusMemory", 6), ("interruptStackMemory", 7), ("processStackMemory", 8), ("localExceptionMemory", 9), ("virtualMemory", 10), ("reservedMemory", 11), ("imageMemory", 12), ("asicMemory", 13), ("posixMemory", 14))

class CempMemBufferPoolIndex(TextualConvention, Unsigned32):
    description = 'A unique value, greater than zero, for each buffer pool in the memory pool on a physical entity. It is recommended that values are assigned contiguously starting from 1 such that the index will be unique within a physical entity. Note that the index does not overlap among different memory pools.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

cempMemPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1), )
if mibBuilder.loadTexts: cempMemPoolTable.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolTable.setDescription('A table of memory pool monitoring entries for all physical entities on a managed system.')
cempMemPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolIndex"))
if mibBuilder.loadTexts: cempMemPoolEntry.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolEntry.setDescription('An entry in the memory pool monitoring table.')
cempMemPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 1), CempMemPoolIndex())
if mibBuilder.loadTexts: cempMemPoolIndex.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolIndex.setDescription('Within each physical entity, the unique value greater than zero, used to represent each memory pool. It is recommended that values are assigned contiguously starting from 1.')
cempMemPoolType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 2), CempMemPoolTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolType.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolType.setDescription('The type of memory pool for which this entry contains information.')
cempMemPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolName.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolName.setDescription('A textual name assigned to the memory pool. This object is suitable for output to a human operator, and may also be used to distinguish among the various pool types.')
cempMemPoolPlatformMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 4), AutonomousType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolPlatformMemory.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolPlatformMemory.setDescription('An indication of the platform-specific memory pool type. The associated instance of cempMemPoolType is used to indicate the general type of memory pool. If no platform specific memory hardware type identifier exists for this physical entity, or the value is unknown by this agent, then the value { 0 0 } is returned.')
cempMemPoolAlternate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 5), CempMemPoolIndexOrNone()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAlternate.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolAlternate.setDescription('Indicates whether or not this memory pool has an alternate pool configured. Alternate pools are used for fallback when the current pool runs out of memory. If an instance of this object has a value of zero, then this pool does not have an alternate. Otherwise the value of this object is the same as the value of cempMemPoolType of the alternate pool.')
cempMemPoolValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolValid.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolValid.setDescription('Indicates whether or not cempMemPoolUsed, cempMemPoolFree, cempMemPoolLargestFree and cempMemPoolLowestFree in this entry contain accurate data. If an instance of this object has the value false (which in and of itself indicates an internal error condition), the values of these objects in the conceptual row may contain inaccurate information (specifically, the reported values may be less than the actual values).')
cempMemPoolUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 7), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsed.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolUsed.setDescription('Indicates the number of bytes from the memory pool that are currently in use by applications on the physical entity.')
cempMemPoolFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 8), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolFree.setDescription('Indicates the number of bytes from the memory pool that are currently unused on the physical entity. Note that the sum of cempMemPoolUsed and cempMemPoolFree is the total amount of memory in the pool')
cempMemPoolLargestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 9), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLargestFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolLargestFree.setDescription('Indicates the largest number of contiguous bytes from the memory pool that are currently unused on the physical entity.')
cempMemPoolLowestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 10), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLowestFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolLowestFree.setDescription('The lowest amount of available memory in the memory pool recorded at any time during the operation of the system.')
cempMemPoolUsedLowWaterMark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMark.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMark.setDescription('Indicates the lowest number of bytes from the memory pool that have been used by applications on the physical entity since sysUpTime.Similarly,the Used High Watermark indicates the largest number of bytes from the memory pool that have been used by applications on the physical entity since sysUpTime.This can be derived as follows: Used High Watermark = cempMemPoolUsed + cempMemPoolFree - cempMemPoolLowestFree.')
cempMemPoolAllocHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAllocHit.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolAllocHit.setDescription('Indicates the number of successful allocations from the memory pool')
cempMemPoolAllocMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolAllocMiss.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolAllocMiss.setDescription('Indicates the number of unsuccessful allocations from the memory pool')
cempMemPoolFreeHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeHit.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolFreeHit.setDescription('Indicates the number of successful frees/ deallocations from the memory pool')
cempMemPoolFreeMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeMiss.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolFreeMiss.setDescription('Indicates the number of unsuccessful attempts to free/deallocate memory from the memory pool. For example, this could be due to ownership errors where the application that did not assign the memory is trying to free it.')
cempMemPoolShared = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 16), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolShared.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolShared.setDescription('Indicates the number of bytes from the memory pool that are currently shared on the physical entity.')
cempMemPoolUsedOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 17), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolUsedOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolUsed. This object needs to be supported only if the used bytes in the memory pool exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 18), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCUsed.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCUsed.setDescription('Indicates the number of bytes from the memory pool that are currently in use by applications on the physical entity. This object is a 64-bit version of cempMemPoolUsed.')
cempMemPoolFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 19), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolFreeOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolFreeOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolFree. This object needs to be supported only if the unused bytes in the memory pool exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 20), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCFree.setDescription('Indicates the number of bytes from the memory pool that are currently unused on the physical entity. This object is a 64-bit version of cempMemPoolFree.')
cempMemPoolLargestFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 21), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLargestFreeOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolLargestFreeOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolLargestFree. This object needs to be supported only if the value of cempMemPoolLargestFree exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCLargestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 22), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCLargestFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCLargestFree.setDescription('Indicates the largest number of contiguous bytes from the memory pool that are currently unused on the physical entity. This object is a 64-bit version of cempMemPoolLargestFree.')
cempMemPoolLowestFreeOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 23), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolLowestFreeOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolLowestFreeOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolLowestFree. This object needs to be supported only if the value of cempMemPoolLowestFree exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCLowestFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 24), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCLowestFree.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCLowestFree.setDescription('The lowest amount of available memory in the memory pool recorded at any time during the operation of the system. This object is a 64-bit version of cempMemPoolLowestFree.')
cempMemPoolUsedLowWaterMarkOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 25), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMarkOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolUsedLowWaterMarkOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolUsedLowWaterMark. This object needs to be supported only if the value of cempMemPoolUsedLowWaterMark exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCUsedLowWaterMark = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 26), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCUsedLowWaterMark.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCUsedLowWaterMark.setDescription('Indicates the lowest number of bytes from the memory pool that have been used by applications on the physical entity since sysUpTime. This object is a 64-bit version of cempMemPoolUsedLowWaterMark.')
cempMemPoolSharedOvrflw = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 27), Gauge32()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolSharedOvrflw.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolSharedOvrflw.setDescription('This object represents the upper 32-bits of cempMemPoolShared. This object needs to be supported only if the value of cempMemPoolShared exceeds 32-bits, otherwise this object value would be set to 0.')
cempMemPoolHCShared = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 1, 1, 28), CounterBasedGauge64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemPoolHCShared.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCShared.setDescription('Indicates the number of bytes from the memory pool that are currently shared on the physical entity. This object is a 64-bit version of cempMemPoolShared.')
cempMemBufferPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2), )
if mibBuilder.loadTexts: cempMemBufferPoolTable.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPoolTable.setDescription('Entries in this table define entities (buffer pools in this case) which are contained in an entity (memory pool) defined by an entry from cempMemPoolTable. -- Basic Pool Architecture -- 1)Pools are classified as being either Static or Dynamic. Static pools make no attempt to increase the number of buffers contained within them if the number of free buffers (cempMemBufferFree) are less than the number of minimum buffers (cempMemBufferMin). With Dynamic pools, the pool attempts to meet the demands of its users. 2)Buffers in a pool are classified as being either Permanent or Temporary. Permanent buffers, as their name suggests, are always in the pool and are never destroyed unless the number of permanent buffers (cempMemBufferPermanent) is changed. Temporary buffers are transient buffers that are created in dynamic pools whenever the free count (cempMemBufferFree) of buffers in the pool drops below the minimum (cempMemBufferMin). 3)Buffers pools are classified as either Public or Private. Public pools are available for all users to allocate buffers from. Private pools are primarily used by interface drivers.')
cempMemBufferPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPoolIndex"))
if mibBuilder.loadTexts: cempMemBufferPoolEntry.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPoolEntry.setDescription('This contains all the memory buffer pool configurations object values. The entPhysicalIndex identifies the entity on which memory buffer pools are present.')
cempMemBufferPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 1), CempMemBufferPoolIndex())
if mibBuilder.loadTexts: cempMemBufferPoolIndex.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPoolIndex.setDescription('Within a physical entity, a unique value used to represent each buffer pool.')
cempMemBufferMemPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 2), CempMemPoolIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferMemPoolIndex.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferMemPoolIndex.setDescription('This index corresponds to the memory pool (with cemMemPoolIndex as index in cempMemPoolTable) from which buffers are allocated.')
cempMemBufferName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferName.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferName.setDescription("A textual name assigned to the buffer pool. This object is suitable for output to a human operator, and may also be used to distinguish among the various buffer types. For example: 'Small', 'Big', 'Serial0/1' etc.")
cempMemBufferDynamic = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferDynamic.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferDynamic.setDescription('Boolean poolDynamic; if TRUE, the number of buffers in the pool is adjusted (adding more packet buffers or deleting excesses) dynamically by the background process. If FALSE, the number of buffers in the pool is never adjusted, even if it falls below the minimum, or to zero.')
cempMemBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 5), Unsigned32()).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferSize.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferSize.setDescription('Indicates the size of buffer element in number of bytes on the physical entity.')
cempMemBufferMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferMin.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferMin.setDescription('Indicates the minimum number of free buffers allowed in the buffer pool or low-water mark (lwm). For example of its usage : If cempMemBufferFree < cempMemBufferMin & pool is dynamic, then signal for growth of particular buffer pool.')
cempMemBufferMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferMax.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferMax.setDescription('Indicates the maximum number of free buffers allowed in the buffer pool or high-water mark (hwm). For example of its usage : If cempMemBufferFree > cempMemBufferMax & pool is dynamic, then signal for trim of particular buffer pool.')
cempMemBufferPermanent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 8), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferPermanent.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPermanent.setDescription('Indicates the total number of permanent buffers in the pool on the physical entity.')
cempMemBufferTransient = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 9), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferTransient.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferTransient.setDescription('Indicates the initial number of temporary buffers in the pool on the physical entity. This object instructs the system to create this many number of temporary extra buffers, just after a system restart. A change in this object will be effective only after a system restart.')
cempMemBufferTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferTotal.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferTotal.setDescription('Indicates the total number of buffers (include allocated and free buffers) in the buffer pool on the physical entity.')
cempMemBufferFree = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFree.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferFree.setDescription('Indicates the current number of free buffers in the buffer pool on the physical entity. Note that the cempMemBufferFree is less than or equal to cempMemBufferTotal.')
cempMemBufferHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferHit.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferHit.setDescription('Indicates the number of buffers successfully allocated from the buffer pool.')
cempMemBufferMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferMiss.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferMiss.setDescription('Indicates the number of times a buffer has been requested, but no buffers were available in the buffer pool, or when there were fewer than min buffers(cempMemBufferMin) in the buffer pool. Note : For interface pools, a miss is actually a fall back to its corresponding public buffer pool.')
cempMemBufferFreeHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFreeHit.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferFreeHit.setDescription('Indicates the number of successful frees/deallocations from the buffer pool.')
cempMemBufferFreeMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFreeMiss.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferFreeMiss.setDescription('Indicates the number of unsuccessful attempts to free/deallocate a buffer from the buffer pool. For example, this could be due to ownership errors where the application that did not assign the buffer is trying to free it.')
cempMemBufferPermChange = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPermChange.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPermChange.setDescription('This value is the difference of the desired number of permanent buffer & total number of permanent buffers present in the pool. A positive value of this object tells the number of buffers needed & a negative value of the object tells the extra number of buffers in the pool.')
cempMemBufferPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPeak.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPeak.setDescription('Indicates the peak number of buffers in pool on the physical entity.')
cempMemBufferPeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 18), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferPeakTime.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferPeakTime.setDescription('Indicates the time of most recent change in the peak number of buffers (cempMemBufferPeak object) in the pool.')
cempMemBufferTrim = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferTrim.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferTrim.setDescription('The number of buffers that have been trimmed from the pool when the number of free buffers (cempMemBufferFree) exceeded the number of max allowed buffers(cempMemBufferMax).')
cempMemBufferGrow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferGrow.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferGrow.setDescription('The number of buffers that have been created in the pool when the number of free buffers(cempMemBufferFree) was less than minimum(cempMemBufferMix).')
cempMemBufferFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferFailures.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferFailures.setDescription('The number of failures to grant a buffer to a requester due to reasons other than insufficient memory. For example, in systems where there are different execution contexts, it may be too expensive to create new buffers when running in certain contexts. In those cases it may be preferable to fail the request.')
cempMemBufferNoStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferNoStorage.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferNoStorage.setDescription('The number of times the system tried to create new buffers, but could not due to insufficient free memory in the system.')
cempMemBufferCachePoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3), )
if mibBuilder.loadTexts: cempMemBufferCachePoolTable.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCachePoolTable.setDescription('A table that lists the cache buffer pools configured on a managed system. 1)To provide a noticeable performance boost, Cache Pool can be used. A Cache Pool is effectively a lookaside list of free buffers that can be accessed quickly. Cache Pool is tied to Buffer Pool. 2)Cache pools can optionally have a threshold value on the number of cache buffers used in a pool. This can provide flow control management by having a implementation specific approach such as invoking a vector when pool cache rises above the optional threshold set for it on creation.')
cempMemBufferCachePoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1), ).setIndexNames((0, "ENTITY-MIB", "entPhysicalIndex"), (0, "CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPoolIndex"))
if mibBuilder.loadTexts: cempMemBufferCachePoolEntry.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCachePoolEntry.setDescription('Each entry represents one of the cache buffer pools available in the system and it contains the parameters configured for it. Note : cempMemBufferCachePoolTable has a sparse dependency with cempMemBufferPoolTable (i.e all the entires in cempMemBufferPoolTable need not have an entry in cempMemBufferCachePoolTable.')
cempMemBufferCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheSize.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheSize.setDescription('Indicates the number of buffers in the cache pool on the physical entity.')
cempMemBufferCacheTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheTotal.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheTotal.setDescription('Indicates the maximum number of free buffers allowed in the cache pool.')
cempMemBufferCacheUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheUsed.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheUsed.setDescription('Indicates the number of cache buffers from the pool that are currently used on the physical entity. Note that the cempMemBufferCacheUsed is less than or equal to cempMemBufferCacheTotal.')
cempMemBufferCacheHit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheHit.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheHit.setDescription('Indicates the number of buffers successfully allocated from the cache pool.')
cempMemBufferCacheMiss = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheMiss.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheMiss.setDescription('Indicates the number of times a buffer has been requested, but no buffers were available in the cache pool.')
cempMemBufferCacheThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheThreshold.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheThreshold.setDescription('Indicates the threshold limit for number of cache buffers used(cempMemBufferCacheUsed).')
cempMemBufferCacheThresholdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cempMemBufferCacheThresholdCount.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferCacheThresholdCount.setDescription('Indicates how many times the number of cache buffers used(cempMemBufferCacheUsed) has crossed the threshold value(cempMemBufferCacheThreshold).')
cempMemBufferNotifyEnabled = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 221, 1, 2, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cempMemBufferNotifyEnabled.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferNotifyEnabled.setDescription("This variable controls generation of the cempMemBufferNotify. When this variable is 'true', generation of cempMemBufferNotify is enabled. When this variable is 'false', generation of cempMemBufferNotify is disabled.")
cempMemBufferNotify = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 221, 0, 1)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeak"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeakTime"))
if mibBuilder.loadTexts: cempMemBufferNotify.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferNotify.setDescription('Whenever cempMemBufferPeak object is updated in the buffer pool, a cempMemBufferNotify notification is sent. The sending of these notifications can be enabled/disabled via the cempMemBufferNotifyEnabled object.')
cempMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3))
cempMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1))
cempMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2))
cempMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 1)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMIBCompliance = cempMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cempMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco Enhanced MemPool MIB.')
cempMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 2)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMIBComplianceRev1 = cempMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: cempMIBComplianceRev1.setDescription('The compliance statement for entities which implement the Cisco Enhanced MemPool MIB. This compliance module deprecates cempMIBCompliance.')
cempMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 3)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMIBComplianceRev2 = cempMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: cempMIBComplianceRev2.setDescription('The compliance statement for entities which implement the Cisco Enhanced MemPool MIB. This compliance module deprecates cempMIBComplianceRev1.')
cempMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 1, 4)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolExtGroupRev1"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferExtGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnableGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCGroup"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolOvrflwGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMIBComplianceRev3 = cempMIBComplianceRev3.setStatus('current')
if mibBuilder.loadTexts: cempMIBComplianceRev3.setDescription('The compliance statement for entities which implement the Cisco Enhanced MemPool MIB. This compliance module deprecates cempMIBComplianceRev2.')
cempMemPoolGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 1)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolType"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolValid"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolGroup = cempMemPoolGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cempMemPoolGroup.setDescription('A collection of objects providing memory pool monitoring.')
cempMemPoolExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 2)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolPlatformMemory"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAlternate"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFree"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolExtGroup = cempMemPoolExtGroup.setStatus('deprecated')
if mibBuilder.loadTexts: cempMemPoolExtGroup.setDescription("A collection of objects providing additional memory pool information. This group is deprecated as new objects cempMemPoolUsedLowWaterMark, cempMemPoolAllocHit, cempMemPoolAllocMiss, cempMemPoolFreeHit, cempMemPool are being added. A new group cempMemPoolExtGroupRev1 is being added in it's place.")
cempMemBufferGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 3)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMemPoolIndex"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferDynamic"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferSize"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMin"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMax"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPermanent"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTransient"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTotal"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFreeHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFreeMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPermChange"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeak"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferPeakTime"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferTrim"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferGrow"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferFailures"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNoStorage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemBufferGroup = cempMemBufferGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferGroup.setDescription('A collection of objects providing memory buffer pool monitoring.')
cempMemBufferExtGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 4)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheSize"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheTotal"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheThreshold"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferCacheThresholdCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemBufferExtGroup = cempMemBufferExtGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferExtGroup.setDescription('A collection of objects providing additional memory buffer pool monitoring.')
cempMemBufferNotifyEnableGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 5)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotifyEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemBufferNotifyEnableGroup = cempMemBufferNotifyEnableGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferNotifyEnableGroup.setDescription('A group of objects related to enabling notifications.')
cempMemBufferNotifyGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 6)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemBufferNotify"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemBufferNotifyGroup = cempMemBufferNotifyGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemBufferNotifyGroup.setDescription('A group of notifications providing additional memory buffer pool monitoring.')
cempMemPoolExtGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 7)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolPlatformMemory"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAlternate"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedLowWaterMark"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAllocHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolAllocMiss"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeHit"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeMiss"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolExtGroupRev1 = cempMemPoolExtGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolExtGroupRev1.setDescription('A group of objects providing additional memory pool information.This group deprecates cempMemPoolExtGroup.')
cempMemPoolGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 8)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolType"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolName"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolValid"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolShared"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolGroupRev1 = cempMemPoolGroupRev1.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolGroupRev1.setDescription('A collection of objects providing memory pool monitoring. This group deprecates cempMemPoolGroup.')
cempMemPoolHCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 9)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCUsed"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCLargestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCLowestFree"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCUsedLowWaterMark"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolHCShared"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolHCGroup = cempMemPoolHCGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolHCGroup.setDescription('A collection of High Capacity(HC) objects providing memory pool monitoring.')
cempMemPoolOvrflwGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 221, 3, 2, 10)).setObjects(("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolFreeOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLargestFreeOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolLowestFreeOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolUsedLowWaterMarkOvrflw"), ("CISCO-ENHANCED-MEMPOOL-MIB", "cempMemPoolSharedOvrflw"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cempMemPoolOvrflwGroup = cempMemPoolOvrflwGroup.setStatus('current')
if mibBuilder.loadTexts: cempMemPoolOvrflwGroup.setDescription('A collection of Overflow (Ovrflw) objects providing memory pool monitoring.')
mibBuilder.exportSymbols("CISCO-ENHANCED-MEMPOOL-MIB", cempMemPoolSharedOvrflw=cempMemPoolSharedOvrflw, cempMemPoolHCUsedLowWaterMark=cempMemPoolHCUsedLowWaterMark, cempMemPoolFree=cempMemPoolFree, cempMemPoolShared=cempMemPoolShared, cempMemPoolGroupRev1=cempMemPoolGroupRev1, cempMemPoolUsedLowWaterMarkOvrflw=cempMemPoolUsedLowWaterMarkOvrflw, cempMemPoolHCFree=cempMemPoolHCFree, cempMIBCompliance=cempMIBCompliance, cempMemBufferMiss=cempMemBufferMiss, cempMemBufferMemPoolIndex=cempMemBufferMemPoolIndex, cempMemBufferCacheThreshold=cempMemBufferCacheThreshold, CempMemPoolIndexOrNone=CempMemPoolIndexOrNone, cempMemBufferName=cempMemBufferName, cempMIBObjects=cempMIBObjects, cempMemBufferFreeMiss=cempMemBufferFreeMiss, cempMemBufferPeak=cempMemBufferPeak, cempMIBComplianceRev2=cempMIBComplianceRev2, cempMemBufferPermChange=cempMemBufferPermChange, cempMemPoolLargestFree=cempMemPoolLargestFree, cempMemPoolFreeMiss=cempMemPoolFreeMiss, cempMemPoolPlatformMemory=cempMemPoolPlatformMemory, cempMemBufferNotify=cempMemBufferNotify, cempMIBComplianceRev3=cempMIBComplianceRev3, cempMemPoolUsedLowWaterMark=cempMemPoolUsedLowWaterMark, cempMemPoolExtGroup=cempMemPoolExtGroup, cempMemBufferCacheHit=cempMemBufferCacheHit, cempMemPoolHCUsed=cempMemPoolHCUsed, cempMemBufferHit=cempMemBufferHit, CempMemBufferPoolIndex=CempMemBufferPoolIndex, cempMemBufferFreeHit=cempMemBufferFreeHit, cempMemBufferCacheThresholdCount=cempMemBufferCacheThresholdCount, cempMemPoolGroup=cempMemPoolGroup, CempMemPoolIndex=CempMemPoolIndex, cempMemBufferTrim=cempMemBufferTrim, cempMIBComplianceRev1=cempMIBComplianceRev1, cempMemPoolHCLargestFree=cempMemPoolHCLargestFree, cempMemBufferFailures=cempMemBufferFailures, cempMIBConformance=cempMIBConformance, cempMemPoolLowestFree=cempMemPoolLowestFree, cempMemPoolTable=cempMemPoolTable, cempMemBufferCacheSize=cempMemBufferCacheSize, cempMemPoolExtGroupRev1=cempMemPoolExtGroupRev1, cempMemBufferPoolTable=cempMemBufferPoolTable, cempMemBufferFree=cempMemBufferFree, cempMemBufferGroup=cempMemBufferGroup, cempMemBufferCacheUsed=cempMemBufferCacheUsed, CempMemPoolTypes=CempMemPoolTypes, PYSNMP_MODULE_ID=ciscoEnhancedMemPoolMIB, cempMemBufferGrow=cempMemBufferGrow, cempMemPoolAlternate=cempMemPoolAlternate, cempMemPoolEntry=cempMemPoolEntry, cempMemPoolHCLowestFree=cempMemPoolHCLowestFree, ciscoEnhancedMemPoolMIB=ciscoEnhancedMemPoolMIB, cempMemPoolFreeOvrflw=cempMemPoolFreeOvrflw, cempMemBufferDynamic=cempMemBufferDynamic, cempMemBufferPoolIndex=cempMemBufferPoolIndex, cempMemBufferNoStorage=cempMemBufferNoStorage, cempMemPoolName=cempMemPoolName, cempMIBNotifications=cempMIBNotifications, cempMemBufferTotal=cempMemBufferTotal, cempMemPool=cempMemPool, cempMemBufferNotifyEnabled=cempMemBufferNotifyEnabled, cempMemPoolHCShared=cempMemPoolHCShared, cempMemPoolType=cempMemPoolType, cempMIBCompliances=cempMIBCompliances, cempMemBufferNotifyGroup=cempMemBufferNotifyGroup, cempMemBufferCacheTotal=cempMemBufferCacheTotal, cempNotificationConfig=cempNotificationConfig, cempMemPoolValid=cempMemPoolValid, cempMemPoolOvrflwGroup=cempMemPoolOvrflwGroup, cempMIBGroups=cempMIBGroups, cempMemPoolIndex=cempMemPoolIndex, cempMemBufferExtGroup=cempMemBufferExtGroup, cempMemPoolLowestFreeOvrflw=cempMemPoolLowestFreeOvrflw, cempMemBufferCachePoolEntry=cempMemBufferCachePoolEntry, cempMemPoolFreeHit=cempMemPoolFreeHit, cempMemBufferPeakTime=cempMemBufferPeakTime, cempMemPoolAllocHit=cempMemPoolAllocHit, cempMemBufferTransient=cempMemBufferTransient, cempMemPoolLargestFreeOvrflw=cempMemPoolLargestFreeOvrflw, cempMemPoolHCGroup=cempMemPoolHCGroup, cempMemBufferMin=cempMemBufferMin, cempMemPoolUsedOvrflw=cempMemPoolUsedOvrflw, cempMemBufferSize=cempMemBufferSize, cempMemBufferCachePoolTable=cempMemBufferCachePoolTable, cempMemBufferMax=cempMemBufferMax, cempMemBufferNotifyEnableGroup=cempMemBufferNotifyEnableGroup, cempMemPoolUsed=cempMemPoolUsed, cempMemBufferCacheMiss=cempMemBufferCacheMiss, cempMemPoolAllocMiss=cempMemPoolAllocMiss, cempMemBufferPermanent=cempMemBufferPermanent, cempMemBufferPoolEntry=cempMemBufferPoolEntry)

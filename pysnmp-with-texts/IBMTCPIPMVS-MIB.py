#
# PySNMP MIB module IBMTCPIPMVS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IBMTCPIPMVS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:51:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
ipForwardEntry, = mibBuilder.importSymbols("IP-FORWARD-MIB", "ipForwardEntry")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
ObjectIdentity, Gauge32, Unsigned32, Counter64, Counter32, enterprises, Bits, TimeTicks, NotificationType, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Gauge32", "Unsigned32", "Counter64", "Counter32", "enterprises", "Bits", "TimeTicks", "NotificationType", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Integer32", "iso")
DateAndTime, DisplayString, TruthValue, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "DisplayString", "TruthValue", "TextualConvention", "RowStatus")
tcpConnEntry, = mibBuilder.importSymbols("TCP-MIB", "tcpConnEntry")
udpEntry, = mibBuilder.importSymbols("UDP-MIB", "udpEntry")
ibmTCPIPmvsMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 2, 6, 19, 2))
ibmTCPIPmvsMIB.setRevisions(('2001-03-23 00:00', '1900-05-08 00:00', '1999-04-01 00:00', '1998-09-16 00:00', '1998-08-26 00:00', '1998-06-03 00:00', '1998-03-05 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ibmTCPIPmvsMIB.setRevisionsDescriptions(('Changes in this revision - Obsoleted the following MIB objects: ibmMvsTcpConnTcpTimer ibmMvsTcpConnTcpSig ibmMvsTcpConnTcpSel ibmMvsTcpConnTcpDet ibmMvsTcpConnTcpPol - Added ibmTCPIPmvsTcpGroup6 - Added the following TCP statistics MIB objects: ibmMvsTcpConnsClosed ibmMvsTcpPassiveDrops ibmMvsTcpTimeWaitReused ibmMvsTcpPredictAck ibmMvsTcpPredictData ibmMvsTcpInDupAck ibmMvsTcpInBadSum ibmMvsTcpInBadLen ibmMvsTcpInShort ibmMvsTcpInPawsDrop ibmMvsTcpInAllBeforeWin ibmMvsTcpInSomeBeforeWin ibmMvsTcpInAllAfterWin ibmMvsTcpInSomeAfterWin ibmMvsTcpInOutOfOrder ibmMvsTcpInAfterClose ibmMvsTcpInWinProbes ibmMvsTcpInWinUpdates ibmMvsTcpOutWinUpdates ibmMvsTcpOutDelayAcks ibmMvsTcpOutWinProbes ibmMvsTcpRxmtTimers ibmMvsTcpRxmtDrops ibmMvsTcpPMTURxmts ibmMvsTcpPMTUErrors ibmMvsTcpProbeDrops ibmMvsTcpKeepAliveProbes ibmMvsTcpKeepAliveDrops ibmMvsTcpFinwait2Drops - Added ibmTCPIPmvsIpGroup - Added the following IP statistics MIB objects: ibmMvsIpInDevLayerCalls ibmMvsIpInUnpackErrors ibmMvsIpInDiscardsMemory ibmMvsIpOutDiscardsDlcSynch ibmMvsIpOutDiscardsDlcAsynch ibmMvsIpOutDiscardsMemory - Added the following MIB objects to the TCP connection table: ibmMvsTcpConnSndBufSize ibmMvsTcpConnAcceptCount ibmMvsTcpConnExceedBacklog ibmMvsTcpConnCurrBacklog ibmMvsTcpConnMaxBacklog ibmMvsTcpConnWindowScale ibmMvsTcpConnTimeStamp ibmMvsTcpConnServerResourceId - Added ibmTCPIPmvsSystemGroup7 - Added the following MIB objects to the System group: ibmMvsTcpFinwait2Time ibmMvsTcpTimeStamp ibmMvsTcpipSubagentVersion - Added OSA-Express adapter management data - Added ibmTCPIPmvsOsaExpGroup - Added the following new MIB tables for OSA-Express adapters: osaexpChannelTable osaexpPerfTable osaexpEthPortTable osaexpEthSnaTable - Moved channel management data for OSA-Express ATM155 adapters from the osasfChannelTable to the osaexpChannelTable - The DeviceLinkTypes textual convention was updated - ibmMvsAtmSnaLeLlcTi object was updated - Removed range values from SYNTAX - Changed DESCRIPTION - Changed DESCRIPTION of ibmMvsAtmSnaLeLlcT1 - Changed DESCRIPTION of ibmMvsAtmSnaceLlcT2 - Changed DESCRIPTION of ibmMvsAtmOsasfPortIpAddress object - Changed SYNTAX and DESCRIPTION of the following MIB objects: ibmMvsDeviceNetmanEnabled ibmMvsDeviceRouterStatus ibmMvsDeviceActualRouterStatus ibmMvsLinkIbmtrCanonical ibmMvsLinkIbmtrBcast ibmMvsAtmOsasfChannelSubType - Changed DESCRIPTION of ibmMvsTcpConnReXmt - Changed DESCRIPTION of ibmMvsTcpConnReXmtCount - Added ibmTCPIPmvsInterfacesGroup5 - Added the following MIB objects to the Device table: ibmMvsDeviceConfigPackingMode ibmMvsDeviceActualPackingMode - Added MIB object ibmMvsLinkMacAddress to the Link table - Added Dynamic VIPA management data - Added ibmTCPIPmvsDVIPAGroup - Added the following MIB tables: ibmMvsDVIPATable ibmMvsDVIPARangeConfTable ibmMvsDVIPADistConfTable ibmMvsDVIPAConnRoutingTable ibmMvsDVIPADistPortTable - Added the following MIB traps: ibmMvsDVIPAStatusChange ibmMvsDVIPARemoved ibmMvsDVIPATargetAdded ibmMvsDVIPATargetRemoved ibmMvsDVIPATargetServerStarted ibmMvsDVIPATargetServerEnded - Added ibmTcpipMvsTcpListenerTable - Added Subagent MIB trap ibmMvsTcpipSubagentColdStart', 'Changes in this revision - Added ibmMvsPortBindIpAddr - Added ibmMvsPortSAFResource - Changed DESCRIPTION of ibmMvsDeviceRouterStatus - Added ibmMvsDeviceActualRouterStatus - Added ibmMvsLinkArpSupport - Added enumerated values to object ibmMvsAtmOsasfChannelType - Added an enumerated value to object ibmMvsAtmOsasfChannelSubType - Added an enumerated value to object ibmMvsAtmOsasfChannelHwModel - Obsoleted the following ATM MIB objects ibmMvsAtmOsasfChannelEcLevel ibmMvsAtmOsasfChannelDate ibmMvsAtmOsasfChannelTime - Changed DESCRIPTION of ibmMvsAtmOsasfPortType - Changed DESCRIPTION of ibmMvsAtmOsasfPortPcmName - Added an enumerated value to object ibmMvsAtmOsasfPortCodeLoadStatus - Changed the range of the values for objects ibmMvsAtmSnaleMaxStations and ibmMvsAtmSnaleMaxSaps - Changed DESCRIPTION of ibmMvsAtmSnaLeLlcTi - Changed DESCRIPTION of ibmMvsAtmSnaLeLlcT1 - Changed DESCRIPTION of ibmMvsAtmSnaLeLlcT2 - Changed DESCRIPTION of ibmMvsAtmSnaLeMaxStations - Changed DESCRIPTION of ibmMvsAtmSnaLeMaxSaps - Changed DESCRIPTION of ibmMvsAtmSnaLeMaxIn - Changed DESCRIPTION of ibmMvsAtmSnaLeMaxOut - Changed DESCRIPTION of ibmMvsAtmSnaLeTrEnableLoadBalancing - Changed DESCRIPTION of ibmMvsAtmSnaLeTrLoadBalancing - Changed DESCRIPTION of ibmMvsAtmSnaLeTrSessionDelay - Added ibmTCPIPmvsInterfacesGroup4 - Added ibmTCPIPmvsPortGroup2 - Added ibmTCPIPmvsAtmSupportGroup4 - The DeviceLinkTypes textual convention was updated - Obsoleted the following TCP/UDP MIB objects ibmMvsTcpConnIpTos ibmMvsUdpTos - Obsoleted the TypeOfService textual convention - Added ibmMvsTcpConnDSField - Added ibmMvsUdpDSField - Added ibmTCPIPmvsTcpGroup5 - Added ibmTCPIPmvsUdpGroup3 - Changed DESCRIPTION of ibmMvsAtmLecConfigTable ibmMvsAtmLecStatusTable ibmMvsAtmLecStatisticsTable ibmMvsAtmLecServerTable ibmMvsAtmLecMacAddressTable - Added ibmMvsAtmLecPortName - Added ibmMvsPortReuse - Added an enumerated value to object ibmMvsAtmOsasfPortHardwareState - Added ibmTCPIPmvsSystemGroup6 - Added ibmMvsDevRetryDuration', 'Changes in this revision - The DeviceLinkTypes textual convention was updated - several MIB objects were changed from Integer32 to Counter32: ibmMvsTcpConnUsrSndNxt ibmMvsTcpConnSndNxt ibmMvsTcpConnSndUna ibmMvsTcpConnOutgoingPush ibmMvsTcpConnOutgoingUrg ibmMvsTcpConnOutgoingWinSeq ibmMvsTcpConnRcvNxt ibmMvsTcpConnUsrRcvNxt ibmMvsTcpConnIncomingPush ibmMvsTcpConnIncomingUrg ibmMvsTcpConnIncomingWinSeq ibmMvsTcpConnSndWl1 ibmMvsTcpConnSndWl2 ibmMvsTcpConnRttSeq ibmMvsTcpConnRttSeq ibmMvsUdpDgramIn ibmMvsUdpBytesIn ibmMvsUdpDgramOut ibmMvsUdpBytesOut - several MIB objects were changed from Integer32 to Unsigned32: ibmMvsLinkMcastRefCount ibmMvsAtmOsasfPvcFwdCellBurstSize ibmMvsAtmOsasfPvcBwdCellBurstSize ibmMvsAtmSnaLeBestEffortPeakRate ibmMvsAtmLecMulticastSendAvgRate ibmMvsAtmLecMulticastSendPeakRate ibmMvsTcpConnBytesIn ibmMvsTcpConnBytesOut ibmMvsTcpConnOutBuffered ibmMvsTcpConnInBuffered ibmMvsTcpConnMaxSndWnd ibmMvsTcpConnCongestionWnd ibmMvsTcpConnSSThresh ibmMvsTcpConnRoundTripTime ibmMvsTcpConnRoundTripVariance ibmMvsTcpConnInitSndSeq ibmMvsTcpConnInitRcvSeq ibmMvsTcpConnSendMSS ibmMvsTcpConnSndWnd ibmMvsTcpConnRcvBufSize ibmMvsTcpConnSubtask ibmMvsTcpConnResourceId ibmMvsTcpConnDupAcks ibmMvsUdpSubtask ibmMvsUdpResourceId ibmMvsUdpSendLim ibmMvsUdpRecvLim - A couple MIB objects were changed from Integer32 to OCTET STRING (SIZE(1)): ibmMvsTcpConnTcpTimer ibmMvsTcpConnTcpSig ibmMvsTcpConnTcpSel - Some MIB objects were changed from STATUS of current to obsolete: ibmMvsAtmOsasfChannelVtamid ibmMvsTcpConnActiveOpen ibmMvsTcpConnPendTcpRecv ibmMvsTcpConnBackoffCount - Updated description of ibmMvsTcpConnTcpSig MIB object - Added values to the DeviceLinkTypes textual convention - Removed unused definition of ibmAgents - Corrected name of ibmAgentCapabilities to to ibmAgentCaps - Obsoleted ibmMvsMultipathEnabled - Added ibmMvsMultipathType - Added ibmMvsTcpConnInSegs - Added ibmMvsTcpConnOutSegs - Added ibmTCPIPmvsSystemGroup5 - Added ibmTCPIPmvsTcpGroup4 - Added ibmTCPIPmvsAtmSupportGroup3 - Added ibmMvsIpForwarding', 'Changes in this revision - Added ibmMvsLinkChecksumEnabled', 'Updated descriptions of following objects: - ibmMvsTcpConnSockOpt - ibmMvsTcpConnTcpTimer - ibmMvsTcpConnTcpSig - ibmMvsTcpConnTcpSel - ibmMvsTcpConnTcpDet - ibmMvsTcpConnTcpPol', 'Changes in this revision - Added ibmTCPIPmvsSystemGroup4 - Added ibmMvsPathMtuDscEnabled - Added ibmTCPIPmvsInterfacesGroup3 - Added ibmMvsDeviceRouterStatus', 'Changes in this revision - Added copyright - Changed CONTACT-INFO - Added ibmTCPIPmvsSystemGroup3 - Added ibmTCPIPmvsInterfacesGroup2 - Added ibmTCPIPmvsUdpGroup2 - Added ibmMvsTcpMaxReceiveBufferSize - Added ibmMvsMultipathEnabled - Added ibmMvsLinkMcast - Added ibmMvsLinkMcastRefCount',))
if mibBuilder.loadTexts: ibmTCPIPmvsMIB.setLastUpdated('200103230000Z')
if mibBuilder.loadTexts: ibmTCPIPmvsMIB.setOrganization('IBM z/OS Communications Server Development')
if mibBuilder.loadTexts: ibmTCPIPmvsMIB.setContactInfo(' Kristine Adamson Postal: International Business Machines Corporation P.O. Box 12195 Dept. G86A/Bldg. 501 Research Triangle Park, NC 27709 USA Tel: +1 919 254 7911 Internet: adamsonus.ibm.com')
if mibBuilder.loadTexts: ibmTCPIPmvsMIB.setDescription('The IBM Communications Server Enterprise Specific MIB definitions for enabling management of an IBM Communications Server IP system. Licensed Materials - Property of IBM Restricted Materials of IBM 5694-A01 (C) Copyright IBM Corp. 1997, 2001 US Government Users Restricted Rights - Use, duplication or disclosure restricted by GSA ADP Schedule Contract with IBM Corp.')
ibm = MibIdentifier((1, 3, 6, 1, 4, 1, 2))
ibmProd = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6))
mvsSNMPagent = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19))
ibmAgentCaps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 11))
ibmTCPIPmvsMIBTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0))
ibmTCPIPmvsAdmin = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 1))
ibmTCPIPmvsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2))
ibmTCPIPmvsConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3))
class TypeOfService(TextualConvention, Integer32):
    description = "Definition of Type-of-Service (tos). The TOS facility is one of the features of the Type of Service octet in the IP datagram header. The Type of Service octet consists of three fields: 0 1 2 3 4 5 6 7 +-----+-----+-----+-----+-----+-----+-----+-----+ : : : : : PRECEDENCE : TOS : MBZ : : : : : +-----+-----+-----+-----+-----+-----+-----+-----+ The first field, labeled 'PRECEDENCE' above, is intended to denote the importance or priority of the datagram. The second field, labeled 'TOS' above, denotes how the network should make tradeoffs between throughput, delay, reliability, and cost. The last field, labeled 'MBZ' (for 'must be zero') above, is currently unused. The originator of a datagram sets this field zero (unless participating in an Internet protocol experiment which makes use of that bit). Routers and recipients of datagrams ignore the value of this field. This field is copied fragmentation. In the past there has been some confusion about the size of the TOS field. RFC-791 defined it as a three bit field, including bits 3-5 in the figure above. It included bit 6 in the MBZ field. RFC-1122 added bits 6 and 7 to the TOS field, eliminating the MBZ field. RFC-1349 further redefined the TOS field to be the four bits shown in the figure above. The semantics of the following TOS field values (expressed as binary numbers): 1000 -- minimize delay 0100 -- maximize throughput 0010 -- maximize reliability 0001 -- minimize monetary cost 0000 -- normal service Precendence declarations 111 -- network control 110 -- internetwork control 101 -- critic ECP 100 -- flash override 011 -- flash 010 -- immediate 001 -- priority 000 -- routine TOS default is 0."
    status = 'obsolete'
    displayHint = '1a'

class DeviceLinkTypes(TextualConvention, Integer32):
    description = 'Defines the various device and link types.'
    status = 'current'
    displayHint = '1a'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28))
    namedValues = NamedValues(("unknown", 0), ("lcs", 1), ("ctc", 2), ("claw", 3), ("cdlc", 4), ("atm", 5), ("x25npsi", 6), ("vipa", 7), ("loopback", 8), ("hch", 9), ("ethernet", 10), ("t8023", 11), ("etheror8023", 12), ("ibmtr", 13), ("fddi", 14), ("ip", 15), ("iucv", 16), ("stack", 17), ("mpcptp", 18), ("snalu0", 19), ("snalu62", 20), ("mpcipa", 21), ("ipaqenet", 22), ("mpcosa", 24), ("osafddi", 25), ("osaenet", 26), ("ipaqtr", 27), ("ipaqidio", 28))

ibmRemotePingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1))
ibmTcpipMvsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2))
ibmTcpipMvsInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3))
ibmTcpipMvsPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4))
ibmTcpipMvsRouteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5))
ibmTcpipMvsAtmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6))
ibmTcpipMvsTcpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7))
ibmTcpipMvsUdpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8))
ibmTcpipMvsIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9))
ibmTcpipMvsOsaExpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10))
ibmTcpipMvsDVIPAGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11))
ibmSNMPRemPing = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmSNMPRemPing.setReference("Refer to the IBM Communications Server: IP User's Guide for an explanation of the remote ping function.")
if mibBuilder.loadTexts: ibmSNMPRemPing.setStatus('obsolete')
if mibBuilder.loadTexts: ibmSNMPRemPing.setDescription('The number of milliseconds it takes for an icmp echo request to respond. ibmSNMPRemPing is -1 if there is an internal error, -2 if the echo request timed out, -4 if the packet size is invalid, -5 if the timeout is invalid, -6 if the IP address was not valid and -7 if the format of the MIB instance is not valid. To request the icmp response time for ip address a.b.c.d with a timeout of e and a packet size of f, send an snmp get request for ibmSNMPRemPing.f.e.a.b.c.d. For example, suppose one wanted to find out the number of milliseconds it took to ping address 9.67.30.4, with a timeout of 8 seconds, and a packet size of 94 bytes. Accordingly, ibmSNMPRemPing.94.8.9.67.30.4 would identify the number of milliseconds.')
ibmRemotePingTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1), )
if mibBuilder.loadTexts: ibmRemotePingTable.setStatus('current')
if mibBuilder.loadTexts: ibmRemotePingTable.setDescription('Defines the a remote ping table in order to use the various parameters as indeces into the table.')
ibmRemotePingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsRPingPacketSize"), (0, "IBMTCPIPMVS-MIB", "ibmMvsRPingTimeOut"), (0, "IBMTCPIPMVS-MIB", "ibmMvsRPingHostAddress"))
if mibBuilder.loadTexts: ibmRemotePingEntry.setStatus('current')
if mibBuilder.loadTexts: ibmRemotePingEntry.setDescription('Defines an entry in the ibmRemotePingTable. This table does not actual exist, but is used to faciliate passing the remote ping parameters.')
ibmMvsRPingPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1, 1, 1), Integer32())
if mibBuilder.loadTexts: ibmMvsRPingPacketSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsRPingPacketSize.setDescription('Specifies the packet size in octets of the PING request. Valid values for packet size are 0 or from 16 to 4096.')
ibmMvsRPingTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1, 1, 2), Integer32())
if mibBuilder.loadTexts: ibmMvsRPingTimeOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsRPingTimeOut.setDescription('Specifies the time-out value, in seconds, for the actual PING request made by the remote host. Valid values for time out are 0 or 3 to 15 seconds.')
ibmMvsRPingHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1, 1, 3), IpAddress())
if mibBuilder.loadTexts: ibmMvsRPingHostAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsRPingHostAddress.setDescription('Specifies the host address used on by PING request by the remote host. The host address specified is required to be an ipAddress.')
ibmMvsRPingResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsRPingResponseTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsRPingResponseTime.setDescription('The result of the PING request made by the remote host: >0 Round-trip response time in milliseconds. -1 Internal error. -2 ICMP echo request timed out. -4 Incorrect packet size. -5 Incorrect Time-out. -6 Unknown destination address. -7 Incorrect MIB instance format. The generic noSuchInstance SNMP error could also occur if the instance specified is incorrect.')
ibmMvsSubagentCacheTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsSubagentCacheTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsSubagentCacheTime.setDescription('Specifies the amount of time to wait for re-retrieval of specific MIB data from target. A value of 0 implies that every GET or GET-NEXT request should result in the re-retrieval of the needed data. Maximum amount of time to cache is 1 hour (3600 seconds).')
ibmMvsIgnoreRedirect = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("process", 0), ("ignore", 1))).clone('process')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsIgnoreRedirect.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIgnoreRedirect.setDescription('IP Layer attribute, default of process redirects. current stack: IGNOREREDIRECT parm on ASSORTEDPARMS statement')
ibmMvsArpCacheTimeout = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 86400)).clone(1200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsArpCacheTimeout.setStatus('current')
if mibBuilder.loadTexts: ibmMvsArpCacheTimeout.setDescription('IF Layer attribute. ARP cache timeout - ARPAGE statement; default= 1200 seconds; 60 <= ARPAGE <= 86400 (24 hours). current stack: ARPAGE statement; default= 20 minutes (1200 seconds). The value of this object is expressed in seconds.')
ibmMvsTcpKeepAliveTimer = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 35791)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveTimer.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveTimer.setDescription('TCP Keepalive timer, expressed in minutes. A value of 0 deactivates the timer.')
ibmMvsTcpReceiveBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 524288)).clone(16384)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpReceiveBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpReceiveBufferSize.setDescription('TCP Receive buffer size, expressed in bytes.')
ibmMvsTcpSendBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 262144)).clone(16384)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpSendBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpSendBufferSize.setDescription('TCP Send buffer size, expressed in bytes.')
ibmMvsUdpChecksum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsUdpChecksum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpChecksum.setDescription('UDP checksum - on or off')
ibmMvsIplDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIplDateAndTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIplDateAndTime.setDescription('The date and time that this TCP/IP instance was started. sysUpTime provides the time from when the SNMP Agent was started, not corresponding TCP/IP instance.')
ibmMvsNoUdpQueueLimit = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("queueLimit", 0), ("noQueueLimit", 1))).clone('queueLimit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsNoUdpQueueLimit.setStatus('current')
if mibBuilder.loadTexts: ibmMvsNoUdpQueueLimit.setDescription('Indicates if the UDP queue limit of 163,840 bytes of UDP data per socket is in effect or not. 163,840 is equal to 8K times 20 datagrams. This limit is based on the total number of bytes, not datagrams.')
ibmMvsSoMaxConn = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsSoMaxConn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsSoMaxConn.setDescription('Maximum number of socket connections.')
ibmMvsTcpipProcname = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpipProcname.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpipProcname.setDescription('MVS Procname of this TCP/IP instance.')
ibmMvsTcpipAsid = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpipAsid.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpipAsid.setDescription('MVS Address Space ID of this TCP/IP instance.')
ibmMvsSourceVipaEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsSourceVipaEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsSourceVipaEnabled.setDescription('Indicates if set to true(1) that SOURCEVIPA support is enabled. This object can be changed via the ASSORTEDPARMS TCP/IP Profile statement.')
ibmMvsOsasfSysplexName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsasfSysplexName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsasfSysplexName.setDescription('Sysplex name, if unknown the value of the zero length string')
ibmMvsOsasfHostName = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsasfHostName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsasfHostName.setDescription('OSASF Host Name, if unknown the value of the zero length string')
ibmMvsOsasfProductVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsasfProductVersion.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsasfProductVersion.setDescription('version/release of product, if unknown the value of the zero length string')
ibmMvsPrimaryInterfaceIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsPrimaryInterfaceIfIndex.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPrimaryInterfaceIfIndex.setDescription("The ifIndex of the designated primary interface. A value of zero implies that this option wasn't configured.")
ibmMvsIpMaxReassemblySize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 18), Integer32().clone(65535)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpMaxReassemblySize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpMaxReassemblySize.setDescription('The maximum ip reassembly size in units of octets.')
ibmMvsTcpRestrictLowPorts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpRestrictLowPorts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpRestrictLowPorts.setDescription('Indicates if TCP low ports are restricted to authorized servers/socket applications.')
ibmMvsUdpRestrictLowPorts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsUdpRestrictLowPorts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpRestrictLowPorts.setDescription('Indicates if UDP low ports are restricted to authorized servers/socket applications.')
ibmMvsUdpSendBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsUdpSendBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpSendBufferSize.setDescription('The default UDP send buffer size.')
ibmMvsUdpRecvBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsUdpRecvBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpRecvBufferSize.setDescription('The default UDP receive buffer size.')
ibmMvsTcpipStatisticsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpipStatisticsEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpipStatisticsEnabled.setDescription('Indicates if set to true(1) that the generation of tcp/ip statistics is enabled. Statistics if enabled will be recorded at the SMF interval via SMF record subtype 5.')
ibmMvsFirewallEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsFirewallEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsFirewallEnabled.setDescription('Indicates if set to true(1) that firewall support is enabled. This object can be changed via the IPCONFIG TCP/IP Profile statement.')
ibmMvsMaximumRetransmitTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 25), Integer32().clone(120000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsMaximumRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsMaximumRetransmitTime.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of 100th of a second.')
ibmMvsMinimumRetransmitTime = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 26), Integer32().clone(500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsMinimumRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsMinimumRetransmitTime.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of 100th of a second.')
ibmMvsRoundTripGain = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 27), Integer32().clone(125)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsRoundTripGain.setStatus('current')
if mibBuilder.loadTexts: ibmMvsRoundTripGain.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsVarianceGain = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 28), Integer32().clone(250)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsVarianceGain.setStatus('current')
if mibBuilder.loadTexts: ibmMvsVarianceGain.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsVarianceMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 29), Integer32().clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsVarianceMultiplier.setStatus('current')
if mibBuilder.loadTexts: ibmMvsVarianceMultiplier.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsSendGarbageEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsSendGarbageEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsSendGarbageEnabled.setDescription('If true(1) indicates that the TCP option SENDGARBAGE is enabled.')
ibmMvsTcpMaxReceiveBufferSize = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(256, 524288)).clone(262144)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpMaxReceiveBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpMaxReceiveBufferSize.setDescription('TCP Maximum Receive buffer size, expressed in bytes.')
ibmMvsMultipathEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 32), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsMultipathEnabled.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsMultipathEnabled.setDescription('If true(1) indicates that the MULTIPATH IP option is enabled. If false(2) indicates that the MULTIPATH IP option is disabled. This object is obsolete. It has been replaced by the ibmMvsMultipathType object.')
ibmMvsPathMtuDscEnabled = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 33), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsPathMtuDscEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPathMtuDscEnabled.setDescription('If true(1) indicates that the PATHMTUDISCOVERY IP option is enabled. If false(2) indicates that the PATHMTUDISCOVERY IP option is disabled.')
ibmMvsMultipathType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("nomultipath", 0), ("perconnection", 2), ("perpacket", 3))).clone('nomultipath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsMultipathType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsMultipathType.setDescription('The type of Multipath processing currently active. The types are defined under the MULTIPATH parameter on the IPCONFIG Profile statement.')
ibmMvsIpForwarding = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notForwarding", 1), ("forwardingNoMultipath", 2), ("forwardingMultipathPkt", 3))).clone('forwardingNoMultipath')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsIpForwarding.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpForwarding.setDescription('The indication of whether this entity is acting as an IP router in respect to the forwarding of datagrams received by, but not addressed to, this entity. If this entity is acting as a router, this object also indicates what type of forwarding is in effect. The value of this object is originally determined by the TCP/IP Profile ASSORTEDPARMS or IPCONFIG statements. A value of notForwarding(1) indicates that this entity is not forwarding datagrams. A value of forwardingNoMultipath(2) indicates that this entity is forwarding datagrams using the first available route. A value of forwardingMultipathPkt(3) indicates that this entity, when forwarding datagrams, will select a route on a round-robin basis from a multipath routing list. This object is related to the ipForwarding object from RFC2011. If ipForwarding is set to notForwarding, this object will also be set to notForwarding. If ipForwarding is set to forwarding, this object will be set to forwardingNoMultipath. If the value of this MIB object is changed, the value of ipForwarding will be changed accordingly.')
ibmMvsDevRetryDuration = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 36), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(90)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsDevRetryDuration.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDevRetryDuration.setDescription('Specifies the duration of the retry period for a failed device. TCP/IP will perform reactivation attempts at 30 second intervals during this retry period. The default duration is 90 seconds. A specification of 0 generates an infinite recovery period, meaning reactivation attempts will be performed until the device is either successfully reactivated, or manually stopped. The value of this object is originally determined by the DEVRETRYDURATION parameter on the IPCONFIG Profile statement.')
ibmMvsTcpFinwait2Time = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 3600)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpFinwait2Time.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpFinwait2Time.setDescription('The number of seconds a TCP connection should remain in the FINWAIT2 state. When this timer expires, it is reset to 75 seconds. When it expires a second time the connection is dropped.')
ibmMvsTcpTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 38), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsTcpTimeStamp.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpTimeStamp.setDescription('If true(1), indicates that the TCPTIMESTAMP option was specified (or defaulted to) on the TCPCONFIG Profile statement. For active connections (TCP/IP initiates the connection) a TCP timestamp option will be sent. For passive connections (TCP/IP receives a connect request) TCP/IP will send a SYN-ACK with its own TCP timestamp option. If false(2), indicates that the NOTCPTIMESTAMP option was specified on the TCPCONFIG Profile statement. TCP/IP will not participate in TCP timestamp negotiations during connection setup or at any future time in the life of the connection.')
ibmMvsTcpipSubagentVersion = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 2, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("v1r2", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpipSubagentVersion.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpipSubagentVersion.setDescription('The version/release of the TCP/IP Subagent. The actual product names associated with the values of this object are: v1r2(1) - z/OS V1R2 Communications Server')
ibmTcpipMvsDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1), )
if mibBuilder.loadTexts: ibmTcpipMvsDeviceTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsDeviceTable.setDescription('Defines the device definition known to an IBM MVS TCP/IP system. A virtual interface entry exists for every entry in this table.')
ibmTcpipMvsDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmTcpipMvsDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsDeviceEntry.setDescription('Descibes a particular device definition')
ibmMvsDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 1), DeviceLinkTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceType.setDescription('Indicates the device type.')
ibmMvsDeviceBaseNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceBaseNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceBaseNumber.setDescription('If this entry is for a CTC, HCH or Vipa device then this object represents its base device number. For an LCS device this object represents the lcs address. For a CLAW device this object represents the device number of the RS/6000 device. For a CDLC device this object represents the device number. A value of 0 implies that this object is not valid for the associated device table entry.')
ibmMvsDeviceIoBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(32768, 65535)).clone(32768)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceIoBufferSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceIoBufferSize.setDescription("The I/O buffersize attribute for this device definition. This is only value for a CTC Device. A reported value of -1 implies that the corresponding device doesn't not support this attribute.")
ibmMvsDeviceAutoRestart = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceAutoRestart.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceAutoRestart.setDescription('A value of true indicates that this device was defined as autorestartable. False indicates that it was not.')
ibmMvsDeviceNetmanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 5), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceNetmanEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceNetmanEnabled.setDescription('A value of 1 indicates that this is an LCS device that was defined to support the 3172 ICP MIB. A value of 0 indicates that this is an LCS device that was not defined to support the 3172 ICP MIB. A reported value of -1 implies that this object is invalid for the corresponding device table entry.')
ibmMvsDeviceHostClawName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceHostClawName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceHostClawName.setDescription('A non NULL OCTET STRING implies that this is the Host Claw Name for a CLAW Device definition.')
ibmMvsDeviceWorkstationClawName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceWorkstationClawName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceWorkstationClawName.setDescription('A non NULL OCTET STRING implies that this is the Workstation Claw name for a CLAW Device definition.')
ibmMvsDeviceReadBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceReadBuffers.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceReadBuffers.setDescription('The number of read buffers for either a CLAW RS/6000 IP or a CDLC device definition. A value of -1 implies that the value of this object is invalid.')
ibmMvsDeviceReadSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceReadSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceReadSize.setDescription('The read buffer size for either a CLAW RS/6000 IP or a CDLC device definition. A value of -1 implies that the value of this object is invalid.')
ibmMvsDeviceWriteBuffers = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceWriteBuffers.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceWriteBuffers.setDescription('The number of write buffers for either a CLAW RS/6000 IP or a CDLC device definition. A value of -1 implies that the value of this object is invalid.')
ibmMvsDeviceWriteSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceWriteSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceWriteSize.setDescription('The write buffer size for either a CLAW RS/6000 IP or a CDLC device definition. A value of -1 implies that the value of this object is invalid.')
ibmMvsDeviceProcname = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceProcname.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceProcname.setDescription('A non NULL OCTET STRING implies that this is the procname for an X25NPSI, SNA LU0, or SNA LU6.2 Device definition.')
ibmMvsDeviceIncomingSvcEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceIncomingSvcEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceIncomingSvcEnabled.setDescription('This object is valid only for an ATM Device. If true then incoming SVCs will be allowed. A value of false for an ATM Device implies that incoming SVC call setup will be rejected.')
ibmMvsDeviceLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceLuName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceLuName.setDescription('A non NULL OCTET STRING implies that this is the Logical Unit name for a SNA LU0 Device definition.')
ibmMvsDeviceRouterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 15), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceRouterStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceRouterStatus.setDescription('This object is valid only for an MPCIPA device and reflects the specified or default parameter from the MPCIPA DEVICE Profile statement. For other devices the value will be set to -1. A value of 0 represents the NONROUTER parameter on the MPCIPA DEVICE profile statement. It indicates that the device will discard any packets received for an unknown IP address. A value of 1 represents the PRIROUTER parameter on the MPCIPA DEVICE profile statement. It indicates that the device will route inbound packets destined for an unknown IP address to this TCP/IP instance. A value of 2 represents the SECROUTER parameter on the MPCIPA DEVICE profile statement. It is similar to a value of 1 but the device will only route the packet to this TCP/IP instance if there is no TCP/IP instance registered as primary router.')
ibmMvsDeviceActualRouterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 16), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceActualRouterStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceActualRouterStatus.setDescription('This object is valid only for an MPCIPA device and is determined when the device is started. For other devices the value will be set to -1. When the device is started, the TCP/IP instance tries to set the router status to the value of the ibmMvsDeviceRouterStatus MIB object. The ibmMvsDeviceActualRouterStatus MIB object reflects the status that was sucessfully set. A value of 0 represents the NONROUTER parameter from the MPCIPA DEVICE profile statement. It indicates the device will discard any inbound packets destined for an unknown IP address. A value of 1 represents the PRIROUTER parameter from the MPCIPA DEVICE profile statement. It indicates that the device will route inbound packets destined for an unknown IP address to this TCP/IP instance. A value of 2 represents the SECROUTER parameter from the MPCIPA DEVICE profile statement. It is similar to a value of 1 but the device will only route the packet to this TCP/IP instance if there is no TCP/IP instance registered as primary router. If the MPCIPA device has not yet been started, the value will be 3, which means the router status of the device is unknown.')
ibmMvsDeviceConfigPackingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 17), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceConfigPackingMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceConfigPackingMode.setDescription('This object is valid only for a CLAW device and is specified on the CLAW Device definition. For other devices the value will be set to -1. A value of 1 implies that the PACKED parameter was not specified on the CLAW DEVICE Profile statement. A value of 2 implies that that the PACKED parameter was specified on the CLAW DEVICE Profile statement.')
ibmMvsDeviceActualPackingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 1, 1, 18), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDeviceActualPackingMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDeviceActualPackingMode.setDescription('This object is valid only for a CLAW device and is determined when the device is started. For other devices the value will be set to -1. A value of 1 implies that the router for the device does not support packing mode. A value of 2 implies that the router for the device does support packing mode. If the CLAW device has not yet been started, the value will be 3, which means the packing support of the router is unknown.')
ibmTcpipMvsLinkTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2), )
if mibBuilder.loadTexts: ibmTcpipMvsLinkTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsLinkTable.setDescription('Defines the link definition known to an IBM MVS TCP/IP system. A physical interface entry exists for every entry in this table.')
ibmTcpipMvsLinkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmTcpipMvsLinkEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsLinkEntry.setDescription('Descibes a particular link definition')
ibmMvsLinkType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 1), DeviceLinkTypes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkType.setDescription('Indicates the link type.')
ibmMvsLinkDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkDeviceIndex.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkDeviceIndex.setDescription('ifIndex of corresponding DEVICE entry.')
ibmMvsLinkAdapterAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 3), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkAdapterAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkAdapterAddr.setDescription('The adapter address associated with this link definition. A value of -1 indicates that this object is invalid for the corresponding link table entry.')
ibmMvsLinkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 4), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkNumber.setDescription('The link number associated with this link definition. A value of -1 indicates that this object is invalid for the corresponding link table entry.')
ibmMvsLinkIbmtrCanonical = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 5), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkIbmtrCanonical.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkIbmtrCanonical.setDescription('For an IBMTR LCS Link, a value of 1 implies that this link was defined with a value of CANONICAL. A value of 0 implies this link was defined with a value of NONCANONICAL. A reported value of -1 implies that the object is not supported by the associated link.')
ibmMvsLinkIbmtrBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 6), Integer32().clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkIbmtrBcast.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkIbmtrBcast.setDescription('For a IBMTR LCS Link, a value of 1 implies that this link was defined with a value of ALLRINGSBCAST. A value of 2 implies this link was defined with a value of LOCALBCAST. A value of 0 implies that the link does not support broadcast. A reported value of -1 implies that the object is not supported by the associated link.')
ibmMvsLinkMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkMcast.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkMcast.setDescription('A value of true(1) indicates that the link is capable of receiving multicast datagrams. A value of false(2) indicates that either the link is not capable of receiving multicast datagrams or, the multicast capability of the link is unknown. Point-to-point links are always multicast capable. For Token Ring, Ethernet, and FDDI, the multicast capability of the link will not be known until after the link is successfully started. Multicast is not supported for ATM links.')
ibmMvsLinkChecksumEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 8), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkChecksumEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkChecksumEnabled.setDescription('The value of this object can vary only for MPCPTP LINK interfaces. For all other LINK interfaces the value is set to true(1). A value of true(1) indicates that an inbound checksum calculation will be performed for all packets received on this interface. A value of false(2) indicates that an inbound checksum calculation will not be performed for any packets received on this interface.')
ibmMvsLinkArpSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("tcpipArp", 2), ("offloadNoInfo", 3), ("offloadArpInfo", 4), ("unknown", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkArpSupport.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkArpSupport.setDescription("This object reflects the status of the interface's ARP support. A value of 'none' indicates that the interface does not support ARP. If the interface supports ARP but the interface is inactive, then the object will be set to a value of 'unknown'. If the interface is active and supports ARP, the object will be set to one of remaining values. A value of 'tcpipArp' indicates that the TCP/IP instance maintains the ARP cache entries and ARP counters for the interface. A value of 'offloadNoInfo' indicates that the interface maintains its ARP cache entries and ARP counters and the TCP/IP instance can not retrieve this information. A value of 'offloadArpInfo' indicates that the interface maintains its ARP cache entries and ARP counters but supports retrieval of this information by the TCP/IP instance. If the value of the MIB object is 'offloadArpInfo', then the ARP cache entries and ARP counters retrieved represent aggregated information and may reflect shared usage of the interface by more than one TCP/IP instance.")
ibmMvsLinkMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkMacAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkMacAddress.setDescription('A 6 byte OCTET STRING which contains the configured MAC address for IPAQTR link interfaces. If the MAC address was not specified, or if the interface is not an IPAQTR link, then the value will be zeros.')
ibmTcpipMvsLinkMcastTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 3), )
if mibBuilder.loadTexts: ibmTcpipMvsLinkMcastTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsLinkMcastTable.setDescription('The table listing those multicast groups for which an application wishes to receive multicast data. An application requests this by issuing a setsockopt() with IP_ADD_MEMBERSHIP option. An entry exists for every multicast group registered per interface.')
ibmTcpipMvsLinkMcastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IBMTCPIPMVS-MIB", "ibmMvsLinkMcastGroupAddr"))
if mibBuilder.loadTexts: ibmTcpipMvsLinkMcastEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsLinkMcastEntry.setDescription('An entry representing a multicast group on an interface.')
ibmMvsLinkMcastGroupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 3, 1, 1), IpAddress())
if mibBuilder.loadTexts: ibmMvsLinkMcastGroupAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkMcastGroupAddr.setDescription('Specifies the ipAddress of the multicast group')
ibmMvsLinkMcastRefCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 3, 3, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsLinkMcastRefCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsLinkMcastRefCount.setDescription('A count of the number of sockets that are members of this multicast group.')
ibmTcpipMvsPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1), )
if mibBuilder.loadTexts: ibmTcpipMvsPortTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsPortTable.setDescription('Reserved ports within a TCP/IP address space.')
ibmTcpipMvsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsPortNumberLow"), (0, "IBMTCPIPMVS-MIB", "ibmMvsPortNumberHigh"), (0, "IBMTCPIPMVS-MIB", "ibmMvsPortProtocol"), (0, "IBMTCPIPMVS-MIB", "ibmMvsPortProcName"))
if mibBuilder.loadTexts: ibmTcpipMvsPortEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsPortEntry.setDescription('Defines a single ibmTcpipMvsPortTable entry.')
ibmMvsPortNumberLow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortNumberLow.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortNumberLow.setDescription('Low port number of entry.')
ibmMvsPortNumberHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortNumberHigh.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortNumberHigh.setDescription('High port number of entry.')
ibmMvsPortProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("tcp", 0), ("udp", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortProtocol.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortProtocol.setDescription('The protocol of the associating port entry.')
ibmMvsPortProcName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortProcName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortProcName.setDescription('Text Name of the associating mvs procedure.')
ibmMvsPortAutoLoggable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortAutoLoggable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortAutoLoggable.setDescription('Should proc be autologged.')
ibmMvsPortDelayAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortDelayAcks.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortDelayAcks.setDescription('A value of true implies that DELAYACKS was selected for this port entry.')
ibmMvsPortOptMaxSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortOptMaxSegmentSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortOptMaxSegmentSize.setDescription('A value of true implies that the Optimal Maximum Segment Size option was selected for this port entry.')
ibmMvsPortSharePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortSharePort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortSharePort.setDescription('A value of true implies that SHAREPORT was selected for this port entry.')
ibmMvsPortBindIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortBindIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortBindIpAddr.setDescription('The IP address specified on the BIND parameter of the PORT Profile statement. If an application issues a bind() with an IP address of zeros (INADDR_ANY), the value of this MIB object will be used to replace the zero IP address. A value of 0.0.0.0 indicates that the BIND parameter was not specified for this PORT.')
ibmMvsPortSAFResource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortSAFResource.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortSAFResource.setDescription("The SAF resource name specified on the SAF parameter of the PORT Profile statement. The value of this MIB object is appended to a security product profile name of the format: EZB.PORTACCESS.sysname.tcpname., where 'sysname' is the MVS image name, and 'tcpname' is the TCP/IP instance name. During bind() processing the security product will be invoked to verify that the user ID associated with the application has authority to the resulting security product profile name. A value of NULL indicates that the SAF parameter was not specified for this PORT.")
ibmMvsPortReuse = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 4, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsPortReuse.setStatus('current')
if mibBuilder.loadTexts: ibmMvsPortReuse.setDescription('This object only applies to TCP port entries. A value of true(1) means that the port is reusable, as if the SO_REUSEADDR socket option had been set in a socket using the port. A value of true will be set for the port if the BIND paramter was also specified on this port reservation, or if the BIND parameter was specified on another port reservation for the same port number. For UDP port entries, this value will always be false(2).')
ibmTcpipMvsGatewayTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1), )
if mibBuilder.loadTexts: ibmTcpipMvsGatewayTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsGatewayTable.setDescription('Extends ipForwardTable to support gateway semantic.')
ibmTcpipMvsGatewayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1), )
ipForwardEntry.registerAugmentions(("IBMTCPIPMVS-MIB", "ibmTcpipMvsGatewayEntry"))
ibmTcpipMvsGatewayEntry.setIndexNames(*ipForwardEntry.getIndexNames())
if mibBuilder.loadTexts: ibmTcpipMvsGatewayEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsGatewayEntry.setDescription('Descibes a particular gateway entry')
ibmMvsGatewayMaximumRetransmitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 1), Integer32().clone(6000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayMaximumRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayMaximumRetransmitTime.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of 100th of a second.')
ibmMvsGatewayMinimumRetransmitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 2), Integer32().clone(75)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayMinimumRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayMinimumRetransmitTime.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of 100th of a second.')
ibmMvsGatewayRoundTripGain = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 3), Integer32().clone(1200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayRoundTripGain.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayRoundTripGain.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsGatewayVarianceGain = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 4), Integer32().clone(2500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayVarianceGain.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayVarianceGain.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsGatewayVarianceMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 5), Integer32().clone(20000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayVarianceMultiplier.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayVarianceMultiplier.setDescription('Used in the TCP/IP re-transmission time-out calculation to determine how long to wait for an acknowledgement before resending a packet. Expressed as a integer in units of .0001.')
ibmMvsGatewayDelayAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 5, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsGatewayDelayAcks.setStatus('current')
if mibBuilder.loadTexts: ibmMvsGatewayDelayAcks.setDescription('Delays transmission of acknowledgements when a packet is received with the PUSH bit on in the TCP header. The DELAYACKS parameter on the GATEWAY statement only applies to the TCP protocol and only affects acknowledgements returned to the foreign host. To delay acknowledgements on a TCP/IP port connection use the DELAYACKS parameter on the PORT statement.')
osasfChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1), )
if mibBuilder.loadTexts: osasfChannelTable.setStatus('current')
if mibBuilder.loadTexts: osasfChannelTable.setDescription('Indexed by ifIndex. One entry in this table will exist per OSA-2 ATM Device Interface. If the values for objects ibmMvsAtmOsasfChannelCurLparName/Num are not the same as values for objects ibmMvsAtmOsasfChannelManParnName/Num then the OSA/SF running in the current LPAR is not the managing OSA/SF for this Device. SNMP Set commands for ibmMvsAtmOsasfPortIpAddress (to set an IP address at the ATM port) will be rejected by OSA/SF if the OSA/SF in the current LPAR is not the managing OSA/SF for the Device.')
osasfChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: osasfChannelEntry.setStatus('current')
if mibBuilder.loadTexts: osasfChannelEntry.setDescription('Definition of a single entry in the osasfChannelTable. Indexed by the ifIndex of the corresponding DEVICE interface.')
ibmMvsAtmOsasfChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelNumber.setDescription('The channel number for this interface')
ibmMvsAtmOsasfChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16, 17, 18))).clone(namedValues=NamedValues(("other", 1), ("osaExp155", 16), ("osaExp155QDIO", 17), ("osa", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelType.setDescription('The value will be osa(18) for ATM OSA-2 adapters. The values of osaExp155(16) and osaExp155QDIO(17) apply only to OSA-Express ATM155 adapters. Since the channel management data for OSA-Express ATM155 adapters has moved to the osaexpChannelTable, these values will never be set for this MIB object. The value should never be other(1) for an OSA ATM adapter.')
ibmMvsAtmOsasfChannelSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelSubType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelSubType.setDescription('Indicates how the channel is configured. The value is one of the following: -1 - Invalid 0 - Unknown 1 - Ethernet 2 - Token Ring 3 - Two Token Ring ports 4 - Token Ring and Ethernet ports 5 - Ethernet and Token Ring ports 6 - Two Ethernet ports 7 - FDDI 8 - No ports defined 9 - ATM Native or IP Forwarding 10 - One Logical Ethernet port 11 - One Logical Token Ring port 12 - ATM LAN Emulation A value of 12 applies only to OSA-Express ATM155 adapters. Since the channel management data for OSA-Express ATM155 adapters has moved to the osaexpChannelTable, this value will never be set for this MIB object. A value of -1 should not occur for this object.')
ibmMvsAtmOsasfChannelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("passthruMode", 2), ("snaMode", 3), ("atmLeTcpipMode", 4), ("atmLeSnaMode", 5), ("atmLeSnaTcpipMode", 6), ("atmNativeMode", 7), ("atmIpFwdMode", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelMode.setDescription('Config mode of the ATM adapter.')
ibmMvsAtmOsasfChannelHwModel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 0), ("osa1", 1), ("osa2", 2), ("osa2Atm", 3), ("osaExp155", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelHwModel.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelHwModel.setDescription("Hardware model of the channel. The field NDModelNum contained in ibmMvsAtmOsasfChannelDeterNodeDesc is a char(3) field that contains a readable format of this object's value. The value of osaExp155(4) applies only to OSA-Express ATM155 adapters. Since the channel management data for OSA-Express ATM155 adapters has moved to the osaexpChannelTable, this value will never be set for this MIB object.")
ibmMvsAtmOsasfChannelState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5))).clone(namedValues=NamedValues(("online", 1), ("notinst", 3), ("offline", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelState.setDescription('Hardware channel state: online, offline, or not installed.')
ibmMvsAtmOsasfChannelShared = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelShared.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelShared.setDescription('An OSA Channel can be shared across multiple LPARs. This object indicates if this channel is currently being shared.')
ibmMvsAtmOsasfChannelNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelNumPorts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelNumPorts.setDescription('Number of physical ports on OSA channel.')
ibmMvsAtmOsasfChannelDeterNodeDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelDeterNodeDesc.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelDeterNodeDesc.setDescription('Describes the generic node descriptor layout. This object represents the ND obtained from the CHSC instruction: /* ND Flags */ int bValidity :3; /* 1:is ND valid */ int bNodeType :1; /* 1:0=dev,1=chnlsubstm nod*/ int bInternal :1; /* internal(1)/external(0) */ int bCHPinvalid :1; /* IF =1,NDCHPID is invalid*/ int bNDRsvd1 :2; /* spare bits for alignment*/ char NDRsvd1; /* reserved by architecture*/ char NDClass; /* Class for subsystem node*/ char NDCHPID; /* CHP ID for specified int*/ char NDTypeNum 6 ; /* type number of the SDC */ char NDModelNum 3 ; /* ND model number in the form of 3 EBCDIC OCTETS */ char NDMfgr 3 ; /* ND manufacturer in the form of 3 EBCDIC OCTETS */ char NDMfgrPlant 2 ; /* ND plant of manufacture (2 EBCDIC OCTETS) */ char NDSeqNum 12 ; /* ND sequence number (12 EBCDIC OCTETS) */ char NDTag 2 ; /* ND tag */')
ibmMvsAtmOsasfChannelControlUnitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelControlUnitNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelControlUnitNumber.setDescription('The control unit number associated with the OSA Channel.')
ibmMvsAtmOsasfChannelCodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCodeLevel.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCodeLevel.setDescription('ibmMvsAtmOsasfChannelCodeLevel is the firmware (or micro code level) of the OSA adapter. For example, ATM OSA-2 adapter level 05.60 would be represented as 0x0560 by this object.')
ibmMvsAtmOsasfChannelEcLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelEcLevel.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelEcLevel.setDescription('The Box EC Level Identifier of the OSA adapter which identifies the current Engineering Change (EC) Level of this OSA adapter (Channel).')
ibmMvsAtmOsasfChannelCurLparName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCurLparName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCurLparName.setDescription('LPAR name of the OSA/SF from which this data was retrieved from')
ibmMvsAtmOsasfChannelCurLparNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCurLparNum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelCurLparNum.setDescription('LPAR number of the OSA/SF from which this data was retrieved')
ibmMvsAtmOsasfChannelManParnName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelManParnName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelManParnName.setDescription('LPAR name of the OSA Support Facility managing this channel. Only one OSA/SF can manage a OSA Channel within an MVS Sysplex even though multiple OSA/SFs can retrieve information from the same OSA Channel.')
ibmMvsAtmOsasfChannelManParnNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelManParnNum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelManParnNum.setDescription('LPAR number of the OSA Support Facility managing this channel (set to 0xFFFF if not being managed by a OSA/SF).')
ibmMvsAtmOsasfChannelDate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelDate.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelDate.setDescription("Date on this channel (set to 'NOTVALID' if there the disk serving function is not active).")
ibmMvsAtmOsasfChannelTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelTime.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelTime.setDescription("Time on this channel (set to 'NOTVALID' if there the disk serving function is not active).")
ibmMvsAtmOsasfChannelFlashLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelFlashLevel.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelFlashLevel.setDescription('Flashlevel is the LAN driver level running on an OSA adapter. For OSA-1 and OSA-2, there is only 1 LAN driver. For OSA-2 ATM, you can have up to 2 LAN driver. The first driver if configured is for SNA and the second driver is for ATM LAN. FlashLevel consists of two 16 OCTET fields, one for each LAN driver. FOR example, S:05:20:A0 for SNA & A:05.60.00 for ATM. This object is not supported for OSA-Express ATM adapters, so the value will be null.')
ibmMvsAtmOsasfChannelVtamId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelVtamId.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsAtmOsasfChannelVtamId.setDescription('VTAM ID if in SNA mode')
osasfPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2), )
if mibBuilder.loadTexts: osasfPortTable.setStatus('current')
if mibBuilder.loadTexts: osasfPortTable.setDescription('This table is intended to represent the ports supported (or associated) with the osasfChannelTable entries and, for OSA-Express ATM155 adapters, with the osaexpChannelTable entries. Each OSA channel has one or more OSA Ports. For an ATM OSA-2 device configured for ATM IP Forwarding mode, the following fields do not apply: - ibmMvsAtmOsasfPortMacAddrBurntIn - ibmMvsAtmOsasfPortMacAddrActive - ibmMvsAtmOsasfPortMaxPcmConnections - ibmMvsAtmOsasfPortPcmName ')
osasfPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: osasfPortEntry.setStatus('current')
if mibBuilder.loadTexts: osasfPortEntry.setDescription("Describes a particular OSA port entry, index by corresponding AAL5 entry's ifIndex.")
ibmMvsAtmOsasfPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNumber.setDescription('Port number, starts at 0.')
ibmMvsAtmOsasfPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 9, 41))).clone(namedValues=NamedValues(("ethernet", 1), ("tokenRing", 2), ("atm", 9), ("osaExp155", 41)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortType.setDescription('For an ATM OSA-2 adapter configured for ATM native traffic, the value of this object is atm(9). For an ATM OSA-2 adapter configured for ATM LAN Emulation, the value is either ethernet(1) or tokenRing(2) and represents the configuration of the first logical port on the adapter. For an OSA-Express ATM155 adapter the value is osaExp155(41). Note that when a port is configured to be running ATM LAN Emulation then up to two logical ATM LE port entities may exist with any combination of ethernet or tokenring port types.')
ibmMvsAtmOsasfPortHardwareState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("enabled", 0), ("hostDisabled", 1), ("externallyDisabled", 2), ("internallyDisabled", 3), ("secmHostDisabled", 4), ("secmExternallyDisabled", 5), ("secmInternallyDisabled", 6), ("linkMonitor", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortHardwareState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortHardwareState.setDescription('The hardware state value ranges from 0 to 6 as follows: 0 - enable 1 - disabled from host 2 - disabled from external source 3 - disabled from internal error 4 - service element control mode/disabled from host 5 - service element control mode/disabled from external source 6 - service element control mode/disabled from internal error 7 - link not operational because ATM155 adapter was unable to register with the switch (only valid for ATM155) where Host - OSA/SF or other host programming product external source - human intervention on the service element')
ibmMvsAtmOsasfPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("coaxCable", 1), ("singleModeFiber", 2), ("multimodeFiber", 3), ("shieldedTwistedPair", 4), ("unshieldedTwistedPair", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMediaType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMediaType.setDescription('ILMI atmfPortMediaType equivalent. OSA supports types 2 and 3')
ibmMvsAtmOsasfPortUniType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("public", 1), ("private", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortUniType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortUniType.setDescription('ILMI atmfAtmLayerUniType. OSA supports only 2')
ibmMvsAtmOsasfPortUniVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("version20", 1), ("version30", 2), ("version31", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortUniVersion.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortUniVersion.setDescription('ILMI atmfAtmLayerUniVersion. OSA supports only 3. This is the highest UNI version supported.')
ibmMvsAtmOsasfPortNetPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefix.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefix.setDescription('A unique value which identifies the UNI port for which the network prefix for ATM addresses is in effect. The value of 0 has the special meaning of identifying the local UNI. OSA currently supports only 0.')
ibmMvsAtmOsasfPortNetPrefixPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(13, 13)).setFixedLength(13)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefixPrefix.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefixPrefix.setDescription('The network prefix for ATM addresses which is in effect on the user-side of the ATM UNIT port. Network prefix is defined as the ATM address, not including the ESA and SEL portions. The meaningful portion of the OCTET STRING is size 8 if it is E.164, 13 if private. In the case of E.164 the remaining 5 octets are padded with zeros.')
ibmMvsAtmOsasfPortNetPrefixStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefixStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortNetPrefixStatus.setDescription('Equivalent to the atmfNetPrefixStatus as defined in the Network Prefix Table in the ILMI Address Registration MIB. An indication of the validity of the network prefix for ATM addresses on the user-side of the UNI port.')
ibmMvsAtmOsasfPortCodeLoadStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("configRejected", 3), ("outOfSync", 4), ("notApplicable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortCodeLoadStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortCodeLoadStatus.setDescription('This object specifies whether the ATM code has been loaded on to the adapter. The configRejected state indicates that the ATM configuration file download via OSA/SF has been found to be incorrect. The outOfSync condition indicates that the OSA firmware and the ATM code both running on the OSA have been found to be at incompatible levels. Any state other than operational infers that the data associated with a port may be incorrect. Note: OSA/SF should only report states operational and notOperational. This object is only valid for ATM OSA-2 adapters. For other ATM adapters the value is notApplicable.')
ibmMvsAtmOsasfPortMacAddrBurntIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMacAddrBurntIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMacAddrBurntIn.setDescription("A 6 byte OCTET STRING which contains the adapter's burned in MAC address. Does not apply to ATM OSA-2 device configured for ATM IP Forwarding mode.")
ibmMvsAtmOsasfPortMacAddrActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMacAddrActive.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMacAddrActive.setDescription('A 6 byte OCTET STRING which contains the current MAC address in use on the adapter. Does not apply to ATM OSA-2 device configured for ATM IP Forwarding mode.')
ibmMvsAtmOsasfPortMaxPcmConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMaxPcmConnections.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortMaxPcmConnections.setDescription('Specifies the maximum number of connects on an OSA port which can be used for ATM exploitation purposes. It can range from 0 to the number specified by atmInterfaceMaxVccs (RFC 1695). A 0 indicates either that the connections on this port are being used by an ATM configured for LAN Emulation or ATM IP Forwarding. If the value specified here is the same as what is specified by atmInterfaceMaxVccs then all connections are allocated to ATM exploitation.')
ibmMvsAtmOsasfPortPcmName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortPcmName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortPcmName.setDescription('Specifies the Port Name which must also be entered at the connection manager on the host and the application. Port Name is specifed to OSA/SF as a config file parameter (PCM_NAME). This value is also specified via ILMI as the value of the atmfPortMyIfName object. Does not apply to an ATM OSA-2 adapter configured for ATM IP Forwarding mode, or an OSA-Express ATM155 adapter configured for QDIO LAN Emulation mode.')
ibmMvsAtmOsasfPortAAL5InPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortAAL5InPackets.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortAAL5InPackets.setDescription('inbound packets at the corresponding AAL5 interface layer.')
ibmMvsAtmOsasfPortAAL5OutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortAAL5OutPackets.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortAAL5OutPackets.setDescription('outbound packets at the corresponding AAL5 interface layer.')
ibmMvsAtmOsasfPortIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortIpAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPortIpAddress.setDescription('The managing IpAddress reported by the ATM port as its atmfMyIpNmAddress as specified by the ATM Forum User-NetworkInterface (UNI) specification. An SNMP Set for this object is only supported for OSA-2 ATM adapters. If the values for objects ibmMvsAtmOsasfChannelCurLparName/Num are not the same as values for objects ibmMvsAtmOsasfChannelManParnName/Num then the OSA/SF running in the current LPAR is not the managing OSA/SF for this adapter. SNMP Set commands for ibmMvsAtmOsasfPortIpAddress (to set an IP address at the ATM port) will be rejected by OSA/SF if the OSA/SF in the current LPAR is not the managing OSA/SF for the adapter.')
osasfPvcTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3), )
if mibBuilder.loadTexts: osasfPvcTable.setStatus('current')
if mibBuilder.loadTexts: osasfPvcTable.setDescription('This table is intended to represent the locally configured PVCs associated with a given OSA Port. There is a limit of 128 PVCs per Port per Channel.')
osasfPvcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"))
if mibBuilder.loadTexts: osasfPvcEntry.setStatus('current')
if mibBuilder.loadTexts: osasfPvcEntry.setDescription('This object is intended to represent a single PVC entry for the osasfPvcTable.')
ibmMvsAtmOsasfPvcName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcName.setDescription('PVC Name')
ibmMvsAtmOsasfPvcBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBestEffort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBestEffort.setDescription('Best Effort rate. 0 indicated that best effort delivery is not desired. 1 indicates that best effort delivery is desired.')
ibmMvsAtmOsasfPvcFwdPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdPeakCellRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdPeakCellRate.setDescription('Forward peak cell rate specified as cells per second. Needed in order to set up either a best effort or a reserved bandwidth PVC. It applies to the outbound direction (OSA to network) and specifies an upper bound on the outbound traffic that can be transmitted on this PVC. This value can not exceed the the link speed of the ATM link which, currently, is 353207.')
ibmMvsAtmOsasfPvcBwdPeakCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdPeakCellRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdPeakCellRate.setDescription('Backward peak cell rate specified as cells per second. Needed in order to set up either a best effort or a reserved bandwidth PVC. It applies to the inbound direction (network to OSA) and specifies an upper bound on the inbound traffic that can be received on this PVC. This value can not exceed the the link speed of the ATM link which, currently, is 353207.')
ibmMvsAtmOsasfPvcFwdsustainCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdsustainCellRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdsustainCellRate.setDescription('Forward sustain cell rate specified as cells per second. If the best effort indicator is on, the value of this object is ignored. Otherwise (for a reserved bandwidth PVC) this value is utilized by OSA. A value of 0xFF indicates that this value is not being used. Forward sustain cell rate specifies the desired cell rate for outbound traffic that can be sustained for life of a connection on this PVC. This value can not exceed the link speed of the ATM port which, currently, is 353207.')
ibmMvsAtmOsasfPvcBwdsustainCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdsustainCellRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdsustainCellRate.setDescription('Backward sustain cell rate specified as cells per second. If the best effort indicator is on, the value of this object is ignored. Otherwise (for a reserved bandwidth PVC) this value is utilized by OSA. A value of 0xFF indicates that this value is not being used. Backward sustain cell rate specifies the desired cell rate for inbound traffic that can be sustained for life of a connection on this PVC. This value can not exceed the link speed of the ATM port which, currently, is 353207.')
ibmMvsAtmOsasfPvcFwdCellBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdCellBurstSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdCellBurstSize.setDescription('Forward cell burst size specified as number of cells. If the best effort indicator is on, the value of this object is ignored. Otherwise (for a reserved bandwidth PVC) this value is utilized by OSA. A value of 0xFF indicates that this value is not being used. Forward cell burst size specifies the maximum number of cells that can be transmitted in the outbound direction at the peak cell rate while maintaining conformance to the PVC traffic contract.')
ibmMvsAtmOsasfPvcBwdCellBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdCellBurstSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdCellBurstSize.setDescription('Backward cell burst size specified as number of cells. If the best effort indicator is on, the value of this object is ignored. Otherwise (for a reserved bandwidth PVC) this value is utilized by OSA. A value of 0xFF indicates that this value is not being used. Backward cell burst size specifies the maximum number of cells that can be received in the inbound direction at the peak cell rate while maintaining conformance to the PVC traffic contract.')
ibmMvsAtmOsasfPvcVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcVpi.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcVpi.setDescription('vpi for this PVC')
ibmMvsAtmOsasfPvcVci = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcVci.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcVci.setDescription('vci for this PVC. This value must be greater than or equal to 32 since the first 32 vci code points have been reserved by the ATM Forum.')
ibmMvsAtmOsasfPvcFwdMaxAal5PduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 9188))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdMaxAal5PduSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcFwdMaxAal5PduSize.setDescription('This field is used to setup the PVC. Units are in OCTETs and represents the largest PDU size for the AAL5 CPCS layer that can be processed in the forward direction for this PVC by the AAL5 entity. For best effort PVCs only, OSA/SF should attempt to default the value to the largest size (9188).')
ibmMvsAtmOsasfPvcBwdMaxAal5PduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(64, 9188))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdMaxAal5PduSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfPvcBwdMaxAal5PduSize.setDescription('This field is used to setup the PVC. Units are in OCTETs and represents the largest PDU size for the AAL5 CPCS layer that can be processed in the backward direction for this PVC by the AAL5 entity. For best effort PVCs only, OSA/SF should attempt to default the value to the largest size (9188).')
ibmMvsAtmSnaLeTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4), )
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running SNA LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table.")
ibmMvsAtmSnaLeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmSnaLeEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeEntry.setDescription('Describes a particular OSA SNA LAN Emulation entry, index by corresponding LAN Emulation ifIndex.')
ibmMvsAtmSnaLeLlcTi = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcTi.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcTi.setDescription('The inactivity timer. An enabled inactivity timer (Ti) periodically tests the viability of the network media. The timer setting applies to all the clients on the target LAN, not to individual clients. The timer interval indicates how quickly a failure of the network media can be detected when the connection is quiescent. If the Ti timer times out, a supervisory poll frame is sent over the connection. The T1 response, or reply, timer clocks the supervisory poll. If the T1 timer times out, the supervisory poll is retransmitted. OSA can retransmit a supervisory poll up to 8 times. If no response is received after the last retransmission, the link is declared inoperative, and the S/390 program issues a message. The value is represented in ticks. The value will either be zero, or in the range of 2 to 750. Each tick equals .12 of a second.')
ibmMvsAtmSnaLeLlcT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcT1.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcT1.setDescription('The response timer. The T1 timer clocks link events that require responses from clients on the network. These link events include SABME/UA exchanges, I-frame link protocol data unit (LPDU) transmissions, and supervisory polls. The value is represented in ticks. Each tick equals .2 of a second.')
ibmMvsAtmSnaLeLlcT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcT2.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeLlcT2.setDescription('The acknowledgement timer. An OSA starts the T2 timer when it receives an I-format LPDU and stops when it sends an acknowledgement. An acknowledgement is sent either when an outgoing I frame is sent, which acts as the acknowledgement, or when N3 number of I-format LPDUs has been received. If the T2 timer times out, the OSA must send an acknowledgement. The value is represented in ticks. Each tick equals .08 of a second.')
ibmMvsAtmSnaleMaxStations = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaleMaxStations.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaleMaxStations.setDescription('The maximum number of connections (PUs) supported by an OSA for this port. This object is not supported for OSA-Express ATM so the value will be set to zero.')
ibmMvsAtmSnaLeMaxSaps = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxSaps.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxSaps.setDescription('The maximum number of service access points (SAP) supported by an OSA for this for this port. This object is not supported for OSA-Express ATM so the value will be set to zero.')
ibmMvsAtmSnaleMaxIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaleMaxIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaleMaxIn.setDescription('Maximum I frames before ACK (N3). The maximum number of I-format link protocol data units (LPDUs) that can be received by an OSA before it sends an acknowledgement (N3 count). It is also called the receive window count.')
ibmMvsAtmSnaLeMaxOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxOut.setDescription('SNA maximum transmit window (TW). The maximum number of outstanding I-format link protocol data units (LPDUs). It is also called the maximum transmit window count or the maximum window out count. The TW count allows the sender to transmit frames before that sender is forced to halt and wait for an acknowledgement. Therefore, the receiver should be able to absorb that number of frames, either in its service access point (SAP) buffers or within the buffers in workstation memory.')
ibmMvsAtmSnaLeCrsGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeCrsGroupAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeCrsGroupAddress.setDescription('This field contains the active Group Addresses. An individual Group Address is 6 bytes long. Therefore, this field is actually 32 times (OCTET STRING(SIZE(6)) + 2 bytes of padding) long.')
ibmMvsAtmSnaLeUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeUserData.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeUserData.setDescription('This field contains a character string of user data that can be used to further describe this port.')
ibmMvsAtmSnaLeClientEnableState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("notDefined", 1), ("lecActivating", 2), ("enabled", 3), ("internalFailureDisabled", 4), ("physicalPortDisabled", 5), ("osasfDisabled", 6), ("externalDisabled", 7), ("unknown", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeClientEnableState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeClientEnableState.setDescription('This object describes the state of the specified LAN Emulation Port. notDefined implies that the port is not defined in the configuration file. lecActivating indicates the port is in the process of being enabled. There are for possible reasons that the port could be diabled as implied by the enumeration list.')
ibmMvsAtmSnaLeBestEffortPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeBestEffortPeakRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeBestEffortPeakRate.setDescription('This object is the signaling parameter that should be used by the LEC when setting up all best effort VCCs. This parameter applies to the forward and backward direction on a per best effort VCC basis. Thus a 155 Mb adapter may be configured to send best effort traffic at 25.6 Mb (per VCC), but with a total adapter bandwidth of up to 155 Mb. Since this parameter has an integer value the unis are 10xMbits/sec.')
ibmMvsAtmSnaLeMaxLECConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxLECConnections.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeMaxLECConnections.setDescription('This object specifies the maximum number of connections on an OSA port which can be used for LAN Emulation purposes. It can range from 0 to the number specified by atmInterfaceMaxVccs. 0 would indicate that the connections on this port are only being used by ATM Exploitation. If the value of this parameter was equal to atmInterfaceMaxVccs then all connections are allocated to LAN Emulation. Note that this number is the same for all LECs. It is NOT defined on a per LEC basis.')
ibmMvsAtmSnaLeTrEnableLoadBalancing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrEnableLoadBalancing.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrEnableLoadBalancing.setDescription('Load balancing control used to enable the load balancing option.')
ibmMvsAtmSnaLeTrLoadBalancing = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 25))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrLoadBalancing.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrLoadBalancing.setDescription('Load balancing factor. Specifies whether this port will be delayed and, if so, by how much time, in establishing a session. This factor is related to the number of connections (PUs) through the OSA port, not the type nor the amount of work that is being done on those connections.')
ibmMvsAtmSnaLeTrSessionDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 375))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrSessionDelay.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmSnaLeTrSessionDelay.setDescription('Session delay is specified to delay the response of this port to a new session request and by the specified length of time. By establishing a longer session delay timeout for this port copmpared with another port in the same set, this port serves as a backup for another port in an overflow condition.')
ibmMvsAtmLecConfigTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5), )
if mibBuilder.loadTexts: ibmMvsAtmLecConfigTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table. This table is modeled after the LEC Config Table from the LAN Emulation MIB defined by the ATM Forum.")
ibmMvsAtmLecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmLecConfigEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigEntry.setDescription("Describes a particular ATM Lec Config Table entry, index by either a aflan802.3 or a aflane802.5 ifEntry's ifIndex.")
ibmMvsAtmLecConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("automatic", 1), ("manual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigMode.setDescription('Indicates whether this LAN Emulation Client should auto-configure the next time it is (re)started. In automatic (1) mode, a client uses a LAN Emulation Configuration Server to learn the ATM address of its LAN Emulation Server, and to obtain other parameters. lecConfig (LanType, MaxDataFrameSize, LanName) are used in the configure request. lecConfigLesAtmAddress is ignored. In manual (2) mode, management tells the client the ATM address of its LAN Emulation Server and the value of the other parmeters. lecConfig (LanType, MaxDataFrameSize, LanName) are used in the Join request. lecConfigLesAtmAddress tells the client which LES to call.')
ibmMvsAtmLecConfigLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("ethernet", 2), ("tokenRing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLanType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLanType.setDescription('The data frame format which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their joint requests.')
ibmMvsAtmLecConfigMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("f1516", 2), ("f4544", 3), ("f9234", 4), ("f18190", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigMaxDataFrameSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigMaxDataFrameSize.setDescription('The maximum data frame size (in bytes) which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their joint requests.')
ibmMvsAtmLecConfigLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLanName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLanName.setDescription('The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their configure requests. Manually configured clients use it in their joint requests.')
ibmMvsAtmLecConfigLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLesAtmAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigLesAtmAddress.setDescription("The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When lecConfigMode is 'automatic', there is no need to set this address, Address) and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in lecActualLesAtmAddress while leaving lecConfigLesAtmAddress alone. Corresponds to Initial State Parameter C9. In LAN Emulation MIB, the OCTET STRING has length 0 or 20. For OSA, the length shall be 20, with the value 0 defined to mean that lecConfigMode is 'automatic'.")
ibmMvsAtmLecControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlTimeout.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlTimeout.setDescription('Control Time-out. Time out period used for timing out most request/response control frame interactions, as specified elsewhere in the LAN Emulation specification. This time value is expressed in seconds. Corresponds to Initial State Parameter C7.')
ibmMvsAtmLecMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMaxUnknownFrameCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMaxUnknownFrameCount.setDescription('Maximum Unknown Frame Count. See the description of lecMaxUnknownFrameTime below. Corresponds to Initial State Parameter C10.')
ibmMvsAtmLecMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMaxUnknownFrameTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMaxUnknownFrameTime.setDescription('Maximum Unknown Frame Time. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to the BUS for a given unicast LAN Destination, and it must also initiate the address resolution protocol to resolve that LAN Destination. This time value is expressed in seconds. Corresponds Initial State Parameter C11.')
ibmMvsAtmLecVccTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecVccTimeoutPeriod.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecVccTimeoutPeriod.setDescription('VCC Time-out Period. A LE Client SHOULD release any Data Direct VCC that it has not used to transmit or receive any data frames for the length of the VCC Time-out Period. This parameter is only meaningful for SVC Data Direct VCCs. This time value is expressed in seconds. The default value is 20 minutes. A value of 0 seconds means that the timeout period is infinite. Negative values will be rejected by the agent. Corresponds to Initial State Parameter C12.')
ibmMvsAtmLecMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMaxRetryCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMaxRetryCount.setDescription("Maximum Retry Count. A LE CLient MUST not retry a LE_ARP_REQUEST for a given frame's LAN destination more than Maximum Retry Count times, after the first LE_ARP_REQUEST for that same frame's LAN destination. Corresponds to Initial State Parameter C13.")
ibmMvsAtmLecAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecAgingTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecAgingTime.setDescription('Aging Time. The maximum time that a LE Client will maintain an entry in its LE_ARP cache in the absence of a verification of that relationship. This time value is expressed in seconds. Corresponds to Initial State Parameter C17.')
ibmMvsAtmLecForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecForwardDelayTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecForwardDelayTime.setDescription('Forward Delay Time. The maximum time that a LE Client will maintain an entry for a non-local MAC address in its LE_ARP cache in the absence of a verification of that relationship, as long as the Topology Change flag C19 is true. lecForwardDelayTime SHOULD BE less than lecAgingTime. When it is not, lecAgingTime governs LE_ARP aging. This time value is expressed in seconds. Corresponds to Initial State Parameter C18.')
ibmMvsAtmLecExpectedArpResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecExpectedArpResponseTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecExpectedArpResponseTime.setDescription('Expected LE_ARP Reponse Time. The maximum time that the LEC expects an LE_ARP_REQUEST/LE_ARP_RESPONSE cycle to take. Used for retries and verifies. This time value is expressed in Time) seconds. Corresponds to Initial State Parameter C20.')
ibmMvsAtmLecFlushTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecFlushTimeout.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecFlushTimeout.setDescription('Flush Time-out. Time limit to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action. This time value is expressed in seconds. Corresponds to Initial State Parameter C21.')
ibmMvsAtmLecPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecPathSwitchingDelay.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecPathSwitchingDelay.setDescription('Path Switching Delay. The time since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol. This time value is expressed in seconds. Corresponds to Initial State Parameter C22.')
ibmMvsAtmLecLocalSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecLocalSegmentID.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecLocalSegmentID.setDescription('Local Segment ID. The segment ID of the emulated LAN. This is only required for IEEE 802.5 clients that are Source Routing bridges. Corresponds to Initial State Parameter C23.')
ibmMvsAtmLecMulticastSendType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("bestEffort", 1), ("variableBitRate", 2), ("constantBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendType.setDescription('Multicast Send VCC Type. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. This is the method to be used by the LE Client when specifying traffic parameters when it sets up the Multicast Send VCC for this emulated LAN. Corresponds to Initial State Parameter C24.')
ibmMvsAtmLecMulticastSendAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendAvgRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendAvgRate.setDescription('Multicast Send VCC AvgRate. Signalling parameter that SHOULD be used by the LE Client when estabishing the Multicast Send VCC. Forward and Backward Sustained Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. Corresponds to Initial State Parameter C25.')
ibmMvsAtmLecMulticastSendPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendPeakRate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendPeakRate.setDescription('Multicast Send VCC PeakRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Peak Cell Rate to be requested by LE Client when setting up the Multicast Send VCC when using either Variable or Constant bit rate codings. Corresponds to Initial State Parameter C26.')
ibmMvsAtmLecConnectionCompleteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConnectionCompleteTimer.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConnectionCompleteTimer.setDescription('Connection Complete Timer. Optional. In Connection Establish ment this is the time period in which data or a READY_IND message is expected from a Calling Party. This time value is expressed in seconds. Corresponds to Initial State Parameter C28.')
ibmMvsAtmLecPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 5, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecPortName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecPortName.setDescription('Specifies the Port Name for the logical port. This object only applies to OSA-Express ATM155 adapters configured for QDIO LAN Emulation mode. For ATM OSA-2 adapters, or OSA-Express ATM155 adapters configured for non-QDIO mode, the value will be null.')
ibmMvsAtmLecStatusTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6), )
if mibBuilder.loadTexts: ibmMvsAtmLecStatusTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecStatusTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table. This table is modeled after the LEC Status Table from the LAN Emulation MIB defined by the ATM Forum.")
ibmMvsAtmLecStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmLecStatusEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecStatusEntry.setDescription("Describes a particular ATM Lec Status Table entry, indexed by either a aflan802.3 or a aflane802.5 ifEntry's ifIndex.")
ibmMvsAtmLecPrimaryAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecPrimaryAtmAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecPrimaryAtmAddress.setDescription("LE Client's ATM Addresses. The primary ATM address of this LAN Emulation Client. This address is used to establish the Control Direct and Multicast Send VCCs, and may also be used to set up Data Direct VCCs. A client may have additional ATM addresses for use with Data Direct VCCs. These addresses are readable via the lecAtmAddressTable. Corresponds to Initial State Parameter C1.")
ibmMvsAtmLecID = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecID.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecID.setDescription("LE Client Identifier. Each LE Client requires a LE Client Identifier (LECID) assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client. This value MUST NOT change without terminating the LE Client and returning to the Initial state. A valid LECID MUST be in the range X'0001' through X'FEFF'. The value of this object is only meaningful for a LEC that is connected to a LES. For a LEC which does not belong to an emulated LAN, the value of this object is defined to be 0. Corresponds to Initial State Parameter C14.")
ibmMvsAtmLecInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecInterfaceState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecInterfaceState.setDescription("The current state of the LAN Emulation Client. Note that 'ifOperStatus' is defined to be 'up' when, and only when, lecInterfaceState' is 'operational'.")
ibmMvsAtmLecLastFailureRespCode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("timeout", 2), ("undefinedError", 3), ("versionNotSupported", 4), ("invalidRequestParameters", 5), ("duplicateLanDestination", 6), ("duplicateAtmAddress", 7), ("insufficientResources", 8), ("accessDenied", 9), ("invalidRequesterId", 10), ("invalidLanDestination", 11), ("invalidAtmAddress", 12), ("noConfiguration", 13), ("leConfigureError", 14), ("insufficientInformation", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecLastFailureRespCode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecLastFailureRespCode.setDescription("Status code from the last failed Configure response or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a timeout period. If none of this client's requests have failed, this object has the value 'none'. If the failed response contained a STATUS code that is not defined in the LAN Emulation specification, this object has the value 'undefinedError'. The value 'timeout' is self explanatory. Other failure codes correspond to those defined in the specification, although they may have different numeric values.")
ibmMvsAtmLecLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initialState", 1), ("lecsConnect", 2), ("configure", 3), ("join", 4), ("initialRegistration", 5), ("busConnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecLastFailureState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecLastFailureState.setDescription("The state this client was in when it updated the 'lecLastFailureRespCode'. If 'lecLastFailureRespCode' is 'none', this object has the value initialState(1).")
ibmMvsAtmLecProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecProtocol.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecProtocol.setDescription('The LAN Emulation protocol which this client supports, and specifies in its LE_JOIN_REQUESTs.')
ibmMvsAtmLecVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecVersion.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecVersion.setDescription('The LAN Emulation protocol version which this client supports, and specifies in its LE_JOIN_REQUESTs.')
ibmMvsAtmLecTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecTopologyChange.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecTopologyChange.setDescription("Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Aging Time C17, to age non-local entries in its LE_ARP cache C16. For a client which is not connected to the LES, this object is defined to have the value 'false'. Corresponds to Initial State Parameter C19.")
ibmMvsAtmLecConfigServerAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigServerAtmAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigServerAtmAddress.setDescription('The ATM address of the LAN Emulation Configuration Server (if known) or the 0 (otherwise). In LAN Emulation MIB, the OCTET STRING is either 0 length or 20 octets. For OSA-ATM, this Address) has been changed to a constant 20 octets, with the value 0 equivalent to the 0 length OCTET STRING.')
ibmMvsAtmLecConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("gotAddressViaIlmi", 1), ("usedWellKnownAddress", 2), ("usedLecsPvc", 3), ("didNotUseLecs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigSource.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigSource.setDescription('Indicates whether this LAN Emulation Client used the LAN Emulation Configuration Server, and, if so, what method it used to establish the Configuration Direct VCC.')
ibmMvsAtmLecActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("ethernet", 2), ("tokenRing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecActualLanType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecActualLanType.setDescription("The data frame format that this LAN Emulation Client is using right now. This may come from lecConfigLanType, the LAN Emulation Configuration Server, or the LAN Emulation Server. This value is related to 'ifMtu' and 'ifType'. See the LEC management specification for more details. Corresponds to Initial State Parameter C2.")
ibmMvsAtmLecActualMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("f1516", 2), ("f4544", 3), ("f9234", 4), ("f18190", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecActualMaxDataFrameSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecActualMaxDataFrameSize.setDescription('Maximum Data Frame Size. The maximum data frame size that this LAN Emulation client is using right now. This may come from lecConfigMaxDataFrameSize, the LAN Emulation Configuration Server, or the LAN Emulation Server Corresponds to Initial State Parameter C3.')
ibmMvsAtmLecActualLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecActualLanName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecActualLanName.setDescription('ELAN Name. The identity of the emulated LAN which this client last joined, or wishes to join. This may come from lecConfigLanName, the LAN Emulation Configuration Server, or the LAN Emulation Server. Corresponds to Initial State Parameter C5.')
ibmMvsAtmLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecAtmAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecAtmAddress.setDescription("LE Server ATM Address. The LAN Emulation Server address currently in use or most recently attempted. If no LAN Emulation Server attachment has been tried, this object's value is zero. Corresponds to Initial State Parameter C9. In LAN Emulation MIB, the OCTET STRING is 0 to 20 octets in length. For OSA-ATM, this has been changed to a constant 20 octets, with the value 0 equivalent to the 0 length OCTET STRING.")
ibmMvsAtmLecProxyClient = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 6, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecProxyClient.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecProxyClient.setDescription('Indicates whether this client is acting as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST frames for such addresses. Corresponds to Initial State Parameter C4.')
ibmMvsAtmLecStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7), )
if mibBuilder.loadTexts: ibmMvsAtmLecStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecStatisticsTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table. This table is modeled after the LEC Statistics Table from the LAN Emulation MIB defined by the ATM Forum.")
ibmMvsAtmLecStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmLecStatisticsEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecStatisticsEntry.setDescription("Describes a particular ATM Lec Statistics Table entry, indexed by either a aflan802.3 or a aflane802.5 ifEntry's ifIndex.")
ibmMvsAtmLecArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecArpRequestsOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecArpRequestsOut.setDescription('The number of LE_ARP_REQUESTs sent over the LUNI by this LAN Emulation Client.')
ibmMvsAtmLecArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecArpRequestsIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecArpRequestsIn.setDescription('The number of LE_ARP_REQUESTs received over the LUNI by this LAN Emulation Client. Requests may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented and the chances it has had for learning. This counter covers both VCCs.')
ibmMvsAtmLecArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecArpRepliesOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecArpRepliesOut.setDescription('The number of LE_ARP_RESPONSEs sent over the LUNI by this LAN Emulation Client.')
ibmMvsAtmLecArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecArpRepliesIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecArpRepliesIn.setDescription('The number of LE_ARP_RESPONSEs received over the LUNI by this LAN Emulation Client. This count includes all such replies, whether solicited or not. Replies may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented. This counter covers both VCCs.')
ibmMvsAtmLecControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlFramesOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlFramesOut.setDescription('The total number of control packets sent by this LAN Emulation Client over the LUNI.')
ibmMvsAtmLecControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlFramesIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlFramesIn.setDescription('The total number of control packets received by this LAN Emulation Client over the LUNI.')
ibmMvsAtmLecSvcFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecSvcFailures.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecSvcFailures.setDescription('The total number of outgoing LAN Emulation SVCs which this client tried, but failed, to open; incoming LAN Emulation SVCs which this client tried, but failed to establish; and incoming LAN Emulation SVCs which this client rejected for protocol or security reasons.')
ibmMvsAtmLecServerTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8), )
if mibBuilder.loadTexts: ibmMvsAtmLecServerTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecServerTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table. This table is modeled after the LEC Server Table from the LAN Emulation MIB defined by the ATM Forum.")
ibmMvsAtmLecServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmLecServerEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecServerEntry.setDescription("Describes a particular ATM Lec Server Table entry, indexed by either a aflan802.3 or a aflane802.5 ifEntry's ifIndex.")
ibmMvsAtmLecConfigDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectInterface.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectInterface.setDescription('The interface associated with the Configuration Direct VCC. If no Configuration Direct VCC exists, this object has the value 0. Otherwise, the objects ( lecConfigDirectInterface, lecConfigDirectVPI, lecConfigDirectVCI ) identify the circuit.')
ibmMvsAtmLecConfigDirectVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectVPI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectVPI.setDescription('If the Configuration Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecConfigDirectVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectVCI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecConfigDirectVCI.setDescription('If the Configuration Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecControlDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectInterface.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectInterface.setDescription('The interface associated with the Control Direct VCC. If no Control Direct VCC exists, this object has the value 0. Otherwise, the objects ( lecControlDirectInterface, lecControlDirectVPI, lecControlDirectVCI ) identify the circuit.')
ibmMvsAtmLecControlDirectVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectVPI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectVPI.setDescription('If the Control Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecControlDirectVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectVCI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDirectVCI.setDescription('If the Control Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecControlDistributeInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeInterface.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeInterface.setDescription('The interface associated with the Control Distribute VCC. If no Control Distribute VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( lecControlDistributeInterface, lecControlDistributeVPI, lecControlDistributeVCI ) identify the circuit.')
ibmMvsAtmLecControlDistributeVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeVPI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeVPI.setDescription('If the Control Distribute VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecControlDistributeVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeVCI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecControlDistributeVCI.setDescription('If the Control Distribute VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object contains the value 0.')
ibmMvsAtmLecMulticastSendInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendInterface.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendInterface.setDescription('The interface associated with the Multicast Send VCC. If no Multicast Send VCC exists, this object has the value 0. Otherwise, the objects ( lecMulticastSendInterface, lecMulticastSendVPI, lecMulticastSendVCI ) identify the circuit.')
ibmMvsAtmLecMulticastSendVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendVPI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendVPI.setDescription('If the Multicast Send VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecMulticastSendVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendVCI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastSendVCI.setDescription('If the Multicast Send VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecMulticastFwdInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdInterface.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdInterface.setDescription('The interface associated with the Multicast Forward VCC. If no Multicast Forward VCC has been set up to this client, this object has the value 0. Otherwise, the objects ( lecMulticastForwardInterface, lecMulticastForwardVPI, lecMulticastForwardVCI ) identify the circuit.')
ibmMvsAtmLecMulticastFwdVPI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdVPI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdVPI.setDescription('If the Multicast Forward VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecMulticastFwdVCI = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 8, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdVCI.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMulticastFwdVCI.setDescription('If the Multicast Forward VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
ibmMvsAtmLecMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 9), )
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddressTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddressTable.setDescription("This table is intended to represent the data that is available from an OSA Port that is running LAN Emulation mode. An entry in this table is indexed by a LAN Emulation ifIndex. An ifEntry who's ifType is either aflane802.3 (59) or aflane802.5 (60) will have a corresponding entry in this table. This table is modeled after the LEC MAC Address Table from the LAN Emulation MIB defined by the ATM Forum.")
ibmMvsAtmLecMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 9, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddressEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddressEntry.setDescription("Describes a particular ATM Lec Mac Address Table entry, indexed by either a aflan802.3 or a aflane802.5 ifEntry's ifIndex.")
ibmMvsAtmLecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 6, 9, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmLecMacAddress.setDescription("A unicast MAC address which the LE client denoted by 'lecIndex' has registered with its LE Server. This value is expressed in canonical form for Ethernet.")
ibmTcpipMvsTcpConnTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1), )
if mibBuilder.loadTexts: ibmTcpipMvsTcpConnTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsTcpConnTable.setDescription('Extends tcpConnTable to provide additional TCP connection information.')
ibmTcpipMvsTcpConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1), )
tcpConnEntry.registerAugmentions(("IBMTCPIPMVS-MIB", "ibmTcpipMvsTcpConnEntry"))
ibmTcpipMvsTcpConnEntry.setIndexNames(*tcpConnEntry.getIndexNames())
if mibBuilder.loadTexts: ibmTcpipMvsTcpConnEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsTcpConnEntry.setDescription('Descibes a particular tcp connection entry.')
ibmMvsTcpConnLastActivity = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnLastActivity.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnLastActivity.setDescription('The number of 100ths of seconds since this entry was last used.')
ibmMvsTcpConnBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnBytesIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnBytesIn.setDescription('The number of bytes received from IP for this connection.')
ibmMvsTcpConnBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnBytesOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnBytesOut.setDescription('The number of bytes sent to IP for this connection.')
ibmMvsTcpConnActiveOpen = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnActiveOpen.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnActiveOpen.setDescription('The number of times that this connection has made a direct transition to the SYN-RCVD state from the listen state.')
ibmMvsTcpConnIpTos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 5), TypeOfService()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnIpTos.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnIpTos.setDescription('Type of Service (tos) in effect for this tcpConnTable entry. Currently not supported and should return a zero.')
ibmMvsTcpConnOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 40))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOptions.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOptions.setDescription('IP options (see RFC 791)')
ibmMvsTcpConnOutBuffered = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOutBuffered.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOutBuffered.setDescription('Number of outgoing bytes buffered')
ibmMvsTcpConnUsrSndNxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnUsrSndNxt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnUsrSndNxt.setDescription('Sequence number of next byte for user')
ibmMvsTcpConnSndNxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndNxt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndNxt.setDescription('Sequence number of next byte for TCP')
ibmMvsTcpConnSndUna = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndUna.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndUna.setDescription('Sequence number of sent/unacked byte')
ibmMvsTcpConnOutgoingPush = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingPush.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingPush.setDescription('Sequence number of last pushed byte')
ibmMvsTcpConnOutgoingUrg = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingUrg.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingUrg.setDescription('Sequence number of last urg byte')
ibmMvsTcpConnOutgoingWinSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingWinSeq.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOutgoingWinSeq.setDescription('Last sequence number in snd window')
ibmMvsTcpConnSendWindowSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSendWindowSeq.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnSendWindowSeq.setDescription('Last sequence number used, win update')
ibmMvsTcpConnSendWindowAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSendWindowAck.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnSendWindowAck.setDescription('Last Ack number used, win update')
ibmMvsTcpConnInBuffered = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnInBuffered.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnInBuffered.setDescription('Number of incoming bytes buffered')
ibmMvsTcpConnRcvNxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnRcvNxt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnRcvNxt.setDescription('Sequence number of next byte for TCP')
ibmMvsTcpConnUsrRcvNxt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnUsrRcvNxt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnUsrRcvNxt.setDescription('Sequence number of next byte for user')
ibmMvsTcpConnIncomingPush = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingPush.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingPush.setDescription('Sequence number of last pushed byte')
ibmMvsTcpConnIncomingUrg = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingUrg.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingUrg.setDescription("Sequence number of 'urgent' byte received")
ibmMvsTcpConnIncomingWinSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingWinSeq.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnIncomingWinSeq.setDescription('Last sequence number in receive window')
ibmMvsTcpConnReXmt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnReXmt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnReXmt.setDescription('Total number of retransmissions for this connection.')
ibmMvsTcpConnMaxSndWnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 23), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnMaxSndWnd.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnMaxSndWnd.setDescription('Maximum send window seen')
ibmMvsTcpConnReXmtCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnReXmtCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnReXmtCount.setDescription('Number of times the current segment has been retransmitted.')
ibmMvsTcpConnCongestionWnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 25), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnCongestionWnd.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnCongestionWnd.setDescription('Congestion window')
ibmMvsTcpConnSSThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 26), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSSThresh.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSSThresh.setDescription('Slow start threshold')
ibmMvsTcpConnRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 27), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnRoundTripTime.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnRoundTripTime.setDescription('The amount of time that has elapsed, measured in milliseconds, from when the last TCP segment was transmitted by the TCP Stack until the ACK was received.')
ibmMvsTcpConnRoundTripVariance = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnRoundTripVariance.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnRoundTripVariance.setDescription('Round trip time variance.')
ibmMvsTcpConnInitSndSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 29), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnInitSndSeq.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnInitSndSeq.setDescription('Initial Send Sequence Number')
ibmMvsTcpConnInitRcvSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 30), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnInitRcvSeq.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnInitRcvSeq.setDescription('Initial Receive Sequence Number')
ibmMvsTcpConnSendMSS = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 31), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSendMSS.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSendMSS.setDescription('Maximum Segment Size we can send')
ibmMvsTcpConnSndWl1 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndWl1.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndWl1.setDescription('Sequence of last window')
ibmMvsTcpConnSndWl2 = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndWl2.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndWl2.setDescription('Ack of last window')
ibmMvsTcpConnSndWnd = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 34), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndWnd.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndWnd.setDescription('Send Window size')
ibmMvsTcpConnPendTcpRecv = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnPendTcpRecv.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnPendTcpRecv.setDescription('TCP non_block read flag')
ibmMvsTcpConnRcvBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 36), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnRcvBufSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnRcvBufSize.setDescription('Receive buffer size')
ibmMvsTcpConnResourceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 37), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnResourceName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnResourceName.setDescription('Resource Name is the text identification of this resource. It represents the user who opened the socket and is updated again during the bind processing.')
ibmMvsTcpConnSubtask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 38), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSubtask.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSubtask.setDescription('The subtask ID represents the task that opened the socket and is updated again during bind processing. It is actually the TCB address.')
ibmMvsTcpConnResourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 39), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnResourceId.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnResourceId.setDescription('Resource ID is the numeric identification of this resource.')
ibmMvsTcpConnSockOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 40), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSockOpt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSockOpt.setDescription('flag for socket options (1 byte hex value) -bit(1) = Sockets SO_REUSEADDR option -bit(2) = SO_OOBINLINE option -bit(3) = SO_LINGER option -bit(4) = T_MSGDONTROUTE -bit(5) = No delay (Nagle off) option -bit(6) = SO_Keepalive option -bit(7) = Currently timing linger -bit(8) = Currently timing keep alive')
ibmMvsTcpConnTcpTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 41), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTcpTimer.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnTcpTimer.setDescription('flag for TCP timers (1 byte hex value) -bit(1) = Currently timing round trip -bit(2) = Currently timing rexmt -bit(3) = Currently timing window probe -bit(4) = Dally timer currently set -bit(5) = Max Seg Lifetime timer set -bit(6) = T_ORDREL_IND is pending -bit(7) = Blocked for writing -bit(8) = Need to send a FIN')
ibmMvsTcpConnTcpSig = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 42), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTcpSig.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnTcpSig.setDescription('1 byte hex flag for TCP signals -bit(1) = Signal urgent data -bit(2) = Signal normal data -bit(3) = Signal timing finwait2 -bit(4) = <reserved> -bit(5) = <reserved> -bit(6) = Window scale option was received -bit(7) = Tcb on accept queue -bit(8) = Socket OPTMSS option')
ibmMvsTcpConnTcpSel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 43), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTcpSel.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnTcpSel.setDescription('TCP select flag byte for TCP select conditions. It is mapped as follows: -bit(1) = ON if active open, off passive -bit(2) = ON means timestamp option supported -bit(3) = ON when select for read issued -bit(4) = ON when select for write -bit(5) = ON when select for exception -bit(6) = ON means this is controlling -bit(7) = ON if accept in progress -bit(8) = ON means we are at OOB mark')
ibmMvsTcpConnRttSeq = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnRttSeq.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnRttSeq.setDescription('4 byte value for the TCP sequence number')
ibmMvsTcpConnBackoffCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnBackoffCount.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnBackoffCount.setDescription("The value of this object will always be zero since it currently isn't reported.")
ibmMvsTcpConnTcpDet = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 46), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTcpDet.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnTcpDet.setDescription('This flag will hold special TCP protocol conditions: - bit(1) = Delay Acks requested on PORT/PORTRANGE - bit(2) = Delay Acks requested on GATEWAY - bit(3) = Use default round trip parms - bit(4) = Connection is one hop away - bit(5) = Optimal max segment size request on PORT/PORTRANGE - bit(6) = FRCA conn deleted - bit(7) = PASCAL Multi Client - bit(8) = Load Balancing child')
ibmMvsTcpConnTcpPol = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 47), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTcpPol.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsTcpConnTcpPol.setDescription('This flag will indicates the following TCP poll conditions: - bit(1) = High priority data received - bit(2) = <reserved> - bit(3) = Written Normal - bit(4) = <reserved> - bit(5) = Reading Normal - bit(6) = <reserved> - bit(7) = <reserved> - bit(8) = <reserved>')
ibmMvsTcpConnTargetAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 48), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTargetAppl.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnTargetAppl.setDescription('When the corresponding TCP connection is for a 3172 Telnet session then this object contains the Target VTAM Application name.')
ibmMvsTcpConnLuName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 49), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnLuName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnLuName.setDescription('When the corresponding TCP connection is for a 3172 Telnet session then this object contains the VTAM LU name.')
ibmMvsTcpConnClientUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 50), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnClientUserId.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnClientUserId.setDescription("When the corresponding TCP connection is for a 3172 Telnet session then this object contains the Client's userid.")
ibmMvsTcpConnLogMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 51), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnLogMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnLogMode.setDescription('When the corresponding TCP connection is for a 3172 Telnet session then this object contains the LOG Mode.')
ibmMvsTcpConnProto = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 52), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnProto.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnProto.setDescription('This flag will indicates the following Telnet modes: -bit(1 - 5) = <reserved> -bit(6) = TN3270 mode -bit(7) = TN3270E mode -bit(8) = line mode')
ibmMvsTcpConnDupacks = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 53), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnDupacks.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnDupacks.setDescription('Number of duplicate ACKs received for this connection.')
ibmMvsTcpConnOptMaxSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOptMaxSegmentSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOptMaxSegmentSize.setDescription('Optimal maximum segment size. The range of this value is from 0 to 65535.')
ibmMvsTcpConnClusterConnFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 55), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnClusterConnFlag.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnClusterConnFlag.setDescription('This flag contains sysplex cluster connection types for this connection: -bit(1) = getsockopt(clusterconntype) requested -bit(2 - 4) = <reserved> -bit(5) = cluster internal -bit(6) = same image -bit(7) = same cluster -bit(8) = none')
ibmMvsTcpConnInSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnInSegs.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnInSegs.setDescription('The number of segments received from IP for this connection.')
ibmMvsTcpConnOutSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnOutSegs.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnOutSegs.setDescription('The number of segments sent to IP for this connection.')
ibmMvsTcpConnDSField = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 58), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnDSField.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnDSField.setDescription('The Differentiated Services field value in effect for this tcpConnTable entry. The value may be one of the following: - If there is a Service Policy Agent policy in effect for this entry, the value will be either: - The IPv4 TOS value defined by RFC 791 and 1349 - The Differentiated Services field value defined by RFC 2474 - If there is no Service Policy Agent policy in effect for this entry, the value will be 0.')
ibmMvsTcpConnSndBufSize = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 59), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnSndBufSize.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnSndBufSize.setDescription('Send buffer size')
ibmMvsTcpConnAcceptCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnAcceptCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnAcceptCount.setDescription('The total number of connections accepted by this listener. Applies only to listener entries.')
ibmMvsTcpConnExceedBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnExceedBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnExceedBacklog.setDescription('The total number of connections dropped by this listener due to backlog exceeded. Applies only to listener entries.')
ibmMvsTcpConnCurrBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnCurrBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnCurrBacklog.setDescription('The current number of connections in backlog. Applies only to listener entries.')
ibmMvsTcpConnMaxBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnMaxBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnMaxBacklog.setDescription('The maximum number of connections allowed in backlog at one time. Applies only to listener entries.')
ibmMvsTcpConnWindowScale = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 64), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnWindowScale.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnWindowScale.setDescription('If true(1), the TCP window scale option is active for this connection. If false(2), the TCP window scale option is not active.')
ibmMvsTcpConnTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 65), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnTimeStamp.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnTimeStamp.setDescription('If true(1), the TCP timestamp option is active for this connection. If false(2), the TCP timestamp option is not active.')
ibmMvsTcpConnServerResourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 1, 1, 66), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnServerResourceId.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnServerResourceId.setDescription('The numeric identification of the server (i.e. listener connection) associated with this client connection. This value only applies to load balancing servers which have bound to a port number for which SHAREPORT was specified on the PORT/PORTRANGE Profile statement. This value will be zero for client connections to servers which are not load balancing servers. The value of this object can be used to retrieve the listener entry from the ibmTcpipMvsTcpListenerTable.')
ibmMvsTcpConnsClosed = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpConnsClosed.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpConnsClosed.setDescription('Number of TCP connections that have corresponding sockets closed.')
ibmMvsTcpPassiveDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpPassiveDrops.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpPassiveDrops.setDescription('Number of passive connection requests discarded.')
ibmMvsTcpTimeWaitReused = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpTimeWaitReused.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpTimeWaitReused.setDescription('Number of TCP connections in the TIMEWAIT state that have been reused for connections in the SYN-RCVD state.')
ibmMvsTcpPredictAck = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpPredictAck.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpPredictAck.setDescription('Number of inbound TCP acknowledgements with successful header prediction.')
ibmMvsTcpPredictData = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpPredictData.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpPredictData.setDescription('Number of inbound TCP data segments with successful header prediction.')
ibmMvsTcpInDupAck = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInDupAck.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInDupAck.setDescription('Number of inbound duplicate TCP acknowledgements.')
ibmMvsTcpInBadSum = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInBadSum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInBadSum.setDescription('Number of inbound TCP segments discarded due to bad checksum.')
ibmMvsTcpInBadLen = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInBadLen.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInBadLen.setDescription('Number of inbound TCP segments discarded due to bad header len.')
ibmMvsTcpInShort = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInShort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInShort.setDescription('Number of inbound TCP data segments discarded due to data length shorter than segment length.')
ibmMvsTcpInPawsDrop = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInPawsDrop.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInPawsDrop.setDescription('Number of inbound TCP data segments discarded due to old timestamp.')
ibmMvsTcpInAllBeforeWin = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInAllBeforeWin.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInAllBeforeWin.setDescription('Number of inbound TCP data segments with all data before current TCP window.')
ibmMvsTcpInSomeBeforeWin = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInSomeBeforeWin.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInSomeBeforeWin.setDescription('Number of inbound TCP data segments with some data before current TCP window.')
ibmMvsTcpInAllAfterWin = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInAllAfterWin.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInAllAfterWin.setDescription('Number of inbound TCP data segments with all data after current TCP window.')
ibmMvsTcpInSomeAfterWin = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInSomeAfterWin.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInSomeAfterWin.setDescription('Number of inbound TCP data segments with some data after current TCP window.')
ibmMvsTcpInOutOfOrder = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInOutOfOrder.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInOutOfOrder.setDescription('Number of inbound TCP data segments that did not contain the next expected sequence number (ie. out-of-order).')
ibmMvsTcpInAfterClose = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInAfterClose.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInAfterClose.setDescription('Number of inbound TCP data segments received after corresponding sockets have been closed.')
ibmMvsTcpInWinProbes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInWinProbes.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInWinProbes.setDescription('Number of inbound TCP segments processed while current receive window size is zero.')
ibmMvsTcpInWinUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpInWinUpdates.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpInWinUpdates.setDescription('Number of inbound TCP segments that only change receive window size.')
ibmMvsTcpOutWinUpdates = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpOutWinUpdates.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpOutWinUpdates.setDescription('Number of outbound TCP segments that only change receive window size.')
ibmMvsTcpOutDelayAcks = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpOutDelayAcks.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpOutDelayAcks.setDescription('Number of delayed outbound TCP acknowledgements.')
ibmMvsTcpOutWinProbes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpOutWinProbes.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpOutWinProbes.setDescription('Number of outbound window probe requests.')
ibmMvsTcpRxmtTimers = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpRxmtTimers.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpRxmtTimers.setDescription('Number of TCP retransmit timer pops.')
ibmMvsTcpRxmtDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpRxmtDrops.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpRxmtDrops.setDescription('Number of TCP connections dropped due to retransmit threshold exceeded.')
ibmMvsTcpPMTURxmts = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpPMTURxmts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpPMTURxmts.setDescription('Number of outbound TCP segments retransmitted due to path MTU discovery.')
ibmMvsTcpPMTUErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpPMTUErrors.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpPMTUErrors.setDescription('Number of TCP connections that exceeded path MTU discovery retransmit threshold.')
ibmMvsTcpProbeDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpProbeDrops.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpProbeDrops.setDescription('Number of TCP connections dropped due to no response while sending window probe requests.')
ibmMvsTcpKeepAliveProbes = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveProbes.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveProbes.setDescription('Number of keepalive probe requests.')
ibmMvsTcpKeepAliveDrops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveDrops.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpKeepAliveDrops.setDescription('Number of TCP connections dropped due to no response while sending keepalive probe requests.')
ibmMvsTcpFinwait2Drops = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpFinwait2Drops.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpFinwait2Drops.setDescription('Number of TCP connections dropped due to FINWAIT2 timer expiring prior to receiving FIN segment.')
ibmTcpipMvsTcpListenerTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31), )
if mibBuilder.loadTexts: ibmTcpipMvsTcpListenerTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsTcpListenerTable.setDescription('Provides TCP connection information for connections in Listen state. Connections in this state are assumed to be servers so only server MIB objects are supported.')
ibmTcpipMvsTcpListenerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsTcpListenerResourceId"))
if mibBuilder.loadTexts: ibmTcpipMvsTcpListenerEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsTcpListenerEntry.setDescription('Descibes a particular tcp listener entry.')
ibmMvsTcpListenerResourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ibmMvsTcpListenerResourceId.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerResourceId.setDescription('Resource ID is the numeric identification of this resource. This value is also known as the connection ID.')
ibmMvsTcpListenerLocalAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalAddrType.setDescription('The IP address type of the ibmMvsTcpListenerLocalAddr object.')
ibmMvsTcpListenerLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalAddr.setDescription('The local IP address for this TCP connection. In the case of a connection in the listen state which is willing to accept connections for any IP interface associated with the node, the value 0.0.0.0 is used.')
ibmMvsTcpListenerLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerLocalPort.setDescription('The local port number for this TCP connection.')
ibmMvsTcpListenerRemoteAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerRemoteAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerRemoteAddrType.setDescription('The IP address type of the ibmMvsTcpListenerRemoteAddr object.')
ibmMvsTcpListenerRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 6), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerRemoteAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerRemoteAddr.setDescription('The remote ip address for this TCP connection.')
ibmMvsTcpListenerRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerRemotePort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerRemotePort.setDescription('The remote port number for this TCP connection.')
ibmMvsTcpListenerAcceptCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerAcceptCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerAcceptCount.setDescription('The total number of connections accepted by this listener.')
ibmMvsTcpListenerExceedBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerExceedBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerExceedBacklog.setDescription('The total number of connections dropped by this listener due to backlog exceeded.')
ibmMvsTcpListenerCurrBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerCurrBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerCurrBacklog.setDescription('The current number of connections in backlog.')
ibmMvsTcpListenerMaxBacklog = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerMaxBacklog.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerMaxBacklog.setDescription('The maximum number of connections allowed in backlog at one time.')
ibmMvsTcpListenerResourceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 7, 31, 1, 12), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsTcpListenerResourceName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpListenerResourceName.setDescription('Resource Name is the text identification of this resource. It represents the user who opened the socket and is updated again during the bind processing.')
ibmTcpipMvsUdpTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1), )
if mibBuilder.loadTexts: ibmTcpipMvsUdpTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsUdpTable.setDescription('Extends udp table to support additional UDP listener information.')
ibmTcpipMvsUdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1), )
udpEntry.registerAugmentions(("IBMTCPIPMVS-MIB", "ibmTcpipMvsUdpEntry"))
ibmTcpipMvsUdpEntry.setIndexNames(*udpEntry.getIndexNames())
if mibBuilder.loadTexts: ibmTcpipMvsUdpEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsUdpEntry.setDescription('Descibes a particular udp entry.')
ibmMvsUdpLastAct = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpLastAct.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpLastAct.setDescription('The amount of time that has elapsed since the corresponding entry has had any activity. Measured in hundreds of seconds.')
ibmMvsUdpTos = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 2), TypeOfService()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpTos.setStatus('obsolete')
if mibBuilder.loadTexts: ibmMvsUdpTos.setDescription('The type of service in effect for this entry. Currently, not supported and will return a zero when retrieved.')
ibmMvsUdpIpOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpIpOpts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpIpOpts.setDescription('IP Options (see RFC 791)')
ibmMvsUdpDgramIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpDgramIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpDgramIn.setDescription('Number of received datagrams.')
ibmMvsUdpBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpBytesIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpBytesIn.setDescription('Number of bytes received.')
ibmMvsUdpDgramOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpDgramOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpDgramOut.setDescription('Number of send datagrams.')
ibmMvsUdpBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpBytesOut.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpBytesOut.setDescription('Number of bytes sent.')
ibmMvsUdpResourceName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpResourceName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpResourceName.setDescription("Resource Name is the text identification of this resource. It represents the ?itName value of the associating resource's relationship with the UDP Stack.")
ibmMvsUdpSubtask = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpSubtask.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpSubtask.setDescription('4 bytes hex decimal')
ibmMvsUdpResourceId = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpResourceId.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpResourceId.setDescription('Resource ID is the numeric identification of this resource.')
ibmMvsUdpSockOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpSockOpt.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpSockOpt.setDescription('flag for socket options (1 byte hex valuel) -bit(1) = allow broadcast address -bit(2) = allow loopback of datagrams -bit(3) = bypass normal routing -bit(4) = forward ICMP message (Pascal) -bit(5) = outgoing multicast datagrams -bit(6) = incoming multicast datagrams -bit(7) = <reserved> -bit(8) = <reserved>')
ibmMvsUdpSendLim = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpSendLim.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpSendLim.setDescription('maximum transmit datagram size ')
ibmMvsUdpRecvLim = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpRecvLim.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpRecvLim.setDescription('maximum received datagram size')
ibmMvsUdpEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("delete", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsUdpEntryState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpEntryState.setDescription("A entry's state will always be active unless it is to be deleted. This is accomplished by setting this object to delete. A set of active is invalid.")
ibmMvsUdpMcastTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 15), Integer32().clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpMcastTTL.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastTTL.setDescription('Time-to-live value for a multicast datagram.')
ibmMvsUdpMcastLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 16), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpMcastLoopback.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastLoopback.setDescription('If true(1), indicates that loopback is enabled for outbound multicast datagrams. If false(2), indicates either that loopback is disabled for outbound multicast datagrams or that the socket is not processing outgoing multicast datagrams. The value of object ibmMvsUdpSockOpt will indicate whether or not the socket is processing outgoing multicast datagrams.')
ibmMvsUdpMcastLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 17), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpMcastLinkAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastLinkAddr.setDescription('IP address of the interface used for outbound multicast datagrams.')
ibmMvsUdpDSField = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpDSField.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpDSField.setDescription('The Differentiated Services field value in effect for this udpTable entry. The value may be one of the following: - If there is a Service Policy Agent policy in effect for this entry, the value will be either: - The IPv4 TOS value defined by RFC 791 and 1349 - The Differentiated Services field value defined by RFC 2474 - If there is no Service Policy Agent policy in effect for this entry, but the entry is being used for an Enterprise Extender connection, the value will be one of the following VTAM IP Type of Service values in hexadecimal. See the SNA Network Implementation Guide for a descripton of VTAM IP Type of Service): 20 - Low 40 - Medium 80 - High C0 - Network - If neither of the above are true, then this value will be 0.')
ibmTcpipMvsUdpMcastRecvTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2), )
if mibBuilder.loadTexts: ibmTcpipMvsUdpMcastRecvTable.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsUdpMcastRecvTable.setDescription('The table listing UDP sockets that receive multicast data. The table is ordered by the interface being used by the socket for incoming datagrams, the UDP socket (local IP address and port), and the mulitcast group to which the socket is registerd.')
ibmTcpipMvsUdpMcastRecvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvLocalAddress"), (0, "IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvLocalPort"), (0, "IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvGroup"), (0, "IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvLinkAddr"))
if mibBuilder.loadTexts: ibmTcpipMvsUdpMcastRecvEntry.setStatus('current')
if mibBuilder.loadTexts: ibmTcpipMvsUdpMcastRecvEntry.setDescription('Entry defining a UDP socket that receives multicast data.')
ibmMvsUdpMcastRecvLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLocalAddress.setDescription('The local IP address for this UDP listener. In the case of a UDP listener which is willing to accept datagrams for any IP interface associated with the node, the value 0.0.0.0 is used.')
ibmMvsUdpMcastRecvLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLocalPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLocalPort.setDescription('The local port number for this UDP listener.')
ibmMvsUdpMcastRecvGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2, 1, 3), IpAddress())
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvGroup.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvGroup.setDescription('Specifies the IP address of the multicast group')
ibmMvsUdpMcastRecvLinkAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 8, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLinkAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsUdpMcastRecvLinkAddr.setDescription('The IP address of the interface used for incoming packets for this multicast group on this socket.')
ibmMvsIpInDevLayerCalls = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpInDevLayerCalls.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpInDevLayerCalls.setDescription('Number of times the inbound TCP/IP Data Path has received control from the Device Layer. This counter may be less than the number of packets received (ipInReceives), as a single inbound call may process several inbound packets.')
ibmMvsIpInUnpackErrors = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpInUnpackErrors.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpInUnpackErrors.setDescription('Number of times a received frame could not be unpacked into its consistuent datagrams, resulting in packet loss. A non-zero value in this counter may be evidence of a buffer-formatting problem within a device.')
ibmMvsIpInDiscardsMemory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpInDiscardsMemory.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpInDiscardsMemory.setDescription('Number of inbound packets discarded due to a CSM storage shortage.')
ibmMvsIpOutDiscardsDlcSynch = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsDlcSynch.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsDlcSynch.setDescription('Number of outbound packets discarded due to a synchronous error in the Data Link Control. Synchronous DLC errors are detected on the interface between TCP/IP and VTAM, and are typically not related to channel or device errors.')
ibmMvsIpOutDiscardsDlcAsynch = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsDlcAsynch.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsDlcAsynch.setDescription('Number of outbound packets discarded due to an asynchronous error in the Data Link Control. Asynchronous DLC errors may occur for a variety of reasons, including channel/device errors, incorrectly formatted data, or storage shortage within VTAM.')
ibmMvsIpOutDiscardsMemory = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 9, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsMemory.setStatus('current')
if mibBuilder.loadTexts: ibmMvsIpOutDiscardsMemory.setDescription('Number of outbound packets discarded due to a CSM storage shortage.')
osaexpChannelTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1), )
if mibBuilder.loadTexts: osaexpChannelTable.setStatus('current')
if mibBuilder.loadTexts: osaexpChannelTable.setDescription('One entry in this table will exist per OSA-Express Device Interface. If the values for objects ibmMvsOsaExpCurLparName/Num are not the same as the values for objects ibmMvsOsaExpManLparName/Num then the OSA/SF running in the current LPAR is not the managing OSA/SF for this Device. The utilization object values will be reset when the CHPID is reset. The processor utilization objects are the sum of the per LPAR processor utilization values in the corresponding osaexpPerfTable entries for the adapter.')
osaexpChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: osaexpChannelEntry.setStatus('current')
if mibBuilder.loadTexts: osaexpChannelEntry.setDescription('Definition of a single entry in the osaexpChannelTable. Indexed by the ifIndex of the corresponding DEVICE interface.')
ibmMvsOsaExpChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelNumber.setDescription('The channel number for this interface.')
ibmMvsOsaExpChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 17))).clone(namedValues=NamedValues(("ose", 16), ("osd", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelType.setDescription('For OSA-Express adapters supporting QDIO mode, the value will be osd(17). For OSA-Express adapters supporting non-QDIO mode, the value will be ose(16).')
ibmMvsOsaExpChannelSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("unknown", 1), ("gigabit", 2), ("fastEthernet", 3), ("atmNative", 4), ("atmLanEmulation", 5), ("noPortsDefined", 6), ("oneLogicalEthPort", 7), ("oneLogicalTokenRingPort", 8), ("twoLogicalEthPorts", 9), ("twoLogicalTokenRingPorts", 10), ("logicalEthernetAndTokenRingPorts", 11), ("logicalTokenRingAndEthPorts", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelSubType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelSubType.setDescription('Indicates how the channel is configured.')
ibmMvsOsaExpChannelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("nothingConfigured", 1), ("passthruMode", 2), ("snaMode", 3), ("passthruAndSna", 4), ("atmLePassthru", 5), ("atmLeSna", 6), ("atmLePassthruAndSna", 7), ("atmNative", 8), ("atmLe", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelMode.setDescription('Configured mode of the OSA-Express adapter. This value will be set to nothingConfigured(1) for QDIO adapters that are not configured for LAN Emulation.')
ibmMvsOsaExpChannelState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 5))).clone(namedValues=NamedValues(("online", 1), ("notinst", 3), ("offline", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelState.setDescription('Hardware channel state: online, not installed, or offline.')
ibmMvsOsaExpChannelShared = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelShared.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelShared.setDescription('An OSA-Express Channel can be shared across multiple LPARs. This object indicates if this channel is currently being shared.')
ibmMvsOsaExpChannelNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelNumPorts.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelNumPorts.setDescription('Number of ports on the OSA-Express adapter. For non-ATM adapters, the value reflects the number of physical ports. For ATM adapters the value reflects the number of logical ports. For ATM155 Native mode adapters, the value should be 1. For ATM155 QDIO LAN Emulation mode adapters, the value can be 1 or 2 depending on the number of logical ports configured.')
ibmMvsOsaExpChannelDeterNodeDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelDeterNodeDesc.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelDeterNodeDesc.setDescription('Describes the generic node descriptor layout. This object represents the ND obtained from the CHSC instruction: /* ND Flags */ int bValidity :3; /* 1:is ND valid */ int bNodeType :1; /* 1:0=dev,1=chnlsubstm nod*/ int bInternal :1; /* internal(1)/external(0) */ int bCHPinvalid :1; /* IF =1,NDCHPID is invalid*/ int bNDRsvd1 :2; /* spare bits for alignment*/ char NDType; /* reserved by architecture*/ char NDClass; /* Class for subsystem node*/ char NDCHPID; /* CHP ID for specified int*/ char NDTypeNum 6 ; /* type number of the SDC */ char NDModelNum 3 ; /* ND model number in the form of 3 EBCDIC OCTETS */ char NDMfgr 3 ; /* ND manufacturer in the form of 3 EBCDIC OCTETS */ char NDMfgrPlant 2 ; /* ND plant of manufacture (2 EBCDIC OCTETS) */ char NDSeqNum 12 ; /* ND sequence number (12 EBCDIC OCTETS) */ char NDTag 2 ; /* ND tag */')
ibmMvsOsaExpChannelControlUnitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelControlUnitNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelControlUnitNumber.setDescription('The control unit number associated with the OSA-Express Channel.')
ibmMvsOsaExpChannelCodeLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCodeLevel.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCodeLevel.setDescription('ibmMvsOsaExpChannelCodeLevel is the firmware (or micro code level) of the OSA adapter. For example, OSA adapter level 05.60 would be represented as 0x0560 by this object.')
ibmMvsOsaExpChannelCurLparName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCurLparName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCurLparName.setDescription('LPAR name of the OSA/SF from which this data was retrieved.')
ibmMvsOsaExpChannelCurLparNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCurLparNum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelCurLparNum.setDescription('LPAR number of the OSA/SF from which this data was retrieved.')
ibmMvsOsaExpChannelManLparName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelManLparName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelManLparName.setDescription('LPAR name of the OSA Support Facility managing this channel. Only one OSA/SF can manage a OSA-Express Channel within an MVS Sysplex even though multiple OSA/SFs can retrieve information from the same OSA-Express Channel.')
ibmMvsOsaExpChannelManLparNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelManLparNum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelManLparNum.setDescription('LPAR number of the OSA Support Facility managing this channel (set to 0xFFFF if not being managed by a OSA/SF).')
ibmMvsOsaExpChannelPCIBusUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtil1Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtil1Min.setDescription('The average, over a 1 minute interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpChannelProcessorUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtil1Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtil1Min.setDescription('The average, over a 1 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpChannelPCIBusUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtil5Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtil5Min.setDescription('The average, over a 5 minute interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpChannelProcessorUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtil5Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtil5Min.setDescription('The average, over a 5 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpChannelPCIBusUtilHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtilHour.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelPCIBusUtilHour.setDescription('The average, over an hour interval, of the percentage of time that the PCI bus was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpChannelProcessorUtilHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtilHour.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpChannelProcessorUtilHour.setDescription('The average, over an hour interval, of the percentage of time that the CHPID Processor was utilized to transfer data. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
osaexpPerfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2), )
if mibBuilder.loadTexts: osaexpPerfTable.setStatus('current')
if mibBuilder.loadTexts: osaexpPerfTable.setDescription("This table provides performance information per each LPAR's utilization of an OSA-Express adapter. The values will be reset when the adapter CHPID is reset.")
osaexpPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfLparNum"))
if mibBuilder.loadTexts: osaexpPerfEntry.setStatus('current')
if mibBuilder.loadTexts: osaexpPerfEntry.setDescription('Definition of a single entry in the osaexpPerfTable. Indexed by the ifIndex of the corresponding DEVICE interface and the LPAR number.')
ibmMvsOsaExpPerfLparNum = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: ibmMvsOsaExpPerfLparNum.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfLparNum.setDescription('LPAR number of the LPAR to which the performance objects apply.')
ibmMvsOsaExpPerfProcessorUtil1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtil1Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtil1Min.setDescription('The average, over a 1 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data for a specific LPAR. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpPerfInKbytesRate1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRate1Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRate1Min.setDescription('The average, over a 1 minute interval, of the number of inbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtil1Min object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
ibmMvsOsaExpPerfOutKbytesRate1Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRate1Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRate1Min.setDescription('The average, over a 1 minute interval, of the number of outbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtil1Min object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
ibmMvsOsaExpPerfProcessorUtil5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtil5Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtil5Min.setDescription('The average, over a 5 minute interval, of the percentage of time that the CHPID Processor was utilized to transfer data for a specific LPAR. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpPerfInKbytesRate5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRate5Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRate5Min.setDescription('The average, over a 5 minute interval, of the number of inbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtil5Min object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
ibmMvsOsaExpPerfOutKbytesRate5Min = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRate5Min.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRate5Min.setDescription('The average, over a 5 minute interval, of the number of outbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtil5Min object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
ibmMvsOsaExpPerfProcessorUtilHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtilHour.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfProcessorUtilHour.setDescription('The average, over an hour interval, of the percentage of time that the CHPID Processor was utilized to transfer data for a specific LPAR. It does not include idle time or time used by routine maintenance tasks. The range of valid values for this object is 0 to 100%. A value of -1 indicates that the value could not be retrieved from the adapter.')
ibmMvsOsaExpPerfInKbytesRateHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRateHour.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfInKbytesRateHour.setDescription('The average, over an hour interval, of the number of inbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtilHour object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
ibmMvsOsaExpPerfOutKbytesRateHour = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRateHour.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpPerfOutKbytesRateHour.setDescription('The average, over an hour interval, of the number of outbound kilobytes processed for a specific LPAR. When the ibmMvsOsaExpPerfProcessorUtilHour object for a specific LPAR has a value of -1, then the interval data could not be retrieved from the adapter and this object will have a value of zero.')
osaexpEthPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3), )
if mibBuilder.loadTexts: osaexpEthPortTable.setStatus('current')
if mibBuilder.loadTexts: osaexpEthPortTable.setDescription('This table is intended to represent the ethernet Ports associated with the osaexpChannelTable entries for ethernet adapters. Each OSA-Express Channel has one or more Ports.')
osaexpEthPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: osaexpEthPortEntry.setStatus('current')
if mibBuilder.loadTexts: osaexpEthPortEntry.setDescription('Definition of a single entry in the osaexpEthPortTable. Indexed by the ifIndex of the corresponding LINK interface.')
ibmMvsOsaExpEthPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortNumber.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortNumber.setDescription('Port number, starts at 0.')
ibmMvsOsaExpEthPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(65, 81))).clone(namedValues=NamedValues(("gigabitEthernet", 65), ("fastEthernet", 81)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortType.setDescription('The physical port type.')
ibmMvsOsaExpEthPortHardwareState = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("linkFailure", 2), ("disabled", 3), ("enabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortHardwareState.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortHardwareState.setDescription('The hardware state of the port: 1 - Unknown port hardware state. 2 - OSA has detected a loss of signal on the link. (A likely cause of this condition is an improperly installed or missing cable connection on the port). For OSA-Express ATM, this condition can also be caused by registration failure. 3 - Port is disabled. The reason for the port being disabled is set in object ibmMvsOsaExpEthPortDisabledStatus. 4 - Port is enabled.')
ibmMvsOsaExpEthPortServiceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("nonserviceMode", 0), ("serviceMode", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortServiceMode.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortServiceMode.setDescription(' ')
ibmMvsOsaExpEthPortDisabledStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortDisabledStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortDisabledStatus.setDescription('When the value of ibmMvsOsaExpEthPortHardwareState is disabled(3), this object explains the reason for the disabled state. The value for this object may be a combination of the following: 0x0001 Disabled internal port failure 0x0002 Disabled service processor request 0x0004 Disabled network request 0x0008 Disabled OSA/SF request 0x0010 Disabled configuration change 0x0020 Disabled link failure threshold exceeded 0x0040 Disabled port temporarily disabled When the value of ibmMvsOsaExpEthPortHardwareState is not disabled(3), the value of this object will be zero.')
ibmMvsOsaExpEthPortConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 34))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortConfigName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortConfigName.setDescription('Configuration name.')
ibmMvsOsaExpEthPortConfigSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 7))).clone(namedValues=NamedValues(("autoNegotiate", 0), ("halfDuplex10Mb", 1), ("fullDuplex10Mb", 2), ("halfDuplex100Mb", 3), ("fullDuplex100Mb", 4), ("fullDuplex1000Mb", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortConfigSpeed.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortConfigSpeed.setDescription('The configured port speed. For OSA-Express Gigabit Ethernet adapters the port speed can not be configured so the value of this object will be 1000MbFullDuplex(7).')
ibmMvsOsaExpEthPortActiveSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 7))).clone(namedValues=NamedValues(("unknown", 0), ("halfDuplex10Mb", 1), ("fullDuplex10Mb", 2), ("halfDuplex100Mb", 3), ("fullDuplex100Mb", 4), ("fullDuplex1000Mb", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortActiveSpeed.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortActiveSpeed.setDescription('The actual port speed.')
ibmMvsOsaExpEthPortMacAddrActive = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortMacAddrActive.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortMacAddrActive.setDescription('A 6 byte OCTET STRING which contains the current MAC address in use on the adapter.')
ibmMvsOsaExpEthPortMacAddrBurntIn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortMacAddrBurntIn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortMacAddrBurntIn.setDescription("A 6 byte OCTET STRING which contains the adapter's burned in MAC address.")
ibmMvsOsaExpEthPortUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortUserData.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortUserData.setDescription('Configured port description.')
ibmMvsOsaExpEthPortOutPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortOutPackets.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortOutPackets.setDescription('The count of the total number of packets transmitted from this port. A CHPID reset will cause this value to be reset to zero.')
ibmMvsOsaExpEthPortInPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInPackets.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInPackets.setDescription('The count of the total number of packets received by this port. A CHPID reset will cause this value to be reset to zero.')
ibmMvsOsaExpEthPortInGroupFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInGroupFrames.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInGroupFrames.setDescription('The count of the total number of group frames received by this port. A CHPID reset will cause this value to be reset to zero.')
ibmMvsOsaExpEthPortInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInBroadcastFrames.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInBroadcastFrames.setDescription('The count of the total number of broadcast frames received by this port. A CHPID reset will cause this value to be reset to zero.')
ibmMvsOsaExpEthPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortName.setDescription('Specifies the Port Name which must also be entered at the connection manager on the host and the application. Port Name is specifed to OSA/SF as a config file parameter (PCM_NAME). This value is also specified via ILMI as the value of the atmfPortMyIfName object. Does not apply to an ATM OSA-2 adapter configured for ATM IP Forwarding mode, or an OSA-Express ATM155 adapter configured for QDIO LAN Emulation mode.')
ibmMvsOsaExpEthPortInUnknownIPFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInUnknownIPFrames.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortInUnknownIPFrames.setDescription('The count of the total number of packets that were discarded because they did not have a matching IP address and there was no primary nor secondary router default defined. This object is not supported for Fast Ethernet adapters so the value will be zero.')
ibmMvsOsaExpEthPortGroupMacAddrs = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 3, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(256, 256)).setFixedLength(256)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortGroupMacAddrs.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthPortGroupMacAddrs.setDescription('This field contains the active Group Addresses. An individual Group Address is 6 bytes long. Therefore, this field is actually 32 times (OCTET STRING(SIZE(6)) + 2 bytes of padding) long.')
osaexpEthSnaTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4), )
if mibBuilder.loadTexts: osaexpEthSnaTable.setStatus('current')
if mibBuilder.loadTexts: osaexpEthSnaTable.setDescription('This table is intended to represent the data that is available from an OSA-Express ethernet Port that is running in SNA mode. An entry in this table is associated with the osaexpEthPortTable entries.')
osaexpEthSnaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: osaexpEthSnaEntry.setStatus('current')
if mibBuilder.loadTexts: osaexpEthSnaEntry.setDescription('Definition of a single entry in the osaexpEthSnaTable. Indexed by the ifIndex of the corresponding LINK interface.')
ibmMvsOsaExpEthSnaInactTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaInactTimer.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaInactTimer.setDescription('The inactivity timer. An enabled inactivity timer (Ti) periodically tests the viability of the network media. The timer setting applies to all the clients on the target LAN, not to individual clients. The timer interval indicates how quickly a failure of the network media can be detected when the connection is quiescent. If the Ti timer times out, a supervisory poll frame is sent over the connection. The T1 response, or reply, timer clocks the supervisory poll. If the T1 timer times out, the supervisory poll is retransmitted. OSA can retransmit a supervisory poll up to 8 times. If no response is received after the last retransmission, the link is declared inoperative, and the MVS program issues a message. The value will either be zero, or in the range of 24 to 9000 in units of 100th of a second.')
ibmMvsOsaExpEthSnaRespTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 510))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaRespTimer.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaRespTimer.setDescription('The response timer. The T1 timer clocks link events that require responses from clients on the network. These link events include SABME/UA exchanges, I-frame link protocol data unit (LPDU) transmissions, and supervisory polls. The value is expressed as an integer in units of 10th of a second.')
ibmMvsOsaExpEthSnaAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2040))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaAckTimer.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaAckTimer.setDescription('The acknowledgement timer. An OSA starts the T2 timer when it receives an I-format LPDU and stops when it sends an acknowledgement. An acknowledgement is sent either when an outgoing I frame is sent, which acts as the acknowledgement, or when N3 number of I-format LPDUs has been received. If the T2 timer times out, the OSA must send an acknowledgement. The value is expressed as an integer in units of 100th of a second.')
ibmMvsOsaExpEthSnaMaxIFramesBeforeAck = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaMaxIFramesBeforeAck.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaMaxIFramesBeforeAck.setDescription('Maximum I frames before ACK (N3). The maximum number of I-format link protocol data units (LPDUs) that can be received by an OSA before it sends an acknowledgement (N3 count). It is also called the receive window count.')
ibmMvsOsaExpEthSnaMaxTransmitWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 10, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaMaxTransmitWindow.setStatus('current')
if mibBuilder.loadTexts: ibmMvsOsaExpEthSnaMaxTransmitWindow.setDescription('SNA maximum transmit window (TW). The maximum number of outstanding I-format link protocol data units (LPDUs). It is also called the maximum transmit window count or the maximum window out count. The TW count allows the sender to transmit frames before that sender is forced to halt and wait for an acknowledgement. Therefore, the receiver should be able to absorb that number of frames, either in its service access point (SAP) buffers or within the buffers in workstation memory.')
ibmMvsDVIPATable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1), )
if mibBuilder.loadTexts: ibmMvsDVIPATable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATable.setDescription('Each entry in this table represents a Dynamic VIPA (DVIPA) interface configured to this stack, and supports DVIPA status information.')
ibmMvsDVIPAEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddr"))
if mibBuilder.loadTexts: ibmMvsDVIPAEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAEntry.setDescription('Definition of a single entry in the ibmMvsDVIPATable.')
ibmMvsDVIPAIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPAIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAIpAddrType.setDescription('The IP address type of the ibmMvsDVIPAIpAddr object.')
ibmMvsDVIPAIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPAIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAIpAddr.setDescription('The dynamic VIPA IP address.')
ibmMvsDVIPAMaskType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAMaskType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAMaskType.setDescription('The IP address type of the ibmMvsDVIPAMaskAddr object This object will be set to unknown(0) for entries whose ibmMvsDVIPAOrigin value is backup(2).')
ibmMvsDVIPAMaskAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAMaskAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAMaskAddr.setDescription('The address mask. This object will be set to a zero-length string for entries whose ibmMvsDVIPAOrigin value is backup(2).')
ibmMvsDVIPAStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("backup", 3), ("moving", 4), ("quiescing", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAStatus.setDescription('The status of this DVIPA on the stack. A status of unknown(1) should not occur and represents an error.')
ibmMvsDVIPAOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 1), ("backup", 2), ("define", 3), ("rangeBind", 4), ("rangeIoctl", 5), ("target", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAOrigin.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAOrigin.setDescription('The origin of how this DVIPA came to be configured to the stack. A value of backup(2) or define(3) indicates which VIPADYNAMIC Profile statement was used to configure the DVIPA to the stack. A value of rangeBind(4) indicates that the DVIPA was dynamically defined when an application issued a BIND function call. A value of rangeIoctl(5) indicates that the DVIPA was dynamically defined when an application issued the SIOCSVIPA IOCTL function call. A value of target(6) indicates that the DVIPA was dynamically defined on the stack because this stack is a target stack for the Sysplex Distributor function. A status of unknown(1) should not occur and represents an error.')
ibmMvsDVIPARank = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPARank.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARank.setDescription("This stack's rank in the chain of backup stacks for a given dynamic VIPA. For entries whose ibmMvsDVIPAOrigin value is not backup(2) or define(3), this object does not apply and will be set to -1.")
ibmMvsDVIPADistributeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("distributor", 2), ("target", 3), ("disgtributorAndTarget", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPADistributeStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistributeStatus.setDescription('The status of this DVIPA on the stack in relation to the Sysplex Distributor function. A value of none(1) indicates that the DVIPA is not participating in the Sysplex Distributor function. A value of distributor(2) indicates that the stack is a distributor for this DVIPA. A value of target(3) indicates that the stack is a target stack for this DVIPA. A value of distributorAndTarget(4) indicates that the stack is both a distributor and a target stack for this DVIPA.')
ibmMvsDVIPAMoveable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("immediate", 2), ("whenIdle", 3), ("nonDisruptive", 4), ("disruptive", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAMoveable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAMoveable.setDescription('The manner in which a dynamic VIPA IP address should be moved to another stack. A value of none(1) indicates that moveable status does not apply to this DVIPA. This value would be set for entries where backup is set as the value for the ibmMvsDVIPAOrigin and ibmMvsDVIPAStatus objects. For DVIPA IP addresses activated as the result of a VIPADEFINE configuration statement, a value of immediate(2) means that this dynamic VIPA can be moved to another stack as soon as the other stack requests ownership of the DVIPA by executing a VIPADEFINE for the same dynamic VIPA. Any existing connections on this stack will be maintained by the new owning stack until the connections are closed. All new connection requests will be directed to the new owning stack. A value of whenIdle(3) means that this dynamic VIPA can be moved to another stack when there are no connections for this dynamic VIPA on this stack. While there are existing connections, any new connection requests will continue to be directed to this stack. For DVIPA IP addresses activated as the result of a VIPARANGE configuration and a subsequent SIOCSVIPA IOCTL or BIND, a value of nonDisruptive(4) means that this DVIPA can be moved to another stack as soon as the other stack requests ownership of the DVIPA by creating the same DVIPA via a subsequent BIND or SIOCSVIPA IOCTL. Any existing connections on this stack will be maintained by the new owning stack until the connections are closed. All new connection requests will be directed to the new stack. A value of disruptive(5) means that one of two different behaviors will occur: - In the case of a subsequent BIND by an application on another stack, no movement of the DVIPA will occur the second application will presumably be disrupted because the BIND fails. (The first application is unaware that another BIND occurred.) - In the case of a subsequent SIOCSVIPA IOCTL, the DVIPA will move to another stack but connections to the DVIPA on this stack will be broken.')
ibmMvsDVIPAServMgrEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrEnabled.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrEnabled.setDescription('The status of this DVIPA on the stack in relation to the Service Manager function. A value of true(1) indicates that the DVIPA is participating in the Service Manager function. A value of false(2) indicates that the DVIPA is not participating in the Service Manager function.')
ibmMvsDVIPARangeConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2), )
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfTable.setDescription('Each entry in this table represents a subnet defined by the VIPARANGE Profile statement in which requests for activating a DVIPA via a BIND or SIOCSVIPA IOCTL, will be honored.')
ibmMvsDVIPARangeConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfIpAddr"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfMaskType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfMaskAddr"))
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfEntry.setDescription('Definition of a single entry in the ibmMvsDVIPARangeConfTable.')
ibmMvsDVIPARangeConfIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfIpAddrType.setDescription('The IP address type of the ibmMvsDVIPARangeConfIpAddr object.')
ibmMvsDVIPARangeConfIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfIpAddr.setDescription('The dynamic VIPA IP address.')
ibmMvsDVIPARangeConfMaskType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 3), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMaskType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMaskType.setDescription('The IP address type of the ibmMvsDVIPARangeConfMaskAddr object.')
ibmMvsDVIPARangeConfMaskAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 16)))
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMaskAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMaskAddr.setDescription('The dynamic VIPA IP address.')
ibmMvsDVIPARangeConfMoveable = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonDisruptive", 1), ("disruptive", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMoveable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfMoveable.setDescription('The manner in which a dynamic VIPA IP address defined by a VIPARANGE statement, should be moved to another stack. A value of nonDisruptive(1) means that this DVIPA can be moved to another stack as soon as the other stack requests ownership of the DVIPA by creating the same DVIPA via a subsequent BIND or SIOCSVIPA IOCTL. Any existing connections on this stack will be maintained by the new owning stack until the connections are closed. All new connection requests will be directed to the new stack. A value of disruptive(2) means that one of two different behaviors will occur: - In the case of a subsequent BIND by an application on another stack, no movement of the DVIPA will occur the second application will presumably be disrupted because the BIND fails. (The first application is unaware that another BIND occurred.) - In the case of a subsequent SIOCSVIPA IOCTL, the DVIPA will move to another stack but connections to the DVIPA on this stack will be broken.')
ibmMvsDVIPARangeConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARangeConfStatus.setDescription('This object allows entries to be created and deleted in the ibmMvsDVIPARangeConfTable. Note that an attempt to set any read-create object defined within an ibmMvsDVIPARangeConfEntry while the value of ibmMvsDVIPARangeConfStatus is active(1) should result in an inconsistentValue error.')
ibmMvsDVIPADistConfTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3), )
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTable.setDescription('Each entry in this table represents a dynamic VIPA and port for which connection requests are to be distributed to other stacks as defined by the VIPADISTRIBUTE Profile statement.')
ibmMvsDVIPADistConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfIpAddr"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfPort"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfTargetDynXcfIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfTargetDynXcfIpAddr"))
if mibBuilder.loadTexts: ibmMvsDVIPADistConfEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfEntry.setDescription('Definition of a single entry in the ibmMvsDVIPADistConfTable.')
ibmMvsDVIPADistConfIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPADistConfIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfIpAddrType.setDescription('The IP address type of the ibmMvsDVIPADistConfIpAddr object.')
ibmMvsDVIPADistConfIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPADistConfIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfIpAddr.setDescription('The dynamic VIPA IP address.')
ibmMvsDVIPADistConfPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ibmMvsDVIPADistConfPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfPort.setDescription('The dynamic VIPA distributed port.')
ibmMvsDVIPADistConfTargetDynXcfIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 4), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTargetDynXcfIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTargetDynXcfIpAddrType.setDescription('The IP address type of the ibmMvsDVIPADistConfTargetDynXcfIpAddr object. If the ALL parameter was specified on the VIPADISTRIBUTE Profile statement, this object will be set to unknown(0).')
ibmMvsDVIPADistConfTargetDynXcfIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 5), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTargetDynXcfIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfTargetDynXcfIpAddr.setDescription('The dynamic XCF IP address of the target stack. If the ALL parameter was specified on the VIPADISTRIBUTE Profile statement, this object will be set to a zero-length string.')
ibmMvsDVIPADistConfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ibmMvsDVIPADistConfStatus.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistConfStatus.setDescription('This object allows entries to be created and deleted in the ibmMvsDVIPADistConfTable.')
ibmMvsDVIPAConnRoutingTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4), )
if mibBuilder.loadTexts: ibmMvsDVIPAConnRoutingTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnRoutingTable.setDescription('Each entry in this table represents a dynamic VIPA TCP connection. Entries will be supported in the table for all dynamic VIPA interfaces for which MOVEABLE IMMEDIATE or NONDISRUPTIVE was specified. On a Sysplex Distributor routing stack, there will be an entry in this table for every connection being routed through the distributor. On a stack taking over a dynamic VIPA, there will be an entry in this table for every connection to the dynamic VIPA. On a Sysplex Distributor target stack or a stack which is in the process of giving up a dynamic VIPA, there will be an entry in this table for every connection for which the stack is an endpoint.')
ibmMvsDVIPAConnRoutingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddr"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnPort"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnRemIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnRemIpAddr"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnRemPort"))
if mibBuilder.loadTexts: ibmMvsDVIPAConnRoutingEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnRoutingEntry.setDescription('Definition of a single entry in the ibmMvsDVIPAConnRoutingTable.')
ibmMvsDVIPAConnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ibmMvsDVIPAConnPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnPort.setDescription('The dynamic VIPA port.')
ibmMvsDVIPAConnRemIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 2), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemIpAddrType.setDescription('The IP address type of the ibmMvsDVIPAConnRemIpAddr object.')
ibmMvsDVIPAConnRemIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemIpAddr.setDescription('The remote IP address for this TCP connection.')
ibmMvsDVIPAConnRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnRemPort.setDescription('The remote port for this TCP connection.')
ibmMvsDVIPAConnDynXcfIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAConnDynXcfIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnDynXcfIpAddrType.setDescription('The IP address type of the ibmMvsDVIPAConnDynXcfIpAddr object.')
ibmMvsDVIPAConnDynXcfIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 6), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAConnDynXcfIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnDynXcfIpAddr.setDescription('The dynamic XCF IP address of the Sysplex Distributor target stack, or stack which is the endpoint of the connection.')
ibmMvsDVIPAConnPolicyRuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAConnPolicyRuleName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnPolicyRuleName.setDescription('The Service Policy Agent Policy Rule name that the connection maps to. If the Service Policy Agent is not active or the connection does not map to a policy, this object will be set to the string value *NONE*.')
ibmMvsDVIPAConnPolicyActionName = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 4, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAConnPolicyActionName.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAConnPolicyActionName.setDescription('The Service Policy Agent Policy Action name that the connection maps to. If the Service Policy Agent is not active or the connection does not map to a policy, this object will be set to the string value *NONE*.')
ibmMvsDVIPADistPortTable = MibTable((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5), )
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTable.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTable.setDescription('An entry exists in this table for every target stack per distributed dynamic VIPA and port. This table is supported only by stacks which are distributing connection requests as part of the Sysplex Distributor function. This table is not supported by stacks which are only targets of the Sysplex Distributor function.')
ibmMvsDVIPADistPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1), ).setIndexNames((0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPAIpAddr"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortPort"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortTargetDynXcfIpAddrType"), (0, "IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortTargetDynXcfIpAddr"))
if mibBuilder.loadTexts: ibmMvsDVIPADistPortEntry.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortEntry.setDescription('Definition of a single entry in the ibmMvsDVIPADistPortTable.')
ibmMvsDVIPADistPortPort = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: ibmMvsDVIPADistPortPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortPort.setDescription('The dynamic VIPA distributed port.')
ibmMvsDVIPADistPortTargetDynXcfIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 2), InetAddressType())
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTargetDynXcfIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTargetDynXcfIpAddrType.setDescription('The IP address type of the ibmMvsDVIPADistPortTargetDynXcfIpAddr object.')
ibmMvsDVIPADistPortTargetDynXcfIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20)))
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTargetDynXcfIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTargetDynXcfIpAddr.setDescription('The dynamic XCF IP address of the target stack.')
ibmMvsDVIPADistPortReadyCount = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPADistPortReadyCount.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortReadyCount.setDescription('The number of servers ready at the port on the target stack, to service connection requests.')
ibmMvsDVIPADistPortTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTotalConn.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortTotalConn.setDescription('The total number of connections for the dynamic VIPA IP address and port which have been distributed to the target stack.')
ibmMvsDVIPADistPortWlmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPADistPortWlmWeight.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPADistPortWlmWeight.setDescription("The Workload Manager weight value for the MVS system on which the target stack is located. The value is normalized such that the lowest value is 1. This weight value is an indication of the MVS system's available CPU capacity. The lower the value the lower the capacity.")
ibmMvsDVIPAServMgrMulticastIpAddrType = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrMulticastIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrMulticastIpAddrType.setDescription('The IP address type of the ibmMvsDVIPAServMgrMulticastIpAddr object.')
ibmMvsDVIPAServMgrMulticastIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 7), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrMulticastIpAddr.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrMulticastIpAddr.setDescription('The type of multicast IP address that will be used for communications between the Sysplex Distributor and the routers acting as Forwarding Agents. This object reflects values from the VIPASMPARMS Profile statement for the Sysplex Distributor Service Manager function.')
ibmMvsDVIPAServMgrPort = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrPort.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrPort.setDescription('The type of multicast IP address that will be used for communications between the Sysplex Distributor and the routers acting as Forwarding Agents. This object reflects values from the VIPASMPARMS Profile statement for the Sysplex Distributor Service Manager function.')
ibmMvsDVIPAServMgrPasswordSpecified = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrPasswordSpecified.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAServMgrPasswordSpecified.setDescription('Indicates whether a password value was specified on the VIPASMPARMS Profile statement for the Sysplex Distributor Service Manager function. A value of true(1) indicates that a password was specified. A value of false(2) indicates that a password was not specified. The password enables MD5 encryption for all communications between the Sysplex Distributor function and routers acting as Forwarding Agents. This password must match configured on the Forwarding Agents.')
ibmMvsDVIPATrapControl = MibScalar((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 2, 11, 10), Bits().clone(namedValues=NamedValues(("dvipaStatusChange", 0), ("dvipaRemoved", 1), ("targetAdded", 2), ("targetRemoved", 3), ("targetServerStarted", 4), ("targetServerEnded", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ibmMvsDVIPATrapControl.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATrapControl.setDescription('The value of this object determines which traps will be generated for all dynamic VIPA events. The value of this object is initialized to dvipaStatusChange(0) and dvipaRemoved(1) so that only those traps will be automatically generated. The following values are only applicable to Sysplex Distributor distributing stacks: - targetAdded(2) - targetRemoved(3) - targetServerStarted(4) - targetServerEnded(5) The following traps are generated when the corresponding bit value for this object is set: BIT value Trap --================================== dvipaStatusChange(0) ibmMvsDVIPAStatusChange dvipaRemoved(1) ibmMvsDVIPARemoved targetAdded(2) ibmMvsDVIPATargetAdded targetRemoved(3) ibmMvsDVIPATargetRemoved targetServerStarted(4 ) ibmMvsDVIPATargetServerStarted targetServerEnded(5) ibmMvsDVIPATargetServerEnded')
ibmMvsAtmOsasfAtmPvcCreate = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 1)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"))
if mibBuilder.loadTexts: ibmMvsAtmOsasfAtmPvcCreate.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfAtmPvcCreate.setDescription("This trap is generated when OSA/SF sends a asynch notification to the TCP/IP DPI Subagent that a PVC was created for a given OSA Port. This notification contains the corresponding ibmMvsAtmOsasfPortName instance. Representation of this will contain the aal5 layer interface ifIndex of the port, the PVC name len, and the PVC name in ASCII as 'ifIndex.pvcNameOctetCount.pvcNameInASCIINvt'.")
ibmMvsAtmOsasfAtmPvcDelete = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 2)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"))
if mibBuilder.loadTexts: ibmMvsAtmOsasfAtmPvcDelete.setStatus('current')
if mibBuilder.loadTexts: ibmMvsAtmOsasfAtmPvcDelete.setDescription("This trap is generated when OSA/SF sends a asyn notification to the TCP/IP DPI Subagent that a PVC was deleted for a given OSA Port. This notification contains the corresponding ibmMvsAtmOsasfPortName instance. Representation of this will contain the aal5 layer interface ifIndex of the port, the PVC name len, and the PVC name in ASCII as 'ifIndex.pvcNameOctetCount.pvcNameInASCIINvt'.")
ibmMvsDVIPAStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 3)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPAStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAOrigin"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARank"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAMoveable"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrEnabled"))
if mibBuilder.loadTexts: ibmMvsDVIPAStatusChange.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPAStatusChange.setDescription('This trap is generated when a dynamic VIPA is defined or its status changes on a TCP/IP stack. The ibmMvsDVIPAOrigin value indicates the reason why the DVIPA was originally defined. The instance value for the trap objects will contain the affected DVIPA IP address.')
ibmMvsDVIPARemoved = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 4)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPAStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAOrigin"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARank"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAMoveable"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrEnabled"))
if mibBuilder.loadTexts: ibmMvsDVIPARemoved.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPARemoved.setDescription('This trap is generated when a dynamic VIPA is removed from a TCP/Id stack. The ibmMvsDVIPAOrigin value indicates the reason why the DVIPA was previously defined. The ibmMvsDVIPAStatus object reflects the status before DVIPA was removed. The instance value for the trap objects will contain the affected DVIPA IP address.')
ibmMvsDVIPATargetAdded = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 5)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfStatus"))
if mibBuilder.loadTexts: ibmMvsDVIPATargetAdded.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATargetAdded.setDescription("This trap is generated by a Sysplex Distributor stack when it determines that a designated target stack is active. Stacks are designated as target stacks on the VIPADISTRIBUTE Profile statement. The instance value for the ibmMvsDVIPADistConfStatus object will indicate the affected DVIPA IP address, the distributed port, and the target stack's dynamic XCF IP address.")
ibmMvsDVIPATargetRemoved = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 6)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfStatus"))
if mibBuilder.loadTexts: ibmMvsDVIPATargetRemoved.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATargetRemoved.setDescription("This trap is generated by a Sysplex Distributor stack when an active target stack is removed from distribution. This can occur when a VIPADISTRIBUTE DELETE Profile statement is processed, or the target stack ends. The instance value for the ibmMvsDVIPADistConfStatus object will indicate the affected DVIPA IP address, the distributed port, and the dynamic XCF IP address of the target stack that is removed from distribution. if the ALL parameter was specified on the VIPADISTRIBUTE DELETE statement, the target stack's IP address type will be unknown (0) and its IP address will be a zero-length string.")
ibmMvsDVIPATargetServerStarted = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 7)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortReadyCount"))
if mibBuilder.loadTexts: ibmMvsDVIPATargetServerStarted.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATargetServerStarted.setDescription("This trap is generated by a Sysplex Distributor stack when it receives notification from a target stack that a server has become active on a distributed port. The instance value for the ibmMvsDVIPADistPortReadyCount object will indicate the affected DVIPA IP address, the distributed port, and the target stack's dynamic XCF IP address.")
ibmMvsDVIPATargetServerEnded = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 8)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortReadyCount"))
if mibBuilder.loadTexts: ibmMvsDVIPATargetServerEnded.setStatus('current')
if mibBuilder.loadTexts: ibmMvsDVIPATargetServerEnded.setDescription("This trap is generated by a Sysplex Distributor stack when it receives notification from a target stack that a server has ended on a distributed port. The instance value for the ibmMvsDVIPADistPortReadyCount object will indicate the affected DVIPA IP address, the distributed port, and the target stack's dynamic XCF IP address.")
ibmMvsTcpipSubagentColdStart = NotificationType((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 0, 9))
if mibBuilder.loadTexts: ibmMvsTcpipSubagentColdStart.setStatus('current')
if mibBuilder.loadTexts: ibmMvsTcpipSubagentColdStart.setDescription('This trap is generated by the TCP/IP Subagent. It signifies that the Subagent, acting in a subagent role, has reinitialized itself and that its configuration may have been altered.')
ibmTCPIPmvsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 1))
ibmTCPIPmvsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2))
ibmTCPIPmvsCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 1, 1)).setObjects(("IBMTCPIPMVS-MIB", "ibmTCPIPmvsPingGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsSystemGroup7"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsTcpGroup6"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsUdpGroup3"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsInterfacesGroup5"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsPortGroup2"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsRoutingGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsIpGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsSystemNotificationGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsAtmSupportGroup4"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsAtmNotificationGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsAtmLeGroup2"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsOsaExpGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsDVIPAGroup"), ("IBMTCPIPMVS-MIB", "ibmTCPIPmvsDVIPANotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsCompliance = ibmTCPIPmvsCompliance.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsCompliance.setDescription('The compliance statement for the IBM Communications Server product.')
ibmTCPIPmvsPingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 1)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsRPingResponseTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsPingGroup = ibmTCPIPmvsPingGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsPingGroup.setDescription(' ')
ibmTCPIPmvsRoutingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 11)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsGatewayMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsGatewayMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsGatewayRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsGatewayVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsGatewayVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsGatewayDelayAcks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsRoutingGroup = ibmTCPIPmvsRoutingGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsRoutingGroup.setDescription('This group comprises the TCP/IP retransmission parms that are in effect for a locally configured route entry.')
ibmTCPIPmvsPortGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 26)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsPortNumberLow"), ("IBMTCPIPMVS-MIB", "ibmMvsPortNumberHigh"), ("IBMTCPIPMVS-MIB", "ibmMvsPortProtocol"), ("IBMTCPIPMVS-MIB", "ibmMvsPortProcName"), ("IBMTCPIPMVS-MIB", "ibmMvsPortAutoLoggable"), ("IBMTCPIPMVS-MIB", "ibmMvsPortDelayAcks"), ("IBMTCPIPMVS-MIB", "ibmMvsPortOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsPortSharePort"), ("IBMTCPIPMVS-MIB", "ibmMvsPortBindIpAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsPortSAFResource"), ("IBMTCPIPMVS-MIB", "ibmMvsPortReuse"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsPortGroup2 = ibmTCPIPmvsPortGroup2.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsPortGroup2.setDescription('This group comprises those objects that represent the current set of PORT and PORTRANGE definitions for this TCP/IP instance.')
ibmTCPIPmvsAtmSupportGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 27)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelSubType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelHwModel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelShared"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDeterNodeDesc"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelControlUnitNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCodeLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelFlashLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortHardwareState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMediaType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortCodeLoadStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrBurntIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrActive"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMaxPcmConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortPcmName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5InPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5OutPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortIpAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBestEffort"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVpi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVci"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdMaxAal5PduSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdMaxAal5PduSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmSupportGroup4 = ibmTCPIPmvsAtmSupportGroup4.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmSupportGroup4.setDescription('This group comprises those objects that are related to atm support.')
ibmTCPIPmvsUdpGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 29)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsUdpLastAct"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpIpOpts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpEntryState"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastTTL"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastLoopback"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastLinkAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDSField"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvLinkAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsUdpGroup3 = ibmTCPIPmvsUdpGroup3.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsUdpGroup3.setDescription('This group defines those objects that are augmented to a udp listen table entry.')
ibmTCPIPmvsAtmLeGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 30)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcTi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcT1"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcT2"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaleMaxStations"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxSaps"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaleMaxIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeCrsGroupAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeUserData"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeClientEnableState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeBestEffortPeakRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxLECConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrEnableLoadBalancing"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrLoadBalancing"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrSessionDelay"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLanType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigMaxDataFrameSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLanName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLesAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxUnknownFrameCount"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxUnknownFrameTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecVccTimeoutPeriod"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxRetryCount"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecAgingTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecForwardDelayTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecExpectedArpResponseTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecFlushTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecPathSwitchingDelay"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLocalSegmentID"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendAvgRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendPeakRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConnectionCompleteTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecPortName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecPrimaryAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecID"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecInterfaceState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLastFailureRespCode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLastFailureState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecProtocol"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecTopologyChange"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigServerAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigSource"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualLanType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualMaxDataFrameSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualLanName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecProxyClient"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRequestsOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRequestsIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRepliesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRepliesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlFramesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlFramesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecSvcFailures"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmLeGroup2 = ibmTCPIPmvsAtmLeGroup2.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmLeGroup2.setDescription('This group comprises those objects that are related to ATM LAN Emulation support.')
ibmTCPIPmvsTcpGroup6 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 32)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTargetAppl"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClientUserId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLogMode"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnProto"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDupacks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClusterConnFlag"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInSegs"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutSegs"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDSField"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnAcceptCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnExceedBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCurrBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnWindowScale"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTimeStamp"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnServerResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnsClosed"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpPassiveDrops"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpTimeWaitReused"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpPredictAck"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpPredictData"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInDupAck"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInBadSum"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInBadLen"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInShort"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInPawsDrop"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInAllBeforeWin"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInSomeBeforeWin"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInAllAfterWin"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInSomeAfterWin"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInOutOfOrder"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInAfterClose"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInWinProbes"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpInWinUpdates"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpOutWinUpdates"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpOutDelayAcks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpOutWinProbes"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRxmtTimers"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRxmtDrops"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpPMTURxmts"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpPMTUErrors"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpProbeDrops"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveProbes"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveDrops"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpFinwait2Drops"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerLocalAddrType"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerLocalAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerLocalPort"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerRemoteAddrType"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerRemoteAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerRemotePort"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerAcceptCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerExceedBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerCurrBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerMaxBacklog"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpListenerResourceName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup6 = ibmTCPIPmvsTcpGroup6.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup6.setDescription('Defines objects that are augmented to the tcpConnTable and statistical objects for TCP entities.')
ibmTCPIPmvsIpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 33)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsIpInDevLayerCalls"), ("IBMTCPIPMVS-MIB", "ibmMvsIpInUnpackErrors"), ("IBMTCPIPMVS-MIB", "ibmMvsIpInDiscardsMemory"), ("IBMTCPIPMVS-MIB", "ibmMvsIpOutDiscardsDlcSynch"), ("IBMTCPIPMVS-MIB", "ibmMvsIpOutDiscardsDlcAsynch"), ("IBMTCPIPMVS-MIB", "ibmMvsIpOutDiscardsMemory"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsIpGroup = ibmTCPIPmvsIpGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsIpGroup.setDescription('This group defines statistical objects for IP entities.')
ibmTCPIPmvsSystemGroup7 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 34)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpMaxReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsPathMtuDscEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMultipathType"), ("IBMTCPIPMVS-MIB", "ibmMvsIpForwarding"), ("IBMTCPIPMVS-MIB", "ibmMvsDevRetryDuration"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpFinwait2Time"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpTimeStamp"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipSubagentVersion"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup7 = ibmTCPIPmvsSystemGroup7.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup7.setDescription(' ')
ibmTCPIPmvsOsaExpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 35)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelType"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelSubType"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelMode"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelState"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelShared"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelNumPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelDeterNodeDesc"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelControlUnitNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelCodeLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelCurLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelCurLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelManLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelManLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelPCIBusUtil1Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelProcessorUtil1Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelPCIBusUtil5Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelProcessorUtil5Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelPCIBusUtilHour"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpChannelProcessorUtilHour"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfProcessorUtil1Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfInKbytesRate1Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfOutKbytesRate1Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfProcessorUtil5Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfInKbytesRate5Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfOutKbytesRate5Min"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfProcessorUtilHour"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfInKbytesRateHour"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpPerfOutKbytesRateHour"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortType"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortHardwareState"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortServiceMode"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortDisabledStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortConfigName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortConfigSpeed"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortActiveSpeed"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortMacAddrActive"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortMacAddrBurntIn"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortUserData"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortOutPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortInPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortInGroupFrames"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortInBroadcastFrames"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortInUnknownIPFrames"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthPortGroupMacAddrs"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthSnaInactTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthSnaRespTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthSnaAckTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthSnaMaxIFramesBeforeAck"), ("IBMTCPIPMVS-MIB", "ibmMvsOsaExpEthSnaMaxTransmitWindow"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsOsaExpGroup = ibmTCPIPmvsOsaExpGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsOsaExpGroup.setDescription('This group comprises those objects that are related to OSA-Express adapter support.')
ibmTCPIPmvsInterfacesGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 36)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDeviceType"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceBaseNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIoBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceAutoRestart"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceNetmanEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceHostClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWorkstationClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIncomingSvcEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceRouterStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceActualRouterStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceConfigPackingMode"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceActualPackingMode"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkType"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkDeviceIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkAdapterAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrCanonical"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrBcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkChecksumEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkArpSupport"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMacAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcastRefCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsInterfacesGroup5 = ibmTCPIPmvsInterfacesGroup5.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsInterfacesGroup5.setDescription('This group comprises those objects that are related to interface entries in the IF-MIB.')
ibmTCPIPmvsDVIPAGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 37)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPAMaskType"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAMaskAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAOrigin"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARank"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistributeStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAMoveable"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfMoveable"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARangeConfStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistConfStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnDynXcfIpAddrType"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnDynXcfIpAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnPolicyRuleName"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAConnPolicyActionName"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortReadyCount"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortTotalConn"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPADistPortWlmWeight"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrMulticastIpAddrType"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrMulticastIpAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrPort"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPAServMgrPasswordSpecified"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPATrapControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsDVIPAGroup = ibmTCPIPmvsDVIPAGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsDVIPAGroup.setDescription('This group comprises those objects that are related to Dynamic VIPA interfaces.')
ibmTCPIPmvsDVIPANotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 38)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDVIPAStatusChange"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPARemoved"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPATargetAdded"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPATargetRemoved"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPATargetServerStarted"), ("IBMTCPIPMVS-MIB", "ibmMvsDVIPATargetServerEnded"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsDVIPANotificationGroup = ibmTCPIPmvsDVIPANotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsDVIPANotificationGroup.setDescription('This group comprises those notification objects that are related to Dynamic VIPA support.')
ibmTCPIPmvsSystemNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 39)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpipSubagentColdStart"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemNotificationGroup = ibmTCPIPmvsSystemNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemNotificationGroup.setDescription('This group comprises those notification objects that are related to the MVS System group.')
ibmTCPIPmvsAtmNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 7)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfAtmPvcCreate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfAtmPvcDelete"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmNotificationGroup = ibmTCPIPmvsAtmNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmNotificationGroup.setDescription('This group comprises those objects that are related to atm support.')
ibmTCPIPmvsObsoleteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 6)).setObjects(("IBMTCPIPMVS-MIB", "ibmSNMPRemPing"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsObsoleteGroup = ibmTCPIPmvsObsoleteGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsObsoleteGroup.setDescription('This group comprises those objects that are obsolete.')
ibmTCPIPmvsTcpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 3)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnActiveOpen"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendWindowSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendWindowAck"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnPendTcpRecv"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSig"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSel"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBackoffCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpDet"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpPol"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup = ibmTCPIPmvsTcpGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup.setDescription('Defines the objects that are argumented to the tcpConnTable')
ibmTCPIPmvsSystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 2)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup = ibmTCPIPmvsSystemGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup.setDescription(' ')
ibmTCPIPmvsSystemGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 13)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup2 = ibmTCPIPmvsSystemGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup2.setDescription(' ')
ibmTCPIPmvsAtmSupportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 5)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelSubType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelHwModel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelShared"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDeterNodeDesc"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelControlUnitNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCodeLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelEcLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelFlashLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelVtamId"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortHardwareState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMediaType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortCodeLoadStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrBurntIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrActive"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMaxPcmConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortPcmName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBestEffort"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVpi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVci"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdMaxAal5PduSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdMaxAal5PduSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmSupportGroup = ibmTCPIPmvsAtmSupportGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmSupportGroup.setDescription('This group comprises those objects that are related to atm support.')
ibmTCPIPmvsInterfacesGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 8)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDeviceType"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceBaseNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIoBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceAutoRestart"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceNetmanEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceHostClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWorkstationClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIncomingSvcEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkType"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkDeviceIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkAdapterAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrCanonical"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrBcast"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsInterfacesGroup = ibmTCPIPmvsInterfacesGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsInterfacesGroup.setDescription('This group comprises those objects that are related to interface entries in the IF-MIB.')
ibmTCPIPmvsUdpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 4)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsUdpLastAct"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpIpOpts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpEntryState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsUdpGroup = ibmTCPIPmvsUdpGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsUdpGroup.setDescription('This group defines those objects that are augmented to a udp listen table entry.')
ibmTCPIPmvsSystemGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 15)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpMaxReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsMultipathEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup3 = ibmTCPIPmvsSystemGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup3.setDescription(' ')
ibmTCPIPmvsInterfacesGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 16)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDeviceType"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceBaseNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIoBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceAutoRestart"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceNetmanEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceHostClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWorkstationClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIncomingSvcEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkType"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkDeviceIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkAdapterAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrCanonical"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrBcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcastRefCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsInterfacesGroup2 = ibmTCPIPmvsInterfacesGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsInterfacesGroup2.setDescription('This group comprises those objects that are related to interface entries in the IF-MIB.')
ibmTCPIPmvsTcpGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 12)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnActiveOpen"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnPendTcpRecv"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSig"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSel"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBackoffCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpDet"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpPol"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTargetAppl"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClientUserId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLogMode"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnProto"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDupacks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptMaxSegmentSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup2 = ibmTCPIPmvsTcpGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup2.setDescription('Defines the objects that are augmented to the tcpConnTable')
ibmTCPIPmvsSystemGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 18)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpMaxReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsMultipathEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsPathMtuDscEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup4 = ibmTCPIPmvsSystemGroup4.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup4.setDescription(' ')
ibmTCPIPmvsTcpGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 20)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnActiveOpen"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnPendTcpRecv"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSig"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSel"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBackoffCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpDet"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpPol"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTargetAppl"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClientUserId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLogMode"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnProto"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDupacks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClusterConnFlag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup3 = ibmTCPIPmvsTcpGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup3.setDescription('Defines the objects that are augmented to the tcpConnTable')
ibmTCPIPmvsAtmSupportGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 14)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelSubType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelHwModel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelShared"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDeterNodeDesc"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelControlUnitNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCodeLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelEcLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelFlashLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelVtamId"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortHardwareState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMediaType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortCodeLoadStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrBurntIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrActive"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMaxPcmConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortPcmName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5InPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5OutPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortIpAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBestEffort"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVpi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVci"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdMaxAal5PduSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdMaxAal5PduSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmSupportGroup2 = ibmTCPIPmvsAtmSupportGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmSupportGroup2.setDescription('This group comprises those objects that are related to atm support.')
ibmTCPIPmvsInterfacesGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 19)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDeviceType"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceBaseNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIoBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceAutoRestart"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceNetmanEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceHostClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWorkstationClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIncomingSvcEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceRouterStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkType"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkDeviceIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkAdapterAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrCanonical"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrBcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkChecksumEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcastRefCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsInterfacesGroup3 = ibmTCPIPmvsInterfacesGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsInterfacesGroup3.setDescription('This group comprises those objects that are related to interface entries in the IF-MIB.')
ibmTCPIPmvsPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 10)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsPortNumberLow"), ("IBMTCPIPMVS-MIB", "ibmMvsPortNumberHigh"), ("IBMTCPIPMVS-MIB", "ibmMvsPortProtocol"), ("IBMTCPIPMVS-MIB", "ibmMvsPortProcName"), ("IBMTCPIPMVS-MIB", "ibmMvsPortAutoLoggable"), ("IBMTCPIPMVS-MIB", "ibmMvsPortDelayAcks"), ("IBMTCPIPMVS-MIB", "ibmMvsPortOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsPortSharePort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsPortGroup = ibmTCPIPmvsPortGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsPortGroup.setDescription('This group comprises those objects that represent the current set of PORT and PORTRANGE definitions for this TCP/IP instance.')
ibmTCPIPmvsAtmSupportGroup3 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 24)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelSubType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelHwModel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelShared"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelNumPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDeterNodeDesc"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelControlUnitNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCodeLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelEcLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelCurLparNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelManParnNum"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelDate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfChannelFlashLevel"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortHardwareState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMediaType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortUniVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixPrefix"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortNetPrefixStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortCodeLoadStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrBurntIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMacAddrActive"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortMaxPcmConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortPcmName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5InPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortAAL5OutPackets"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPortIpAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBestEffort"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdPeakCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdsustainCellRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdCellBurstSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVpi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcVci"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcFwdMaxAal5PduSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmOsasfPvcBwdMaxAal5PduSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmSupportGroup3 = ibmTCPIPmvsAtmSupportGroup3.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmSupportGroup3.setDescription('This group comprises those objects that are related to atm support.')
ibmTCPIPmvsTcpGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 22)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSig"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSel"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpDet"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpPol"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTargetAppl"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClientUserId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLogMode"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnProto"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDupacks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClusterConnFlag"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInSegs"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutSegs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup4 = ibmTCPIPmvsTcpGroup4.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup4.setDescription('Defines the objects that are augmented to the tcpConnTable')
ibmTCPIPmvsUdpGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 17)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsUdpLastAct"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpTos"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpIpOpts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpDgramOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvLim"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpEntryState"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastTTL"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastLoopback"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastLinkAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpMcastRecvLinkAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsUdpGroup2 = ibmTCPIPmvsUdpGroup2.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsUdpGroup2.setDescription('This group defines those objects that are argumented to a udp listen table entry.')
ibmTCPIPmvsAtmLeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 9)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcTi"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcT1"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeLlcT2"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaleMaxStations"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxSaps"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaleMaxIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeCrsGroupAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeUserData"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeClientEnableState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeBestEffortPeakRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeMaxLECConnections"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrEnableLoadBalancing"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrLoadBalancing"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmSnaLeTrSessionDelay"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigMode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLanType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigMaxDataFrameSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLanName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigLesAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxUnknownFrameCount"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxUnknownFrameTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecVccTimeoutPeriod"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMaxRetryCount"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecAgingTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecForwardDelayTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecExpectedArpResponseTime"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecFlushTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecPathSwitchingDelay"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLocalSegmentID"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendAvgRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendPeakRate"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConnectionCompleteTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecPrimaryAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecID"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecInterfaceState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLastFailureRespCode"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecLastFailureState"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecProtocol"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecTopologyChange"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigServerAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigSource"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualLanType"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualMaxDataFrameSize"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecActualLanName"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecAtmAddress"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecProxyClient"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRequestsOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRequestsIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRepliesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecArpRepliesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlFramesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlFramesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecSvcFailures"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecConfigDirectVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDirectVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecControlDistributeVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastSendVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdInterface"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdVPI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMulticastFwdVCI"), ("IBMTCPIPMVS-MIB", "ibmMvsAtmLecMacAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsAtmLeGroup = ibmTCPIPmvsAtmLeGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsAtmLeGroup.setDescription('This group comprises those objects that are related to ATM LAN Emulation support.')
ibmTCPIPmvsSystemGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 21)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpMaxReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsPathMtuDscEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMultipathType"), ("IBMTCPIPMVS-MIB", "ibmMvsIpForwarding"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup5 = ibmTCPIPmvsSystemGroup5.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup5.setDescription(' ')
ibmTCPIPmvsTcpGroup5 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 28)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLastActivity"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesIn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnBytesOut"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptions"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndUna"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutgoingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInBuffered"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnUsrRcvNxt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingPush"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingUrg"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnIncomingWinSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnMaxSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnReXmtCount"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnCongestionWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSSThresh"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripTime"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRoundTripVariance"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitSndSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInitRcvSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSendMSS"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl1"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWl2"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSndWnd"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRcvBufSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSubtask"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnResourceId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnSockOpt"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSig"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpSel"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnRttSeq"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpDet"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTcpPol"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnTargetAppl"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClientUserId"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnLogMode"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnProto"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDupacks"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOptMaxSegmentSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnClusterConnFlag"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnInSegs"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnOutSegs"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpConnDSField"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsTcpGroup5 = ibmTCPIPmvsTcpGroup5.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsTcpGroup5.setDescription('Defines the objects that are augmented to the tcpConnTable')
ibmTCPIPmvsSystemGroup6 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 31)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsSubagentCacheTime"), ("IBMTCPIPMVS-MIB", "ibmMvsIgnoreRedirect"), ("IBMTCPIPMVS-MIB", "ibmMvsArpCacheTimeout"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpKeepAliveTimer"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpChecksum"), ("IBMTCPIPMVS-MIB", "ibmMvsIplDateAndTime"), ("IBMTCPIPMVS-MIB", "ibmMvsNoUdpQueueLimit"), ("IBMTCPIPMVS-MIB", "ibmMvsSoMaxConn"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipAsid"), ("IBMTCPIPMVS-MIB", "ibmMvsSourceVipaEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfSysplexName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfHostName"), ("IBMTCPIPMVS-MIB", "ibmMvsOsasfProductVersion"), ("IBMTCPIPMVS-MIB", "ibmMvsPrimaryInterfaceIfIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsIpMaxReassemblySize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRestrictLowPorts"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpSendBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsUdpRecvBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpipStatisticsEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsFirewallEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMaximumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsMinimumRetransmitTime"), ("IBMTCPIPMVS-MIB", "ibmMvsRoundTripGain"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceMultiplier"), ("IBMTCPIPMVS-MIB", "ibmMvsVarianceGain"), ("IBMTCPIPMVS-MIB", "ibmMvsSendGarbageEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsTcpMaxReceiveBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsPathMtuDscEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsMultipathType"), ("IBMTCPIPMVS-MIB", "ibmMvsIpForwarding"), ("IBMTCPIPMVS-MIB", "ibmMvsDevRetryDuration"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsSystemGroup6 = ibmTCPIPmvsSystemGroup6.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsSystemGroup6.setDescription(' ')
ibmTCPIPmvsInterfacesGroup4 = ObjectGroup((1, 3, 6, 1, 4, 1, 2, 6, 19, 2, 3, 2, 25)).setObjects(("IBMTCPIPMVS-MIB", "ibmMvsDeviceType"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceBaseNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIoBufferSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceAutoRestart"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceNetmanEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceHostClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWorkstationClawName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceReadSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteBuffers"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceWriteSize"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceProcname"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceIncomingSvcEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceLuName"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceRouterStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsDeviceActualRouterStatus"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkType"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkDeviceIndex"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkAdapterAddr"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkNumber"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrCanonical"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkIbmtrBcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcast"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkChecksumEnabled"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkArpSupport"), ("IBMTCPIPMVS-MIB", "ibmMvsLinkMcastRefCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ibmTCPIPmvsInterfacesGroup4 = ibmTCPIPmvsInterfacesGroup4.setStatus('obsolete')
if mibBuilder.loadTexts: ibmTCPIPmvsInterfacesGroup4.setDescription('This group comprises those objects that are related to interface entries in the IF-MIB.')
mibBuilder.exportSymbols("IBMTCPIPMVS-MIB", ibmMvsAtmLecControlDistributeInterface=ibmMvsAtmLecControlDistributeInterface, ibmMvsOsaExpEthSnaRespTimer=ibmMvsOsaExpEthSnaRespTimer, ibmTCPIPmvsPingGroup=ibmTCPIPmvsPingGroup, ibmMvsAtmOsasfPortNetPrefix=ibmMvsAtmOsasfPortNetPrefix, ibmMvsAtmLecControlDirectInterface=ibmMvsAtmLecControlDirectInterface, ibmMvsPortProtocol=ibmMvsPortProtocol, ibmMvsTcpConnInitRcvSeq=ibmMvsTcpConnInitRcvSeq, ibmMvsIgnoreRedirect=ibmMvsIgnoreRedirect, ibmMvsUdpSendLim=ibmMvsUdpSendLim, ibmMvsPortDelayAcks=ibmMvsPortDelayAcks, ibmMvsAtmOsasfPvcBwdPeakCellRate=ibmMvsAtmOsasfPvcBwdPeakCellRate, ibmTCPIPmvsMIBObjects=ibmTCPIPmvsMIBObjects, ibmMvsTcpListenerLocalPort=ibmMvsTcpListenerLocalPort, ibmMvsOsaExpChannelProcessorUtil1Min=ibmMvsOsaExpChannelProcessorUtil1Min, ibmMvsDVIPAConnPort=ibmMvsDVIPAConnPort, ibmMvsTcpipProcname=ibmMvsTcpipProcname, ibmMvsAtmLecMulticastSendVCI=ibmMvsAtmLecMulticastSendVCI, ibmMvsTcpConnReXmtCount=ibmMvsTcpConnReXmtCount, ibmMvsOsaExpPerfProcessorUtilHour=ibmMvsOsaExpPerfProcessorUtilHour, ibmMvsAtmLecLocalSegmentID=ibmMvsAtmLecLocalSegmentID, ibmMvsAtmLecLastFailureState=ibmMvsAtmLecLastFailureState, ibmMvsTcpRxmtTimers=ibmMvsTcpRxmtTimers, ibmMvsOsaExpChannelMode=ibmMvsOsaExpChannelMode, ibmMvsUdpMcastRecvLocalPort=ibmMvsUdpMcastRecvLocalPort, ibmTcpipMvsIpGroup=ibmTcpipMvsIpGroup, ibmMvsAtmOsasfPortHardwareState=ibmMvsAtmOsasfPortHardwareState, ibmMvsOsaExpChannelProcessorUtil5Min=ibmMvsOsaExpChannelProcessorUtil5Min, ibmMvsTcpInWinUpdates=ibmMvsTcpInWinUpdates, ibmTCPIPmvsOsaExpGroup=ibmTCPIPmvsOsaExpGroup, ibmMvsAtmOsasfChannelDate=ibmMvsAtmOsasfChannelDate, ibmMvsTcpConnOutgoingUrg=ibmMvsTcpConnOutgoingUrg, ibmMvsAtmLecPathSwitchingDelay=ibmMvsAtmLecPathSwitchingDelay, ibmMvsTcpListenerResourceName=ibmMvsTcpListenerResourceName, ibmMvsDeviceAutoRestart=ibmMvsDeviceAutoRestart, ibmMvsOsaExpEthPortInGroupFrames=ibmMvsOsaExpEthPortInGroupFrames, ibmTCPIPmvsMIBTraps=ibmTCPIPmvsMIBTraps, ibmMvsTcpInBadLen=ibmMvsTcpInBadLen, ibmMvsSourceVipaEnabled=ibmMvsSourceVipaEnabled, ibmMvsUdpRestrictLowPorts=ibmMvsUdpRestrictLowPorts, ibmMvsDVIPAConnPolicyActionName=ibmMvsDVIPAConnPolicyActionName, ibmMvsUdpBytesOut=ibmMvsUdpBytesOut, ibmMvsPortSharePort=ibmMvsPortSharePort, ibmTcpipMvsTcpConnEntry=ibmTcpipMvsTcpConnEntry, ibmMvsIpOutDiscardsDlcSynch=ibmMvsIpOutDiscardsDlcSynch, ibmMvsAtmOsasfChannelVtamId=ibmMvsAtmOsasfChannelVtamId, ibmMvsDeviceWorkstationClawName=ibmMvsDeviceWorkstationClawName, ibmMvsTcpConnTargetAppl=ibmMvsTcpConnTargetAppl, ibmMvsUdpMcastLoopback=ibmMvsUdpMcastLoopback, ibmMvsAtmLecConfigMode=ibmMvsAtmLecConfigMode, ibmMvsTcpipStatisticsEnabled=ibmMvsTcpipStatisticsEnabled, ibmMvsAtmOsasfChannelFlashLevel=ibmMvsAtmOsasfChannelFlashLevel, ibmMvsAtmLecConfigDirectVCI=ibmMvsAtmLecConfigDirectVCI, ibmMvsOsaExpEthPortConfigSpeed=ibmMvsOsaExpEthPortConfigSpeed, ibmMvsTcpProbeDrops=ibmMvsTcpProbeDrops, ibmTCPIPmvsSystemNotificationGroup=ibmTCPIPmvsSystemNotificationGroup, ibmMvsAtmOsasfChannelCodeLevel=ibmMvsAtmOsasfChannelCodeLevel, ibmMvsTcpConnTcpDet=ibmMvsTcpConnTcpDet, osaexpEthPortEntry=osaexpEthPortEntry, ibmMvsOsaExpEthPortNumber=ibmMvsOsaExpEthPortNumber, ibmTCPIPmvsInterfacesGroup2=ibmTCPIPmvsInterfacesGroup2, ibmMvsPortAutoLoggable=ibmMvsPortAutoLoggable, ibmMvsAtmOsasfChannelHwModel=ibmMvsAtmOsasfChannelHwModel, ibmMvsDeviceReadBuffers=ibmMvsDeviceReadBuffers, ibmMvsAtmOsasfPvcFwdMaxAal5PduSize=ibmMvsAtmOsasfPvcFwdMaxAal5PduSize, ibmMvsAtmOsasfChannelState=ibmMvsAtmOsasfChannelState, ibmTcpipMvsPortEntry=ibmTcpipMvsPortEntry, ibmMvsDeviceHostClawName=ibmMvsDeviceHostClawName, ibmMvsDVIPAIpAddr=ibmMvsDVIPAIpAddr, ibmTcpipMvsDVIPAGroup=ibmTcpipMvsDVIPAGroup, ibmMvsTcpConnInBuffered=ibmMvsTcpConnInBuffered, ibmTcpipMvsUdpEntry=ibmTcpipMvsUdpEntry, ibmMvsDVIPARemoved=ibmMvsDVIPARemoved, ibmMvsDeviceActualRouterStatus=ibmMvsDeviceActualRouterStatus, ibmMvsDVIPADistConfEntry=ibmMvsDVIPADistConfEntry, ibmMvsAtmOsasfChannelControlUnitNumber=ibmMvsAtmOsasfChannelControlUnitNumber, ibmMvsTcpInPawsDrop=ibmMvsTcpInPawsDrop, ibmMvsAtmSnaleMaxStations=ibmMvsAtmSnaleMaxStations, ibmMvsAtmOsasfChannelNumPorts=ibmMvsAtmOsasfChannelNumPorts, ibmMvsDeviceLuName=ibmMvsDeviceLuName, ibmMvsTcpConnIncomingWinSeq=ibmMvsTcpConnIncomingWinSeq, ibmMvsUdpResourceId=ibmMvsUdpResourceId, ibmMvsTcpConnRttSeq=ibmMvsTcpConnRttSeq, ibmMvsTcpInOutOfOrder=ibmMvsTcpInOutOfOrder, osasfPortTable=osasfPortTable, ibmMvsOsaExpChannelCurLparNum=ibmMvsOsaExpChannelCurLparNum, ibmRemotePingGroup=ibmRemotePingGroup, ibmMvsTcpOutDelayAcks=ibmMvsTcpOutDelayAcks, ibmTCPIPmvsTcpGroup4=ibmTCPIPmvsTcpGroup4, ibmMvsOsaExpEthPortInBroadcastFrames=ibmMvsOsaExpEthPortInBroadcastFrames, osaexpPerfEntry=osaexpPerfEntry, ibmMvsOsaExpEthPortDisabledStatus=ibmMvsOsaExpEthPortDisabledStatus, ibmMvsFirewallEnabled=ibmMvsFirewallEnabled, ibmMvsTcpConnActiveOpen=ibmMvsTcpConnActiveOpen, ibmMvsDVIPARangeConfIpAddr=ibmMvsDVIPARangeConfIpAddr, ibmMvsAtmLecTopologyChange=ibmMvsAtmLecTopologyChange, ibmMvsOsaExpEthPortHardwareState=ibmMvsOsaExpEthPortHardwareState, ibmTCPIPmvsInterfacesGroup3=ibmTCPIPmvsInterfacesGroup3, ibmMvsOsaExpEthPortMacAddrBurntIn=ibmMvsOsaExpEthPortMacAddrBurntIn, ibmMvsAtmSnaLeMaxOut=ibmMvsAtmSnaLeMaxOut, ibmMvsOsaExpChannelNumPorts=ibmMvsOsaExpChannelNumPorts, ibmTCPIPmvsUdpGroup3=ibmTCPIPmvsUdpGroup3, ibmTcpipMvsInterfaceGroup=ibmTcpipMvsInterfaceGroup, ibmMvsDVIPAConnRemIpAddr=ibmMvsDVIPAConnRemIpAddr, ibmMvsDVIPAConnPolicyRuleName=ibmMvsDVIPAConnPolicyRuleName, ibmTCPIPmvsSystemGroup6=ibmTCPIPmvsSystemGroup6, ibmMvsAtmOsasfPortNetPrefixStatus=ibmMvsAtmOsasfPortNetPrefixStatus, ibmMvsTcpConnClientUserId=ibmMvsTcpConnClientUserId, ibmMvsOsaExpEthSnaMaxIFramesBeforeAck=ibmMvsOsaExpEthSnaMaxIFramesBeforeAck, ibmMvsTcpConnTcpTimer=ibmMvsTcpConnTcpTimer, ibmMvsAtmSnaLeTable=ibmMvsAtmSnaLeTable, ibmTCPIPmvsSystemGroup=ibmTCPIPmvsSystemGroup, ibmMvsTcpConnSndWl2=ibmMvsTcpConnSndWl2, ibmMvsTcpConnRoundTripVariance=ibmMvsTcpConnRoundTripVariance, ibmMvsAtmOsasfAtmPvcDelete=ibmMvsAtmOsasfAtmPvcDelete, ibmMvsUdpMcastRecvLinkAddr=ibmMvsUdpMcastRecvLinkAddr, ibmMvsOsaExpChannelDeterNodeDesc=ibmMvsOsaExpChannelDeterNodeDesc, ibmTCPIPmvsAtmLeGroup2=ibmTCPIPmvsAtmLeGroup2, ibmMvsDeviceIncomingSvcEnabled=ibmMvsDeviceIncomingSvcEnabled, ibmMvsOsaExpPerfInKbytesRateHour=ibmMvsOsaExpPerfInKbytesRateHour, ibmTcpipMvsUdpMcastRecvEntry=ibmTcpipMvsUdpMcastRecvEntry, ibmMvsDVIPADistConfIpAddr=ibmMvsDVIPADistConfIpAddr, ibmTcpipMvsPortGroup=ibmTcpipMvsPortGroup, ibmMvsAtmSnaLeClientEnableState=ibmMvsAtmSnaLeClientEnableState, ibmMvsAtmLecMulticastFwdVPI=ibmMvsAtmLecMulticastFwdVPI, ibmMvsDVIPATargetServerStarted=ibmMvsDVIPATargetServerStarted, ibmMvsTcpConnSendWindowSeq=ibmMvsTcpConnSendWindowSeq, ibmMvsDVIPAMoveable=ibmMvsDVIPAMoveable, ibmMvsUdpIpOpts=ibmMvsUdpIpOpts, ibmMvsDVIPAServMgrMulticastIpAddr=ibmMvsDVIPAServMgrMulticastIpAddr, ibmMvsLinkMcastRefCount=ibmMvsLinkMcastRefCount, ibmMvsDVIPADistPortTargetDynXcfIpAddrType=ibmMvsDVIPADistPortTargetDynXcfIpAddrType, ibmMvsDVIPARangeConfStatus=ibmMvsDVIPARangeConfStatus, ibmMvsOsaExpChannelType=ibmMvsOsaExpChannelType, ibmMvsDVIPADistPortTable=ibmMvsDVIPADistPortTable, ibmMvsOsaExpChannelManLparName=ibmMvsOsaExpChannelManLparName, ibmMvsSoMaxConn=ibmMvsSoMaxConn, ibmMvsAtmLecConfigMaxDataFrameSize=ibmMvsAtmLecConfigMaxDataFrameSize, ibmMvsLinkChecksumEnabled=ibmMvsLinkChecksumEnabled, ibmTcpipMvsUdpTable=ibmTcpipMvsUdpTable, ibmMvsAtmLecControlDistributeVPI=ibmMvsAtmLecControlDistributeVPI, ibmMvsLinkMcastGroupAddr=ibmMvsLinkMcastGroupAddr, ibmMvsAtmOsasfPortUniType=ibmMvsAtmOsasfPortUniType, ibmMvsDVIPAServMgrPort=ibmMvsDVIPAServMgrPort, ibmMvsTcpConnOutSegs=ibmMvsTcpConnOutSegs, ibmMvsPortReuse=ibmMvsPortReuse, ibmMvsTcpConnIncomingUrg=ibmMvsTcpConnIncomingUrg, ibmMvsPortNumberHigh=ibmMvsPortNumberHigh, ibmTCPIPmvsAtmNotificationGroup=ibmTCPIPmvsAtmNotificationGroup, ibmMvsOsaExpEthPortOutPackets=ibmMvsOsaExpEthPortOutPackets, ibmTcpipMvsLinkMcastTable=ibmTcpipMvsLinkMcastTable, ibmMvsGatewayMaximumRetransmitTime=ibmMvsGatewayMaximumRetransmitTime, ibmMvsTcpFinwait2Drops=ibmMvsTcpFinwait2Drops, ibmMvsAtmOsasfPvcBwdCellBurstSize=ibmMvsAtmOsasfPvcBwdCellBurstSize, ibmTCPIPmvsPortGroup=ibmTCPIPmvsPortGroup, ibmTcpipMvsDeviceEntry=ibmTcpipMvsDeviceEntry, ibmMvsTcpConnBackoffCount=ibmMvsTcpConnBackoffCount, ibmMvsUdpSockOpt=ibmMvsUdpSockOpt, ibmMvsDeviceProcname=ibmMvsDeviceProcname, ibmMvsOsaExpPerfLparNum=ibmMvsOsaExpPerfLparNum, ibmMvsAtmLecAtmAddress=ibmMvsAtmLecAtmAddress, ibmMvsAtmSnaLeTrLoadBalancing=ibmMvsAtmSnaLeTrLoadBalancing, ibmMvsAtmLecMacAddress=ibmMvsAtmLecMacAddress, ibmTCPIPmvsCompliances=ibmTCPIPmvsCompliances, ibmMvsAtmOsasfPortMacAddrBurntIn=ibmMvsAtmOsasfPortMacAddrBurntIn, ibmMvsAtmLecConfigEntry=ibmMvsAtmLecConfigEntry, ibmMvsIpInUnpackErrors=ibmMvsIpInUnpackErrors, ibmMvsDVIPAConnRoutingEntry=ibmMvsDVIPAConnRoutingEntry, ibmMvsDVIPATargetRemoved=ibmMvsDVIPATargetRemoved, ibmMvsDeviceRouterStatus=ibmMvsDeviceRouterStatus, ibmMvsOsaExpEthSnaAckTimer=ibmMvsOsaExpEthSnaAckTimer, ibmMvsLinkIbmtrCanonical=ibmMvsLinkIbmtrCanonical, ibmMvsAtmLecStatusTable=ibmMvsAtmLecStatusTable, ibmMvsAtmOsasfChannelSubType=ibmMvsAtmOsasfChannelSubType, ibmMvsUdpRecvBufferSize=ibmMvsUdpRecvBufferSize, ibmMvsDVIPAConnRoutingTable=ibmMvsDVIPAConnRoutingTable, ibmMvsTcpConnLuName=ibmMvsTcpConnLuName, ibmMvsOsaExpEthPortMacAddrActive=ibmMvsOsaExpEthPortMacAddrActive, ibmMvsAtmLecConfigLesAtmAddress=ibmMvsAtmLecConfigLesAtmAddress, ibmMvsTcpListenerRemoteAddrType=ibmMvsTcpListenerRemoteAddrType, ibmMvsAtmLecExpectedArpResponseTime=ibmMvsAtmLecExpectedArpResponseTime, ibmMvsTcpConnPendTcpRecv=ibmMvsTcpConnPendTcpRecv, ibmMvsOsasfProductVersion=ibmMvsOsasfProductVersion, ibmTcpipMvsSystem=ibmTcpipMvsSystem, ibmMvsAtmOsasfChannelMode=ibmMvsAtmOsasfChannelMode, ibmMvsDVIPAIpAddrType=ibmMvsDVIPAIpAddrType, ibmMvsAtmOsasfPvcVpi=ibmMvsAtmOsasfPvcVpi, ibmMvsDVIPARangeConfIpAddrType=ibmMvsDVIPARangeConfIpAddrType, ibmMvsAtmLecInterfaceState=ibmMvsAtmLecInterfaceState, ibmMvsAtmOsasfPortMacAddrActive=ibmMvsAtmOsasfPortMacAddrActive, ibmMvsTcpOutWinUpdates=ibmMvsTcpOutWinUpdates, ibmMvsTcpListenerMaxBacklog=ibmMvsTcpListenerMaxBacklog, ibmMvsOsaExpChannelSubType=ibmMvsOsaExpChannelSubType, ibmTCPIPmvsAtmSupportGroup4=ibmTCPIPmvsAtmSupportGroup4, ibmMvsTcpKeepAliveTimer=ibmMvsTcpKeepAliveTimer, ibmMvsOsaExpEthPortGroupMacAddrs=ibmMvsOsaExpEthPortGroupMacAddrs, ibmMvsTcpConnUsrSndNxt=ibmMvsTcpConnUsrSndNxt, ibmMvsTcpConnOptions=ibmMvsTcpConnOptions, ibmMvsUdpSendBufferSize=ibmMvsUdpSendBufferSize, ibmMvsRPingHostAddress=ibmMvsRPingHostAddress, ibmMvsGatewayMinimumRetransmitTime=ibmMvsGatewayMinimumRetransmitTime, ibmMvsTcpConnSndWl1=ibmMvsTcpConnSndWl1, ibmMvsAtmLecFlushTimeout=ibmMvsAtmLecFlushTimeout, ibmMvsTcpipSubagentColdStart=ibmMvsTcpipSubagentColdStart, ibmTCPIPmvsSystemGroup7=ibmTCPIPmvsSystemGroup7, ibmMvsPathMtuDscEnabled=ibmMvsPathMtuDscEnabled, ibmMvsAtmLecConfigTable=ibmMvsAtmLecConfigTable, ibmMvsAtmLecSvcFailures=ibmMvsAtmLecSvcFailures, ibmTCPIPmvsAtmSupportGroup3=ibmTCPIPmvsAtmSupportGroup3, ibmMvsTcpListenerCurrBacklog=ibmMvsTcpListenerCurrBacklog, ibmMvsTcpSendBufferSize=ibmMvsTcpSendBufferSize, ibmMvsAtmOsasfPortMediaType=ibmMvsAtmOsasfPortMediaType, ibmMvsTcpConnIncomingPush=ibmMvsTcpConnIncomingPush, ibmMvsTcpConnReXmt=ibmMvsTcpConnReXmt, ibmMvsTcpConnServerResourceId=ibmMvsTcpConnServerResourceId, ibmMvsUdpRecvLim=ibmMvsUdpRecvLim, ibmTCPIPmvsSystemGroup4=ibmTCPIPmvsSystemGroup4, ibmMvsAtmLecControlDirectVCI=ibmMvsAtmLecControlDirectVCI, ibmMvsLinkArpSupport=ibmMvsLinkArpSupport, ibmMvsTcpPMTURxmts=ibmMvsTcpPMTURxmts, ibmMvsTcpInAllAfterWin=ibmMvsTcpInAllAfterWin, TypeOfService=TypeOfService, ibmMvsDeviceType=ibmMvsDeviceType, ibmTCPIPmvsMIB=ibmTCPIPmvsMIB, ibmMvsPortNumberLow=ibmMvsPortNumberLow, ibmMvsAtmLecMulticastSendAvgRate=ibmMvsAtmLecMulticastSendAvgRate, osasfPvcTable=osasfPvcTable, ibmMvsAtmOsasfPvcBestEffort=ibmMvsAtmOsasfPvcBestEffort, ibmMvsGatewayVarianceMultiplier=ibmMvsGatewayVarianceMultiplier, ibmMvsTcpConnTcpSel=ibmMvsTcpConnTcpSel, ibmMvsDevRetryDuration=ibmMvsDevRetryDuration, ibmMvsUdpDSField=ibmMvsUdpDSField, ibmMvsOsaExpChannelNumber=ibmMvsOsaExpChannelNumber, ibmMvsTcpKeepAliveProbes=ibmMvsTcpKeepAliveProbes, ibmMvsTcpConnMaxSndWnd=ibmMvsTcpConnMaxSndWnd, ibmMvsAtmLecAgingTime=ibmMvsAtmLecAgingTime, ibmTcpipMvsTcpGroup=ibmTcpipMvsTcpGroup, ibmTCPIPmvsAtmSupportGroup=ibmTCPIPmvsAtmSupportGroup, ibmTcpipMvsPortTable=ibmTcpipMvsPortTable, ibmMvsAtmOsasfPortMaxPcmConnections=ibmMvsAtmOsasfPortMaxPcmConnections, ibmMvsAtmSnaLeCrsGroupAddress=ibmMvsAtmSnaLeCrsGroupAddress, ibmMvsTcpConnDupacks=ibmMvsTcpConnDupacks, ibmMvsOsaExpChannelCodeLevel=ibmMvsOsaExpChannelCodeLevel, ibmMvsTcpConnSndWnd=ibmMvsTcpConnSndWnd, ibmMvsOsaExpPerfInKbytesRate5Min=ibmMvsOsaExpPerfInKbytesRate5Min, ibmMvsAtmLecMulticastFwdVCI=ibmMvsAtmLecMulticastFwdVCI, ibmMvsAtmLecActualLanName=ibmMvsAtmLecActualLanName, ibmMvsDVIPAConnRemPort=ibmMvsDVIPAConnRemPort, ibmTCPIPmvsObsoleteGroup=ibmTCPIPmvsObsoleteGroup, osasfChannelTable=osasfChannelTable, ibmMvsSendGarbageEnabled=ibmMvsSendGarbageEnabled, ibmMvsUdpChecksum=ibmMvsUdpChecksum, ibmMvsUdpBytesIn=ibmMvsUdpBytesIn, ibmRemotePingEntry=ibmRemotePingEntry, ibmMvsTcpConnClusterConnFlag=ibmMvsTcpConnClusterConnFlag)
mibBuilder.exportSymbols("IBMTCPIPMVS-MIB", ibmMvsTcpConnSendWindowAck=ibmMvsTcpConnSendWindowAck, ibmTCPIPmvsUdpGroup=ibmTCPIPmvsUdpGroup, ibmMvsTcpConnResourceId=ibmMvsTcpConnResourceId, ibmMvsDVIPAOrigin=ibmMvsDVIPAOrigin, ibmMvsAtmLecMacAddressEntry=ibmMvsAtmLecMacAddressEntry, ibmMvsLinkNumber=ibmMvsLinkNumber, ibmMvsAtmLecPrimaryAtmAddress=ibmMvsAtmLecPrimaryAtmAddress, ibmMvsAtmOsasfPvcFwdCellBurstSize=ibmMvsAtmOsasfPvcFwdCellBurstSize, ibmMvsAtmOsasfPvcBwdMaxAal5PduSize=ibmMvsAtmOsasfPvcBwdMaxAal5PduSize, ibmMvsAtmSnaLeTrSessionDelay=ibmMvsAtmSnaLeTrSessionDelay, ibmMvsTcpListenerRemoteAddr=ibmMvsTcpListenerRemoteAddr, ibmMvsDVIPADistPortWlmWeight=ibmMvsDVIPADistPortWlmWeight, ibmMvsAtmLecPortName=ibmMvsAtmLecPortName, ibmMvsAtmOsasfChannelCurLparNum=ibmMvsAtmOsasfChannelCurLparNum, ibmMvsAtmLecMulticastSendInterface=ibmMvsAtmLecMulticastSendInterface, ibmMvsTcpConnSSThresh=ibmMvsTcpConnSSThresh, ibmMvsAtmLecStatisticsTable=ibmMvsAtmLecStatisticsTable, ibmMvsAtmLecConfigLanName=ibmMvsAtmLecConfigLanName, ibmMvsTcpConnLastActivity=ibmMvsTcpConnLastActivity, ibmMvsOsaExpPerfProcessorUtil1Min=ibmMvsOsaExpPerfProcessorUtil1Min, ibmMvsDeviceIoBufferSize=ibmMvsDeviceIoBufferSize, ibmMvsOsaExpEthSnaInactTimer=ibmMvsOsaExpEthSnaInactTimer, ibmMvsUdpMcastLinkAddr=ibmMvsUdpMcastLinkAddr, ibmMvsTcpPredictAck=ibmMvsTcpPredictAck, ibmMvsOsaExpPerfInKbytesRate1Min=ibmMvsOsaExpPerfInKbytesRate1Min, ibmMvsDVIPAServMgrMulticastIpAddrType=ibmMvsDVIPAServMgrMulticastIpAddrType, ibmMvsPortSAFResource=ibmMvsPortSAFResource, ibmMvsAtmOsasfChannelTime=ibmMvsAtmOsasfChannelTime, ibmMvsTcpConnOptMaxSegmentSize=ibmMvsTcpConnOptMaxSegmentSize, ibmTcpipMvsUdpMcastRecvTable=ibmTcpipMvsUdpMcastRecvTable, ibmMvsUdpResourceName=ibmMvsUdpResourceName, ibmMvsOsaExpChannelPCIBusUtilHour=ibmMvsOsaExpChannelPCIBusUtilHour, ibmMvsDVIPAEntry=ibmMvsDVIPAEntry, osaexpEthSnaTable=osaexpEthSnaTable, ibmMvsAtmLecVccTimeoutPeriod=ibmMvsAtmLecVccTimeoutPeriod, ibmTcpipMvsTcpListenerEntry=ibmTcpipMvsTcpListenerEntry, ibmMvsAtmOsasfPortAAL5InPackets=ibmMvsAtmOsasfPortAAL5InPackets, ibmTcpipMvsLinkTable=ibmTcpipMvsLinkTable, ibmMvsTcpKeepAliveDrops=ibmMvsTcpKeepAliveDrops, ibmMvsIpInDiscardsMemory=ibmMvsIpInDiscardsMemory, ibmMvsTcpOutWinProbes=ibmMvsTcpOutWinProbes, ibmMvsVarianceGain=ibmMvsVarianceGain, ibmMvsGatewayVarianceGain=ibmMvsGatewayVarianceGain, ibmMvsAtmLecForwardDelayTime=ibmMvsAtmLecForwardDelayTime, ibmTCPIPmvsUdpGroup2=ibmTCPIPmvsUdpGroup2, mvsSNMPagent=mvsSNMPagent, ibmMvsOsasfHostName=ibmMvsOsasfHostName, ibmMvsRPingResponseTime=ibmMvsRPingResponseTime, ibmTCPIPmvsTcpGroup=ibmTCPIPmvsTcpGroup, ibmMvsDVIPARangeConfTable=ibmMvsDVIPARangeConfTable, ibmTCPIPmvsAtmLeGroup=ibmTCPIPmvsAtmLeGroup, ibmMvsIplDateAndTime=ibmMvsIplDateAndTime, ibmMvsAtmOsasfPvcBwdsustainCellRate=ibmMvsAtmOsasfPvcBwdsustainCellRate, ibmMvsAtmLecMaxRetryCount=ibmMvsAtmLecMaxRetryCount, ibmMvsAtmLecVersion=ibmMvsAtmLecVersion, ibmMvsPrimaryInterfaceIfIndex=ibmMvsPrimaryInterfaceIfIndex, ibmMvsAtmOsasfPortIpAddress=ibmMvsAtmOsasfPortIpAddress, ibmMvsTcpConnBytesIn=ibmMvsTcpConnBytesIn, ibmMvsAtmOsasfPortUniVersion=ibmMvsAtmOsasfPortUniVersion, ibmMvsOsasfSysplexName=ibmMvsOsasfSysplexName, ibmMvsAtmLecActualLanType=ibmMvsAtmLecActualLanType, ibmMvsTcpConnTimeStamp=ibmMvsTcpConnTimeStamp, ibmTcpipMvsLinkEntry=ibmTcpipMvsLinkEntry, ibmMvsArpCacheTimeout=ibmMvsArpCacheTimeout, ibmMvsUdpMcastTTL=ibmMvsUdpMcastTTL, ibmMvsPortProcName=ibmMvsPortProcName, ibmTCPIPmvsInterfacesGroup5=ibmTCPIPmvsInterfacesGroup5, ibmMvsAtmLecControlFramesOut=ibmMvsAtmLecControlFramesOut, ibmTCPIPmvsTcpGroup5=ibmTCPIPmvsTcpGroup5, ibmMvsUdpLastAct=ibmMvsUdpLastAct, ibmMvsAtmSnaLeMaxLECConnections=ibmMvsAtmSnaLeMaxLECConnections, ibmMvsOsaExpEthPortActiveSpeed=ibmMvsOsaExpEthPortActiveSpeed, ibmMvsTcpListenerRemotePort=ibmMvsTcpListenerRemotePort, ibmMvsAtmLecServerEntry=ibmMvsAtmLecServerEntry, ibmMvsAtmLecID=ibmMvsAtmLecID, ibmMvsUdpDgramOut=ibmMvsUdpDgramOut, ibmMvsTcpPMTUErrors=ibmMvsTcpPMTUErrors, ibmMvsDVIPAConnDynXcfIpAddrType=ibmMvsDVIPAConnDynXcfIpAddrType, ibmMvsTcpInDupAck=ibmMvsTcpInDupAck, ibmMvsDVIPARangeConfEntry=ibmMvsDVIPARangeConfEntry, ibmMvsUdpDgramIn=ibmMvsUdpDgramIn, ibmMvsGatewayDelayAcks=ibmMvsGatewayDelayAcks, ibmMvsTcpConnExceedBacklog=ibmMvsTcpConnExceedBacklog, ibmMvsTcpListenerLocalAddrType=ibmMvsTcpListenerLocalAddrType, ibmMvsOsaExpChannelPCIBusUtil1Min=ibmMvsOsaExpChannelPCIBusUtil1Min, ibmMvsDVIPADistConfStatus=ibmMvsDVIPADistConfStatus, ibmMvsDVIPADistPortEntry=ibmMvsDVIPADistPortEntry, ibmMvsIpInDevLayerCalls=ibmMvsIpInDevLayerCalls, osaexpEthPortTable=osaexpEthPortTable, ibmTcpipMvsRouteGroup=ibmTcpipMvsRouteGroup, ibmMvsTcpInWinProbes=ibmMvsTcpInWinProbes, ibmMvsAtmOsasfPortNumber=ibmMvsAtmOsasfPortNumber, ibmMvsAtmLecArpRepliesIn=ibmMvsAtmLecArpRepliesIn, ibmMvsOsaExpPerfOutKbytesRateHour=ibmMvsOsaExpPerfOutKbytesRateHour, ibmMvsTcpConnInitSndSeq=ibmMvsTcpConnInitSndSeq, ibmMvsAtmLecProtocol=ibmMvsAtmLecProtocol, ibmMvsIpOutDiscardsMemory=ibmMvsIpOutDiscardsMemory, ibmMvsAtmLecArpRepliesOut=ibmMvsAtmLecArpRepliesOut, ibmMvsTcpipSubagentVersion=ibmMvsTcpipSubagentVersion, ibmMvsAtmLecArpRequestsIn=ibmMvsAtmLecArpRequestsIn, ibmMvsTcpConnSendMSS=ibmMvsTcpConnSendMSS, ibmMvsAtmLecMaxUnknownFrameCount=ibmMvsAtmLecMaxUnknownFrameCount, ibmMvsAtmOsasfPortType=ibmMvsAtmOsasfPortType, ibmTCPIPmvsTcpGroup3=ibmTCPIPmvsTcpGroup3, ibmMvsOsaExpPerfOutKbytesRate1Min=ibmMvsOsaExpPerfOutKbytesRate1Min, ibmMvsDVIPATrapControl=ibmMvsDVIPATrapControl, ibmTCPIPmvsTcpGroup2=ibmTCPIPmvsTcpGroup2, ibmMvsDVIPARangeConfMaskAddr=ibmMvsDVIPARangeConfMaskAddr, ibmMvsTcpReceiveBufferSize=ibmMvsTcpReceiveBufferSize, ibmMvsAtmSnaleMaxIn=ibmMvsAtmSnaleMaxIn, ibmTCPIPmvsAdmin=ibmTCPIPmvsAdmin, ibmMvsDVIPADistConfTable=ibmMvsDVIPADistConfTable, ibmMvsDVIPAServMgrEnabled=ibmMvsDVIPAServMgrEnabled, ibmTCPIPmvsConformance=ibmTCPIPmvsConformance, ibmMvsAtmLecMulticastSendVPI=ibmMvsAtmLecMulticastSendVPI, ibmMvsPortOptMaxSegmentSize=ibmMvsPortOptMaxSegmentSize, ibmTCPIPmvsTcpGroup6=ibmTCPIPmvsTcpGroup6, ibmMvsLinkMcast=ibmMvsLinkMcast, ibmMvsGatewayRoundTripGain=ibmMvsGatewayRoundTripGain, ibmMvsAtmLecConfigServerAtmAddress=ibmMvsAtmLecConfigServerAtmAddress, ibmMvsLinkType=ibmMvsLinkType, ibmMvsAtmOsasfPvcFwdsustainCellRate=ibmMvsAtmOsasfPvcFwdsustainCellRate, ibmMvsTcpConnSndBufSize=ibmMvsTcpConnSndBufSize, ibmMvsAtmLecMulticastFwdInterface=ibmMvsAtmLecMulticastFwdInterface, ibmMvsDVIPAConnRemIpAddrType=ibmMvsDVIPAConnRemIpAddrType, ibmMvsTcpConnTcpPol=ibmMvsTcpConnTcpPol, ibmMvsTcpConnLogMode=ibmMvsTcpConnLogMode, ibmMvsDVIPAStatusChange=ibmMvsDVIPAStatusChange, ibmMvsOsaExpEthPortServiceMode=ibmMvsOsaExpEthPortServiceMode, ibmMvsAtmLecActualMaxDataFrameSize=ibmMvsAtmLecActualMaxDataFrameSize, ibmMvsPortBindIpAddr=ibmMvsPortBindIpAddr, ibmMvsAtmOsasfPvcFwdPeakCellRate=ibmMvsAtmOsasfPvcFwdPeakCellRate, ibmMvsTcpConnOutBuffered=ibmMvsTcpConnOutBuffered, ibmTcpipMvsUdpGroup=ibmTcpipMvsUdpGroup, ibmMvsMaximumRetransmitTime=ibmMvsMaximumRetransmitTime, ibmTCPIPmvsInterfacesGroup4=ibmTCPIPmvsInterfacesGroup4, ibmMvsAtmOsasfChannelCurLparName=ibmMvsAtmOsasfChannelCurLparName, ibmMvsOsaExpEthSnaMaxTransmitWindow=ibmMvsOsaExpEthSnaMaxTransmitWindow, ibmMvsDVIPARangeConfMaskType=ibmMvsDVIPARangeConfMaskType, ibmMvsAtmSnaLeLlcTi=ibmMvsAtmSnaLeLlcTi, ibmTCPIPmvsGroups=ibmTCPIPmvsGroups, ibmMvsRPingTimeOut=ibmMvsRPingTimeOut, ibmMvsTcpConnSndUna=ibmMvsTcpConnSndUna, ibmMvsVarianceMultiplier=ibmMvsVarianceMultiplier, ibmTCPIPmvsAtmSupportGroup2=ibmTCPIPmvsAtmSupportGroup2, ibmMvsOsaExpPerfProcessorUtil5Min=ibmMvsOsaExpPerfProcessorUtil5Min, ibmMvsDVIPAConnDynXcfIpAddr=ibmMvsDVIPAConnDynXcfIpAddr, ibmTCPIPmvsCompliance=ibmTCPIPmvsCompliance, ibmMvsOsaExpPerfOutKbytesRate5Min=ibmMvsOsaExpPerfOutKbytesRate5Min, ibmMvsOsaExpChannelProcessorUtilHour=ibmMvsOsaExpChannelProcessorUtilHour, ibmMvsOsaExpChannelManLparNum=ibmMvsOsaExpChannelManLparNum, ibmMvsTcpConnsClosed=ibmMvsTcpConnsClosed, ibmMvsOsaExpEthPortInUnknownIPFrames=ibmMvsOsaExpEthPortInUnknownIPFrames, ibmMvsDVIPAServMgrPasswordSpecified=ibmMvsDVIPAServMgrPasswordSpecified, ibmTcpipMvsTcpConnTable=ibmTcpipMvsTcpConnTable, ibmTCPIPmvsSystemGroup2=ibmTCPIPmvsSystemGroup2, ibmMvsAtmSnaLeMaxSaps=ibmMvsAtmSnaLeMaxSaps, ibmMvsOsaExpChannelControlUnitNumber=ibmMvsOsaExpChannelControlUnitNumber, ibmMvsAtmLecControlTimeout=ibmMvsAtmLecControlTimeout, ibmMvsAtmSnaLeTrEnableLoadBalancing=ibmMvsAtmSnaLeTrEnableLoadBalancing, ibmMvsTcpConnRoundTripTime=ibmMvsTcpConnRoundTripTime, ibmMvsTcpPredictData=ibmMvsTcpPredictData, ibmMvsOsaExpEthPortUserData=ibmMvsOsaExpEthPortUserData, ibmMvsOsaExpEthPortName=ibmMvsOsaExpEthPortName, ibmMvsAtmOsasfChannelManParnName=ibmMvsAtmOsasfChannelManParnName, ibmMvsAtmOsasfChannelNumber=ibmMvsAtmOsasfChannelNumber, ibmMvsTcpConnSubtask=ibmMvsTcpConnSubtask, ibmMvsTcpConnDSField=ibmMvsTcpConnDSField, ibmMvsAtmLecConfigDirectVPI=ibmMvsAtmLecConfigDirectVPI, ibmMvsDVIPADistPortTotalConn=ibmMvsDVIPADistPortTotalConn, ibmMvsTcpInSomeBeforeWin=ibmMvsTcpInSomeBeforeWin, ibmMvsTcpConnRcvNxt=ibmMvsTcpConnRcvNxt, ibmMvsTcpConnOutgoingWinSeq=ibmMvsTcpConnOutgoingWinSeq, ibmTcpipMvsTcpListenerTable=ibmTcpipMvsTcpListenerTable, ibmMvsDVIPADistConfPort=ibmMvsDVIPADistConfPort, ibmMvsUdpSubtask=ibmMvsUdpSubtask, ibmMvsAtmLecStatusEntry=ibmMvsAtmLecStatusEntry, ibmMvsAtmLecArpRequestsOut=ibmMvsAtmLecArpRequestsOut, ibmMvsTcpConnWindowScale=ibmMvsTcpConnWindowScale, ibmMvsAtmOsasfPortPcmName=ibmMvsAtmOsasfPortPcmName, ibmMvsAtmLecConfigLanType=ibmMvsAtmLecConfigLanType, ibmMvsAtmLecProxyClient=ibmMvsAtmLecProxyClient, osaexpPerfTable=osaexpPerfTable, ibmMvsLinkMacAddress=ibmMvsLinkMacAddress, ibmSNMPRemPing=ibmSNMPRemPing, ibm=ibm, ibmMvsAtmLecConfigDirectInterface=ibmMvsAtmLecConfigDirectInterface, ibmMvsTcpInBadSum=ibmMvsTcpInBadSum, ibmMvsIpForwarding=ibmMvsIpForwarding, ibmMvsDVIPADistPortTargetDynXcfIpAddr=ibmMvsDVIPADistPortTargetDynXcfIpAddr, ibmMvsLinkAdapterAddr=ibmMvsLinkAdapterAddr, ibmMvsAtmOsasfPortAAL5OutPackets=ibmMvsAtmOsasfPortAAL5OutPackets, ibmMvsRoundTripGain=ibmMvsRoundTripGain, osasfPortEntry=osasfPortEntry, ibmMvsAtmLecConnectionCompleteTimer=ibmMvsAtmLecConnectionCompleteTimer, ibmMvsTcpConnSndNxt=ibmMvsTcpConnSndNxt, ibmAgentCaps=ibmAgentCaps, ibmMvsAtmLecMulticastSendPeakRate=ibmMvsAtmLecMulticastSendPeakRate, ibmMvsAtmSnaLeLlcT1=ibmMvsAtmSnaLeLlcT1, ibmMvsTcpInAllBeforeWin=ibmMvsTcpInAllBeforeWin, ibmMvsAtmOsasfPortCodeLoadStatus=ibmMvsAtmOsasfPortCodeLoadStatus, ibmMvsTcpConnAcceptCount=ibmMvsTcpConnAcceptCount, ibmMvsTcpConnIpTos=ibmMvsTcpConnIpTos, ibmMvsOsaExpChannelShared=ibmMvsOsaExpChannelShared, ibmMvsDeviceReadSize=ibmMvsDeviceReadSize, ibmTcpipMvsDeviceTable=ibmTcpipMvsDeviceTable, ibmMvsRPingPacketSize=ibmMvsRPingPacketSize, ibmMvsOsaExpChannelCurLparName=ibmMvsOsaExpChannelCurLparName, ibmMvsTcpConnRcvBufSize=ibmMvsTcpConnRcvBufSize, ibmMvsMultipathEnabled=ibmMvsMultipathEnabled, ibmProd=ibmProd, ibmTCPIPmvsIpGroup=ibmTCPIPmvsIpGroup, ibmTcpipMvsGatewayTable=ibmTcpipMvsGatewayTable, ibmMvsDeviceBaseNumber=ibmMvsDeviceBaseNumber, ibmMvsLinkDeviceIndex=ibmMvsLinkDeviceIndex, ibmMvsTcpMaxReceiveBufferSize=ibmMvsTcpMaxReceiveBufferSize, PYSNMP_MODULE_ID=ibmTCPIPmvsMIB, ibmMvsAtmLecMacAddressTable=ibmMvsAtmLecMacAddressTable, ibmTCPIPmvsSystemGroup5=ibmTCPIPmvsSystemGroup5, ibmMvsDeviceConfigPackingMode=ibmMvsDeviceConfigPackingMode, ibmMvsOsaExpChannelPCIBusUtil5Min=ibmMvsOsaExpChannelPCIBusUtil5Min, ibmMvsAtmLecControlDistributeVCI=ibmMvsAtmLecControlDistributeVCI, ibmMvsAtmOsasfAtmPvcCreate=ibmMvsAtmOsasfAtmPvcCreate, ibmMvsAtmSnaLeBestEffortPeakRate=ibmMvsAtmSnaLeBestEffortPeakRate, ibmTCPIPmvsSystemGroup3=ibmTCPIPmvsSystemGroup3, ibmMvsTcpFinwait2Time=ibmMvsTcpFinwait2Time, ibmMvsDVIPADistConfTargetDynXcfIpAddrType=ibmMvsDVIPADistConfTargetDynXcfIpAddrType, ibmMvsNoUdpQueueLimit=ibmMvsNoUdpQueueLimit, ibmMvsOsaExpEthPortType=ibmMvsOsaExpEthPortType, osaexpEthSnaEntry=osaexpEthSnaEntry, ibmMvsDVIPATargetAdded=ibmMvsDVIPATargetAdded, ibmMvsAtmOsasfChannelManParnNum=ibmMvsAtmOsasfChannelManParnNum, ibmMvsDVIPADistributeStatus=ibmMvsDVIPADistributeStatus, ibmMvsTcpConnOutgoingPush=ibmMvsTcpConnOutgoingPush, DeviceLinkTypes=DeviceLinkTypes, ibmRemotePingTable=ibmRemotePingTable, ibmMvsTcpInAfterClose=ibmMvsTcpInAfterClose, ibmMvsTcpConnResourceName=ibmMvsTcpConnResourceName, ibmMvsDVIPADistPortPort=ibmMvsDVIPADistPortPort, ibmMvsAtmLecConfigSource=ibmMvsAtmLecConfigSource, ibmMvsDeviceActualPackingMode=ibmMvsDeviceActualPackingMode, ibmMvsMinimumRetransmitTime=ibmMvsMinimumRetransmitTime, ibmMvsAtmOsasfChannelDeterNodeDesc=ibmMvsAtmOsasfChannelDeterNodeDesc, ibmMvsUdpMcastRecvLocalAddress=ibmMvsUdpMcastRecvLocalAddress, ibmMvsUdpMcastRecvGroup=ibmMvsUdpMcastRecvGroup, ibmMvsTcpInSomeAfterWin=ibmMvsTcpInSomeAfterWin, ibmMvsTcpListenerLocalAddr=ibmMvsTcpListenerLocalAddr, ibmMvsTcpConnUsrRcvNxt=ibmMvsTcpConnUsrRcvNxt, ibmMvsTcpConnTcpSig=ibmMvsTcpConnTcpSig, ibmMvsTcpRestrictLowPorts=ibmMvsTcpRestrictLowPorts, ibmMvsAtmSnaLeUserData=ibmMvsAtmSnaLeUserData, ibmMvsDVIPADistPortReadyCount=ibmMvsDVIPADistPortReadyCount, ibmMvsTcpListenerAcceptCount=ibmMvsTcpListenerAcceptCount, ibmMvsOsaExpChannelState=ibmMvsOsaExpChannelState)
mibBuilder.exportSymbols("IBMTCPIPMVS-MIB", ibmMvsTcpConnProto=ibmMvsTcpConnProto, ibmMvsTcpConnInSegs=ibmMvsTcpConnInSegs, osasfPvcEntry=osasfPvcEntry, ibmMvsAtmLecControlDirectVPI=ibmMvsAtmLecControlDirectVPI, ibmMvsAtmOsasfPvcVci=ibmMvsAtmOsasfPvcVci, ibmMvsDVIPATable=ibmMvsDVIPATable, ibmMvsAtmLecMaxUnknownFrameTime=ibmMvsAtmLecMaxUnknownFrameTime, ibmMvsDVIPADistConfIpAddrType=ibmMvsDVIPADistConfIpAddrType, ibmTCPIPmvsPortGroup2=ibmTCPIPmvsPortGroup2, ibmMvsDVIPAMaskType=ibmMvsDVIPAMaskType, ibmTcpipMvsOsaExpGroup=ibmTcpipMvsOsaExpGroup, osaexpChannelTable=osaexpChannelTable, ibmMvsDVIPATargetServerEnded=ibmMvsDVIPATargetServerEnded, ibmMvsOsaExpEthPortConfigName=ibmMvsOsaExpEthPortConfigName, ibmMvsDVIPARank=ibmMvsDVIPARank, ibmMvsAtmLecStatisticsEntry=ibmMvsAtmLecStatisticsEntry, ibmMvsAtmSnaLeEntry=ibmMvsAtmSnaLeEntry, ibmMvsAtmOsasfPortNetPrefixPrefix=ibmMvsAtmOsasfPortNetPrefixPrefix, ibmMvsUdpTos=ibmMvsUdpTos, ibmMvsAtmOsasfChannelShared=ibmMvsAtmOsasfChannelShared, ibmMvsAtmLecLastFailureRespCode=ibmMvsAtmLecLastFailureRespCode, ibmTcpipMvsAtmGroup=ibmTcpipMvsAtmGroup, ibmMvsDVIPAMaskAddr=ibmMvsDVIPAMaskAddr, ibmMvsUdpEntryState=ibmMvsUdpEntryState, ibmMvsDVIPAStatus=ibmMvsDVIPAStatus, ibmMvsTcpListenerResourceId=ibmMvsTcpListenerResourceId, ibmMvsTcpListenerExceedBacklog=ibmMvsTcpListenerExceedBacklog, ibmMvsOsaExpEthPortInPackets=ibmMvsOsaExpEthPortInPackets, ibmMvsDeviceWriteSize=ibmMvsDeviceWriteSize, ibmMvsAtmOsasfChannelType=ibmMvsAtmOsasfChannelType, ibmMvsIpMaxReassemblySize=ibmMvsIpMaxReassemblySize, ibmMvsLinkIbmtrBcast=ibmMvsLinkIbmtrBcast, osasfChannelEntry=osasfChannelEntry, ibmMvsTcpConnCongestionWnd=ibmMvsTcpConnCongestionWnd, ibmMvsDVIPADistConfTargetDynXcfIpAddr=ibmMvsDVIPADistConfTargetDynXcfIpAddr, ibmMvsTcpInShort=ibmMvsTcpInShort, ibmMvsTcpConnMaxBacklog=ibmMvsTcpConnMaxBacklog, ibmMvsDVIPARangeConfMoveable=ibmMvsDVIPARangeConfMoveable, ibmMvsTcpipAsid=ibmMvsTcpipAsid, ibmMvsDeviceNetmanEnabled=ibmMvsDeviceNetmanEnabled, ibmMvsTcpTimeStamp=ibmMvsTcpTimeStamp, ibmMvsDeviceWriteBuffers=ibmMvsDeviceWriteBuffers, ibmTcpipMvsGatewayEntry=ibmTcpipMvsGatewayEntry, ibmTCPIPmvsDVIPAGroup=ibmTCPIPmvsDVIPAGroup, ibmMvsAtmLecMulticastSendType=ibmMvsAtmLecMulticastSendType, ibmMvsAtmOsasfChannelEcLevel=ibmMvsAtmOsasfChannelEcLevel, ibmMvsTcpRxmtDrops=ibmMvsTcpRxmtDrops, ibmMvsTcpConnCurrBacklog=ibmMvsTcpConnCurrBacklog, osaexpChannelEntry=osaexpChannelEntry, ibmMvsTcpPassiveDrops=ibmMvsTcpPassiveDrops, ibmMvsMultipathType=ibmMvsMultipathType, ibmTCPIPmvsRoutingGroup=ibmTCPIPmvsRoutingGroup, ibmMvsAtmLecServerTable=ibmMvsAtmLecServerTable, ibmMvsSubagentCacheTime=ibmMvsSubagentCacheTime, ibmMvsTcpConnBytesOut=ibmMvsTcpConnBytesOut, ibmMvsIpOutDiscardsDlcAsynch=ibmMvsIpOutDiscardsDlcAsynch, ibmMvsAtmSnaLeLlcT2=ibmMvsAtmSnaLeLlcT2, ibmMvsAtmOsasfPvcName=ibmMvsAtmOsasfPvcName, ibmTCPIPmvsDVIPANotificationGroup=ibmTCPIPmvsDVIPANotificationGroup, ibmMvsTcpTimeWaitReused=ibmMvsTcpTimeWaitReused, ibmTCPIPmvsInterfacesGroup=ibmTCPIPmvsInterfacesGroup, ibmMvsTcpConnSockOpt=ibmMvsTcpConnSockOpt, ibmTcpipMvsLinkMcastEntry=ibmTcpipMvsLinkMcastEntry, ibmMvsAtmLecControlFramesIn=ibmMvsAtmLecControlFramesIn)

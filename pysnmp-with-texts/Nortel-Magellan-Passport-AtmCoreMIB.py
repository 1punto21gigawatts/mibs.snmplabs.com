#
# PySNMP MIB module Nortel-Magellan-Passport-AtmCoreMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-AtmCoreMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:26:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
Counter32, RowStatus, DisplayString, Gauge32, PassportCounter64, Unsigned32, Integer32, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "Counter32", "RowStatus", "DisplayString", "Gauge32", "PassportCounter64", "Unsigned32", "Integer32", "StorageType")
Hex, AsciiStringIndex, Link, IntegerSequence, AsciiString, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "Hex", "AsciiStringIndex", "Link", "IntegerSequence", "AsciiString", "NonReplicated")
passportMIBs, components = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs", "components")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, ModuleIdentity, IpAddress, MibIdentifier, NotificationType, Gauge32, iso, Unsigned32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, Integer32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "IpAddress", "MibIdentifier", "NotificationType", "Gauge32", "iso", "Unsigned32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "Integer32", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
atmCoreMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123))
atmIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114))
atmIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1), )
if mibBuilder.loadTexts: atmIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRowStatusTable.setDescription('This entry controls the addition and deletion of atmIf components.')
atmIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRowStatusEntry.setDescription('A single entry in the table represents a single atmIf component.')
atmIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIf components. These components can be added and deleted.')
atmIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStorageType.setDescription('This variable represents the storage type value for the atmIf tables.')
atmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)))
if mibBuilder.loadTexts: atmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfIndex.setDescription('This variable represents the index for the atmIf tables.')
atmIfCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 100), )
if mibBuilder.loadTexts: atmIfCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
atmIfCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCidDataEntry.setDescription('An entry in the atmIfCidDataTable.')
atmIfCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
atmIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110), )
if mibBuilder.loadTexts: atmIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfProvTable.setDescription('This group contains provisionable attributes for the AtmIf component.')
atmIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfProvEntry.setDescription('An entry in the atmIfProvTable.')
atmIfInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 10), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfInterfaceName.setDescription('This attribute associates the AtmIf component with a specific interface on a Function Processorfor example, Lp/1 Ds3/0. This implicitly defines the logical processor on which the AtmIf is activated.')
atmIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("uni", 0), ("ppi", 1))).clone('uni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfType.setDescription('This attribute indicates the type of AtmIf, either uni or ppi. These types differ only in their handling of OAM cellsall connections passing through a uni interface terminate segment loopback cells; whereas a ppi interface permits these cells to be passed transparently. This is obsoleted. The value is migrated into oamSegmentBoundary. uni maps to yes. ppi maps to no.')
atmIfOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOamSegmentBoundary.setDescription('This attribute specifies whether the interface is on an OAM segment boundary. When yes is selected, the interface is on an OAM segment boundary and all connections passing through the interface terminate OAM segment cells. When no is selected, the interface is not on an OAM segment boundary and the interface permits the segment cells to be passed transparently.')
atmIfMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfMaxVpcs.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfMaxVpcs.setDescription("This attribute specifies the maximum number of VPCs that can be configured on this AtmIf. The value must not exceed the total number of usable VPCs supported by this AtmIf (which is equal to 256 or (256 - (number of VPIs used for VCCs)), according to the ConnectionMapping component). Furthermore, if the AtmIf is linked to an LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + 1) across all AtmIf linked to that Lp must be less than or equal to the totalConnectionPoolCapacity attribute of the Arc component. If the Arc component doesn't exist, the default value of totalConnectionPoolCapacity is used as the limit. This attribute has been migrated to the Ca component.")
atmIfMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfMaxVccs.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfMaxVccs.setDescription("This attribute specifies the maximum number of usable VCCs that can be configured on this AtmIf. The value must not exceed the number of non-reserved VCC identifiers in the Vcc space supported by this AtmIf (which is specified by the ConnectionMapping component). Furthermore, if the AtmIf is linked to an LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + 1) across all AtmIf linked to that Lp must be less than the totalConnectionPoolCapacity attribute of the Arc component. If the Arc component doesn't exist, the default value of totalConnectionPoolCapacity is used as the limit. This attribute has been migrated to the Ca component.")
atmIfTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfTrafficShaping.setDescription('It is migrated in P6.0 to a combination of the trafficShaping attributes and the emissionPriority attributes under each ATM service category component of the AtmIf CA. This attribute defines whether traffic shaping is enabled or disabled for the entire AtmIf. When this attribute is set to enabled, each provisioned connection under the interface can be individually provisioned to permit or prohibit traffic shaping. When this attribute is set to disabled, no traffic shaping is performed on the transmit path for any of the connections. This attribute may be set to enabled if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl component. If the AtmResourceControl component does not exist, this attribute may not be set to enabled.')
atmIfUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfUnshapedTransmitQueueing.setDescription('It is migrated in P6.0 to the attributes of the same name under each ATM service category component of the AtmIf CA. This attribute applies only for unshaped VCC and VPC connections. This attribute defines the transmit queueing method for all unshaped connections under this AtmIf. Per-VC queueing means that unshaped connections are treated with the same fairness as shaped queues in the transmit round-robin scheduling. The alternative to per-VC queueing is to use the common queue for a particular service category (medium or low priority). The common queue is only counted as one queue in the transmit round-robin scheduling. Thus, if there are multiple connections which are destined for the common queue, they are not fairly allocated a portion of the transmit bandwidth compared to shaped connections. When this attribute is set to perVc, any unshaped connection is allocated its own per-VC queue, and is treated with the same fairness as any shaped connections. Per-VC queues have a maximum rate of 58,962 cell/s (25 Mbit/s) in a multi-port shaping configuration. Per-VC queues also have their own congestion control level. This means that total number of cell/frame blocks allocated for several per-VC queues are higher than would be allowed on the common queue. This can be an advantage in reducing cell loss due to queue congestion. This attribute may only be set to perVc if the interface supports per-VC queueing, (specified by the perVcQueueInterfaces attribute in the AtmResourceControl component). When this attribute is set to common, any unshaped connection is destined for the common queue. The common queue has one set of congestion control levels for all cells enqueued on it. The common queue is only allocated one queue position when scheduling which queue to transmit from. Due to the possibility of unfairness, this value is only recommended in cases where the configuration cannot otherwise achieve full link utilization. When this attribute is set to autoConfigure and the interface support per-VC queueing (specified by the perVcQueueInterfaces attribute in the AtmResourceControl component) per-VC queueing is enabled for all unshaped connections. Otherwise, the common queue is used. The unshapedTransmitQueueingOper attribute indicates whether the transmit queueing is perVc or common.')
atmIfUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfUsageParameterControl.setDescription('It is migrated in P6.0 to the attributes of the same name under each ATM service category component of the AtmIf CA. This attribute defines whether usage parameter control (UPC) is enabled or disabled for receive traffic for Vcc and Vpc connections for this entire AtmIf. When this attribute is set to enabled, each provisioned connection under the interface can be individually provisioned to enforce or ignore UPC. When this attribute is set to disabled, UPC cannot be enabled on the receive path for any of the connections.')
atmIfMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 85), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), )).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfMaxVpiBits.setDescription('This attribute specifies the maximum number of VPI bits that may be active for this AtmIf. These bits start at the least significant bit position and are contiguous. In general, the maximum VPI which may be used on the interface is 2**maxVpiBits - 1. The value of the remaining (inactive) VPI bits is ignored on cells received from the link. If the AtmIf is linked to a LogicalProcessor of cardType 3pOC3MmAtm, 3pOC3SmAtm, 3pE3Atm, 3pDS3Atm, 3pE1Atm, 3pDS1Atm, or 2pJ6MAtm, the value of this attribute must be 8. The maximum VPI supported on these card types is 255. If the AtmIf is linked to a LogicalProcessor of any other cardType, the value of this attribute may be 8 or 12. The maximum VPI supported on these card types is 4095. An exception is that cardType 8pE1Atm and 8pDS1Atm do not support VPI 4095; the maximum VPI on these card types is 4094. If a Uni or an Iisp component is present directly under the AtmIf, the value of this attribute must be 8.')
atmIfRemoteAtmInterfaceLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 90), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfRemoteAtmInterfaceLabel.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRemoteAtmInterfaceLabel.setDescription("This attribute specifies a unique indication of the remote ATM service or interface component connected to this one. The value of this attribute can be used by network management applications to discover the network's ATM topology from its configuration information. The syntax of the value, such as component ID, address, or other numerical identifier, must follow the conventions of the network management platform. In absence of such convention or platform, the value should be left empty. The value is only stored by the module. It is neither validated nor used to perform any form of remote connectivity validation.")
atmIfTxCellMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 91), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfTxCellMemory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemory.setDescription("This attribute specifies the percentage of total transmit cell memory which is available for use by connections under this AtmIf. This attribute is not applicable, and is ignored for CQC-based ATM FPs. Transmit cell memory is used for storing ATM cells to be transmitted by connections under this AtmIf. It includes all cells in connections at the nrt-VBR or UBR service category. It includes cells in CBR or rt-VBR connections which are doing per-VC queueing. It does not include cells in CBR or rt-VBR connections which are allocated from the dedicated buffer for CBR common queuing or rt-VBR common queuing. If the value of this attribute is specified as 100, connections under this AtmIf may use up to 100% of the total transmit cell memory. If this attribute is specified as an amount less than 100, then only that percentage of the total transmit cell memory may be used by connections under this AtmIf. The minimum value for this attribute is 1% since some cell memory is always required for connections. For 3pDs3Atm2 and 3pE3Atm2 card types, the total cell memory displayed in Lp/x Eng Arc Aqm/0 txCellMemoryThreshold 0 is shared across all three interfaces for the card. Specifying a value of 100% enables complete overbooking of the total transmit cell memory by the three AtmIf's on this card. On a DS3 or E3 card, specifying values for this attribute such that each value is less than 100% but the sum for the three AtmIf's is more than 100% enables partial overbooking of the transmit cell memory. Specifying values for this attribute under the three AtmIf's where the sum of these attributes adds up to exactly 100%, ensures that each AtmIf has a dedicated pool of transmit cells with no overbooking. Specifying values for this attribute under the three AtmIf's where the sum of these attributes adds up to less than 100%, restricts the total size of the free list. This can be used to ensure the functioning of port aggregation even with a small number of connections. For 2pOc3MmAtm2 and 2pOC3SmAtm2 card types, the cell memory displayed in Lp/x Eng Arc Aqm/0 txCellMemoryThreshold 0 is allocated to the first interface for the card. Cell memory displayed in Lp/x Eng Arc Aqm/1 txCellMemoryThreshold 0 is allocated to the second interface for the card. Specifying an amount less than 100% restricts the total size of the free list. This can be used to ensure the functioning of port aggregation even with a small number of connections.")
atmIfFaultHoldOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 110, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 65535))).clone(namedValues=NamedValues(("n0", 0), ("infinity", 65535))).clone('infinity')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfFaultHoldOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfFaultHoldOffTime.setDescription('This attribute specifies the delay before faults detected at the VP layer are propagated to the VC layer, and thus to the application using the connection. If the value is 0 (zero), applications using a VirtualPathTerminator are immediately notified of faults detected by the VP. Using this value allows these applications to be advised of faults without requiring loopbacks on each Vcc. Typically, the application goes out of service when advised of a fault. If the value is infinity, applications are not notified of VP layer faults. Using this value allows the applications to survive transient VP layer fault conditions. The value chosen applies only to Vpts and Vccs directly beneath a Vpt.')
atmIfLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120), )
if mibBuilder.loadTexts: atmIfLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLbkTable.setDescription('This group contains the default loopback attribute values for all Vcc, Vpc and Vpt components. Note that these attribute values can be overridden by setting different values in the Vcd component of the provisioned Vcc or the Vpd component of the provisioned Vpc or Vpt. Certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the AtmStatus group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed.')
atmIfLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLbkEntry.setDescription('An entry in the atmIfLbkTable.')
atmIfSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfSegLinkSideLoopback.setDescription('This attribute specifies the default value for link-side segment loopback insertion for all connections under this interface. Link- side segment loopback is not possible if the oamSegmentBoundary attribute of the AtmIf component is no.')
atmIfSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfSegSwitchSideLoopback.setDescription('This attribute specifies the default value for switch-side segment loopback insertion for all connections under this interface. Switch- side segment loopback is not possible if the oamSegmentBoundary attribute of the AtmIf component is no.')
atmIfEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEndToEndLoopback.setDescription('This attribute specifies the default value for end-to-end loopback insertion for all connections under this interface. End-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is possible if the connectionPointType attribute of the Vcc or Vpc component is connectionEndPoint. End-to-end loopback insertion is always possible on a Vpt component.')
atmIfLoopbackMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 120, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfLoopbackMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLoopbackMonitoring.setDescription("'This attribute specifies the default value for loopback monitoring for all connecting points of this interface. Currently this attribute only applies to Passport specific trace cells. When Passport-specific trace cells are received at connecting points connections under this interface the value of this attribute determines if a response will be generated. This attribute is only applicable to connectingPoint and will be ignored by connectionEndPoints or segmentEndPoints.'")
atmIfStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130), )
if mibBuilder.loadTexts: atmIfStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
atmIfStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStateEntry.setDescription('An entry in the atmIfStateTable.')
atmIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
atmIfOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
atmIfUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
atmIfAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
atmIfProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
atmIfControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
atmIfAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
atmIfStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
atmIfUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 130, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
atmIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140), )
if mibBuilder.loadTexts: atmIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOperTable.setDescription('This group contains operational attributes which show the status of the AtmIf component.')
atmIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfOperEntry.setDescription('An entry in the atmIfOperTable.')
atmIfTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellMemoryAvailable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfTxCellMemoryAvailable.setDescription("This attribute is HISTORICAL and is replaced by txCellMemoryUsage. This attribute is only valid for AtmIf's on ATM IP FPs. It is not displayed for AtmIf's on other card types. This attribute indicates the current amount of transmit cells available for this AtmIf. Transmit cell memory is the memory available for storing ATM cells to be transmitted by connections under this AtmIf.")
atmIfTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryCongestionState.setDescription("This attribute indicates the congestion state of the transmit cell memory for this AtmIf. This attribute is not applicable, and is not displayed on CQC-based ATM FPs. This attribute indicates which txCellMemoryThreshold corresponds to the current value of txCellMemoryUsage. The congestion state is used to determine if cells of a particular discard priority (DP) are discarded before being queued for transmit. The congestion state of transmit cell memory is indicated by a numeric value ranging from 3 to 0. When transmit cell memory is in congestion state 'x', traffic with DP > 'x' is discarded before transmit. Traffic with DP < 'x' may be queued for transmit, depending on the congestion level of the connection transmit queue. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of txCellMemoryUsage is to the next threshold as displayed in txCellMemoryThreshold. For example, CLP1 traffic is queued until the value indicated by txCellMemoryUsage equals the value indicated in txCellMemoryThreshold 3. At that point, CLP1 traffic is discarded.")
atmIfTxCellMemoryUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellMemoryUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryUsage.setDescription('This attribute indicates the current number of transmit cells which are in use for this AtmIf. This attribute is not applicable, and is not displayed on CQC-based ATM FPs. Transmit cell memory is used for storing ATM cells to be transmitted by connections under this AtmIf. It includes all cells in connections at the nrt-VBR or UBR service category. It includes cells in CBR or rt-VBR connections which are doing per-VC queueing. It does not include cells in CBR or rt-VBR connections which are allocated from the dedicated buffer for CBR common queuing or rt-VBR common queuing.')
atmIfUnshapedTransmitQueueingOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 140, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfUnshapedTransmitQueueingOper.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfUnshapedTransmitQueueingOper.setDescription('This attribute is HISTORICAL in P6.0. This attribute indicates the state of transmit queuing for unshaped connections under this AtmIf. A value of perVc indicates that any unshaped connections use per- VC queueing in the CQC. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the atmServiceCategory for this connection.')
atmIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150), )
if mibBuilder.loadTexts: atmIfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStatsTable.setDescription('This group contains operational attributes which keep statistics about the behavior of the AtmIf component.')
atmIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"))
if mibBuilder.loadTexts: atmIfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfStatsEntry.setDescription('An entry in the atmIfStatsTable.')
atmIfTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTransmittedCells.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfTransmittedCells.setDescription('This attribute is renamed in P6.0 to txCell for naming compatibility with the Vcc and Vpc components. This attribute counts cells transmitted from the ATM interface. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds the maximum value of (2**64)-1.')
atmIfTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCell.setDescription('This attribute counts cells transmitted from the ATM interface. It does not include cells discarded due to congestion before transmit. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells transmitted from the ATM interface which have the CLP bit set to 1. This includes cells which arrive at this interface with CLP=1, and also cells which are marked with CLP=1 as a result of forced tagging at this interface. This count is included in the txCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfTxCellEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellEfci.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells transmitted from the ATM interface which have the EFCI bit set to 1. This includes cells which arrive at this interface with EFCI=1, and also cells which are marked with EFCI=1 as a result of congestion at this interface. This count is included in the txCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellDiscard.setDescription("This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells discarded and not transmitted out the ATM interface. Since cells are discarded before they are transmitted, this count is not included in the txCell attribute. This count is independent of the txFrameDiscard attribute. Transmit cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.")
atmIfTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 17), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellDiscardClp.setDescription("This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells discarded and not transmitted out the ATM interface which have the CLP bit set to 1. Since cells are discarded before they are transmitted, this count is not included in the txCellClp attribute. This count is included in the txCellDiscard attribute, but it is independent of the txFrameDiscardClp attribute. Transmit cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.")
atmIfTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 18), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxFrameDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames discarded and not transmitted out the ATM interface. This count is independent of txCellDiscard. Transmit frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 19), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxFrameDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames which have at least one cell with the CLP bit set to 1, and have been discarded and not transmitted out the ATM interface. It is independent of the txCellDiscard attribute. This count is included in the txFrameDiscard attribute. Transmit frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfReceivedCells.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfReceivedCells.setDescription('This attribute is renamed in P6.0 to rxCell for naming compatibility with the Vcc and Vpc component. This attribute counts valid cells received from the ATM interface. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 23), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxCell.setDescription('This attribute counts valid cells received from the ATM interface. This count includes cells which may be subsequently discarded. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. On ATM IP FPs valid cells include cells that arrive on a VCC whose VPI.VCI cannot be identified. These cells are also counted under the droppedRxCell attribute. The value of this attribute on ATM IP FPs should be greater than or equal to the sum of droppedRxCell and all the Vcc and Vpc rxCell attributes under this interface. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 24), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxCellClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the CLP bit set to 1. This count includes cells which may be subsequently discarded. This count is included in the rxCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxCellEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 25), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCellEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxCellEfci.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the EFCI bit set to 1. This count includes cells which may be subsequently discarded. This count is included in the rxCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 26), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxCellDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells received from the ATM interface which have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 27), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxCellDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the CLP bit set to 1, which have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. This counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 28), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxFrameDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames received from the ATM interface which have been discarded. This count includes the count of rxFrameDiscardClp and aal5RxErrors. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 29), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxFrameDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames received from the ATM interface which have been discarded and which have at least one cell with the CLP bit set to 1. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscardClp attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
atmIfDroppedRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfDroppedRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfDroppedRxCells.setDescription('This attribute counts cells received from the interface that were dropped because they contained invalid VPI or VCI values, or dropped because they had no associated connection for the VPI or VCI. On ATM IP FPs this count is included in the rxCell count for the interface. Note that this attribute does not keep an exact count. Idle cells and unassigned cells are ignored without being counted as dropped cells. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last dropped cell are indicated in the attribute lastDroppedRxCellConnection.')
atmIfLastDroppedRxCellConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 31), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLastDroppedRxCellConnection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLastDroppedRxCellConnection.setDescription('This attribute indicates the VPI and VCI of the last cell that was dropped. Cells are dropped because they have no associated connection for the VPI and VCI. Dropped cells are counted in the attribute droppedRxCells.')
atmIfAal5RxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfAal5RxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAal5RxErrors.setDescription('This attribute counts AAL5 frame reassembly errors which have occurred since the component was activated. These errors are either CRC errors or length errors, possibly caused by dropped cells.This attribute includes the count of AAL5 aborted frames. This count is included in the rxFrameDiscard count. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which exhibited AAL5 reassembly errors are indicated in the attribute lastAal5ErrorConnection.')
atmIfLastAal5RxErrorConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 33), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLastAal5RxErrorConnection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLastAal5RxErrorConnection.setDescription('This attribute indicates the VPI and VCI of the last connection that exhibited AAL5 reassembly errors. These errors are counted in the attribute aal5RxErrors.')
atmIfLrcFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLrcFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLrcFrameErrors.setDescription('This attribute counts egress LRC frame errors on frames received across the bus. The likely cause of this is a hardware fault on either the sending or receiving card. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which exhibited LRC errors are indicated in the attribute lastLrcFrameErrorConnection.')
atmIfLastLrcFrameErrorConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 35), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLastLrcFrameErrorConnection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLastLrcFrameErrorConnection.setDescription('This attribute indicates the VPI and VCI of the last connection that had LRC frame errors on frames received across the bus. These errors are counted in the attribute lrcFrameErrors.')
atmIfAal5RxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfAal5RxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfAal5RxAborts.setDescription('This attribute is not supported on any card type in Release 6.0 or earlier. This attribute counts AAL5 frame aborts which have been received since the component was activated. An AAL5 aborted frame is one in which the AAL5 frame length has been set to zero. This count is included in aal5RxErrors. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which received AAL5 abort errors are displayed in the attribute lastAal5RxAbortConnection.')
atmIfLastAal5RxAbortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 50), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfLastAal5RxAbortConnection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfLastAal5RxAbortConnection.setDescription('This attribute is not supported on any card type in Release 6.0 or earlier. This attribute indicates the VPI and VCI of the last connection that exhibited AAL5 aborts. These errors are counted in the attribute aal5RxAborts.')
atmIfTxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 59), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxLinkUtilization.setDescription('This attribute indicates the current transmit interface utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this ATM interface.')
atmIfRxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 150, 1, 60), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfRxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfRxLinkUtilization.setDescription('This attribute indicates the current receive interface utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this ATM interface.')
atmIfTxCellMemoryThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 441), )
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdTable.setDescription('This attribute is a vector which indicates the size and three discard thresholds for transmit cell memory for this AtmIf. This attribute is not applicable, and is not displayed on CQC-based ATM FPs. Transmit cell memory used for storing ATM cells to be transmitted by connections under this AtmIf. It includes all cells in connections at the nrt-VBR or UBR service category. It includes cells in CBR or rt-VBR connections which are doing per-VC queueing. It does not include cells in CBR or rt-VBR connections which are allocated from the dedicated buffer for CBR common queuing or rt-VBR common queuing. The first value indicates the transmit cell memory size. It is the multiplication of the Lp/x Eng Arc Aqm/y txCellMemoryThreshold 0 attribute by the txCellMemoryPercentage attribute of this AtmIf. The current value of txCellMemoryUsage together with the vector of values in txCellMemoryThreshold determines the txCellMemoryCongestionState. The congestion state determines whether cells of a given discard priority (DP) are discarded or queued for transmit. When the txCellMemoryUsage attribute is between threshold 0 and threshold 1, the txCellMemoryCongestionState indicates the value 0. In congestion state 0, traffic with DP > 0 is discarded. Threshold 1 is set approximately at 90 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 1 and threshold 2, the txCellMemoryCongestionState indicates the value 1. In congestion state 1, traffic with DP > 1 is discarded. Threshold 2 is set approximately at 85 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is between threshold 2 and threshold 3, the txCellMemoryCongestionState indicates the value 2. In congestion state 2, traffic with DP > 2 is discarded. Threshold 3 is set approximately at 75 percent of threshold 0, the total transmit cell memory size. When the txCellMemoryUsage attribute is below threshold 3, the txCellMemoryCongestionState indicates the value 3. In congestion state 3, traffic with DP=3 is queued.')
atmIfTxCellMemoryThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 441, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfTxCellMemoryThresholdIndex"))
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdEntry.setDescription('An entry in the atmIfTxCellMemoryThresholdTable.')
atmIfTxCellMemoryThresholdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 441, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdIndex.setDescription('This variable represents the atmIfTxCellMemoryThresholdTable specific index for the atmIfTxCellMemoryThresholdTable.')
atmIfTxCellMemoryThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 441, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfTxCellMemoryThresholdValue.setDescription('This variable represents an individual value for the atmIfTxCellMemoryThresholdTable.')
atmIfConnMap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2))
atmIfConnMapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1), )
if mibBuilder.loadTexts: atmIfConnMapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfConnMap components.')
atmIfConnMapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapIndex"))
if mibBuilder.loadTexts: atmIfConnMapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapRowStatusEntry.setDescription('A single entry in the table represents a single atmIfConnMap component.')
atmIfConnMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnMapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfConnMap components. These components can be added and deleted.')
atmIfConnMapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfConnMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapStorageType.setDescription('This variable represents the storage type value for the atmIfConnMap tables.')
atmIfConnMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfConnMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapIndex.setDescription('This variable represents the index for the atmIfConnMap tables.')
atmIfConnMapVccProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100), )
if mibBuilder.loadTexts: atmIfConnMapVccProvTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapVccProvTable.setDescription("This group is obsolete. Please refer to the Override component below for the current provisioning group This group contains provisionable attributes which specify the VCC space to be supported by an ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case atmNumberOfNonZeroVpisForVccs_m must also be 0. The optional Programmable VCC Space is used to support VCCs with a VPI other than zero. The VPI values supported in this space must lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the Programmable VCC Space (should it exist) must adhere to the following rules: If (firstNonZeroVpiForVccs = 1) THEN (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi must be a multiple of 256 OTHERWISE numNonZeroVpisForVccs * numVccsPerNonZeroVpi must be a multiple of 256 If the AtmIf is linked to a LogicalProcessor with a cardType of 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm or 2pJ6MAtm, the size of the entire VCC space (both mandatory and optional parts) and VPC space must not exceed the capacity of the port to which the interface is linked, which is defined in the Arc component's totalConnectionPoolCapacity or connectionPoolCapacity attribute (whichever is non-zero). When using the totalConnectionPoolCapacity attribute, the capacity of the port is (totalConnectionPoolCapacity divided by the number of physical ports). The number of connection identifiers in the VCC and VPC space can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ids = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ids = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ids = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi)")
atmIfConnMapVccProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapIndex"))
if mibBuilder.loadTexts: atmIfConnMapVccProvEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapVccProvEntry.setDescription('An entry in the atmIfConnMapVccProvTable.')
atmIfConnMapNumVccsForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16128)).clone(768)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmIfConnMapNumVccsForVpiZero.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapNumVccsForVpiZero.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case atmNumberOfNonZeroVpisForVccs_m must also be 0. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
atmIfConnMapNumNonZeroVpisForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmIfConnMapNumNonZeroVpisForVccs.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapNumNonZeroVpisForVccs.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of conti guous VPIs supported in the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
atmIfConnMapFirstNonZeroVpiForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(48, 48), ValueRangeConstraint(64, 64), ValueRangeConstraint(80, 80), ValueRangeConstraint(96, 96), ValueRangeConstraint(112, 112), ValueRangeConstraint(128, 128), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(176, 176), ValueRangeConstraint(192, 192), ValueRangeConstraint(208, 208), ValueRangeConstraint(224, 224), ValueRangeConstraint(240, 240), )).clone(1)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmIfConnMapFirstNonZeroVpiForVccs.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapFirstNonZeroVpiForVccs.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The initial VPI of the Programmable VCC Space must either be 1 or a non-zero multiple of 16. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
atmIfConnMapNumVccsPerNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), )).clone(64)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmIfConnMapNumVccsPerNonZeroVpi.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfConnMapNumVccsPerNonZeroVpi.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. The size of the Programmable VCC Space must be a power of 2. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
atmIfConnMapOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110), )
if mibBuilder.loadTexts: atmIfConnMapOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOperTable.setDescription("This group contains operational attributes which specify the VCC space to be supported by an ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to an optionally provisioned maximum of numVccsForVpiZero. The size of the VPI Zero VCC Space is either 0 or a multiple of 256. A value of 0 implies that not only can no VCCs be provisioned in the VPI Zero VCC Space but no Programmable VCCs can be used. In this case numNonZeroVpisForVccs will also be 0. The optional Programmable VCC Space supports VCCs with a VPI other than zero. The VPI values supported in this space lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to an optionally provisioned maximum. The number of connection identifier resources in the VCC and VPC space (not all of which are available for user connections) is the value reported in the Lp/n Eng Arc totalConnectionPoolAvailable attribute divided by the number of physical ports on the card, and can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ID resources = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi)")
atmIfConnMapOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapIndex"))
if mibBuilder.loadTexts: atmIfConnMapOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOperEntry.setDescription('An entry in the atmIfConnMapOperTable.')
atmIfConnMapNumVccsForVpiZeroOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapNumVccsForVpiZeroOper.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapNumVccsForVpiZeroOper.setDescription('This attribute indicates the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). To override the system default, see the AtmIf ConnMap Ov attribute numVccsForVpiZero.')
atmIfConnMapNumNonZeroVpisForVccsOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapNumNonZeroVpisForVccsOper.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapNumNonZeroVpisForVccsOper.setDescription('This attribute indicates the number of contiguous VPIs supported in the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). To override the system default, see the AtmIf ConnMap Ov attribute numNonZeroVpisForVccs.')
atmIfConnMapFirstNonZeroVpiForVccsOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(48, 48), ValueRangeConstraint(64, 64), ValueRangeConstraint(80, 80), ValueRangeConstraint(96, 96), ValueRangeConstraint(112, 112), ValueRangeConstraint(128, 128), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(176, 176), ValueRangeConstraint(192, 192), ValueRangeConstraint(208, 208), ValueRangeConstraint(224, 224), ValueRangeConstraint(240, 240), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapFirstNonZeroVpiForVccsOper.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapFirstNonZeroVpiForVccsOper.setDescription('This attribute indicates the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). To override the system default, see the AtmIf ConnMap Ov attribute firstNonZeroVpiForVccs.')
atmIfConnMapNumVccsPerNonZeroVpiOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 110, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapNumVccsPerNonZeroVpiOper.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapNumVccsPerNonZeroVpiOper.setDescription('This attribute indicates the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. To override the system default, see the AtmIf ConnMap Ov attribute numVccsPerNonZeroVpi.')
atmIfConnMapOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120))
atmIfConnMapOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1), )
if mibBuilder.loadTexts: atmIfConnMapOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfConnMapOv components.')
atmIfConnMapOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapOvIndex"))
if mibBuilder.loadTexts: atmIfConnMapOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvRowStatusEntry.setDescription('A single entry in the table represents a single atmIfConnMapOv component.')
atmIfConnMapOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfConnMapOv components. These components cannot be added nor deleted.')
atmIfConnMapOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfConnMapOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfConnMapOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvStorageType.setDescription('This variable represents the storage type value for the atmIfConnMapOv tables.')
atmIfConnMapOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfConnMapOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvIndex.setDescription('This variable represents the index for the atmIfConnMapOv tables.')
atmIfConnMapOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100), )
if mibBuilder.loadTexts: atmIfConnMapOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvProvTable.setDescription("This group contains provisionable attributes which specify the VCC space to be supported by this ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case numNonZeroVpisForVccs must also be 0. The optional Programmable VCC Space is used to support VCCs with a VPI other than zero. The VPI values supported in this space must lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the Programmable VCC Space (should it exist) must adhere to the following rules: If (firstNonZeroVpiForVccs = 1) THEN (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi must be a multiple of 256 OTHERWISE numNonZeroVpisForVccs * numVccsPerNonZeroVpi must be a multiple of 256 The number of connection identifier resources in the VCC and VPC space can be determined as follows: The number of connection identifier resources in the VCC and VPC space (not all of which are available for user connections) is reported in the Lp/n Eng Arc totalConnectionPoolAvailable attribute, and can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ID resources = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi) The number of connection identifier resources must not exceed the capacity of the port to which the interface is linked. If the Lp has an Eng Arc Cqc Ov component provisioned with a non-zero connectionPoolCapacity the port's capacity is specified by this attribute. Otherwise the port's capacity is indicated by the Lp/n Eng Arc totalConnectionPoolAvailable divided by the number of physical ports on the card.")
atmIfConnMapOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfConnMapOvIndex"))
if mibBuilder.loadTexts: atmIfConnMapOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvProvEntry.setDescription('An entry in the atmIfConnMapOvProvTable.')
atmIfConnMapOvNumVccsForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16128)).clone(768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnMapOvNumVccsForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvNumVccsForVpiZero.setDescription('This attribute specifies the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case numNonZeroVpisForVccs must also be 0. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
atmIfConnMapOvNumNonZeroVpisForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnMapOvNumNonZeroVpisForVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvNumNonZeroVpisForVccs.setDescription('This attribute specifies the number of contiguous VPIs supported in the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
atmIfConnMapOvFirstNonZeroVpiForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(48, 48), ValueRangeConstraint(64, 64), ValueRangeConstraint(80, 80), ValueRangeConstraint(96, 96), ValueRangeConstraint(112, 112), ValueRangeConstraint(128, 128), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(176, 176), ValueRangeConstraint(192, 192), ValueRangeConstraint(208, 208), ValueRangeConstraint(224, 224), ValueRangeConstraint(240, 240), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnMapOvFirstNonZeroVpiForVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvFirstNonZeroVpiForVccs.setDescription('This attribute specifies the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 then the Programmable VCC Space does not exist and the value of this attribute is ignored. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The initial VPI of the Programmable VCC Space must either be 1 or a non-zero multiple of 16. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
atmIfConnMapOvNumVccsPerNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 2, 120, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), )).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfConnMapOvNumVccsPerNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfConnMapOvNumVccsPerNonZeroVpi.setDescription('This attribute specifies the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
atmIfCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3))
atmIfCARowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1), )
if mibBuilder.loadTexts: atmIfCARowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCA components.')
atmIfCARowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"))
if mibBuilder.loadTexts: atmIfCARowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARowStatusEntry.setDescription('A single entry in the table represents a single atmIfCA component.')
atmIfCARowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCARowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCA components. These components cannot be added nor deleted.')
atmIfCAComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCAStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAStorageType.setDescription('This variable represents the storage type value for the atmIfCA tables.')
atmIfCAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfCAIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAIndex.setDescription('This variable represents the index for the atmIfCA tables.')
atmIfCAProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100), )
if mibBuilder.loadTexts: atmIfCAProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAProvTable.setDescription('This group contains provisioned attributes which specify the behavior of Connection Admission Control (CAC) for the ATM connections configured on an ATM interface. Note that the names of some of the attributes follow the conventions of UNI 4.0 for forward compatibility reasons. This does not imply conformance in general with the UNI 4.0 specification.')
atmIfCAProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"))
if mibBuilder.loadTexts: atmIfCAProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAProvEntry.setDescription('An entry in the atmIfCAProvTable.')
atmIfCAMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxVpcs.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAMaxVpcs.setDescription("This attribute specifies the maximum number of Vpcs that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all AtmIfs linked to that Lp must not exceed the totalConnectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc totalConnectionPoolCapacity attribute is used as the limit. This attribute has been obsoleted and its value migrated to the maxVpcs attribute.")
atmIfCAMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxVccs.setDescription("This attribute specifies the maximum number of usable Vccs (and Vpt Vccs) that can be configured on this AtmIf. The value must not exceed the number of non-reserved Vcc identifiers in the Vcc space supported by this AtmIf (which is specified by the ConnectionMapping component). Furthermore, if the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all AtmIfs linked to that Lp must not exceed the totalConnectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc totalConnectionPoolCapacity attribute is used as the limit.")
atmIfCAMinMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMinMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMinMulticastBranches.setDescription('This attribute specifies the guaranteed number of multicast branches that can be activated on this AtmIf, including those activated beneath a Vpt. The sum of minMulticastBranches across all AtmIfs of the Lp must be less than or equal to the multicastBranchesCapacity attribute of the Arc component of the Lp. For CQC-based ATM cards, the value of the attribute can not exceed 10752. If this value is non zero, the Arc component must exist and have multicastBranchesCapacity set to a value greater than or equal to this attribute.')
atmIfCAMaxMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16384), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxMulticastBranches.setDescription('This attribute specifies the maximum number of provisionable multicast branches that can be activated on this AtmIf, including those activated beneath a Vpt. If this attribute is set to a value other than autoConfigure, it must be greater than or equal to the value of minMulticastBranches of this AtmIf. For CQC-based ATM cards, the value of the attribute can not exceed 10752. When this attribute is set to autoConfigure, an appropriate value is selected based on the card type. It is set to 10752 for all CQC-based ATM cards, and to 16384 for ATM IP cards. VALUES ( 0 = autoConfigure )')
atmIfCAMaxVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxVpts.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAMaxVpts.setDescription("This attribute specifies the maximum number of Vpts that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all AtmIfs linked to that Lp must not exceed the totalConnectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc totalConnectionPoolCapacity attribute is used as the limit. This attribute has been obsoleted and its value migrated to the maxVpts attribute.")
atmIfCAMinAutoSelectedVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVci.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVci.setDescription('This attribute specifies the default lower boundary for VCIs which are automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This attribute has been obsoleted and its value migrated to the minAutoSelectedVciForVpiZero attribute.')
atmIfCAMinAutoSelectedVciForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVciForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVciForVpiZero.setDescription('This attribute specifies the minimum VCI value which is automatically allocated for a switched Vcc with VPI value of zero. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath Vpt/0.')
atmIfCAMinAutoSelectedVciForNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVciForNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVciForNonZeroVpi.setDescription('This attribute specifies the minimum VCI value which is automatically allocated for a switched Vcc with a non-zero VPI value. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath a Vpt.')
atmIfCAPermittedSvcAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAPermittedSvcAtmServiceCategories.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAPermittedSvcAtmServiceCategories.setDescription('This attribute specifies which ATM service categories are permitted on this interface for SVCs. The value of this attribute does not affect control VCCs, such as signalling and ILMI channels. If the value is empty, no SVCs may use this interface. This attribute has been obsoleted and its value migrated to the permittedAtmServiceCategories attribute. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)')
atmIfCACbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrPool.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCACbrPool.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category. When the user does not intend to support the CBR service category, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic.')
atmIfCACbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCACbrCdvt.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT) which is to be applied to the entire ATM Interface for CBR traffic.')
atmIfCACbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCACbrCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. In addition, the type and range of the new attribute have been changed. This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then cbrCellLossRatio = -10. This number must be the same as the vbrRtCellLossRatio since CBR and rt-VBR traffic have the same discard priority. The cbrCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
atmIfCASvcCbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCASvcCbrHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCASvcCbrHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. This attribute specifies the default holding priority which applies for SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
atmIfCASvcVbrRtHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCASvcVbrRtHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCASvcVbrRtHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. This attribute specifies the default holding priority which applies for SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
atmIfCASvcVbrNrtHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCASvcVbrNrtHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCASvcVbrNrtHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. This attribute specifies the default holding priority which applies for SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
atmIfCAVbrRtPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrRtPool.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrRtPool.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the variable bit rate real time (rt-VBR) service category. When the user does not intend to support the rt-VBR service category, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic.')
atmIfCAVbrRtCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrRtCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrRtCdvt.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT) which is to be applied to the entire ATM Interface for rt-VBR traffic.')
atmIfCAVbrRtCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 80), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrRtCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrRtCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. In addition, the type and range of this attribute has been changed. This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then vbrRtCellLossRatio = - 10. This number must be the same as the cbrCellLossRatio since CBR and rt-VBR traffic have the same discard priority. The vbrRtCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the vbrNrtCellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
atmIfCAVbrNrtPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrNrtPool.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrNrtPool.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the variable bit rate non-real time (nrt-VBR) service category. When the user does not intend to support the nrt-VBR, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic.')
atmIfCAVbrNrtCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrNrtCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrNrtCdvt.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT), which is to be applied to the entire ATM Interface for nrt-VBR traffic.')
atmIfCAMaxCaVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 105), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxCaVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxCaVpcs.setDescription("This attribute specifies the maximum number of Vpcs that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all AtmIfs linked to that Lp must not exceed the totalConnectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc totalConnectionPoolCapacity attribute is used as the limit.")
atmIfCAMaxCaVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 106), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxCaVpts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxCaVpts.setDescription("This attribute specifies the maximum number of Vpts that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all AtmIfs linked to that Lp must not exceed the totalConnectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc totalConnectionPoolCapacity attribute is used as the limit.")
atmIfCAVbrNrtCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 110), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAVbrNrtCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAVbrNrtCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. In addition, the type and range of new attribute has been changed. This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then vbrNrtCellLossRatio = - 10.This number must be greater than or equal to vbrRtCellLossRatio since rt-VBR traffic has a higher discard priority. The vbrNrtCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
atmIfCAUbrMaxConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 120), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(16384)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMaxConnections.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAUbrMaxConnections.setDescription('This attribute is obsolete in P6.0, and has been migrated to the CA Ubr/0 maxVccs and maxVpcs attributes. This attribute specifies the maximum number of unspecified bit rate (UBR) connections which are to be admitted managed by this CA. This number is enforced by the connection admission control (CAC) algorithm for this AtmIf.')
atmIfCAMinAutoSelectedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 121), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMinAutoSelectedVpi.setDescription('This attribute specifies the minimum VPI value which will be automatically allocated for a switched Vpc. A VPI number is automatically allocated when a switched Vpc does not request a specific VPI number.')
atmIfCAPermittedAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 122), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAPermittedAtmServiceCategories.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPermittedAtmServiceCategories.setDescription("This attribute specifies which ATM service categories are permitted on this interface for SVPs and SVCs. The value of this attribute does not affect control VCCs, such as signalling and ILMI channels. If the value is empty, no non-control SVPs or SVCs will use this interface. This attribute is ignored for the admission of provisioned VCCs, VPCs, VPTs, S-PVCs, and S-PVPs. The value of the permittedAtmServiceCategories in a VPT CA overrides this AtmIf CA setting for all the given VPT's VCCs. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)")
atmIfCAMaxAutoSelectedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 125), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVpi.setDescription('This attribute specifies the maximumVPI value which will be automatically allocated for a switched Vpc or Vcc. A VPI number is automatically allocated when a switched Vpc or Vcc does not request a specific VPI number.')
atmIfCAMaxAutoSelectedVciForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 126), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVciForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVciForVpiZero.setDescription('This attribute specifies the maximum VCI value which is automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath Vpt/0.')
atmIfCAMaxAutoSelectedVciForNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 100, 1, 127), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535)).clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVciForNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAMaxAutoSelectedVciForNonZeroVpi.setDescription('This attribute specifies the maximum VCI value which is automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath non zero Vpts.')
atmIfCAOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110), )
if mibBuilder.loadTexts: atmIfCAOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAOperTable.setDescription('This group contains operational attributes giving statistics about the ATM connections configured on an ATM interface.')
atmIfCAOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"))
if mibBuilder.loadTexts: atmIfCAOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAOperEntry.setDescription('An entry in the atmIfCAOperTable.')
atmIfCAPermanentVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPermanentVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPermanentVpcs.setDescription('This attribute indicates the number of permanent Vpcs that are currently provisioned on this interface.')
atmIfCAPermanentVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPermanentVpts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPermanentVpts.setDescription('This attribute indicates the number of permanent Vpts that are currently provisioned on this interface.')
atmIfCAPermanentVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPermanentVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPermanentVccs.setDescription('This attribute indicates the number of permanent Vccs that are currently provisioned on this interface (this includes Vccs having SrcPvc subcomponents). Vpt Vccs are also included in this count.')
atmIfCASwitchedVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 30), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCASwitchedVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCASwitchedVccs.setDescription('This attribute indicates the number of switched Vccs that are currently active on this interface. Vpt Vccs are also included in this count.')
atmIfCASwitchedMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 40), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCASwitchedMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCASwitchedMulticastBranches.setDescription('This attribute indicates the number of multicast branches used in switched Vccs, including Vpt Vccs, that are currently active on this interface. The sum of this attribute for all AtmIf components linked to an Lp gives the value of multiCastBranchesUsage in the Arc component.')
atmIfCATroubledVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 60), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCATroubledVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCATroubledVpcs.setDescription("This attribute indicates the number of troubled Vpcs on this interface. A Vpc is 'troubled' if its operational troubled attribute has the value yes.")
atmIfCATroubledVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 65), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCATroubledVpts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCATroubledVpts.setDescription("This attribute indicates the number of troubled Vpts on this interface. A Vpt is 'troubled' if its operational troubled attribute has the value yes.")
atmIfCATroubledVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCATroubledVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCATroubledVccs.setDescription("This attribute indicates the number of troubled Vccs on this interface. A Vcc is 'troubled' if its operational troubled attribute has the value yes.")
atmIfCAUbrAvailableConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 80), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrAvailableConnections.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAUbrAvailableConnections.setDescription('This attribute is historical in P6.0. Refer instead to the vccUsage and vpcUsage under the AtmIf CA Ubr component. This attribute indicates the available UBR connections. Its value is ubrMaxConnections minus the number of admitted connections.')
atmIfCAConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 81), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAConnectionPoolUsage.setDescription('This attribute indicates the number of enabled VCCs, VPCs, and VPTs in this AtmIf. An example of a VCC not in the enabled state is a Vcc with a Test subcomponent where the test is not started. Each Vcc or Vpc is counted as 1 connection. Each basic Vpt is counted as 2 connections and each standard Vpt is counted as 3 connections. Each connection appropriately reduces the number of connections indicated in Arc totalConnectionPoolAvailable and increases the number of connections indicated in Arc totalConnectionPoolUsage.')
atmIfCASwitchedVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 82), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCASwitchedVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCASwitchedVpcs.setDescription('This attribute indicates the number of switched Vpcs that are currently active on this interface.')
atmIfCAVirtualLinkRequestedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 130), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAVirtualLinkRequestedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAVirtualLinkRequestedBandwidth.setDescription('This attribute specifies the total bandwidth requested by all Virtual Link VPTs for this AtmIf.')
atmIfCAVirtualLinkAdmittedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 131), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAVirtualLinkAdmittedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAVirtualLinkAdmittedBandwidth.setDescription('This attribute specifies the total bandwidth allocated to all Virtual Link VPTs for this AtmIf.')
atmIfCAVirtualLinkUnallocatedBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 110, 1, 132), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAVirtualLinkUnallocatedBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAVirtualLinkUnallocatedBandwidth.setDescription('This attribute specifies the total bandwidth that has not been allocated to either Virtual Link VPTs or the AtmIf.')
atmIfCABwPoolTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 293), )
if mibBuilder.loadTexts: atmIfCABwPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCABwPoolTable.setDescription('Link capacity is partitioned into five bandwidth pools. This attribute specifies the percentage of link bandwidth that is allowed for each pool. The percentage for each pool ranges from 0% to 12,800%. This allows for both under and over subscription of the link. Under subscription occurs when the sum of the percentages assigned to the five pools is less than 100%. Over subscription occurs when the sum of the percentages for the five pools exceeds 100%.')
atmIfCABwPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 293, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCABwPoolIndex"))
if mibBuilder.loadTexts: atmIfCABwPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCABwPoolEntry.setDescription('An entry in the atmIfCABwPoolTable.')
atmIfCABwPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 293, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCABwPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCABwPoolIndex.setDescription('This variable represents the atmIfCABwPoolTable specific index for the atmIfCABwPoolTable.')
atmIfCABwPoolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 293, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCABwPoolValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCABwPoolValue.setDescription('This variable represents an individual value for the atmIfCABwPoolTable.')
atmIfCAPoolRequBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 296), )
if mibBuilder.loadTexts: atmIfCAPoolRequBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolRequBwTable.setDescription('This attribute indicates the total requested bandwidth from bandwidthPool except for connections managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) for connections which are admitted, and for connections which are requesting admission but have not yet been admitted.')
atmIfCAPoolRequBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 296, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolRequBwIndex"))
if mibBuilder.loadTexts: atmIfCAPoolRequBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolRequBwEntry.setDescription('An entry in the atmIfCAPoolRequBwTable.')
atmIfCAPoolRequBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 296, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolRequBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolRequBwIndex.setDescription('This variable represents the atmIfCAPoolRequBwTable specific index for the atmIfCAPoolRequBwTable.')
atmIfCAPoolRequBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 296, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolRequBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolRequBwValue.setDescription('This variable represents an individual value for the atmIfCAPoolRequBwTable.')
atmIfCAPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 299), )
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwTable.setDescription('This attribute indicates the total admitted bandwidth in bandwidthPool except for connections managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) of the admitted connections.')
atmIfCAPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 299, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolAdmitBwIndex"))
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwEntry.setDescription('An entry in the atmIfCAPoolAdmitBwTable.')
atmIfCAPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 299, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwIndex.setDescription('This variable represents the atmIfCAPoolAdmitBwTable specific index for the atmIfCAPoolAdmitBwTable.')
atmIfCAPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 299, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmitBwValue.setDescription('This variable represents an individual value for the atmIfCAPoolAdmitBwTable.')
atmIfCAPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 300), )
if mibBuilder.loadTexts: atmIfCAPoolAvailBwTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAPoolAvailBwTable.setDescription('This attribute indicates the total available bandwidth in bandwidthPool. Its value is the link capacity reduced by the sum of the equivalent cell rates (ECR) of the admitted connections.')
atmIfCAPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 300, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolAvailBwIndex"))
if mibBuilder.loadTexts: atmIfCAPoolAvailBwEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAPoolAvailBwEntry.setDescription('An entry in the atmIfCAPoolAvailBwTable.')
atmIfCAPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 300, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: atmIfCAPoolAvailBwIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAPoolAvailBwIndex.setDescription('This variable represents the atmIfCAPoolAvailBwTable specific index for the atmIfCAPoolAvailBwTable.')
atmIfCAPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 300, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolAvailBwValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCAPoolAvailBwValue.setDescription('This variable represents an individual value for the atmIfCAPoolAvailBwTable.')
atmIfCAPoolProvBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 319), )
if mibBuilder.loadTexts: atmIfCAPoolProvBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolProvBwTable.setDescription('This attribute indicates the total bandwidth from bandwidthPool which is specified by provisioned connections except for those managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) of the provisioned connections. Provisioned connections include provisioned AtmIf Vccs, AtmIf Vpcs, AtmIf Vpts, Vpt Vccs, and Vccs or Vpcs with a Src component under them.')
atmIfCAPoolProvBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 319, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolProvBwIndex"))
if mibBuilder.loadTexts: atmIfCAPoolProvBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolProvBwEntry.setDescription('An entry in the atmIfCAPoolProvBwTable.')
atmIfCAPoolProvBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 319, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolProvBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolProvBwIndex.setDescription('This variable represents the atmIfCAPoolProvBwTable specific index for the atmIfCAPoolProvBwTable.')
atmIfCAPoolProvBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 319, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolProvBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolProvBwValue.setDescription('This variable represents an individual value for the atmIfCAPoolProvBwTable.')
atmIfCAPoolWaitAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 320), )
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsTable.setDescription('This attribute indicates the total number of connections which have currently requested admission in bandwidthPool but are not yet admitted. This attribute does not include connections that are managed by a Vpt CA.')
atmIfCAPoolWaitAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 320, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolWaitAdmConnsIndex"))
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsEntry.setDescription('An entry in the atmIfCAPoolWaitAdmConnsTable.')
atmIfCAPoolWaitAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 320, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsIndex.setDescription('This variable represents the atmIfCAPoolWaitAdmConnsTable specific index for the atmIfCAPoolWaitAdmConnsTable.')
atmIfCAPoolWaitAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 320, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolWaitAdmConnsValue.setDescription('This variable represents an individual value for the atmIfCAPoolWaitAdmConnsTable.')
atmIfCAPoolAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 321), )
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsTable.setDescription('This attribute indicates the total number of connections which are currently admitted in bandwidthPool except for those managed by a Vpt CA.')
atmIfCAPoolAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 321, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolAdmConnsIndex"))
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsEntry.setDescription('An entry in the atmIfCAPoolAdmConnsTable.')
atmIfCAPoolAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 321, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsIndex.setDescription('This variable represents the atmIfCAPoolAdmConnsTable specific index for the atmIfCAPoolAdmConnsTable.')
atmIfCAPoolAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 321, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAdmConnsValue.setDescription('This variable represents an individual value for the atmIfCAPoolAdmConnsTable.')
atmIfCAPoolAvailableBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 326), )
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwTable.setDescription('This attribute indicates the total available bandwidth in bandwidthPool. A positive number indicates that there is still bandwidth available in the pool which has not been allocated. A negative value indicates that some bandwidth-elastic provisioned connections are running in reduced mode, where their allocated bandwidth is below their originally allocated ECR. The negative amount is equal to the sum of the bwReduction attribute for all connections under this bandwidthPool.')
atmIfCAPoolAvailableBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 326, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAPoolAvailableBwIndex"))
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwEntry.setDescription('An entry in the atmIfCAPoolAvailableBwTable.')
atmIfCAPoolAvailableBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 326, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwIndex.setDescription('This variable represents the atmIfCAPoolAvailableBwTable specific index for the atmIfCAPoolAvailableBwTable.')
atmIfCAPoolAvailableBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 326, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAPoolAvailableBwValue.setDescription('This variable represents an individual value for the atmIfCAPoolAvailableBwTable.')
atmIfCACbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2))
atmIfCACbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1), )
if mibBuilder.loadTexts: atmIfCACbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCACbr components.')
atmIfCACbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCACbrIndex"))
if mibBuilder.loadTexts: atmIfCACbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfCACbr component.')
atmIfCACbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCACbr components. These components can be added.')
atmIfCACbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCACbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCACbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCACbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrStorageType.setDescription('This variable represents the storage type value for the atmIfCACbr tables.')
atmIfCACbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfCACbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrIndex.setDescription('This variable represents the index for the atmIfCACbr tables.')
atmIfCACbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100), )
if mibBuilder.loadTexts: atmIfCACbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrProvTable.setDescription('This group contains provisioned attributes which control the CBR service category for this interface.')
atmIfCACbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCACbrIndex"))
if mibBuilder.loadTexts: atmIfCACbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrProvEntry.setDescription('An entry in the atmIfCACbrProvTable.')
atmIfCACbrProvPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrProvPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrProvPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfCACbrProvCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrProvCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrProvCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the CBR service category except those managed by a Vpt CA. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is used by the CAC function to compute the equivalent cell rate (ECR) required by a given CBR connection. The larger the value of CDVT, the larger is its ECR. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
atmIfCACbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to the entire ATM Interface for CBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The worst case value of this attribute can be computed as the txQueueLimit divided by the link rate of this ATM Interface. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the CDV requirements of the connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
atmIfCACbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to the entire ATM Interface for CBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the ATM connection's MaxCTD requirement.")
atmIfCACbrProvClr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrProvClr.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrProvClr.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then Cbr cellLossRatio = 10. This number must be the same as the RtVbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The Cbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for CBR connections, and CAC is effectively turned off. All CBR connections are admitted.')
atmIfCACbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the CBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. For a per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. CQC-based ATM cards do not support per-VC queues at the CBR service category. When this attribute is set to autoConfigure, an appropriate value is selected based on the card type. It is set to 96 for all Passport ATM cards (DS1, E1, IMA, JT2, DS3, E3, OC3, both CQC-based cards and ATM IP cards). For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
atmIfCACbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrHoldingPriority.setDescription("This attribute specifies the holding priority which applies to SVP and SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCACbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCACbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
atmIfCACbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC CBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCACbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 80), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 12000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the CBR service category. This attribute is ignored on CQC-based ATM cards, because they do not support per-VC queues at the CBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
atmIfCACbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 90), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the CBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. This attribute is ignored on CQC-based ATM cards, because they do not support per-VC queues at the CBR service category. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 80000 for all cards which support per-VC queuing at the CBR service category (3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2, 2pOC3MmAtm2). For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
atmIfCACbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the CBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 140), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the CBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any CBR connections. For CQC-based ATM FPs, this attribute must be set to disabled. Traffic shaping is not supported for CBR connections on CQC- based ATM FPs. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. If this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse-UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 150), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('minimumCdv')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the CBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 160), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1))).clone('common')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the CBR service category. On ATM IP cards, this attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue for this service category. The common queue has one set of congestion control levels for all cells enqueued on it. For CQC-based ATM cards, this attribute must be set to common. CQC-based ATM cards do not support per-VC queueing for the CBR service category. For ATM IP cards, if traffic shaping for this service category is not disabled, this attribute must be set to perVc. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 165), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrWeightPolicy.setDescription('This attribute specifies the default policy which is applied when calculating the fairness weight for unshaped connections of the CBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the CBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 169), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all CBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
atmIfCACbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 100, 1, 170), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCACbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the CBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced by default for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all CBR connections. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCACbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 110), )
if mibBuilder.loadTexts: atmIfCACbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrOperTable.setDescription('This group contains operational attributes for the CBR service category.')
atmIfCACbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCACbrIndex"))
if mibBuilder.loadTexts: atmIfCACbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrOperEntry.setDescription('An entry in the atmIfCACbrOperTable.')
atmIfCACbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCACbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCACbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
atmIfCARtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3))
atmIfCARtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1), )
if mibBuilder.loadTexts: atmIfCARtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCARtVbr components.')
atmIfCARtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCARtVbrIndex"))
if mibBuilder.loadTexts: atmIfCARtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfCARtVbr component.')
atmIfCARtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCARtVbr components. These components can be added.')
atmIfCARtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCARtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCARtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCARtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrStorageType.setDescription('This variable represents the storage type value for the atmIfCARtVbr tables.')
atmIfCARtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfCARtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrIndex.setDescription('This variable represents the index for the atmIfCARtVbr tables.')
atmIfCARtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100), )
if mibBuilder.loadTexts: atmIfCARtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrProvTable.setDescription('This group contains provisioned attributes which control the rt-VBR service category for this interface.')
atmIfCARtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCARtVbrIndex"))
if mibBuilder.loadTexts: atmIfCARtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrProvEntry.setDescription('An entry in the atmIfCARtVbrProvTable.')
atmIfCARtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the real-time variable bit rate (rt-VBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfCARtVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the rt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC to bandwidth usage beyond the traffic contract.")
atmIfCARtVbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1268)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to the entire ATM Interface for rt-VBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The worst case value of this attribute can be computed as the txQueueLimit divided by the link rate of this ATM Interface. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the CDV requirement for that connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
atmIfCARtVbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to the entire ATM Interface for rt-VBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the ATM connection's MaxCTD requirement.")
atmIfCARtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then RtVbr cellLossRatio = 10. This number must be the same as the Cbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The RtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the NrtVbr cellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for rt-VBR connections, and CAC is effectively turned off. All rt-VBR are admitted.')
atmIfCARtVbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the rt-VBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. For a per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75, and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2, and DP=1, respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 288 for low speed cards such as DS1, E1 and IMA, and set to 480 for high speed cards such as JT2, DS3, E3 and OC3 (including ATM IP FPs). For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
atmIfCARtVbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 12000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the rt-VBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
atmIfCARtVbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 75), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the rt-VBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1, and IMA, and set to 14740 for high speed cards such as JT2, DS3, E3 and OC3. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
atmIfCARtVbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs are released as a unit, according to the Vpt's holdingPriority.")
atmIfCARtVbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCARtVbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
atmIfCARtVbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC rt-VBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCARtVbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 82), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the rt-VBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCARtVbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the rt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any rt-VBR connections. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCARtVbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('minimumCdv')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the rt-VBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from another connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities.')
atmIfCARtVbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the rt-VBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue for this service category. The common queue has one set of congestion control levels for all cells enqueued on it. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCARtVbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the rt-VBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all rt-VBR connections. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCARtVbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the rt-VBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the rt-VBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCARtVbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 100, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCARtVbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all rt-VBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
atmIfCARtVbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 110), )
if mibBuilder.loadTexts: atmIfCARtVbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrOperTable.setDescription('This group contains operational attributes for the rt-VBR service category.')
atmIfCARtVbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCARtVbrIndex"))
if mibBuilder.loadTexts: atmIfCARtVbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrOperEntry.setDescription('An entry in the atmIfCARtVbrOperTable.')
atmIfCARtVbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCARtVbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped rt-VBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
atmIfCARtVbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 3, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCARtVbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCARtVbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
atmIfCANrtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4))
atmIfCANrtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1), )
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCANrtVbr components.')
atmIfCANrtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfCANrtVbr component.')
atmIfCANrtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCANrtVbr components. These components can be added.')
atmIfCANrtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCANrtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCANrtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCANrtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrStorageType.setDescription('This variable represents the storage type value for the atmIfCANrtVbr tables.')
atmIfCANrtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfCANrtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrIndex.setDescription('This variable represents the index for the atmIfCANrtVbr tables.')
atmIfCANrtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100), )
if mibBuilder.loadTexts: atmIfCANrtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrProvTable.setDescription('This group contains provisioned attributes which control the nrt- VBR service category for this interface.')
atmIfCANrtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: atmIfCANrtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrProvEntry.setDescription('An entry in the atmIfCANrtVbrProvTable.')
atmIfCANrtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the non-real-time variable bit rate (nrt-VBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfCANrtVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the nrt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
atmIfCANrtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then NrtVbr cellLossRatio = 10. This number must be greater than or equal to RtVbr cellLossRatio since rt-VBR traffic has a higher discard priority. The NrtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case no bandwidth is reserved for nrt-VBR connections, and CAC is effectively turned off. All nrt-VBR connections are admitted.')
atmIfCANrtVbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrTxQueueLimit.setDescription('This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the nrt-VBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. For per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75, and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1, and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. When using per-VC queueing, this attribute is used as the default txQueueLimit for all standard Vpts, regardless of their atmServiceCategory. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )')
atmIfCANrtVbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfCANrtVbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
atmIfCANrtVbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 30000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the nrt-VBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. This attribute is used as the default minPerVcQueueLimit for all standard Vpts, regardless of their atmServiceCategory. This attribute does not apply to basic Vpts.')
atmIfCANrtVbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the nrt-VBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. This attribute is used as the default perVcQueueLimitReferenceRate for all standard Vpts, regardless of their atmServiceCategory. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )')
atmIfCANrtVbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC nrt-VBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCANrtVbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrHoldingPriority.setDescription("This attribute specifies the holding priority which applies to SVP and SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCANrtVbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the nrt-VBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the nrt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any nrt-VBR connections. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('maximumEfficiency')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the nrt-VBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the nrt-VBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue. The common queue has one set of congestion control levels for all cells enqueued on it. For ATM IP cards, there is one common queue for the nrt-VBR service category. For CQC-based ATM cards, there is one common queue which is shared by the nrt-VBR, ABR and UBR service categories. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take the values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the nrt-VBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enabled for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all nrt-VBR connections. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the nrt-VBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the nrt-VBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCANrtVbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCANrtVbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all nrt-VBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
atmIfCANrtVbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 110), )
if mibBuilder.loadTexts: atmIfCANrtVbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrOperTable.setDescription('This group contains operational attributes for the nrt-VBR service category.')
atmIfCANrtVbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: atmIfCANrtVbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrOperEntry.setDescription('An entry in the atmIfCANrtVbrOperTable.')
atmIfCANrtVbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCANrtVbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped nrt-VBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
atmIfCANrtVbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 4, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCANrtVbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCANrtVbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
atmIfCAAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5))
atmIfCAAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1), )
if mibBuilder.loadTexts: atmIfCAAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCAAbr components.')
atmIfCAAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAAbrIndex"))
if mibBuilder.loadTexts: atmIfCAAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfCAAbr component.')
atmIfCAAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCAAbr components. These components can be added.')
atmIfCAAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCAAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrStorageType.setDescription('This variable represents the storage type value for the atmIfCAAbr tables.')
atmIfCAAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfCAAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrIndex.setDescription('This variable represents the index for the atmIfCAAbr tables.')
atmIfCAAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100), )
if mibBuilder.loadTexts: atmIfCAAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrProvTable.setDescription('This group contains provisioned attributes which control the ABR service category for this interface.')
atmIfCAAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAAbrIndex"))
if mibBuilder.loadTexts: atmIfCAAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrProvEntry.setDescription('An entry in the atmIfCAAbrProvTable.')
atmIfCAAbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the available bit rate (ABR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to ABR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfCAAbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrCdvt.setDescription('This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the ABR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component, or signalled in the SVC Traffic Descriptor Information Element. This attribute is used by dynamic generic cell rate algorithm (DGCRA) policer on ATM IP cards. On CQC-based ATM cards ABR UPC is enforced using PCR and CDVT.')
atmIfCAAbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the ABR service category. It is used as the basis for setting the discard thresholds on ABR per-VC queues. For per-VC queue, the actual limit may be reduced depending on the peak cell rate. The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1 and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
atmIfCAAbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 63488)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the ABR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the peak cell rate of that queue. This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
atmIfCAAbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the ABR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
atmIfCAAbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the ABR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAAbrFairnessPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("pcr", 2), ("pcrMinusMcr", 4))).clone('pcrMinusMcr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrFairnessPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrFairnessPolicy.setDescription('This attribute specifies the fairness policy which is applied to available bandwidth when performing the ER calculation in the ABR service category. This applies to any connection point performing explicit rate calculations. Each ABR connection is assigned a weight. Connections with a higher weight get a greater proportion of the available ABR bandwidth compared with connections that have lower weights. This attribute is ignored on CQC-based ATM cards. If the value is mcr, the congestion fairness weight is based on the Minimum Cell Rate (MCR) of the connection. If the value is pcr, the congestion fairness weight is based on the Peak Cell Rate (PCR) of the connection. If the value is pcrMinusMcr, the congestion fairness weight is based on the difference between the Peak Cell Rate and the Minimum Cell Rate (PCR - MCR) of the connection.')
atmIfCAAbrFrttPortion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrFrttPortion.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrFrttPortion.setDescription('This attribute specifies the portion of the Fixed Round Trip Time (FRTT) which is added to each ABR call setup which traverses this interface. The FRTT for the entire call is the sum of the FRTT portions for each interface traversed by the call. FRTT is used by the ABR Source or Virtual Source to adjust the value of ICR according to the rules specified in the ATM Forum TM Version 4.0 specification. The frttPortion includes propagation delay through the physical media, plus delays included by the transmission system, plus fixed components of switch processing delay. This attribute is used by ATM Networking at call set-up time for ABR connections directed over this interface.')
atmIfCAAbrAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 5))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("nonAbrInterworking", 5))).clone('abrSwitch')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrAbrConnectionType.setDescription('This attribute specifies the default type for ABR connections. It may be overridden by the abrConnectionType attribute under the Vcd Tm or Vpd Tm component, or by other configuration options. For example, for ABR end point connections originating at this switch, the Vcc Tm abrConnectionType will show sourceDest regardless of the setting of this attribute. If this attribute is set to abrSwitch, traversing ABR connections default either to erSwitch or to efciSwitch, depending on the card type and connection type. If the interface to which traffic is directed across the backplane is configured as type virtualSourceDest and this is a ATM IP FP, then connection points under this AtmIf are activated as type virtualSourceDest. If this attribute is set to virtualSourceDest, traversing ABR connections may be instantiated as one of the following types: erSwitch, efciSwitch, or virtualSourceDest. A Virtual Source- Virtual Destination (VS/VD) boundary forms a break in the end to end flow of RM cells as defined in the ATM Forum Specification for Traffic Management Version 4.0. On ATM IP cards, a VS/VD boundary can be configured for a connection providing all of the following conditions are met: 1. the ABR connection is traversing (not terminating at) this interface; 2. both this interface and next hop interface to which traffic is directed across the backplane are located on ATM IP cards; 3. one or both connecting points are configured as virtualSourceDest, 4. the next hop interface to which traffic is directed across the backplane is not configured as nonAbrInterworking, 5. the connection is not a Vcc under a standard VPT. If this attribute is set to nonAbrInterworking, this interface is defined as a point of interworking between an ABR and a non-ABR connection. In this case the next hop interface to which traffic is directed across the backplane is activated as type sourceDest. The Vcc or Vpc Tm abrConnectionType operational attribute indicates what type of ABR connection was activated.')
atmIfCAAbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the ABR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. For ATM IP cards, if this attribute is set to enforced, UPC for ABR connection is enforced as a Dynamic Generic Cell Rate Algorithm (DGCRA) based on the connection traffic descriptor. For CQC-based ATM cards, if this attribute is set to enforced, the connection enforces a single GCRA policer at the defined PCR and CDVT for this connection. When UPC is enforced on an ABR connection, non-conforming cells are discarded. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all ABR connections. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777218)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrInitialCellRate.setDescription('This attribute specifies the default Initial Cell Rate (ICR) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. When this attribute is set to some explicit number, that number is used as the ICR, provided it is between MCR and PCR. If the explicit number is below MCR, then MCR is used as ICR. If the explicit number is above PCR, then PCR is used as ICR. VALUES ( 16777217 = useMcr 16777218 = usePcr )')
atmIfCAAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrRateDecreaseFactor.setDescription('This attribute specifies the default Rate Decrease Factor (RDF) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (B- RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR.')
atmIfCAAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrRateIncreaseFactor.setDescription('This attribute specifies the default Rate Increase Factor (RIF) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (B-RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR.')
atmIfCAAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 26), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), )).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrMaxCellPerRmCell.setDescription('This attribute specifies the default number of user cells per Resource Management cell (NRM) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled as the NRM parameter in the ABR Additional Parameters Information Element. NRM is the maximum number of cells an ABR source may transmit for each forward Resource Management (F-RM) cell. The count of the cells transmitted includes user cells, OAM cells, backward RM cells, and the forward RM cell. Note that a value of 2 is not recommended even though it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the Vcc Tm or Vpc Tm operational attribute abrConnectionType indicates explicitRateMarking.')
atmIfCAAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 27), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), )).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the default time between Resource Management cells (TRM) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. TRM provides an upper bound on the time interval between forward Resource Management (F-RM) cells for an ABR source. Since the last F-RM cell was sent, if at least TRM time has elapsed and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the Vcc Tm or Vcd Tm operational attribute abrConnectionType is displayed as erSwitch. The provisioned value of 781 is signalled in the ABR Additional Parameters Information Element as 0. 1563 is signalled as 1. 3125 is signalled as 2. 6250 is signalled as 3. 12500 is signalled as 4. 25000 is signalled as 5. 50000 is signalled as 6. 100000 is signalled as 7.')
atmIfCAAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), )).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrCutoffDecreaseFactor.setDescription('This attribute specifies the default Cutoff Decrease Factor (CDF) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter. CRM is the limit of the number of forward Resource Management (F-RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the MCR, in which case the ACR is set to MCR.')
atmIfCAAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the default Allowed Cell Rate Decrease Time Factor (ADTF) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. ADTF is the time interval permitted between sending forward Resource Management (F-RM) cells before the Allowed Cell Rate (ACR) is decreased to the Initial Cell Rate (ICR). In other words, if the source does not transmit a forward RM cell for a period of ADTF centi-seconds (hundredths of a second), it will reduce its ACR to the value of its ICR. If ACR is already at or below ICR, further rate reductions are defined by the CRM ABR parameter.')
atmIfCAAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16700000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrDgcraMaximumDelay.setDescription('This attribute specifies the default maximum delay for Dynamic General Cell Rate Algorithm (DGCRA) rate changes for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component. This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (B-RM) cell departing from this interface (in the backward direction) is expected to be observed at the interface (in the forward connection). This upper bound may be approximated as the round trip sum of the fixed and propagation delays and the maximum queueing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the DGCRA. A larger value for this attribute implies a more lenient policer. When there is a decrease in the Allowed Cell Rate (ACR), the policer waits a correspondingly longer period of time before it enforces the new cell rate. The value of this attribute must be greater than or equal to dgcraMinimumDelay, since the maximum delay must be greater than or equal to the minimum delay.')
atmIfCAAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16700000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrDgcraMinimumDelay.setDescription('This attribute specifies the default minimum delay for Dynamic General Cell Rate Algorithm (DGCRA) rate changes for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component. This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (B-RM) cell departing from this interface (in the backward direction) is expected to be observed at the interface (in the forward connection). This lower bound may be approximated as the round trip sum of the fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the DGCRA. A smaller value for this attribute implies a more lenient policer. When there is an increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces the new cell rate. The value of this attribute must be less than or equal to dgcraMaximumDelay, since the maximum delay must be greater than or equal to the minimum delay.')
atmIfCAAbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 100, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAAbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC ABR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCAAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 110), )
if mibBuilder.loadTexts: atmIfCAAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrOperTable.setDescription('This group contains operational attributes for the ABR service category.')
atmIfCAAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAAbrIndex"))
if mibBuilder.loadTexts: atmIfCAAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrOperEntry.setDescription('An entry in the atmIfCAAbrOperTable.')
atmIfCAAbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 5, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAAbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAAbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
atmIfCAUbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6))
atmIfCAUbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1), )
if mibBuilder.loadTexts: atmIfCAUbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfCAUbr components.')
atmIfCAUbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAUbrIndex"))
if mibBuilder.loadTexts: atmIfCAUbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfCAUbr component.')
atmIfCAUbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfCAUbr components. These components can be added.')
atmIfCAUbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfCAUbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrStorageType.setDescription('This variable represents the storage type value for the atmIfCAUbr tables.')
atmIfCAUbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfCAUbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrIndex.setDescription('This variable represents the index for the atmIfCAUbr tables.')
atmIfCAUbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100), )
if mibBuilder.loadTexts: atmIfCAUbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrProvTable.setDescription('This group contains provisioned attributes for the UBR service category.')
atmIfCAUbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAUbrIndex"))
if mibBuilder.loadTexts: atmIfCAUbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrProvEntry.setDescription('An entry in the atmIfCAUbrProvTable.')
atmIfCAUbrMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrMaxVpcs.setDescription('This attribute specifies the maximum number of UBR Vpcs that can be activated on this AtmIf. The value must not exceed the maxVpcs attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vpcs is defined by the AtmIf/n CA maxVpcs attribute. Changes to this attribute do not affect existing Vpcs. If the value is changed to a number smaller than the current number of active UBR VPCs, no new UBR VPCs are admitted until the number of active UBR VPCs drops below the value of this attribute. The current number of active UBR VPCs is indicated by the Ubr/0 vpcUsage operational attribute. VALUES ( 16385 = sameAsCa )')
atmIfCAUbrMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrMaxVccs.setDescription('This attribute specifies the maximum number of UBR Vccs that can be activated on this AtmIf, including UBR Vpt Vccs. The value must not exceed the maxVccs attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vccs is defined by the AtmIf/n CA maxVccs attribute. Changes to this attribute do not affect existing Vccs. If the value is changed to a number smaller than the current number of active UBR VCCs, no new UBR VCCs are admitted until the number of active UBR VCCs drops below the value of this attribute. The current number of active UBR VCCs is indicated by the Ubr/0 vccUsage operational attribute. VALUES ( 16385 = sameAsCa )')
atmIfCAUbrMaxVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMaxVpts.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrMaxVpts.setDescription('This attribute specifies the maximum number of UBR Vpts that can be activated on this AtmIf. The value must not exceed the maxVpts attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vpts is defined by the AtmIf/n CA maxVpts attribute. Changes to this attribute do not affect existing Vpts. If the value is changed to a number smaller than the current number of active UBR VPTs, no new UBR VPTs are admitted until the number of active UBR VPTs drops below the value of this attribute. The current number of active UBR VPTs is indicated by the Ubr/0 vptUsage operational attribute. VALUES ( 16385 = sameAsCa )')
atmIfCAUbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the unspecified bit rate (UBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to UBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA. The amount of bandwidth reserved for each UBR connection is specified in the minimumCellRate attribute.')
atmIfCAUbrMinimumCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMinimumCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrMinimumCellRate.setDescription('This attribute specifies the minimum cell rate (MCR) which is allocated from the UBR bandwidth pool for each UBR connection which is admitted using Connection Admission Control (CAC) except for connections managed by a Vpt CA. UBR connections normally are serviced on a best effort basis, but this attribute allows allocation of a default minimum bandwidth for each connection.')
atmIfCAUbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the UBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75 and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. For per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1 and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
atmIfCAUbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 30000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the UBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
atmIfCAUbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the UBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
atmIfCAUbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the UBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the UBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any UBR connection. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('maximumEfficiency')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the UBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the UBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue. The common queue has one set of congestion control levels for all cells enqueued on it. For ATM IP cards, there is one common queue for the UBR service category. For CQC-based ATM cards, there is one common queue which is shared by the nrt-VBR, ABR and UBR service categories. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take the values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the UBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all UBR connections. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("mcr", 0), ("pcr", 2), ("ecr", 3))).clone('pcr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the UBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the UBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to mcr, the fairness weight is proportional to the default minimum cell rate (MCR) for UBR connections. If the default minimum cell rate is 0, all UBR connections get a minimum weight, which is 1. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to standard Vpt Vccs and basic Vpts.')
atmIfCAUbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all UBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. This is in conformance with the ATM Forum TM4.0 UBR.2 service definition. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This is in conformance with the ATM Forum TM4.0 UBR.1 service definition. This attribute never applies to any type of Vpt.')
atmIfCAUbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the UBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
atmIfCAUbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC UBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCAUbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfCAUbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC UBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
atmIfCAUbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110), )
if mibBuilder.loadTexts: atmIfCAUbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrOperTable.setDescription('This group contains operational attributes for the UBR service category.')
atmIfCAUbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfCAUbrIndex"))
if mibBuilder.loadTexts: atmIfCAUbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrOperEntry.setDescription('An entry in the atmIfCAUbrOperTable.')
atmIfCAUbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped UBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
atmIfCAUbrVpcUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrVpcUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrVpcUsage.setDescription('This attribute indicates the number of active UBR Vpcs under this interface. It includes switched and permanent connections.')
atmIfCAUbrVccUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrVccUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrVccUsage.setDescription('This attribute indicates the number of active UBR Vccs under this interface. It includes switched and permanent connections, and Vpt Vccs.')
atmIfCAUbrVptUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrVptUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrVptUsage.setDescription('This attribute indicates the number of active UBR Vpts under this interface.')
atmIfCAUbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 3, 6, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfCAUbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfCAUbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
atmIfVpc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4))
atmIfVpcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1), )
if mibBuilder.loadTexts: atmIfVpcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpc components.')
atmIfVpcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpc component.')
atmIfVpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpc components. These components can be added and deleted.')
atmIfVpcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStorageType.setDescription('This variable represents the storage type value for the atmIfVpc tables.')
atmIfVpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmIfVpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcIndex.setDescription('This variable represents the index for the atmIfVpc tables.')
atmIfVpcStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 100), )
if mibBuilder.loadTexts: atmIfVpcStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVpcStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStateEntry.setDescription('An entry in the atmIfVpcStateTable.')
atmIfVpcAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVpcOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVpcUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVpcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 110), )
if mibBuilder.loadTexts: atmIfVpcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
atmIfVpcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcOperEntry.setDescription('An entry in the atmIfVpcOperTable.')
atmIfVpcConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
atmIfVpcStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120), )
if mibBuilder.loadTexts: atmIfVpcStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc, or Vpt component.')
atmIfVpcStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatusEntry.setDescription('An entry in the atmIfVpcStatusTable.')
atmIfVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc, or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
atmIfVpcLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc, or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
atmIfVpcTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
atmIfVpcSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVpcSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
atmIfVpcEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVpcRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
atmIfVpcAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcAisState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVpcRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVpcTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130), )
if mibBuilder.loadTexts: atmIfVpcTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
atmIfVpcTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTrafficEntry.setDescription('An entry in the atmIfVpcTrafficTable.')
atmIfVpcTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVpcTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
atmIfVpcFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
atmIfVpcTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
atmIfVpcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVpcRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVpcRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
atmIfVpcBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVpcTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
atmIfVpcBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVpcClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
atmIfVpcBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
atmIfVpcTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVpcRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVpcBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVpcBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVpcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140), )
if mibBuilder.loadTexts: atmIfVpcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
atmIfVpcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"))
if mibBuilder.loadTexts: atmIfVpcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsEntry.setDescription('An entry in the atmIfVpcStatsTable.')
atmIfVpcStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 48), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTxUtilization.setDescription('This attribute indicates the current transmit utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVpcStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxCell.setDescription('This attribute counts cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxCellClp.setDescription('This attribute counts cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVpcStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 89), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcRxUtilization.setDescription('This attribute indicates the current receive utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVpcStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVpcTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 294), )
if mibBuilder.loadTexts: atmIfVpcTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVpcTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 294, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxTdpEntry.setDescription('An entry in the atmIfVpcTxTdpTable.')
atmIfVpcTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxTdpIndex.setDescription('This variable represents the atmIfVpcTxTdpTable specific index for the atmIfVpcTxTdpTable.')
atmIfVpcTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcTxTdpTable.')
atmIfVpcRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 295), )
if mibBuilder.loadTexts: atmIfVpcRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVpcRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 295, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxTdpEntry.setDescription('An entry in the atmIfVpcRxTdpTable.')
atmIfVpcRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVpcRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxTdpIndex.setDescription('This variable represents the atmIfVpcRxTdpTable specific index for the atmIfVpcRxTdpTable.')
atmIfVpcRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcRxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcRxTdpTable.')
atmIfVpcTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 352), )
if mibBuilder.loadTexts: atmIfVpcTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
atmIfVpcTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 352, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVpcTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQThreshEntry.setDescription('An entry in the atmIfVpcTxQThreshTable.')
atmIfVpcTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVpcTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQThreshIndex.setDescription('This variable represents the atmIfVpcTxQThreshTable specific index for the atmIfVpcTxQThreshTable.')
atmIfVpcTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVpcTxQThreshTable.')
atmIfVpcFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 357), )
if mibBuilder.loadTexts: atmIfVpcFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVpcFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 357, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcFqpIndex"))
if mibBuilder.loadTexts: atmIfVpcFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcFqpEntry.setDescription('An entry in the atmIfVpcFqpTable.')
atmIfVpcFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcFqpIndex.setDescription('This variable represents the atmIfVpcFqpTable specific index for the atmIfVpcFqpTable.')
atmIfVpcFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcFqpValue.setDescription('This variable represents an individual value for the atmIfVpcFqpTable.')
atmIfVpcBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 358), )
if mibBuilder.loadTexts: atmIfVpcBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVpcBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 358, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcBqpIndex"))
if mibBuilder.loadTexts: atmIfVpcBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBqpEntry.setDescription('An entry in the atmIfVpcBqpTable.')
atmIfVpcBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBqpIndex.setDescription('This variable represents the atmIfVpcBqpTable specific index for the atmIfVpcBqpTable.')
atmIfVpcBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcBqpValue.setDescription('This variable represents an individual value for the atmIfVpcBqpTable.')
atmIfVpcVpd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2))
atmIfVpcVpdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1), )
if mibBuilder.loadTexts: atmIfVpcVpdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcVpd components.')
atmIfVpcVpdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcVpd component.')
atmIfVpcVpdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcVpd components. These components cannot be added nor deleted.')
atmIfVpcVpdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcVpdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdStorageType.setDescription('This variable represents the storage type value for the atmIfVpcVpd tables.')
atmIfVpcVpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcVpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdIndex.setDescription('This variable represents the index for the atmIfVpcVpd tables.')
atmIfVpcVpdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100), )
if mibBuilder.loadTexts: atmIfVpcVpdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
atmIfVpcVpdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdLbkEntry.setDescription('An entry in the atmIfVpcVpdLbkTable.')
atmIfVpcVpdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
atmIfVpcVpdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
atmIfVpcVpdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
atmIfVpcVpdLoopbackMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 100, 1, 1000), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdLoopbackMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdLoopbackMonitoring.setDescription("This attribute specifies whether or not a connection monitors the OAM stream for loopback cells. Currently this attributed is only applied to Passport-specific trace cells and only affects connectingPoints. When sameAsInterface is selected, the trace visibility for the connection is based on the traceVisible attribute of the connection's parent AtmIf componentif the ATM interface is trace visible, then the connection is also trace visible. When on or off is selected, the connection is nor isn't visible to trace cells respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that trace visibility only affects connections whose connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Trace visibility is also not possible if the distributionType of the Vcc is pointToMultipoint.")
atmIfVpcVpdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110), )
if mibBuilder.loadTexts: atmIfVpcVpdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
atmIfVpcVpdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTrafficEntry.setDescription('An entry in the atmIfVpcVpdTrafficTable.')
atmIfVpcVpdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVpcVpdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
atmIfVpcVpdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVpcVpdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
atmIfVpcVpdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
atmIfVpcVpdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
atmIfVpcVpdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVpcVpdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVpcVpdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVpcVpdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
atmIfVpcVpdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVpcVpdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVpcVpdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVpcVpdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVpcVpdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVpcVpdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
atmIfVpcVpdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
atmIfVpcVpdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 111), )
if mibBuilder.loadTexts: atmIfVpcVpdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
atmIfVpcVpdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 111, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdAcctEntry.setDescription('An entry in the atmIfVpcVpdAcctTable.')
atmIfVpcVpdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
atmIfVpcVpdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 297), )
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
atmIfVpcVpdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 297, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpEntry.setDescription('An entry in the atmIfVpcVpdTxTdpTable.')
atmIfVpcVpdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpIndex.setDescription('This variable represents the atmIfVpcVpdTxTdpTable specific index for the atmIfVpcVpdTxTdpTable.')
atmIfVpcVpdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdTxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdTxTdpTable.')
atmIfVpcVpdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 298), )
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
atmIfVpcVpdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 298, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpEntry.setDescription('An entry in the atmIfVpcVpdRxTdpTable.')
atmIfVpcVpdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpIndex.setDescription('This variable represents the atmIfVpcVpdRxTdpTable specific index for the atmIfVpcVpdRxTdpTable.')
atmIfVpcVpdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdRxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdRxTdpTable.')
atmIfVpcVpdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 359), )
if mibBuilder.loadTexts: atmIfVpcVpdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVpcVpdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 359, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdFqpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFqpEntry.setDescription('An entry in the atmIfVpcVpdFqpTable.')
atmIfVpcVpdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcVpdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFqpIndex.setDescription('This variable represents the atmIfVpcVpdFqpTable specific index for the atmIfVpcVpdFqpTable.')
atmIfVpcVpdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdFqpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdFqpTable.')
atmIfVpcVpdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 360), )
if mibBuilder.loadTexts: atmIfVpcVpdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVpcVpdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 360, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdBqpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBqpEntry.setDescription('An entry in the atmIfVpcVpdBqpTable.')
atmIfVpcVpdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcVpdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBqpIndex.setDescription('This variable represents the atmIfVpcVpdBqpTable specific index for the atmIfVpcVpdBqpTable.')
atmIfVpcVpdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcVpdBqpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdBqpTable.')
atmIfVpcVpdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2))
atmIfVpcVpdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcVpdTm components.')
atmIfVpcVpdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcVpdTm component.')
atmIfVpcVpdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcVpdTm components. These components cannot be added nor deleted.')
atmIfVpcVpdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcVpdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmStorageType.setDescription('This variable represents the storage type value for the atmIfVpcVpdTm tables.')
atmIfVpcVpdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcVpdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmIndex.setDescription('This variable represents the index for the atmIfVpcVpdTm tables.')
atmIfVpcVpdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100), )
if mibBuilder.loadTexts: atmIfVpcVpdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
atmIfVpcVpdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmProvEntry.setDescription('An entry in the atmIfVpcVpdTmProvTable.')
atmIfVpcVpdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
atmIfVpcVpdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVpcVpdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. A value other than sameAsCa may be specified only for ATM IP cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
atmIfVpcVpdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
atmIfVpcVpdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
atmIfVpcVpdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVpcVpdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVpcVpdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
atmIfVpcVpdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
atmIfVpcVpdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP, and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
atmIfVpcVpdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards, and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
atmIfVpcVpdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. When monitored is selected, UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. If this is a connection of serviceCategory abr on an ATM IP card, and the abrConnectionType is sourceDest, virtualSourceDest or explicitRate, selecting enforced enables dynamic generic cell rate algorithm (DGCRA) to discard violating cells. Selecting monitored enables DGCRA to count violating cells. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
atmIfVpcVpdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVpcVpdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVpcVpdTmTxWredThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(25, 25), ValueRangeConstraint(50, 50), ValueRangeConstraint(75, 75), )).clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxWredThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxWredThreshold.setDescription('This attribute determines at what percentage of the queue being at the EPD threshold, WRED starts. When the value is set to 25%, WRED starts as soon as the queue is 25% of the way to the EPD threshold. When the value is set to 50%, WRED starts later, after the queue is 50% of the way to the EPD threshold. When the value is set to 75%, WRED starts only when the queue is 75% of the way to the EPD threshold. The EPD threshold is 85% of the transmit queue length. This attribue is ignored if txWredMode or txPacketWiseDiscard is disabled. It is always ignored on CQC-based ATM FP.')
atmIfVpcVpdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVpcVpdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVpcVpdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVpcVpdTmTxWredMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("perFlow", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxWredMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxWredMode.setDescription("This attribute specifies the activation of weighted random early detection (WRED) functionality. WRED is only available on ATM IP FPs. On CQC-based ATM FPs, this attribute is ignored. If txPacketWiseDiscard is set to disabled this attribute is ignored. This attribute is not applicable for Vpts or Vpt Vccs. WRED is applied in the transmit direction for this connection. WRED function should be enabled only for connections which are transferring TCP/IP traffic. WRED acts to prevent synchronization of multiple TCP/IP sources by randomly discarding a small percentage of frames when transmit queue congestion reaches the designated level. W-RED may also be used to differentiate service on VCC's by preferentially discarding one VCC before another. Discards start at 0% of cells, when the queue is part-way to the Early Packet Discard (EPD) threshold, and rise to 100% of cells discarded at the EPD threshold. WRED discards all the cells in a frame. If this attribute is set to enabled, WRED is enabled for all applications linked to the given Vcc. If it is set to perFlow, each TCP application has individual control over whether to enable or disable WRED If txPacketWiseDiscard is set to disabled, or if this attribute is set to disabled, WRED functionality is disabled. If WRED is active, it is visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVpcVpdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
atmIfVpcVpdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
atmIfVpcVpdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 456), )
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
atmIfVpcVpdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpEntry.setDescription('An entry in the atmIfVpcVpdTmTxTdpTable.')
atmIfVpcVpdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpIndex.setDescription('This variable represents the atmIfVpcVpdTmTxTdpTable specific index for the atmIfVpcVpdTmTxTdpTable.')
atmIfVpcVpdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdTmTxTdpTable.')
atmIfVpcVpdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 457), )
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
atmIfVpcVpdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpEntry.setDescription('An entry in the atmIfVpcVpdTmRxTdpTable.')
atmIfVpcVpdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpIndex.setDescription('This variable represents the atmIfVpcVpdTmRxTdpTable specific index for the atmIfVpcVpdTmRxTdpTable.')
atmIfVpcVpdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdTmRxTdpTable.')
atmIfVpcVpdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 458), )
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVpcVpdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmFqpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpEntry.setDescription('An entry in the atmIfVpcVpdTmFqpTable.')
atmIfVpcVpdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpIndex.setDescription('This variable represents the atmIfVpcVpdTmFqpTable specific index for the atmIfVpcVpdTmFqpTable.')
atmIfVpcVpdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmFqpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdTmFqpTable.')
atmIfVpcVpdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 459), )
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpTable.setDescription('This attribute is a vector of two elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVpcVpdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmBqpIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpEntry.setDescription('An entry in the atmIfVpcVpdTmBqpTable.')
atmIfVpcVpdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("cdv", 0), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpIndex.setDescription('This variable represents the atmIfVpcVpdTmBqpTable specific index for the atmIfVpcVpdTmBqpTable.')
atmIfVpcVpdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmBqpValue.setDescription('This variable represents an individual value for the atmIfVpcVpdTmBqpTable.')
atmIfVpcVpdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2))
atmIfVpcVpdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcVpdTmAbr components.')
atmIfVpcVpdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcVpdTmAbr component.')
atmIfVpcVpdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcVpdTmAbr components. These components can be added and deleted.')
atmIfVpcVpdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcVpdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVpcVpdTmAbr tables.')
atmIfVpcVpdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrIndex.setDescription('This variable represents the index for the atmIfVpcVpdTmAbr tables.')
atmIfVpcVpdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110), )
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
atmIfVpcVpdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcVpdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrProvEntry.setDescription('An entry in the atmIfVpcVpdTmAbrProvTable.')
atmIfVpcVpdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
atmIfVpcVpdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
atmIfVpcVpdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
atmIfVpcVpdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
atmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(1024, 1024), )).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute. VALUES ( 1024 = sameAsLocal )')
atmIfVpcVpdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777219, 16777219), )).clone(16777219)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcVpdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr. VALUES ( 16777219 = sameAsLocal )')
atmIfVpcLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3))
atmIfVpcLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1), )
if mibBuilder.loadTexts: atmIfVpcLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcLoop components.')
atmIfVpcLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcLoopIndex"))
if mibBuilder.loadTexts: atmIfVpcLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcLoop component.')
atmIfVpcLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVpcLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcLoop components. These components can be added and deleted.')
atmIfVpcLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopStorageType.setDescription('This variable represents the storage type value for the atmIfVpcLoop tables.')
atmIfVpcLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcLoopIndex.setDescription('This variable represents the index for the atmIfVpcLoop tables.')
atmIfVpcTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9))
atmIfVpcTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1), )
if mibBuilder.loadTexts: atmIfVpcTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcTm components.')
atmIfVpcTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"))
if mibBuilder.loadTexts: atmIfVpcTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcTm component.')
atmIfVpcTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcTm components. These components cannot be added nor deleted.')
atmIfVpcTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmStorageType.setDescription('This variable represents the storage type value for the atmIfVpcTm tables.')
atmIfVpcTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmIndex.setDescription('This variable represents the index for the atmIfVpcTm tables.')
atmIfVpcTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100), )
if mibBuilder.loadTexts: atmIfVpcTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
atmIfVpcTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"))
if mibBuilder.loadTexts: atmIfVpcTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmOperEntry.setDescription('An entry in the atmIfVpcTmOperTable.')
atmIfVpcTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVpcTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. This attribute does not apply to basic Vpts.')
atmIfVpcTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
atmIfVpcTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
atmIfVpcTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVpcTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. This attribute does not apply to Virtual Link VPTs and will always be displayed as constantBitRate. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVpcTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6), ("dynamic", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is dynamic. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
atmIfVpcTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVpcTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts.')
atmIfVpcTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVpcTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
atmIfVpcTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth, or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
atmIfVpcTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4), ("abrMonitored", 5), ("abrEnforced", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrEnforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection and that violating cells are discarded. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrMonitored indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection but that violating cells are counted only. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection.")
atmIfVpcTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
atmIfVpcTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
atmIfVpcTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
atmIfVpcTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVpcTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, or if the connection is not active, this attribute value is displayed as notApplicable. For CQC-based ATM cards, the only possible values are notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards, if the connectionPointType is displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
atmIfVpcTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 451), )
if mibBuilder.loadTexts: atmIfVpcTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVpcTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 451, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxTdpEntry.setDescription('An entry in the atmIfVpcTmTxTdpTable.')
atmIfVpcTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVpcTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxTdpIndex.setDescription('This variable represents the atmIfVpcTmTxTdpTable specific index for the atmIfVpcTmTxTdpTable.')
atmIfVpcTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcTmTxTdpTable.')
atmIfVpcTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 452), )
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
atmIfVpcTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 452, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshEntry.setDescription('An entry in the atmIfVpcTmTxQThreshTable.')
atmIfVpcTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshIndex.setDescription('This variable represents the atmIfVpcTmTxQThreshTable specific index for the atmIfVpcTmTxQThreshTable.')
atmIfVpcTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVpcTmTxQThreshTable.')
atmIfVpcTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 453), )
if mibBuilder.loadTexts: atmIfVpcTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 indicates the instantaneous rate at which dynamic generic cell rate algorithm (DGCRA) is in effect. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVpcTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 453, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVpcTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxTdpEntry.setDescription('An entry in the atmIfVpcTmRxTdpTable.')
atmIfVpcTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVpcTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxTdpIndex.setDescription('This variable represents the atmIfVpcTmRxTdpTable specific index for the atmIfVpcTmRxTdpTable.')
atmIfVpcTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVpcTmRxTdpTable.')
atmIfVpcTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 454), )
if mibBuilder.loadTexts: atmIfVpcTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVpcTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 454, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmTqpIndex"))
if mibBuilder.loadTexts: atmIfVpcTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTqpEntry.setDescription('An entry in the atmIfVpcTmTqpTable.')
atmIfVpcTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTqpIndex.setDescription('This variable represents the atmIfVpcTmTqpTable specific index for the atmIfVpcTmTqpTable.')
atmIfVpcTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmTqpValue.setDescription('This variable represents an individual value for the atmIfVpcTmTqpTable.')
atmIfVpcTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 455), )
if mibBuilder.loadTexts: atmIfVpcTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVpcTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 455, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmRqpIndex"))
if mibBuilder.loadTexts: atmIfVpcTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRqpEntry.setDescription('An entry in the atmIfVpcTmRqpTable.')
atmIfVpcTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVpcTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRqpIndex.setDescription('This variable represents the atmIfVpcTmRqpTable specific index for the atmIfVpcTmRqpTable.')
atmIfVpcTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmRqpValue.setDescription('This variable represents an individual value for the atmIfVpcTmRqpTable.')
atmIfVpcTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2))
atmIfVpcTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1), )
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpcTmAbr components.')
atmIfVpcTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpcTmAbr component.')
atmIfVpcTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpcTmAbr components. These components cannot be added nor deleted.')
atmIfVpcTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVpcTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVpcTmAbr tables.')
atmIfVpcTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVpcTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrIndex.setDescription('This variable represents the index for the atmIfVpcTmAbr tables.')
atmIfVpcTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110), )
if mibBuilder.loadTexts: atmIfVpcTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
atmIfVpcTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVpcTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVpcTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrOperEntry.setDescription('An entry in the atmIfVpcTmAbrOperTable.')
atmIfVpcTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrInitialCellRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
atmIfVpcTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrTransientBufferExposure.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVpcTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrFixedRoundTripTime.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVpcTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRateDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVpcTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRateIncreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVpcTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrMaxCellPerRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVpcTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrMaxTimeBetweenRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVpcTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrCutoffDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVpcTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrAcrDecreaseTimeFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVpcTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrForwardRmCellLimit.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
atmIfVpcTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrTxRateChangeInfo.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVpcTmAbrTxRateChangeInfo.setDescription('THIS ATTRIBUTE IS HISTORICAL:This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
atmIfVpcTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrAcrRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
atmIfVpcTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrTxFwdRmCells.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
atmIfVpcTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrRxEfci.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
atmIfVpcTmAbrBrmRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrBrmRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrBrmRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the values of key fields which affect the rate change. These fields are from the most recent Backward Resource Management (B-RM) cell on this connection. These fields may have been set by a connection point at some switch prior to the B-RM cell arriving at this connection point. A value of ci indicates that the Congestion Indication (CI) field is set in the B-RM cell. A value of ni indicates that the No Increase (NI) field is set in the B-RM cell. A value of er indicates that a rate decrease is indicated by the Explicit Rate in the B-RM cell having a value lower than the Current Cell Rate (CCR) field in the B-RM cell. The actual explicit rate from the B-RM cell is shown in the brmEr attribute of this component. Description of bits: ci(0) ni(1) er(2)')
atmIfVpcTmAbrBrmExplicitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 4, 9, 2, 110, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVpcTmAbrBrmExplicitRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVpcTmAbrBrmExplicitRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the value of the Explicit Rate field from the most recent Backward Resource Management (B-RM) cell on this connection. This is the rate from the B-RM cell which may be different from the explicit rate (ER) offered at this connection point. Specifically, this attribute may indicate the ER which has been set in the B-RM cell by some connection point before the B-RM cell arrived at this connection point.')
atmIfVcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5))
atmIfVccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1), )
if mibBuilder.loadTexts: atmIfVccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVcc components.')
atmIfVccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVcc component.')
atmIfVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVcc components. These components can be added and deleted.')
atmIfVccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStorageType.setDescription('This variable represents the storage type value for the atmIfVcc tables.')
atmIfVccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 10)))
if mibBuilder.loadTexts: atmIfVccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccIndex.setDescription('This variable represents the index for the atmIfVcc tables.')
atmIfVccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 100), )
if mibBuilder.loadTexts: atmIfVccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStateEntry.setDescription('An entry in the atmIfVccStateTable.')
atmIfVccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 110), )
if mibBuilder.loadTexts: atmIfVccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
atmIfVccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccOperEntry.setDescription('An entry in the atmIfVccOperTable.')
atmIfVccConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
atmIfVccConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 115), )
if mibBuilder.loadTexts: atmIfVccConnInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccConnInfoTable.setDescription('This group contains operational connection characteristics information for a Vcc component.')
atmIfVccConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 115, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccConnInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccConnInfoEntry.setDescription('An entry in the atmIfVccConnInfoTable.')
atmIfVccDistributionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 115, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipoint", 1))).clone('pointToPoint')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccDistributionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccDistributionType.setDescription('This attribute indicates the way data is distributed in the connection. A value of pointToPoint indicates this connection point is part of a point-to-point connection. A value of pointToMultipoint indicates this connection point is part of a point-to-multipoint connection.')
atmIfVccNumLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 115, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccNumLeaves.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNumLeaves.setDescription('This attribute indicates the number of destination leaves of the connection. If the distributionType is pointToPoint the value of this attribute is 0.')
atmIfVccCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 115, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fromLink", 0), ("toLink", 1), ("notApplicable", 2))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccCallDirection.setDescription('This attribute indicates the direction of the call setup request for an SVC. A value of fromLink means that the call setup originated from the link. A value of toLink means that the call setup was directed to the link. For PVC connections, the value of this attribute is notApplicable. For SPVC connections, the value of this attribute is notApplicable for Vccs with the SourcePVC and DestinationPVC subcomponents. For Signalling channels, the value of this attribute is notApplicable.')
atmIfVccStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120), )
if mibBuilder.loadTexts: atmIfVccStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc, or Vpt component.')
atmIfVccStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatusEntry.setDescription('An entry in the atmIfVccStatusTable.')
atmIfVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc, or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
atmIfVccLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc, or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
atmIfVccTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
atmIfVccSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVccSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
atmIfVccEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVccRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
atmIfVccAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccAisState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVccRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVccTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130), )
if mibBuilder.loadTexts: atmIfVccTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
atmIfVccTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTrafficEntry.setDescription('An entry in the atmIfVccTrafficTable.')
atmIfVccTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVccTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
atmIfVccFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
atmIfVccTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
atmIfVccHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVccRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVccRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
atmIfVccBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVccTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
atmIfVccBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVccClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
atmIfVccBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
atmIfVccTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVccRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVccBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVccBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140), )
if mibBuilder.loadTexts: atmIfVccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
atmIfVccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"))
if mibBuilder.loadTexts: atmIfVccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsEntry.setDescription('An entry in the atmIfVccStatsTable.')
atmIfVccStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 48), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTxUtilization.setDescription('This attribute indicates the current transmit utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVccStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxCell.setDescription('This attribute counts cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxCellClp.setDescription('This attribute counts cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVccStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 89), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccRxUtilization.setDescription('This attribute indicates the current receive utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVccStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 294), )
if mibBuilder.loadTexts: atmIfVccTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVccTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 294, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxTdpEntry.setDescription('An entry in the atmIfVccTxTdpTable.')
atmIfVccTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxTdpIndex.setDescription('This variable represents the atmIfVccTxTdpTable specific index for the atmIfVccTxTdpTable.')
atmIfVccTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxTdpValue.setDescription('This variable represents an individual value for the atmIfVccTxTdpTable.')
atmIfVccRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 295), )
if mibBuilder.loadTexts: atmIfVccRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVccRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 295, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxTdpEntry.setDescription('An entry in the atmIfVccRxTdpTable.')
atmIfVccRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVccRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxTdpIndex.setDescription('This variable represents the atmIfVccRxTdpTable specific index for the atmIfVccRxTdpTable.')
atmIfVccRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccRxTdpValue.setDescription('This variable represents an individual value for the atmIfVccRxTdpTable.')
atmIfVccTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 352), )
if mibBuilder.loadTexts: atmIfVccTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
atmIfVccTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 352, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVccTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQThreshEntry.setDescription('An entry in the atmIfVccTxQThreshTable.')
atmIfVccTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVccTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQThreshIndex.setDescription('This variable represents the atmIfVccTxQThreshTable specific index for the atmIfVccTxQThreshTable.')
atmIfVccTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVccTxQThreshTable.')
atmIfVccFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 357), )
if mibBuilder.loadTexts: atmIfVccFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVccFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 357, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccFqpIndex"))
if mibBuilder.loadTexts: atmIfVccFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccFqpEntry.setDescription('An entry in the atmIfVccFqpTable.')
atmIfVccFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccFqpIndex.setDescription('This variable represents the atmIfVccFqpTable specific index for the atmIfVccFqpTable.')
atmIfVccFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccFqpValue.setDescription('This variable represents an individual value for the atmIfVccFqpTable.')
atmIfVccBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 358), )
if mibBuilder.loadTexts: atmIfVccBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVccBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 358, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccBqpIndex"))
if mibBuilder.loadTexts: atmIfVccBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBqpEntry.setDescription('An entry in the atmIfVccBqpTable.')
atmIfVccBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBqpIndex.setDescription('This variable represents the atmIfVccBqpTable specific index for the atmIfVccBqpTable.')
atmIfVccBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccBqpValue.setDescription('This variable represents an individual value for the atmIfVccBqpTable.')
atmIfVccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2))
atmIfVccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1), )
if mibBuilder.loadTexts: atmIfVccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccVcd components.')
atmIfVccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccVcd component.')
atmIfVccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccVcd components. These components cannot be added nor deleted.')
atmIfVccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdStorageType.setDescription('This variable represents the storage type value for the atmIfVccVcd tables.')
atmIfVccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdIndex.setDescription('This variable represents the index for the atmIfVccVcd tables.')
atmIfVccVcdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100), )
if mibBuilder.loadTexts: atmIfVccVcdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
atmIfVccVcdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVccVcdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdLbkEntry.setDescription('An entry in the atmIfVccVcdLbkTable.')
atmIfVccVcdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
atmIfVccVcdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
atmIfVccVcdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
atmIfVccVcdLoopbackMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 100, 1, 1000), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdLoopbackMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdLoopbackMonitoring.setDescription("This attribute specifies whether or not a connection monitors the OAM stream for loopback cells. Currently this attributed is only applied to Passport-specific trace cells and only affects connectingPoints. When sameAsInterface is selected, the trace visibility for the connection is based on the traceVisible attribute of the connection's parent AtmIf componentif the ATM interface is trace visible, then the connection is also trace visible. When on or off is selected, the connection is nor isn't visible to trace cells respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that trace visibility only affects connections whose connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Trace visibility is also not possible if the distributionType of the Vcc is pointToMultipoint.")
atmIfVccVcdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110), )
if mibBuilder.loadTexts: atmIfVccVcdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
atmIfVccVcdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTrafficEntry.setDescription('An entry in the atmIfVccVcdTrafficTable.')
atmIfVccVcdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVccVcdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
atmIfVccVcdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVccVcdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
atmIfVccVcdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
atmIfVccVcdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
atmIfVccVcdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
atmIfVccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVccVcdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVccVcdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVccVcdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVccVcdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVccVcdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
atmIfVccVcdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
atmIfVccVcdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 111), )
if mibBuilder.loadTexts: atmIfVccVcdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
atmIfVccVcdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 111, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVccVcdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdAcctEntry.setDescription('An entry in the atmIfVccVcdAcctTable.')
atmIfVccVcdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
atmIfVccVcdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 297), )
if mibBuilder.loadTexts: atmIfVccVcdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
atmIfVccVcdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 297, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxTdpEntry.setDescription('An entry in the atmIfVccVcdTxTdpTable.')
atmIfVccVcdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccVcdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxTdpIndex.setDescription('This variable represents the atmIfVccVcdTxTdpTable specific index for the atmIfVccVcdTxTdpTable.')
atmIfVccVcdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdTxTdpValue.setDescription('This variable represents an individual value for the atmIfVccVcdTxTdpTable.')
atmIfVccVcdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 298), )
if mibBuilder.loadTexts: atmIfVccVcdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
atmIfVccVcdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 298, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxTdpEntry.setDescription('An entry in the atmIfVccVcdRxTdpTable.')
atmIfVccVcdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccVcdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxTdpIndex.setDescription('This variable represents the atmIfVccVcdRxTdpTable specific index for the atmIfVccVcdRxTdpTable.')
atmIfVccVcdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdRxTdpValue.setDescription('This variable represents an individual value for the atmIfVccVcdRxTdpTable.')
atmIfVccVcdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 359), )
if mibBuilder.loadTexts: atmIfVccVcdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVccVcdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 359, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdFqpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFqpEntry.setDescription('An entry in the atmIfVccVcdFqpTable.')
atmIfVccVcdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccVcdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFqpIndex.setDescription('This variable represents the atmIfVccVcdFqpTable specific index for the atmIfVccVcdFqpTable.')
atmIfVccVcdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdFqpValue.setDescription('This variable represents an individual value for the atmIfVccVcdFqpTable.')
atmIfVccVcdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 360), )
if mibBuilder.loadTexts: atmIfVccVcdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVccVcdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 360, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdBqpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBqpEntry.setDescription('An entry in the atmIfVccVcdBqpTable.')
atmIfVccVcdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccVcdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBqpIndex.setDescription('This variable represents the atmIfVccVcdBqpTable specific index for the atmIfVccVcdBqpTable.')
atmIfVccVcdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccVcdBqpValue.setDescription('This variable represents an individual value for the atmIfVccVcdBqpTable.')
atmIfVccVcdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2))
atmIfVccVcdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccVcdTm components.')
atmIfVccVcdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccVcdTm component.')
atmIfVccVcdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccVcdTm components. These components cannot be added nor deleted.')
atmIfVccVcdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccVcdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmStorageType.setDescription('This variable represents the storage type value for the atmIfVccVcdTm tables.')
atmIfVccVcdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccVcdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmIndex.setDescription('This variable represents the index for the atmIfVccVcdTm tables.')
atmIfVccVcdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100), )
if mibBuilder.loadTexts: atmIfVccVcdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
atmIfVccVcdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmProvEntry.setDescription('An entry in the atmIfVccVcdTmProvTable.')
atmIfVccVcdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
atmIfVccVcdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVccVcdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. A value other than sameAsCa may be specified only for ATM IP cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
atmIfVccVcdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
atmIfVccVcdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
atmIfVccVcdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVccVcdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVccVcdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
atmIfVccVcdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
atmIfVccVcdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP, and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
atmIfVccVcdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards, and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
atmIfVccVcdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. When monitored is selected, UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. If this is a connection of serviceCategory abr on an ATM IP card, and the abrConnectionType is sourceDest, virtualSourceDest or explicitRate, selecting enforced enables dynamic generic cell rate algorithm (DGCRA) to discard violating cells. Selecting monitored enables DGCRA to count violating cells. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
atmIfVccVcdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVccVcdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVccVcdTmTxWredThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(25, 25), ValueRangeConstraint(50, 50), ValueRangeConstraint(75, 75), )).clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxWredThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxWredThreshold.setDescription('This attribute determines at what percentage of the queue being at the EPD threshold, WRED starts. When the value is set to 25%, WRED starts as soon as the queue is 25% of the way to the EPD threshold. When the value is set to 50%, WRED starts later, after the queue is 50% of the way to the EPD threshold. When the value is set to 75%, WRED starts only when the queue is 75% of the way to the EPD threshold. The EPD threshold is 85% of the transmit queue length. This attribue is ignored if txWredMode or txPacketWiseDiscard is disabled. It is always ignored on CQC-based ATM FP.')
atmIfVccVcdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVccVcdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVccVcdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVccVcdTmTxWredMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("perFlow", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxWredMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxWredMode.setDescription("This attribute specifies the activation of weighted random early detection (WRED) functionality. WRED is only available on ATM IP FPs. On CQC-based ATM FPs, this attribute is ignored. If txPacketWiseDiscard is set to disabled this attribute is ignored. This attribute is not applicable for Vpts or Vpt Vccs. WRED is applied in the transmit direction for this connection. WRED function should be enabled only for connections which are transferring TCP/IP traffic. WRED acts to prevent synchronization of multiple TCP/IP sources by randomly discarding a small percentage of frames when transmit queue congestion reaches the designated level. W-RED may also be used to differentiate service on VCC's by preferentially discarding one VCC before another. Discards start at 0% of cells, when the queue is part-way to the Early Packet Discard (EPD) threshold, and rise to 100% of cells discarded at the EPD threshold. WRED discards all the cells in a frame. If this attribute is set to enabled, WRED is enabled for all applications linked to the given Vcc. If it is set to perFlow, each TCP application has individual control over whether to enable or disable WRED If txPacketWiseDiscard is set to disabled, or if this attribute is set to disabled, WRED functionality is disabled. If WRED is active, it is visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVccVcdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
atmIfVccVcdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
atmIfVccVcdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 456), )
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
atmIfVccVcdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpEntry.setDescription('An entry in the atmIfVccVcdTmTxTdpTable.')
atmIfVccVcdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpIndex.setDescription('This variable represents the atmIfVccVcdTmTxTdpTable specific index for the atmIfVccVcdTmTxTdpTable.')
atmIfVccVcdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVccVcdTmTxTdpTable.')
atmIfVccVcdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 457), )
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
atmIfVccVcdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpEntry.setDescription('An entry in the atmIfVccVcdTmRxTdpTable.')
atmIfVccVcdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpIndex.setDescription('This variable represents the atmIfVccVcdTmRxTdpTable specific index for the atmIfVccVcdTmRxTdpTable.')
atmIfVccVcdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVccVcdTmRxTdpTable.')
atmIfVccVcdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 458), )
if mibBuilder.loadTexts: atmIfVccVcdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVccVcdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmFqpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmFqpEntry.setDescription('An entry in the atmIfVccVcdTmFqpTable.')
atmIfVccVcdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccVcdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmFqpIndex.setDescription('This variable represents the atmIfVccVcdTmFqpTable specific index for the atmIfVccVcdTmFqpTable.')
atmIfVccVcdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmFqpValue.setDescription('This variable represents an individual value for the atmIfVccVcdTmFqpTable.')
atmIfVccVcdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 459), )
if mibBuilder.loadTexts: atmIfVccVcdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBqpTable.setDescription('This attribute is a vector of two elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVccVcdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmBqpIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBqpEntry.setDescription('An entry in the atmIfVccVcdTmBqpTable.')
atmIfVccVcdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("cdv", 0), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccVcdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBqpIndex.setDescription('This variable represents the atmIfVccVcdTmBqpTable specific index for the atmIfVccVcdTmBqpTable.')
atmIfVccVcdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmBqpValue.setDescription('This variable represents an individual value for the atmIfVccVcdTmBqpTable.')
atmIfVccVcdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2))
atmIfVccVcdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccVcdTmAbr components.')
atmIfVccVcdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccVcdTmAbr component.')
atmIfVccVcdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccVcdTmAbr components. These components can be added and deleted.')
atmIfVccVcdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccVcdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVccVcdTmAbr tables.')
atmIfVccVcdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccVcdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrIndex.setDescription('This variable represents the index for the atmIfVccVcdTmAbr tables.')
atmIfVccVcdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110), )
if mibBuilder.loadTexts: atmIfVccVcdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
atmIfVccVcdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVccVcdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrProvEntry.setDescription('An entry in the atmIfVccVcdTmAbrProvTable.')
atmIfVccVcdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
atmIfVccVcdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
atmIfVccVcdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
atmIfVccVcdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
atmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(1024, 1024), )).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute. VALUES ( 1024 = sameAsLocal )')
atmIfVccVcdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777219, 16777219), )).clone(16777219)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccVcdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr. VALUES ( 16777219 = sameAsLocal )')
atmIfVccLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3))
atmIfVccLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1), )
if mibBuilder.loadTexts: atmIfVccLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccLoop components.')
atmIfVccLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccLoopIndex"))
if mibBuilder.loadTexts: atmIfVccLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccLoop component.')
atmIfVccLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccLoop components. These components can be added and deleted.')
atmIfVccLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopStorageType.setDescription('This variable represents the storage type value for the atmIfVccLoop tables.')
atmIfVccLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccLoopIndex.setDescription('This variable represents the index for the atmIfVccLoop tables.')
atmIfVccNep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5))
atmIfVccNepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1), )
if mibBuilder.loadTexts: atmIfVccNepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccNep components.')
atmIfVccNepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccNepIndex"))
if mibBuilder.loadTexts: atmIfVccNepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccNep component.')
atmIfVccNepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccNepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccNep components. These components can be added and deleted.')
atmIfVccNepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccNepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccNepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccNepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepStorageType.setDescription('This variable represents the storage type value for the atmIfVccNep tables.')
atmIfVccNepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccNepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepIndex.setDescription('This variable represents the index for the atmIfVccNep tables.')
atmIfVccNepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 100), )
if mibBuilder.loadTexts: atmIfVccNepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepProvTable.setDescription('This group contains provisionable attributes for the Nep component.')
atmIfVccNepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccNepIndex"))
if mibBuilder.loadTexts: atmIfVccNepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepProvEntry.setDescription('An entry in the atmIfVccNepProvTable.')
atmIfVccNepApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 5, 100, 1, 10), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccNepApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccNepApplicationName.setDescription("This attribute specifies the application that sends and receives frames using the VCC. This attribute is set, for example, by provisioning the Trunk AtmAccess AtmConnection attribute. If it is properly configured, this attribute will show a value such as 'Trk/22 AtmAccess'.")
atmIfVccTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6))
atmIfVccTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1), )
if mibBuilder.loadTexts: atmIfVccTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccTest components.')
atmIfVccTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTestIndex"))
if mibBuilder.loadTexts: atmIfVccTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccTest component.')
atmIfVccTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccTest components. These components can be added and deleted.')
atmIfVccTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestStorageType.setDescription('This variable represents the storage type value for the atmIfVccTest tables.')
atmIfVccTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestIndex.setDescription('This variable represents the index for the atmIfVccTest tables.')
atmIfVccTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 100), )
if mibBuilder.loadTexts: atmIfVccTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVccTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTestIndex"))
if mibBuilder.loadTexts: atmIfVccTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestStateEntry.setDescription('An entry in the atmIfVccTestStateTable.')
atmIfVccTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVccTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVccTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVccTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110), )
if mibBuilder.loadTexts: atmIfVccTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestSetupTable.setDescription('This group contains attributes that govern the operation of an ATM connection test. These attributes cannot be changed while the test is running.')
atmIfVccTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTestIndex"))
if mibBuilder.loadTexts: atmIfVccTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestSetupEntry.setDescription('An entry in the atmIfVccTestSetupTable.')
atmIfVccTestFrmTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestFrmTypes.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestFrmTypes.setDescription("This attribute specifies the types of the test frames to be transmitted during the ATM connection test. It must contain at least one of the following: loading: A set of 'loading frames' is circulated over the link as rapidly as possible. This frame type should be selected when the test is intended to verify the operation of the connection under a specified load. These frames are not checked for bit errors. verification: A single 'verification frame' is transmitted over the link; when the frame is returned, its contents are verified and the next verification frame in the series is transmitted. This frame type should be selected when the test is intended to verify that frames are not being corrupted as they pass over the connection. Description of bits: loading(0) verification(1)")
atmIfVccTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestFrmSize.setDescription('This attribute defines the size of the test frames used in an ATM connection test.')
atmIfVccTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestFrmPatternType.setDescription('This attribute specifies the bit sequence used to fill the frames used in the ATM connection test. It must contain one of the following values: ccitt32kBitPattern: a pseudo-random sequence of 32 Kbit is used ccitt8MBitPattern: a pseudo-random sequence of 8Mbit is used customizedPattern: the pattern defined in the customizedPattern attribute is used')
atmIfVccTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 40), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestCustomizedPattern.setDescription('This attribute specifies a 32 bit sequence to be used to fill frames when the framePatternType attribute is set to customizedPattern. The default value gives a pattern of alternating 0 and 1 bits.')
atmIfVccTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestDuration.setDescription('This attribute specifies the maximum number of minutes that the ATM connection test is allowed to run. The maximum allowed value permits the test to be run for up to 21 days.')
atmIfVccTestBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestBandwidthElastic.setDescription('This attribute specifies whether the connection (VCC) should be configured with elastic bandwidth or not. Elastic bandwidth is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be reduced in bandwidth based on the setting of the bwElastic attribute. If this attribute is set to yes, the Test application signals to the connection that the bandwidth for this connection is elastic, and may be reduced in the case of IMA link failures. If the bandwidth is reduced, the rate of test cells which can be handled by the connection will also be reduced. If this attribute is set to no, the Test application signals to the connection that the bandwidth for this connection must be maintained at the requested level. If the connection cannot maintain the full bandwidth, the connection may be released (cleared) based on the holding priority of the connection.')
atmIfVccTestOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVccTestOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestOverrideHoldingPriority.setDescription("This attribute specifies the override holding priority which should be signalled to the VCC connection at the start of the test. Holding priority is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be released based on the connection's holding priority. Zero (0) is thie highest holding priority, and four (4) is the lowest priority. A setting of zero to four overrides whatever holding priority that has been configured at the connection (VCC). A setting of noOverride means that the connection should use its internally configured holding priority.")
atmIfVccTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120), )
if mibBuilder.loadTexts: atmIfVccTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestResultsTable.setDescription('This group contains attributes that show the result of an ATM connection test; if no test is running, the attribute group contains the results of the most recently completed test. The attributes of the Results group are reset to their inital values whenever a test is started or any attribute of the Setup group is set.')
atmIfVccTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTestIndex"))
if mibBuilder.loadTexts: atmIfVccTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestResultsEntry.setDescription('An entry in the atmIfVccTestResultsTable.')
atmIfVccTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestElapsedTime.setDescription('This attribute displays the number of minutes that the test has been running.')
atmIfVccTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestTimeRemaining.setDescription('This attribute displays the number of minutes that the test will continue to run before stopping automatically.')
atmIfVccTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("neverStarted", 2), ("testRunning", 3))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestCauseOfTermination.setDescription('This attribute displays the reason the test ended. It contains one fo the following values. testTimeExpired: the test ran for the specified duration stoppedByOperator: a STOP command was issued neverStarted: the test has not been started testRunning: the test is currently running')
atmIfVccTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestBytesTx.setDescription('This attribute displays the number of bytes sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestBytesRx.setDescription('This attribute displays the number of bytes received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestLoadingFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmTx.setDescription('This attribute displays the number of loading frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestLoadingFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmRx.setDescription('This attribute displays the number of loading frames received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestLoadingFrmLost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmLost.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestLoadingFrmLost.setDescription('This attribute displays the number of loading frames that were lost during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestVerificationFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmTx.setDescription('This attribute displays the number of verification frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTestVerificationFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmRx.setDescription('This attribute displays the number of verification frames received during the test (including errored verification frames). The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of verification frames lost during the test can be computed by the expression verificationFrmTx - verificationFrmRx.')
atmIfVccTestVerificationFrmBad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 110), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmBad.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestVerificationFrmBad.setDescription('This attribute displays the number of errored verification frames received during the test. A verification frame is considered to be errored if it contains a recognizable verification frame header, but does not match the transmitted frame bit for bit. (Thus, a verification frame that returns after the succeeding verification frame has been transmitted is considered to be errored.) The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of correct verification frames received during the test can be computed by the expression verificationFrmRx - verificationFrmBad.')
atmIfVccTestUnrecognizableFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 6, 120, 1, 120), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTestUnrecognizableFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTestUnrecognizableFrmRx.setDescription('This attribute displays the number of frames received during the test which do not contain a valid loading frame header or verification frame header. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVccTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7))
atmIfVccTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1), )
if mibBuilder.loadTexts: atmIfVccTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccTm components.')
atmIfVccTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"))
if mibBuilder.loadTexts: atmIfVccTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccTm component.')
atmIfVccTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccTm components. These components cannot be added nor deleted.')
atmIfVccTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmStorageType.setDescription('This variable represents the storage type value for the atmIfVccTm tables.')
atmIfVccTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmIndex.setDescription('This variable represents the index for the atmIfVccTm tables.')
atmIfVccTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100), )
if mibBuilder.loadTexts: atmIfVccTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
atmIfVccTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"))
if mibBuilder.loadTexts: atmIfVccTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmOperEntry.setDescription('An entry in the atmIfVccTmOperTable.')
atmIfVccTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVccTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. This attribute does not apply to basic Vpts.')
atmIfVccTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
atmIfVccTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
atmIfVccTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVccTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. This attribute does not apply to Virtual Link VPTs and will always be displayed as constantBitRate. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVccTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6), ("dynamic", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is dynamic. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
atmIfVccTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVccTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts.')
atmIfVccTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVccTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
atmIfVccTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth, or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
atmIfVccTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4), ("abrMonitored", 5), ("abrEnforced", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrEnforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection and that violating cells are discarded. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrMonitored indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection but that violating cells are counted only. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection.")
atmIfVccTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
atmIfVccTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
atmIfVccTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
atmIfVccTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVccTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, or if the connection is not active, this attribute value is displayed as notApplicable. For CQC-based ATM cards, the only possible values are notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards, if the connectionPointType is displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
atmIfVccTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 451), )
if mibBuilder.loadTexts: atmIfVccTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVccTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 451, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxTdpEntry.setDescription('An entry in the atmIfVccTmTxTdpTable.')
atmIfVccTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVccTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxTdpIndex.setDescription('This variable represents the atmIfVccTmTxTdpTable specific index for the atmIfVccTmTxTdpTable.')
atmIfVccTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVccTmTxTdpTable.')
atmIfVccTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 452), )
if mibBuilder.loadTexts: atmIfVccTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
atmIfVccTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 452, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVccTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQThreshEntry.setDescription('An entry in the atmIfVccTmTxQThreshTable.')
atmIfVccTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVccTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQThreshIndex.setDescription('This variable represents the atmIfVccTmTxQThreshTable specific index for the atmIfVccTmTxQThreshTable.')
atmIfVccTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVccTmTxQThreshTable.')
atmIfVccTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 453), )
if mibBuilder.loadTexts: atmIfVccTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 indicates the instantaneous rate at which dynamic generic cell rate algorithm (DGCRA) is in effect. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVccTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 453, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVccTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxTdpEntry.setDescription('An entry in the atmIfVccTmRxTdpTable.')
atmIfVccTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVccTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxTdpIndex.setDescription('This variable represents the atmIfVccTmRxTdpTable specific index for the atmIfVccTmRxTdpTable.')
atmIfVccTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVccTmRxTdpTable.')
atmIfVccTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 454), )
if mibBuilder.loadTexts: atmIfVccTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVccTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 454, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmTqpIndex"))
if mibBuilder.loadTexts: atmIfVccTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTqpEntry.setDescription('An entry in the atmIfVccTmTqpTable.')
atmIfVccTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTqpIndex.setDescription('This variable represents the atmIfVccTmTqpTable specific index for the atmIfVccTmTqpTable.')
atmIfVccTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmTqpValue.setDescription('This variable represents an individual value for the atmIfVccTmTqpTable.')
atmIfVccTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 455), )
if mibBuilder.loadTexts: atmIfVccTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVccTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 455, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmRqpIndex"))
if mibBuilder.loadTexts: atmIfVccTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRqpEntry.setDescription('An entry in the atmIfVccTmRqpTable.')
atmIfVccTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVccTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRqpIndex.setDescription('This variable represents the atmIfVccTmRqpTable specific index for the atmIfVccTmRqpTable.')
atmIfVccTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmRqpValue.setDescription('This variable represents an individual value for the atmIfVccTmRqpTable.')
atmIfVccTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2))
atmIfVccTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1), )
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVccTmAbr components.')
atmIfVccTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVccTmAbr component.')
atmIfVccTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVccTmAbr components. These components cannot be added nor deleted.')
atmIfVccTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVccTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVccTmAbr tables.')
atmIfVccTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVccTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrIndex.setDescription('This variable represents the index for the atmIfVccTmAbr tables.')
atmIfVccTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110), )
if mibBuilder.loadTexts: atmIfVccTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
atmIfVccTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVccTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVccTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrOperEntry.setDescription('An entry in the atmIfVccTmAbrOperTable.')
atmIfVccTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrInitialCellRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
atmIfVccTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrTransientBufferExposure.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVccTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrFixedRoundTripTime.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVccTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRateDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVccTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRateIncreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVccTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrMaxCellPerRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVccTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrMaxTimeBetweenRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVccTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrCutoffDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVccTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrAcrDecreaseTimeFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVccTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrForwardRmCellLimit.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
atmIfVccTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrTxRateChangeInfo.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVccTmAbrTxRateChangeInfo.setDescription('THIS ATTRIBUTE IS HISTORICAL:This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
atmIfVccTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrAcrRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
atmIfVccTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrTxFwdRmCells.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
atmIfVccTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrRxEfci.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
atmIfVccTmAbrBrmRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrBrmRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrBrmRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the values of key fields which affect the rate change. These fields are from the most recent Backward Resource Management (B-RM) cell on this connection. These fields may have been set by a connection point at some switch prior to the B-RM cell arriving at this connection point. A value of ci indicates that the Congestion Indication (CI) field is set in the B-RM cell. A value of ni indicates that the No Increase (NI) field is set in the B-RM cell. A value of er indicates that a rate decrease is indicated by the Explicit Rate in the B-RM cell having a value lower than the Current Cell Rate (CCR) field in the B-RM cell. The actual explicit rate from the B-RM cell is shown in the brmEr attribute of this component. Description of bits: ci(0) ni(1) er(2)')
atmIfVccTmAbrBrmExplicitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 5, 7, 2, 110, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVccTmAbrBrmExplicitRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVccTmAbrBrmExplicitRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the value of the Explicit Rate field from the most recent Backward Resource Management (B-RM) cell on this connection. This is the rate from the B-RM cell which may be different from the explicit rate (ER) offered at this connection point. Specifically, this attribute may indicate the ER which has been set in the B-RM cell by some connection point before the B-RM cell arrived at this connection point.')
atmIfNAcct = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8))
atmIfNAcctRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1), )
if mibBuilder.loadTexts: atmIfNAcctRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfNAcct components.')
atmIfNAcctRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfNAcctIndex"))
if mibBuilder.loadTexts: atmIfNAcctRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctRowStatusEntry.setDescription('A single entry in the table represents a single atmIfNAcct component.')
atmIfNAcctRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfNAcctRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfNAcct components. These components can be added and deleted.')
atmIfNAcctComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfNAcctComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfNAcctStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfNAcctStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctStorageType.setDescription('This variable represents the storage type value for the atmIfNAcct tables.')
atmIfNAcctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfNAcctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctIndex.setDescription('This variable represents the index for the atmIfNAcct tables.')
atmIfNAcctProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10), )
if mibBuilder.loadTexts: atmIfNAcctProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctProvTable.setDescription('This group contains the provisionable attributes for PVC accounting.')
atmIfNAcctProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfNAcctIndex"))
if mibBuilder.loadTexts: atmIfNAcctProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctProvEntry.setDescription('An entry in the atmIfNAcctProvTable.')
atmIfNAcctAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfNAcctAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctAccountCollection.setDescription('This attribute specifies the reason(s) for which accounting data is collected: billing, test, study, audit or force. If the set of reasons is not empty then accounting records will be generated by this interface in the following situations: - on a TODA (time of day accounting) changeover if TODA is enabled; - every 12 hours (per connection) if TODA is disabled; - when the PVC is deleted (a call record is generated with final cell counts). If none of the reasons is present, then accounting will be suppressed for all PVCs on this interface. Accounting can be suppressed on individual PVCs by specifying a null correlationTag attribute in the AtmIf NAcct component. The reason for collection is recorded in the accounting record, in the attribute callingCollectReason or calledCollectReason, as appropriate. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
atmIfNAcctAccountConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("origTerm", 0), ("intermediate", 1))).clone('origTerm')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfNAcctAccountConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctAccountConnectionType.setDescription('This attribute specifies whether accounting records generated for the PVCs on this interface should be marked as originating, terminating or intermediate. This attribute, in combination with the direction of the call, determines the value of attribute connPointType of the accounting record. It may be used by downstream accounting processing to correlate the records. If the value is origTerm then the value of attribute connPointType in the accounting records generated for incoming calls will be originating and records generated for outgoing calls will be terminating. If the value is intermediate then the value of attribute connPointType in the accounting records generated for all calls will be intermediate.')
atmIfNAcctAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfNAcctAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctAccountClass.setDescription('This attribute specifies the accounting class associated with the PVCs on this interface. Its meaning is determined by the network operator. Its value is recorded in the accounting records generated by this interface, in the attributes, callingServiceType and calledServiceType.')
atmIfNAcctServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 8, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfNAcctServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfNAcctServiceExchange.setDescription('This attribute specifies the data service exchange associated with this interface. Its meaning is determined by the network operator. Its value is recorded in the accounting records generated by this interface, in the attributes, callingDse and calledDse.')
atmIfVpt = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9))
atmIfVptRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1), )
if mibBuilder.loadTexts: atmIfVptRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVpt components.')
atmIfVptRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVpt component.')
atmIfVptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVpt components. These components can be added and deleted.')
atmIfVptComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStorageType.setDescription('This variable represents the storage type value for the atmIfVpt tables.')
atmIfVptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: atmIfVptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptIndex.setDescription('This variable represents the index for the atmIfVpt tables.')
atmIfVptStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 100), )
if mibBuilder.loadTexts: atmIfVptStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVptStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStateEntry.setDescription('An entry in the atmIfVptStateTable.')
atmIfVptAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVptOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVptUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVptOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 110), )
if mibBuilder.loadTexts: atmIfVptOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
atmIfVptOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptOperEntry.setDescription('An entry in the atmIfVptOperTable.')
atmIfVptConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
atmIfVptStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120), )
if mibBuilder.loadTexts: atmIfVptStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc, or Vpt component.')
atmIfVptStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatusEntry.setDescription('An entry in the atmIfVptStatusTable.')
atmIfVptOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc, or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
atmIfVptLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc, or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
atmIfVptTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
atmIfVptSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVptSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
atmIfVptEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVptRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
atmIfVptAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptAisState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVptRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVptTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130), )
if mibBuilder.loadTexts: atmIfVptTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
atmIfVptTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTrafficEntry.setDescription('An entry in the atmIfVptTrafficTable.')
atmIfVptTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
atmIfVptFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
atmIfVptTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
atmIfVptHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVptRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVptRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
atmIfVptBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
atmIfVptBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVptClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
atmIfVptBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
atmIfVptTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVptRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVptBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVptBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVptStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140), )
if mibBuilder.loadTexts: atmIfVptStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
atmIfVptStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"))
if mibBuilder.loadTexts: atmIfVptStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsEntry.setDescription('An entry in the atmIfVptStatsTable.')
atmIfVptStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 48), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTxUtilization.setDescription('This attribute indicates the current transmit utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVptStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxCell.setDescription('This attribute counts cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxCellClp.setDescription('This attribute counts cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 89), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptRxUtilization.setDescription('This attribute indicates the current receive utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVptStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 294), )
if mibBuilder.loadTexts: atmIfVptTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVptTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 294, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxTdpEntry.setDescription('An entry in the atmIfVptTxTdpTable.')
atmIfVptTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxTdpIndex.setDescription('This variable represents the atmIfVptTxTdpTable specific index for the atmIfVptTxTdpTable.')
atmIfVptTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptTxTdpTable.')
atmIfVptRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 295), )
if mibBuilder.loadTexts: atmIfVptRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVptRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 295, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxTdpEntry.setDescription('An entry in the atmIfVptRxTdpTable.')
atmIfVptRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVptRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxTdpIndex.setDescription('This variable represents the atmIfVptRxTdpTable specific index for the atmIfVptRxTdpTable.')
atmIfVptRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptRxTdpTable.')
atmIfVptTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 352), )
if mibBuilder.loadTexts: atmIfVptTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
atmIfVptTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 352, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVptTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQThreshEntry.setDescription('An entry in the atmIfVptTxQThreshTable.')
atmIfVptTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVptTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQThreshIndex.setDescription('This variable represents the atmIfVptTxQThreshTable specific index for the atmIfVptTxQThreshTable.')
atmIfVptTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVptTxQThreshTable.')
atmIfVptFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 357), )
if mibBuilder.loadTexts: atmIfVptFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 357, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptFqpIndex"))
if mibBuilder.loadTexts: atmIfVptFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptFqpEntry.setDescription('An entry in the atmIfVptFqpTable.')
atmIfVptFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptFqpIndex.setDescription('This variable represents the atmIfVptFqpTable specific index for the atmIfVptFqpTable.')
atmIfVptFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptFqpValue.setDescription('This variable represents an individual value for the atmIfVptFqpTable.')
atmIfVptBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 358), )
if mibBuilder.loadTexts: atmIfVptBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 358, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptBqpIndex"))
if mibBuilder.loadTexts: atmIfVptBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBqpEntry.setDescription('An entry in the atmIfVptBqpTable.')
atmIfVptBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBqpIndex.setDescription('This variable represents the atmIfVptBqpTable specific index for the atmIfVptBqpTable.')
atmIfVptBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptBqpValue.setDescription('This variable represents an individual value for the atmIfVptBqpTable.')
atmIfVptVpd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2))
atmIfVptVpdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVpdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVpd components.')
atmIfVptVpdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"))
if mibBuilder.loadTexts: atmIfVptVpdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVpd component.')
atmIfVptVpdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVpd components. These components cannot be added nor deleted.')
atmIfVptVpdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVpdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdStorageType.setDescription('This variable represents the storage type value for the atmIfVptVpd tables.')
atmIfVptVpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdIndex.setDescription('This variable represents the index for the atmIfVptVpd tables.')
atmIfVptVpdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100), )
if mibBuilder.loadTexts: atmIfVptVpdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
atmIfVptVpdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"))
if mibBuilder.loadTexts: atmIfVptVpdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdLbkEntry.setDescription('An entry in the atmIfVptVpdLbkTable.')
atmIfVptVpdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
atmIfVptVpdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
atmIfVptVpdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
atmIfVptVpdLoopbackMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 100, 1, 1000), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdLoopbackMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdLoopbackMonitoring.setDescription("This attribute specifies whether or not a connection monitors the OAM stream for loopback cells. Currently this attributed is only applied to Passport-specific trace cells and only affects connectingPoints. When sameAsInterface is selected, the trace visibility for the connection is based on the traceVisible attribute of the connection's parent AtmIf componentif the ATM interface is trace visible, then the connection is also trace visible. When on or off is selected, the connection is nor isn't visible to trace cells respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that trace visibility only affects connections whose connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Trace visibility is also not possible if the distributionType of the Vcc is pointToMultipoint.")
atmIfVptVpdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110), )
if mibBuilder.loadTexts: atmIfVptVpdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
atmIfVptVpdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTrafficEntry.setDescription('An entry in the atmIfVptVpdTrafficTable.')
atmIfVptVpdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptVpdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
atmIfVptVpdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVptVpdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
atmIfVptVpdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
atmIfVptVpdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
atmIfVptVpdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVptVpdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVpdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVptVpdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
atmIfVptVpdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVptVpdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVptVpdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVpdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVptVpdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVpdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
atmIfVptVpdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
atmIfVptVpdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 111), )
if mibBuilder.loadTexts: atmIfVptVpdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
atmIfVptVpdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 111, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"))
if mibBuilder.loadTexts: atmIfVptVpdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdAcctEntry.setDescription('An entry in the atmIfVptVpdAcctTable.')
atmIfVptVpdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
atmIfVptVpdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 112), )
if mibBuilder.loadTexts: atmIfVptVpdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdProvTable.setDescription('This group contains the provisionable ATM Virtual Path Descriptor attributes for a Vpt component.')
atmIfVptVpdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 112, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"))
if mibBuilder.loadTexts: atmIfVptVpdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdProvEntry.setDescription('An entry in the atmIfVptVpdProvTable.')
atmIfVptVpdVptType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 112, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("basic", 0), ("standard", 1), ("virtualLink", 2))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdVptType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdVptType.setDescription('This attribute specifies the type of the Vpt. On CQC-based ATM FPs all Vpts must be basic. Vpts on ATM IP FPs may be of any type. A value of basic configures one level of traffic management (TM) for the VPT, at the VC level. VCs within the VP are treated like independent VCC connections, and thus, are scheduled the same as other VCs under the AtmIf, with no scheduling done for the VP itself. A value of standard configures two levels of TM for the VPT, one level for VP TM and one level for VC level TM. VCs within the VP use weighted fair queueing (standard VPT VCC scheduling) to schedule VCs within the VPT, with VCs differentiated as either real-time (CBR, rt-VBR) or non-real-time (nrt-VBR, UBR) connections. The VP itself has a full range of emission scheduling and service category differentiation available between itself and the other connections under the AtmIf.')
atmIfVptVpdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 297), )
if mibBuilder.loadTexts: atmIfVptVpdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
atmIfVptVpdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 297, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxTdpEntry.setDescription('An entry in the atmIfVptVpdTxTdpTable.')
atmIfVptVpdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVpdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxTdpIndex.setDescription('This variable represents the atmIfVptVpdTxTdpTable specific index for the atmIfVptVpdTxTdpTable.')
atmIfVptVpdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVpdTxTdpTable.')
atmIfVptVpdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 298), )
if mibBuilder.loadTexts: atmIfVptVpdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
atmIfVptVpdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 298, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxTdpEntry.setDescription('An entry in the atmIfVptVpdRxTdpTable.')
atmIfVptVpdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVpdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxTdpIndex.setDescription('This variable represents the atmIfVptVpdRxTdpTable specific index for the atmIfVptVpdRxTdpTable.')
atmIfVptVpdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVpdRxTdpTable.')
atmIfVptVpdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 359), )
if mibBuilder.loadTexts: atmIfVptVpdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVpdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 359, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdFqpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFqpEntry.setDescription('An entry in the atmIfVptVpdFqpTable.')
atmIfVptVpdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVpdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFqpIndex.setDescription('This variable represents the atmIfVptVpdFqpTable specific index for the atmIfVptVpdFqpTable.')
atmIfVptVpdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdFqpValue.setDescription('This variable represents an individual value for the atmIfVptVpdFqpTable.')
atmIfVptVpdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 360), )
if mibBuilder.loadTexts: atmIfVptVpdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVpdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 360, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdBqpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBqpEntry.setDescription('An entry in the atmIfVptVpdBqpTable.')
atmIfVptVpdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVpdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBqpIndex.setDescription('This variable represents the atmIfVptVpdBqpTable specific index for the atmIfVptVpdBqpTable.')
atmIfVptVpdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVpdBqpValue.setDescription('This variable represents an individual value for the atmIfVptVpdBqpTable.')
atmIfVptVpdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2))
atmIfVptVpdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVpdTm components.')
atmIfVptVpdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVpdTm component.')
atmIfVptVpdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVpdTm components. These components cannot be added nor deleted.')
atmIfVptVpdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVpdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmStorageType.setDescription('This variable represents the storage type value for the atmIfVptVpdTm tables.')
atmIfVptVpdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVpdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmIndex.setDescription('This variable represents the index for the atmIfVptVpdTm tables.')
atmIfVptVpdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100), )
if mibBuilder.loadTexts: atmIfVptVpdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
atmIfVptVpdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmProvEntry.setDescription('An entry in the atmIfVptVpdTmProvTable.')
atmIfVptVpdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
atmIfVptVpdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVptVpdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. A value other than sameAsCa may be specified only for ATM IP cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
atmIfVptVpdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
atmIfVptVpdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
atmIfVptVpdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVptVpdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVpdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
atmIfVptVpdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
atmIfVptVpdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP, and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
atmIfVptVpdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards, and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
atmIfVptVpdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. When monitored is selected, UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. If this is a connection of serviceCategory abr on an ATM IP card, and the abrConnectionType is sourceDest, virtualSourceDest or explicitRate, selecting enforced enables dynamic generic cell rate algorithm (DGCRA) to discard violating cells. Selecting monitored enables DGCRA to count violating cells. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
atmIfVptVpdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVptVpdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVpdTmTxWredThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(25, 25), ValueRangeConstraint(50, 50), ValueRangeConstraint(75, 75), )).clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxWredThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxWredThreshold.setDescription('This attribute determines at what percentage of the queue being at the EPD threshold, WRED starts. When the value is set to 25%, WRED starts as soon as the queue is 25% of the way to the EPD threshold. When the value is set to 50%, WRED starts later, after the queue is 50% of the way to the EPD threshold. When the value is set to 75%, WRED starts only when the queue is 75% of the way to the EPD threshold. The EPD threshold is 85% of the transmit queue length. This attribue is ignored if txWredMode or txPacketWiseDiscard is disabled. It is always ignored on CQC-based ATM FP.')
atmIfVptVpdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVptVpdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVpdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVptVpdTmTxWredMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("perFlow", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxWredMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxWredMode.setDescription("This attribute specifies the activation of weighted random early detection (WRED) functionality. WRED is only available on ATM IP FPs. On CQC-based ATM FPs, this attribute is ignored. If txPacketWiseDiscard is set to disabled this attribute is ignored. This attribute is not applicable for Vpts or Vpt Vccs. WRED is applied in the transmit direction for this connection. WRED function should be enabled only for connections which are transferring TCP/IP traffic. WRED acts to prevent synchronization of multiple TCP/IP sources by randomly discarding a small percentage of frames when transmit queue congestion reaches the designated level. W-RED may also be used to differentiate service on VCC's by preferentially discarding one VCC before another. Discards start at 0% of cells, when the queue is part-way to the Early Packet Discard (EPD) threshold, and rise to 100% of cells discarded at the EPD threshold. WRED discards all the cells in a frame. If this attribute is set to enabled, WRED is enabled for all applications linked to the given Vcc. If it is set to perFlow, each TCP application has individual control over whether to enable or disable WRED If txPacketWiseDiscard is set to disabled, or if this attribute is set to disabled, WRED functionality is disabled. If WRED is active, it is visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVptVpdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
atmIfVptVpdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
atmIfVptVpdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 456), )
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
atmIfVptVpdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpEntry.setDescription('An entry in the atmIfVptVpdTmTxTdpTable.')
atmIfVptVpdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpIndex.setDescription('This variable represents the atmIfVptVpdTmTxTdpTable specific index for the atmIfVptVpdTmTxTdpTable.')
atmIfVptVpdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVpdTmTxTdpTable.')
atmIfVptVpdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 457), )
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
atmIfVptVpdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpEntry.setDescription('An entry in the atmIfVptVpdTmRxTdpTable.')
atmIfVptVpdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpIndex.setDescription('This variable represents the atmIfVptVpdTmRxTdpTable specific index for the atmIfVptVpdTmRxTdpTable.')
atmIfVptVpdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVpdTmRxTdpTable.')
atmIfVptVpdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 458), )
if mibBuilder.loadTexts: atmIfVptVpdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVpdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmFqpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmFqpEntry.setDescription('An entry in the atmIfVptVpdTmFqpTable.')
atmIfVptVpdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVpdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmFqpIndex.setDescription('This variable represents the atmIfVptVpdTmFqpTable specific index for the atmIfVptVpdTmFqpTable.')
atmIfVptVpdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmFqpValue.setDescription('This variable represents an individual value for the atmIfVptVpdTmFqpTable.')
atmIfVptVpdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 459), )
if mibBuilder.loadTexts: atmIfVptVpdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBqpTable.setDescription('This attribute is a vector of two elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVpdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmBqpIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBqpEntry.setDescription('An entry in the atmIfVptVpdTmBqpTable.')
atmIfVptVpdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("cdv", 0), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVpdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBqpIndex.setDescription('This variable represents the atmIfVptVpdTmBqpTable specific index for the atmIfVptVpdTmBqpTable.')
atmIfVptVpdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmBqpValue.setDescription('This variable represents an individual value for the atmIfVptVpdTmBqpTable.')
atmIfVptVpdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2))
atmIfVptVpdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVpdTmAbr components.')
atmIfVptVpdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVpdTmAbr component.')
atmIfVptVpdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVpdTmAbr components. These components can be added and deleted.')
atmIfVptVpdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVpdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptVpdTmAbr tables.')
atmIfVptVpdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVpdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrIndex.setDescription('This variable represents the index for the atmIfVptVpdTmAbr tables.')
atmIfVptVpdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110), )
if mibBuilder.loadTexts: atmIfVptVpdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
atmIfVptVpdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVpdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVpdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrProvEntry.setDescription('An entry in the atmIfVptVpdTmAbrProvTable.')
atmIfVptVpdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
atmIfVptVpdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
atmIfVptVpdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
atmIfVptVpdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
atmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(1024, 1024), )).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute. VALUES ( 1024 = sameAsLocal )')
atmIfVptVpdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777219, 16777219), )).clone(16777219)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVpdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr. VALUES ( 16777219 = sameAsLocal )')
atmIfVptCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5))
atmIfVptCARowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1), )
if mibBuilder.loadTexts: atmIfVptCARowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCA components.')
atmIfVptCARowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"))
if mibBuilder.loadTexts: atmIfVptCARowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCA component.')
atmIfVptCARowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCA components. These components can be added and deleted.')
atmIfVptCAComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCAStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAStorageType.setDescription('This variable represents the storage type value for the atmIfVptCA tables.')
atmIfVptCAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptCAIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAIndex.setDescription('This variable represents the index for the atmIfVptCA tables.')
atmIfVptCAProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 100), )
if mibBuilder.loadTexts: atmIfVptCAProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for the ATM connections associated with a Virtual Path Terminator. Note that the names of some of the attributes follow the conventions of UNI 4.0 for forward compatibility reasons. This does not imply conformance in general with the UNI 4.0 specification. The provisioned attributes of this ConnectionAdministrator will override those of the AtmIf CA, for all connections associated with this Vpt. Any attributes of the AtmIf CA that cannot be overridden in the Vpt CA affect all connections, including Vpt Vccs.')
atmIfVptCAProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"))
if mibBuilder.loadTexts: atmIfVptCAProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAProvEntry.setDescription('An entry in the atmIfVptCAProvTable.')
atmIfVptCAMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAMaxVccs.setDescription('This attribute specifies the maximum number of Vccs that can be associated with this Vpt. The value must not exceed the maxVccs attribute of the Atmif CA.')
atmIfVptCAPermittedAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 100, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAPermittedAtmServiceCategories.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPermittedAtmServiceCategories.setDescription('This attribute specifies which ATM service categories are permitted on this Vpt for SVCs. The value of this attribute does not affect control Vccs, such as signalling and ILMI channels. If the value is empty, no SVCs are permitted to use this Vpt. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)')
atmIfVptCAOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110), )
if mibBuilder.loadTexts: atmIfVptCAOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAOperTable.setDescription('This group contains operational attributes giving statistics about the ATM connections associated with a Virtual Path Terminator (VPT).')
atmIfVptCAOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"))
if mibBuilder.loadTexts: atmIfVptCAOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAOperEntry.setDescription('An entry in the atmIfVptCAOperTable.')
atmIfVptCAPermanentVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPermanentVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPermanentVccs.setDescription('This attribute indicates the number of permanent Vccs that are currently associated with this Vpt.')
atmIfVptCASwitchedVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110, 1, 30), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCASwitchedVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCASwitchedVccs.setDescription('This attribute indicates the number of switched Vccs that are currently associated with this Vpt.')
atmIfVptCATroubledVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCATroubledVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCATroubledVccs.setDescription("This attribute indicates the number of troubled Vccs associated with this Vpt. A Vcc is 'troubled' if its operational troubled attribute has the value yes.")
atmIfVptCAConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 110, 1, 81), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAConnectionPoolUsage.setDescription('This attribute indicates the number of allocated VCCs associated with this VPT. Each of these VCCs uses a connection out of the pool defined by the Arc totalConnectionPoolAvailable attribute.')
atmIfVptCAPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 460), )
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwTable.setDescription('This attribute indicates the total available bandwidth in the corresponding bandwidthPool. A non-zero number indicates that there is still bandwidth available in the pool which has not been allocated.')
atmIfVptCAPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 460, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolAvailBwIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwEntry.setDescription('An entry in the atmIfVptCAPoolAvailBwTable.')
atmIfVptCAPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 460, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwIndex.setDescription('This variable represents the atmIfVptCAPoolAvailBwTable specific index for the atmIfVptCAPoolAvailBwTable.')
atmIfVptCAPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 460, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAvailBwValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolAvailBwTable.')
atmIfVptCABwPoolTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 461), )
if mibBuilder.loadTexts: atmIfVptCABwPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCABwPoolTable.setDescription('Total bandwidth capacity is partitioned into five bandwidth pools. This attribute specifies the percentage of Vpt bandwidth that is allowed for each pool. The percentage for each pool ranges from 0% to 12,800%. This allows for both under and over subscription of the VPT bandwidth. Under subscription occurs when the sum of the percentages assigned to the five pools is less than 100%. Over subscription occurs when the sum of the percentages for the five pools exceeds 100%.')
atmIfVptCABwPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 461, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCABwPoolIndex"))
if mibBuilder.loadTexts: atmIfVptCABwPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCABwPoolEntry.setDescription('An entry in the atmIfVptCABwPoolTable.')
atmIfVptCABwPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 461, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCABwPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCABwPoolIndex.setDescription('This variable represents the atmIfVptCABwPoolTable specific index for the atmIfVptCABwPoolTable.')
atmIfVptCABwPoolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 461, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCABwPoolValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCABwPoolValue.setDescription('This variable represents an individual value for the atmIfVptCABwPoolTable.')
atmIfVptCAPoolProvBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 462), )
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwTable.setDescription('This attribute indicates the total provisioned bandwidth from the corresponding bandwidthPool. Its value is the sum of the equivalent cell rates (ECR) of the provisioned connections.')
atmIfVptCAPoolProvBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 462, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolProvBwIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwEntry.setDescription('An entry in the atmIfVptCAPoolProvBwTable.')
atmIfVptCAPoolProvBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 462, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwIndex.setDescription('This variable represents the atmIfVptCAPoolProvBwTable specific index for the atmIfVptCAPoolProvBwTable.')
atmIfVptCAPoolProvBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 462, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolProvBwValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolProvBwTable.')
atmIfVptCAPoolRequBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 463), )
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwTable.setDescription('This attribute indicates the total requested bandwidth from the corresponding bandwidthPool. Its value is the sum of the equivalent cell rates (ECR) for connections which are admitted and connections which are requesting admission, but have not yet been admitted.')
atmIfVptCAPoolRequBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 463, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolRequBwIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwEntry.setDescription('An entry in the atmIfVptCAPoolRequBwTable.')
atmIfVptCAPoolRequBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 463, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwIndex.setDescription('This variable represents the atmIfVptCAPoolRequBwTable specific index for the atmIfVptCAPoolRequBwTable.')
atmIfVptCAPoolRequBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 463, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolRequBwValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolRequBwTable.')
atmIfVptCAPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 464), )
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwTable.setDescription('This attribute indicates the total admitted bandwidth in the corresponding bandwidthPool. Its value is the sum of the equivalent cell rates (ECR) of the admitted connections.')
atmIfVptCAPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 464, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolAdmitBwIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwEntry.setDescription('An entry in the atmIfVptCAPoolAdmitBwTable.')
atmIfVptCAPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 464, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwIndex.setDescription('This variable represents the atmIfVptCAPoolAdmitBwTable specific index for the atmIfVptCAPoolAdmitBwTable.')
atmIfVptCAPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 464, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmitBwValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolAdmitBwTable.')
atmIfVptCAPoolAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 465), )
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsTable.setDescription('This attribute indicates the total number of connections which are currently admitted in the corresponding bandwidthPool.')
atmIfVptCAPoolAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 465, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolAdmConnsIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsEntry.setDescription('An entry in the atmIfVptCAPoolAdmConnsTable.')
atmIfVptCAPoolAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 465, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsIndex.setDescription('This variable represents the atmIfVptCAPoolAdmConnsTable specific index for the atmIfVptCAPoolAdmConnsTable.')
atmIfVptCAPoolAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 465, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolAdmConnsValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolAdmConnsTable.')
atmIfVptCAPoolWaitAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 466), )
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsTable.setDescription('This attribute indicates the total number of connections which have currently requested admission in the corresponding bandwidthPool but are not yet admitted.')
atmIfVptCAPoolWaitAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 466, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAPoolWaitAdmConnsIndex"))
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsEntry.setDescription('An entry in the atmIfVptCAPoolWaitAdmConnsTable.')
atmIfVptCAPoolWaitAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 466, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsIndex.setDescription('This variable represents the atmIfVptCAPoolWaitAdmConnsTable specific index for the atmIfVptCAPoolWaitAdmConnsTable.')
atmIfVptCAPoolWaitAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 466, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAPoolWaitAdmConnsValue.setDescription('This variable represents an individual value for the atmIfVptCAPoolWaitAdmConnsTable.')
atmIfVptCACbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2))
atmIfVptCACbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1), )
if mibBuilder.loadTexts: atmIfVptCACbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCACbr components.')
atmIfVptCACbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCACbrIndex"))
if mibBuilder.loadTexts: atmIfVptCACbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCACbr component.')
atmIfVptCACbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCACbr components. These components can be added.')
atmIfVptCACbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCACbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCACbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCACbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptCACbr tables.')
atmIfVptCACbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfVptCACbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrIndex.setDescription('This variable represents the index for the atmIfVptCACbr tables.')
atmIfVptCACbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100), )
if mibBuilder.loadTexts: atmIfVptCACbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and Usage Parameter Control (UPC) attributes for the CBR ATM connections managed by this Vpt. Any attributes of the AtmIf CA Cbr that cannot be overridden in the Vpt CA Cbr affect all connections, including Vpt Vccs.')
atmIfVptCACbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCACbrIndex"))
if mibBuilder.loadTexts: atmIfVptCACbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrProvEntry.setDescription('An entry in the atmIfVptCACbrProvTable.')
atmIfVptCACbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfVptCACbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for connections of the CBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is used by the CAC function to compute the equivalent cell rate (ECR) required by a given CBR connection. The larger the value of CDVT, the larger is its ECR. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function on the ingress to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
atmIfVptCACbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrCdv.setDescription("This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to connections associated with this Vpt for CBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's CDV requirement. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.")
atmIfVptCACbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to all connections associated with this Vpt for CBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's MaxCTD requirement.")
atmIfVptCACbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 2, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCACbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCACbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then Cbr cellLossRatio = 10. This number must be the same as the RtVbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The Cbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for CBR connections, and CAC is effectively turned off. All CBR connections are admitted.')
atmIfVptCARtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3))
atmIfVptCARtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1), )
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCARtVbr components.')
atmIfVptCARtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCARtVbrIndex"))
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCARtVbr component.')
atmIfVptCARtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCARtVbr components. These components can be added.')
atmIfVptCARtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCARtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCARtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCARtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptCARtVbr tables.')
atmIfVptCARtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfVptCARtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrIndex.setDescription('This variable represents the index for the atmIfVptCARtVbr tables.')
atmIfVptCARtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100), )
if mibBuilder.loadTexts: atmIfVptCARtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and UPC attributes for the rt- VBR ATM connections associated with this Vpt. Any attributes of the AtmIf CA RtVbr that cannot be overridden in the Vpt CA RtVbr affect all connections, including Vpt Vccs.')
atmIfVptCARtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCARtVbrIndex"))
if mibBuilder.loadTexts: atmIfVptCARtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrProvEntry.setDescription('An entry in the atmIfVptCARtVbrProvTable.')
atmIfVptCARtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the real-time variable bit rate (rt-VBR) service category. The percentage of Vpt capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the Vpt CA.')
atmIfVptCARtVbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1268)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARtVbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to all rt-VBR connections associated with this Vpt. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the CDV requirement for that connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
atmIfVptCARtVbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARtVbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to all rt-VBR connections associated with this Vpt. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's MaxCTD requirement.")
atmIfVptCARtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 3, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCARtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCARtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then RtVbr cellLossRatio = 10. This number must be the same as the Cbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The RtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the NrtVbr cellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for rt-VBR connections and CAC is effectively turned off. All rt-VBR connections are admitted.')
atmIfVptCANrtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4))
atmIfVptCANrtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1), )
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCANrtVbr components.')
atmIfVptCANrtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCANrtVbrIndex"))
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCANrtVbr component.')
atmIfVptCANrtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCANrtVbr components. These components can be added.')
atmIfVptCANrtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCANrtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCANrtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCANrtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptCANrtVbr tables.')
atmIfVptCANrtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfVptCANrtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrIndex.setDescription('This variable represents the index for the atmIfVptCANrtVbr tables.')
atmIfVptCANrtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 100), )
if mibBuilder.loadTexts: atmIfVptCANrtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and UPC attributes for the nrt-VBR ATM connections associated with this Vpt. Any attributes of the AtmIf CA NrtVbr that cannot be overridden in the Vpt CA NrtVbr affect all connections, including Vpt Vccs.')
atmIfVptCANrtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCANrtVbrIndex"))
if mibBuilder.loadTexts: atmIfVptCANrtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrProvEntry.setDescription('An entry in the atmIfVptCANrtVbrProvTable.')
atmIfVptCANrtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCANrtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the non-real time variable bit rate (nrt-VBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfVptCANrtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 4, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCANrtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCANrtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic. The number is the negative logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then NrtVbr cellLossRatio = 10. This number must be greater than or equal to RtVbr cellLossRatio since rt-VBR traffic has a higher discard priority. The NrtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for nrt-VBR connections, and CAC is effectively turned off. All nrt-VBR connections are admitted.')
atmIfVptCAAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5))
atmIfVptCAAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1), )
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCAAbr components.')
atmIfVptCAAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAAbrIndex"))
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCAAbr component.')
atmIfVptCAAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCAAbr components. These components can be added.')
atmIfVptCAAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCAAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptCAAbr tables.')
atmIfVptCAAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfVptCAAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrIndex.setDescription('This variable represents the index for the atmIfVptCAAbr tables.')
atmIfVptCAAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 100), )
if mibBuilder.loadTexts: atmIfVptCAAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for ABR connections associated with this Vpt. Any attributes of the AtmIf CA Abr that cannot be overridden in the Vpt CA Abr affect all connections, including Vpt Vccs.')
atmIfVptCAAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAAbrIndex"))
if mibBuilder.loadTexts: atmIfVptCAAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrProvEntry.setDescription('An entry in the atmIfVptCAAbrProvTable.')
atmIfVptCAAbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 5, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAAbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAAbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the available bit rate (ABR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to ABR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfVptCAUbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6))
atmIfVptCAUbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1), )
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptCAUbr components.')
atmIfVptCAUbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptCAUbr component.')
atmIfVptCAUbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptCAUbr components. These components can be added.')
atmIfVptCAUbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAUbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptCAUbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAUbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptCAUbr tables.')
atmIfVptCAUbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: atmIfVptCAUbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrIndex.setDescription('This variable represents the index for the atmIfVptCAUbr tables.')
atmIfVptCAUbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 100), )
if mibBuilder.loadTexts: atmIfVptCAUbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for UBR connections associated with this Vpt. Any attributes of the AtmIf CA Ubr that cannot be overridden in the Vpt CA Ubr affect all connections, including Vpt Vccs.')
atmIfVptCAUbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: atmIfVptCAUbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrProvEntry.setDescription('An entry in the atmIfVptCAUbrProvTable.')
atmIfVptCAUbrMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAUbrMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrMaxVccs.setDescription('This attribute specifies the maximum number of UBR Vccs that can be configured associated with this Vpt. The value must not exceed the maxVccs attribute of the parent Vpt CA component. If this attribute is set to sameAsCa, the maximum number of UBR Vccs is the same as specified by the maxVccs attribute of the Vpt CA. Changes to this attribute are not critical to the Vpt. If the value is changed to a number smaller than the current number of active VCCs, no new VCCs can be admitted until the number of active VCCs drops below the value of this attribute. The current number of active VCCs is indicated by the sum of the permanentVccs and switchedVccs operational attribute under the Vpt CA component. VALUES ( 16385 = sameAsCa )')
atmIfVptCAUbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAUbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the unspecified bit rate (UBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to UBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
atmIfVptCAUbrMinimumCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptCAUbrMinimumCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrMinimumCellRate.setDescription('This attribute specifies the default minimum cell rate (MCR) which is allocated from the UBR pool bandwidth for each UBR connection which is admitted. UBR connections normally are serviced on a best effort basis, but this attribute allows allocation of a default minimum bandwidth for each connection.')
atmIfVptCAUbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 110), )
if mibBuilder.loadTexts: atmIfVptCAUbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrOperTable.setDescription('This group contains operational attributes which show operational attributes for UBR connections associated with this Vpt.')
atmIfVptCAUbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: atmIfVptCAUbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrOperEntry.setDescription('An entry in the atmIfVptCAUbrOperTable.')
atmIfVptCAUbrVccUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 5, 6, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptCAUbrVccUsage.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptCAUbrVccUsage.setDescription('This attribute indicates the number of active UBR Vccs under this Vpt. It includes switched and permanent connections.')
atmIfVptTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9))
atmIfVptTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1), )
if mibBuilder.loadTexts: atmIfVptTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptTm components.')
atmIfVptTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"))
if mibBuilder.loadTexts: atmIfVptTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptTm component.')
atmIfVptTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptTm components. These components cannot be added nor deleted.')
atmIfVptTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmStorageType.setDescription('This variable represents the storage type value for the atmIfVptTm tables.')
atmIfVptTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmIndex.setDescription('This variable represents the index for the atmIfVptTm tables.')
atmIfVptTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100), )
if mibBuilder.loadTexts: atmIfVptTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
atmIfVptTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"))
if mibBuilder.loadTexts: atmIfVptTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmOperEntry.setDescription('An entry in the atmIfVptTmOperTable.')
atmIfVptTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. This attribute does not apply to basic Vpts.')
atmIfVptTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
atmIfVptTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
atmIfVptTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVptTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. This attribute does not apply to Virtual Link VPTs and will always be displayed as constantBitRate. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6), ("dynamic", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is dynamic. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
atmIfVptTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVptTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts.')
atmIfVptTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
atmIfVptTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth, or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
atmIfVptTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4), ("abrMonitored", 5), ("abrEnforced", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrEnforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection and that violating cells are discarded. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrMonitored indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection but that violating cells are counted only. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection.")
atmIfVptTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
atmIfVptTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
atmIfVptTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
atmIfVptTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVptTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, or if the connection is not active, this attribute value is displayed as notApplicable. For CQC-based ATM cards, the only possible values are notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards, if the connectionPointType is displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
atmIfVptTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 451), )
if mibBuilder.loadTexts: atmIfVptTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVptTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 451, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxTdpEntry.setDescription('An entry in the atmIfVptTmTxTdpTable.')
atmIfVptTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxTdpIndex.setDescription('This variable represents the atmIfVptTmTxTdpTable specific index for the atmIfVptTmTxTdpTable.')
atmIfVptTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptTmTxTdpTable.')
atmIfVptTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 452), )
if mibBuilder.loadTexts: atmIfVptTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
atmIfVptTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 452, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVptTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQThreshEntry.setDescription('An entry in the atmIfVptTmTxQThreshTable.')
atmIfVptTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVptTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQThreshIndex.setDescription('This variable represents the atmIfVptTmTxQThreshTable specific index for the atmIfVptTmTxQThreshTable.')
atmIfVptTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVptTmTxQThreshTable.')
atmIfVptTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 453), )
if mibBuilder.loadTexts: atmIfVptTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 indicates the instantaneous rate at which dynamic generic cell rate algorithm (DGCRA) is in effect. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVptTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 453, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxTdpEntry.setDescription('An entry in the atmIfVptTmRxTdpTable.')
atmIfVptTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVptTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxTdpIndex.setDescription('This variable represents the atmIfVptTmRxTdpTable specific index for the atmIfVptTmRxTdpTable.')
atmIfVptTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptTmRxTdpTable.')
atmIfVptTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 454), )
if mibBuilder.loadTexts: atmIfVptTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 454, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmTqpIndex"))
if mibBuilder.loadTexts: atmIfVptTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTqpEntry.setDescription('An entry in the atmIfVptTmTqpTable.')
atmIfVptTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTqpIndex.setDescription('This variable represents the atmIfVptTmTqpTable specific index for the atmIfVptTmTqpTable.')
atmIfVptTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmTqpValue.setDescription('This variable represents an individual value for the atmIfVptTmTqpTable.')
atmIfVptTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 455), )
if mibBuilder.loadTexts: atmIfVptTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 455, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmRqpIndex"))
if mibBuilder.loadTexts: atmIfVptTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRqpEntry.setDescription('An entry in the atmIfVptTmRqpTable.')
atmIfVptTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRqpIndex.setDescription('This variable represents the atmIfVptTmRqpTable specific index for the atmIfVptTmRqpTable.')
atmIfVptTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmRqpValue.setDescription('This variable represents an individual value for the atmIfVptTmRqpTable.')
atmIfVptTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2))
atmIfVptTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1), )
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptTmAbr components.')
atmIfVptTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptTmAbr component.')
atmIfVptTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptTmAbr components. These components cannot be added nor deleted.')
atmIfVptTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptTmAbr tables.')
atmIfVptTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrIndex.setDescription('This variable represents the index for the atmIfVptTmAbr tables.')
atmIfVptTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110), )
if mibBuilder.loadTexts: atmIfVptTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
atmIfVptTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrOperEntry.setDescription('An entry in the atmIfVptTmAbrOperTable.')
atmIfVptTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrInitialCellRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
atmIfVptTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrTransientBufferExposure.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrFixedRoundTripTime.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRateDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRateIncreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrMaxCellPerRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrMaxTimeBetweenRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrCutoffDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrAcrDecreaseTimeFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrForwardRmCellLimit.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
atmIfVptTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrTxRateChangeInfo.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptTmAbrTxRateChangeInfo.setDescription('THIS ATTRIBUTE IS HISTORICAL:This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
atmIfVptTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrAcrRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
atmIfVptTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrTxFwdRmCells.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
atmIfVptTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrRxEfci.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
atmIfVptTmAbrBrmRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrBrmRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrBrmRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the values of key fields which affect the rate change. These fields are from the most recent Backward Resource Management (B-RM) cell on this connection. These fields may have been set by a connection point at some switch prior to the B-RM cell arriving at this connection point. A value of ci indicates that the Congestion Indication (CI) field is set in the B-RM cell. A value of ni indicates that the No Increase (NI) field is set in the B-RM cell. A value of er indicates that a rate decrease is indicated by the Explicit Rate in the B-RM cell having a value lower than the Current Cell Rate (CCR) field in the B-RM cell. The actual explicit rate from the B-RM cell is shown in the brmEr attribute of this component. Description of bits: ci(0) ni(1) er(2)')
atmIfVptTmAbrBrmExplicitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 9, 2, 110, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptTmAbrBrmExplicitRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptTmAbrBrmExplicitRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the value of the Explicit Rate field from the most recent Backward Resource Management (B-RM) cell on this connection. This is the rate from the B-RM cell which may be different from the explicit rate (ER) offered at this connection point. Specifically, this attribute may indicate the ER which has been set in the B-RM cell by some connection point before the B-RM cell arrived at this connection point.')
atmIfVptVcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20))
atmIfVptVccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1), )
if mibBuilder.loadTexts: atmIfVptVccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVcc components.')
atmIfVptVccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVcc component.')
atmIfVptVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVcc components. These components can be added and deleted.')
atmIfVptVccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStorageType.setDescription('This variable represents the storage type value for the atmIfVptVcc tables.')
atmIfVptVccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: atmIfVptVccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccIndex.setDescription('This variable represents the index for the atmIfVptVcc tables.')
atmIfVptVccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 100), )
if mibBuilder.loadTexts: atmIfVptVccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVptVccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStateEntry.setDescription('An entry in the atmIfVptVccStateTable.')
atmIfVptVccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVptVccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVptVccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVptVccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 110), )
if mibBuilder.loadTexts: atmIfVptVccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
atmIfVptVccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccOperEntry.setDescription('An entry in the atmIfVptVccOperTable.')
atmIfVptVccConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
atmIfVptVccConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 115), )
if mibBuilder.loadTexts: atmIfVptVccConnInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccConnInfoTable.setDescription('This group contains operational connection characteristics information for a Vcc component.')
atmIfVptVccConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 115, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccConnInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccConnInfoEntry.setDescription('An entry in the atmIfVptVccConnInfoTable.')
atmIfVptVccDistributionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 115, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipoint", 1))).clone('pointToPoint')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccDistributionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccDistributionType.setDescription('This attribute indicates the way data is distributed in the connection. A value of pointToPoint indicates this connection point is part of a point-to-point connection. A value of pointToMultipoint indicates this connection point is part of a point-to-multipoint connection.')
atmIfVptVccNumLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 115, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccNumLeaves.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNumLeaves.setDescription('This attribute indicates the number of destination leaves of the connection. If the distributionType is pointToPoint the value of this attribute is 0.')
atmIfVptVccCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 115, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fromLink", 0), ("toLink", 1), ("notApplicable", 2))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccCallDirection.setDescription('This attribute indicates the direction of the call setup request for an SVC. A value of fromLink means that the call setup originated from the link. A value of toLink means that the call setup was directed to the link. For PVC connections, the value of this attribute is notApplicable. For SPVC connections, the value of this attribute is notApplicable for Vccs with the SourcePVC and DestinationPVC subcomponents. For Signalling channels, the value of this attribute is notApplicable.')
atmIfVptVccStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120), )
if mibBuilder.loadTexts: atmIfVptVccStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc, or Vpt component.')
atmIfVptVccStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatusEntry.setDescription('An entry in the atmIfVptVccStatusTable.')
atmIfVptVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc, or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
atmIfVptVccLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc, or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
atmIfVptVccTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
atmIfVptVccSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVptVccSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
atmIfVptVccEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
atmIfVptVccRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
atmIfVptVccAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccAisState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVptVccRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
atmIfVptVccTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130), )
if mibBuilder.loadTexts: atmIfVptVccTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
atmIfVptVccTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTrafficEntry.setDescription('An entry in the atmIfVptVccTrafficTable.')
atmIfVptVccTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptVccTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
atmIfVptVccFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
atmIfVptVccTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
atmIfVptVccHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVptVccRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVptVccRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
atmIfVptVccBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVccTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
atmIfVptVccBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVptVccClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
atmIfVptVccBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
atmIfVptVccTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVptVccRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
atmIfVptVccBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
atmIfVptVccBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVptVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140), )
if mibBuilder.loadTexts: atmIfVptVccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
atmIfVptVccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"))
if mibBuilder.loadTexts: atmIfVptVccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsEntry.setDescription('An entry in the atmIfVptVccStatsTable.')
atmIfVptVccStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccTxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 48), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTxUtilization.setDescription('This attribute indicates the current transmit utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVptVccStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxCell.setDescription('This attribute counts cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellClp.setDescription('This attribute counts cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
atmIfVptVccStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccRxUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 89), Gauge32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 200), ValueRangeConstraint(255, 255), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccRxUtilization.setDescription('This attribute indicates the current receive utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this connection. This attribute is only applicable for Vpts and not for Vpcs or Vccs. When the Vpt is shaped, the value of this attribute is calculated using its actual shaping rate (ASR) and should not exceed 100. When the Vpt is unshaped, the value of this attribute is calculated using its peak cell rate (PCR) and should not exceed 200. If the PCR is 0, the value 255 is used.')
atmIfVptVccStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs, and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 294), )
if mibBuilder.loadTexts: atmIfVptVccTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVptVccTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 294, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxTdpEntry.setDescription('An entry in the atmIfVptVccTxTdpTable.')
atmIfVptVccTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxTdpIndex.setDescription('This variable represents the atmIfVptVccTxTdpTable specific index for the atmIfVptVccTxTdpTable.')
atmIfVptVccTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccTxTdpTable.')
atmIfVptVccRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 295), )
if mibBuilder.loadTexts: atmIfVptVccRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVptVccRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 295, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxTdpEntry.setDescription('An entry in the atmIfVptVccRxTdpTable.')
atmIfVptVccRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVptVccRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxTdpIndex.setDescription('This variable represents the atmIfVptVccRxTdpTable specific index for the atmIfVptVccRxTdpTable.')
atmIfVptVccRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccRxTdpTable.')
atmIfVptVccTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 352), )
if mibBuilder.loadTexts: atmIfVptVccTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
atmIfVptVccTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 352, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVptVccTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQThreshEntry.setDescription('An entry in the atmIfVptVccTxQThreshTable.')
atmIfVptVccTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVptVccTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQThreshIndex.setDescription('This variable represents the atmIfVptVccTxQThreshTable specific index for the atmIfVptVccTxQThreshTable.')
atmIfVptVccTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVptVccTxQThreshTable.')
atmIfVptVccFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 357), )
if mibBuilder.loadTexts: atmIfVptVccFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptVccFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 357, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccFqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccFqpEntry.setDescription('An entry in the atmIfVptVccFqpTable.')
atmIfVptVccFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccFqpIndex.setDescription('This variable represents the atmIfVptVccFqpTable specific index for the atmIfVptVccFqpTable.')
atmIfVptVccFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccFqpValue.setDescription('This variable represents an individual value for the atmIfVptVccFqpTable.')
atmIfVptVccBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 358), )
if mibBuilder.loadTexts: atmIfVptVccBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptVccBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 358, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccBqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBqpEntry.setDescription('An entry in the atmIfVptVccBqpTable.')
atmIfVptVccBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBqpIndex.setDescription('This variable represents the atmIfVptVccBqpTable specific index for the atmIfVptVccBqpTable.')
atmIfVptVccBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccBqpValue.setDescription('This variable represents an individual value for the atmIfVptVccBqpTable.')
atmIfVptVccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2))
atmIfVptVccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccVcd components.')
atmIfVptVccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccVcd component.')
atmIfVptVccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccVcd components. These components cannot be added nor deleted.')
atmIfVptVccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccVcd tables.')
atmIfVptVccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdIndex.setDescription('This variable represents the index for the atmIfVptVccVcd tables.')
atmIfVptVccVcdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100), )
if mibBuilder.loadTexts: atmIfVptVccVcdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
atmIfVptVccVcdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdLbkEntry.setDescription('An entry in the atmIfVptVccVcdLbkTable.')
atmIfVptVccVcdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
atmIfVptVccVcdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
atmIfVptVccVcdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
atmIfVptVccVcdLoopbackMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 100, 1, 1000), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdLoopbackMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdLoopbackMonitoring.setDescription("This attribute specifies whether or not a connection monitors the OAM stream for loopback cells. Currently this attributed is only applied to Passport-specific trace cells and only affects connectingPoints. When sameAsInterface is selected, the trace visibility for the connection is based on the traceVisible attribute of the connection's parent AtmIf componentif the ATM interface is trace visible, then the connection is also trace visible. When on or off is selected, the connection is nor isn't visible to trace cells respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that trace visibility only affects connections whose connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Trace visibility is also not possible if the distributionType of the Vcc is pointToMultipoint.")
atmIfVptVccVcdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110), )
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
atmIfVptVccVcdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficEntry.setDescription('An entry in the atmIfVptVccVcdTrafficTable.')
atmIfVptVccVcdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptVccVcdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
atmIfVptVccVcdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVptVccVcdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
atmIfVptVccVcdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
atmIfVptVccVcdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
atmIfVptVccVcdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVptVccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVptVccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
atmIfVptVccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
atmIfVptVccVcdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVptVccVcdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVccVcdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVptVccVcdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVccVcdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
atmIfVptVccVcdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
atmIfVptVccVcdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 111), )
if mibBuilder.loadTexts: atmIfVptVccVcdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
atmIfVptVccVcdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 111, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdAcctEntry.setDescription('An entry in the atmIfVptVccVcdAcctTable.')
atmIfVptVccVcdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
atmIfVptVccVcdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 297), )
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
atmIfVptVccVcdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 297, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpEntry.setDescription('An entry in the atmIfVptVccVcdTxTdpTable.')
atmIfVptVccVcdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpIndex.setDescription('This variable represents the atmIfVptVccVcdTxTdpTable specific index for the atmIfVptVccVcdTxTdpTable.')
atmIfVptVccVcdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdTxTdpTable.')
atmIfVptVccVcdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 298), )
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
atmIfVptVccVcdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 298, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpEntry.setDescription('An entry in the atmIfVptVccVcdRxTdpTable.')
atmIfVptVccVcdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpIndex.setDescription('This variable represents the atmIfVptVccVcdRxTdpTable specific index for the atmIfVptVccVcdRxTdpTable.')
atmIfVptVccVcdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdRxTdpTable.')
atmIfVptVccVcdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 359), )
if mibBuilder.loadTexts: atmIfVptVccVcdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVccVcdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 359, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdFqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFqpEntry.setDescription('An entry in the atmIfVptVccVcdFqpTable.')
atmIfVptVccVcdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccVcdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFqpIndex.setDescription('This variable represents the atmIfVptVccVcdFqpTable specific index for the atmIfVptVccVcdFqpTable.')
atmIfVptVccVcdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdFqpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdFqpTable.')
atmIfVptVccVcdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 360), )
if mibBuilder.loadTexts: atmIfVptVccVcdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVccVcdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 360, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdBqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBqpEntry.setDescription('An entry in the atmIfVptVccVcdBqpTable.')
atmIfVptVccVcdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccVcdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBqpIndex.setDescription('This variable represents the atmIfVptVccVcdBqpTable specific index for the atmIfVptVccVcdBqpTable.')
atmIfVptVccVcdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccVcdBqpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdBqpTable.')
atmIfVptVccVcdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2))
atmIfVptVccVcdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccVcdTm components.')
atmIfVptVccVcdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccVcdTm component.')
atmIfVptVccVcdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccVcdTm components. These components cannot be added nor deleted.')
atmIfVptVccVcdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccVcdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccVcdTm tables.')
atmIfVptVccVcdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccVcdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmIndex.setDescription('This variable represents the index for the atmIfVptVccVcdTm tables.')
atmIfVptVccVcdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
atmIfVptVccVcdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmProvEntry.setDescription('An entry in the atmIfVptVccVcdTmProvTable.')
atmIfVptVccVcdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
atmIfVptVccVcdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
atmIfVptVccVcdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. A value other than sameAsCa may be specified only for ATM IP cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
atmIfVptVccVcdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
atmIfVptVccVcdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
atmIfVptVccVcdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
atmIfVptVccVcdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVccVcdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
atmIfVptVccVcdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
atmIfVptVccVcdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP, and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
atmIfVptVccVcdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards, and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
atmIfVptVccVcdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. When monitored is selected, UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. If this is a connection of serviceCategory abr on an ATM IP card, and the abrConnectionType is sourceDest, virtualSourceDest or explicitRate, selecting enforced enables dynamic generic cell rate algorithm (DGCRA) to discard violating cells. Selecting monitored enables DGCRA to count violating cells. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
atmIfVptVccVcdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
atmIfVptVccVcdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVccVcdTmTxWredThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 73), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(25, 25), ValueRangeConstraint(50, 50), ValueRangeConstraint(75, 75), )).clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxWredThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxWredThreshold.setDescription('This attribute determines at what percentage of the queue being at the EPD threshold, WRED starts. When the value is set to 25%, WRED starts as soon as the queue is 25% of the way to the EPD threshold. When the value is set to 50%, WRED starts later, after the queue is 50% of the way to the EPD threshold. When the value is set to 75%, WRED starts only when the queue is 75% of the way to the EPD threshold. The EPD threshold is 85% of the transmit queue length. This attribue is ignored if txWredMode or txPacketWiseDiscard is disabled. It is always ignored on CQC-based ATM FP.')
atmIfVptVccVcdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
atmIfVptVccVcdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
atmIfVptVccVcdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVptVccVcdTmTxWredMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("perFlow", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxWredMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxWredMode.setDescription("This attribute specifies the activation of weighted random early detection (WRED) functionality. WRED is only available on ATM IP FPs. On CQC-based ATM FPs, this attribute is ignored. If txPacketWiseDiscard is set to disabled this attribute is ignored. This attribute is not applicable for Vpts or Vpt Vccs. WRED is applied in the transmit direction for this connection. WRED function should be enabled only for connections which are transferring TCP/IP traffic. WRED acts to prevent synchronization of multiple TCP/IP sources by randomly discarding a small percentage of frames when transmit queue congestion reaches the designated level. W-RED may also be used to differentiate service on VCC's by preferentially discarding one VCC before another. Discards start at 0% of cells, when the queue is part-way to the Early Packet Discard (EPD) threshold, and rise to 100% of cells discarded at the EPD threshold. WRED discards all the cells in a frame. If this attribute is set to enabled, WRED is enabled for all applications linked to the given Vcc. If it is set to perFlow, each TCP application has individual control over whether to enable or disable WRED If txPacketWiseDiscard is set to disabled, or if this attribute is set to disabled, WRED functionality is disabled. If WRED is active, it is visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
atmIfVptVccVcdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
atmIfVptVccVcdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
atmIfVptVccVcdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 456), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
atmIfVptVccVcdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpEntry.setDescription('An entry in the atmIfVptVccVcdTmTxTdpTable.')
atmIfVptVccVcdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpIndex.setDescription('This variable represents the atmIfVptVccVcdTmTxTdpTable specific index for the atmIfVptVccVcdTmTxTdpTable.')
atmIfVptVccVcdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdTmTxTdpTable.')
atmIfVptVccVcdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 457), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
atmIfVptVccVcdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpEntry.setDescription('An entry in the atmIfVptVccVcdTmRxTdpTable.')
atmIfVptVccVcdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpIndex.setDescription('This variable represents the atmIfVptVccVcdTmRxTdpTable specific index for the atmIfVptVccVcdTmRxTdpTable.')
atmIfVptVccVcdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdTmRxTdpTable.')
atmIfVptVccVcdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 458), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVccVcdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmFqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpEntry.setDescription('An entry in the atmIfVptVccVcdTmFqpTable.')
atmIfVptVccVcdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpIndex.setDescription('This variable represents the atmIfVptVccVcdTmFqpTable specific index for the atmIfVptVccVcdTmFqpTable.')
atmIfVptVccVcdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmFqpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdTmFqpTable.')
atmIfVptVccVcdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 459), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpTable.setDescription('This attribute is a vector of two elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
atmIfVptVccVcdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmBqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpEntry.setDescription('An entry in the atmIfVptVccVcdTmBqpTable.')
atmIfVptVccVcdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("cdv", 0), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpIndex.setDescription('This variable represents the atmIfVptVccVcdTmBqpTable specific index for the atmIfVptVccVcdTmBqpTable.')
atmIfVptVccVcdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmBqpValue.setDescription('This variable represents an individual value for the atmIfVptVccVcdTmBqpTable.')
atmIfVptVccVcdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2))
atmIfVptVccVcdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccVcdTmAbr components.')
atmIfVptVccVcdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccVcdTmAbr component.')
atmIfVptVccVcdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccVcdTmAbr components. These components can be added and deleted.')
atmIfVptVccVcdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccVcdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccVcdTmAbr tables.')
atmIfVptVccVcdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrIndex.setDescription('This variable represents the index for the atmIfVptVccVcdTmAbr tables.')
atmIfVptVccVcdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110), )
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
atmIfVptVccVcdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrProvEntry.setDescription('An entry in the atmIfVptVccVcdTmAbrProvTable.')
atmIfVptVccVcdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
atmIfVptVccVcdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
atmIfVptVccVcdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
atmIfVptVccVcdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
atmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(1024, 1024), )).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute. VALUES ( 1024 = sameAsLocal )')
atmIfVptVccVcdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777219, 16777219), )).clone(16777219)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccVcdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr. VALUES ( 16777219 = sameAsLocal )')
atmIfVptVccLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3))
atmIfVptVccLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1), )
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccLoop components.')
atmIfVptVccLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccLoopIndex"))
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccLoop component.')
atmIfVptVccLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccLoop components. These components can be added and deleted.')
atmIfVptVccLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccLoop tables.')
atmIfVptVccLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccLoopIndex.setDescription('This variable represents the index for the atmIfVptVccLoop tables.')
atmIfVptVccNep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5))
atmIfVptVccNepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1), )
if mibBuilder.loadTexts: atmIfVptVccNepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccNep components.')
atmIfVptVccNepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccNepIndex"))
if mibBuilder.loadTexts: atmIfVptVccNepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccNep component.')
atmIfVptVccNepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccNepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccNep components. These components can be added and deleted.')
atmIfVptVccNepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccNepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccNepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccNepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccNep tables.')
atmIfVptVccNepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccNepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepIndex.setDescription('This variable represents the index for the atmIfVptVccNep tables.')
atmIfVptVccNepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 100), )
if mibBuilder.loadTexts: atmIfVptVccNepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepProvTable.setDescription('This group contains provisionable attributes for the Nep component.')
atmIfVptVccNepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccNepIndex"))
if mibBuilder.loadTexts: atmIfVptVccNepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepProvEntry.setDescription('An entry in the atmIfVptVccNepProvTable.')
atmIfVptVccNepApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 5, 100, 1, 10), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccNepApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccNepApplicationName.setDescription("This attribute specifies the application that sends and receives frames using the VCC. This attribute is set, for example, by provisioning the Trunk AtmAccess AtmConnection attribute. If it is properly configured, this attribute will show a value such as 'Trk/22 AtmAccess'.")
atmIfVptVccTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6))
atmIfVptVccTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1), )
if mibBuilder.loadTexts: atmIfVptVccTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccTest components.')
atmIfVptVccTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTestIndex"))
if mibBuilder.loadTexts: atmIfVptVccTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccTest component.')
atmIfVptVccTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccTest components. These components can be added and deleted.')
atmIfVptVccTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccTest tables.')
atmIfVptVccTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestIndex.setDescription('This variable represents the index for the atmIfVptVccTest tables.')
atmIfVptVccTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 100), )
if mibBuilder.loadTexts: atmIfVptVccTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
atmIfVptVccTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTestIndex"))
if mibBuilder.loadTexts: atmIfVptVccTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestStateEntry.setDescription('An entry in the atmIfVptVccTestStateTable.')
atmIfVptVccTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
atmIfVptVccTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
atmIfVptVccTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
atmIfVptVccTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110), )
if mibBuilder.loadTexts: atmIfVptVccTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestSetupTable.setDescription('This group contains attributes that govern the operation of an ATM connection test. These attributes cannot be changed while the test is running.')
atmIfVptVccTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTestIndex"))
if mibBuilder.loadTexts: atmIfVptVccTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestSetupEntry.setDescription('An entry in the atmIfVptVccTestSetupTable.')
atmIfVptVccTestFrmTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestFrmTypes.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestFrmTypes.setDescription("This attribute specifies the types of the test frames to be transmitted during the ATM connection test. It must contain at least one of the following: loading: A set of 'loading frames' is circulated over the link as rapidly as possible. This frame type should be selected when the test is intended to verify the operation of the connection under a specified load. These frames are not checked for bit errors. verification: A single 'verification frame' is transmitted over the link; when the frame is returned, its contents are verified and the next verification frame in the series is transmitted. This frame type should be selected when the test is intended to verify that frames are not being corrupted as they pass over the connection. Description of bits: loading(0) verification(1)")
atmIfVptVccTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestFrmSize.setDescription('This attribute defines the size of the test frames used in an ATM connection test.')
atmIfVptVccTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestFrmPatternType.setDescription('This attribute specifies the bit sequence used to fill the frames used in the ATM connection test. It must contain one of the following values: ccitt32kBitPattern: a pseudo-random sequence of 32 Kbit is used ccitt8MBitPattern: a pseudo-random sequence of 8Mbit is used customizedPattern: the pattern defined in the customizedPattern attribute is used')
atmIfVptVccTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 40), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestCustomizedPattern.setDescription('This attribute specifies a 32 bit sequence to be used to fill frames when the framePatternType attribute is set to customizedPattern. The default value gives a pattern of alternating 0 and 1 bits.')
atmIfVptVccTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestDuration.setDescription('This attribute specifies the maximum number of minutes that the ATM connection test is allowed to run. The maximum allowed value permits the test to be run for up to 21 days.')
atmIfVptVccTestBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestBandwidthElastic.setDescription('This attribute specifies whether the connection (VCC) should be configured with elastic bandwidth or not. Elastic bandwidth is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be reduced in bandwidth based on the setting of the bwElastic attribute. If this attribute is set to yes, the Test application signals to the connection that the bandwidth for this connection is elastic, and may be reduced in the case of IMA link failures. If the bandwidth is reduced, the rate of test cells which can be handled by the connection will also be reduced. If this attribute is set to no, the Test application signals to the connection that the bandwidth for this connection must be maintained at the requested level. If the connection cannot maintain the full bandwidth, the connection may be released (cleared) based on the holding priority of the connection.')
atmIfVptVccTestOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfVptVccTestOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestOverrideHoldingPriority.setDescription("This attribute specifies the override holding priority which should be signalled to the VCC connection at the start of the test. Holding priority is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be released based on the connection's holding priority. Zero (0) is thie highest holding priority, and four (4) is the lowest priority. A setting of zero to four overrides whatever holding priority that has been configured at the connection (VCC). A setting of noOverride means that the connection should use its internally configured holding priority.")
atmIfVptVccTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120), )
if mibBuilder.loadTexts: atmIfVptVccTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestResultsTable.setDescription('This group contains attributes that show the result of an ATM connection test; if no test is running, the attribute group contains the results of the most recently completed test. The attributes of the Results group are reset to their inital values whenever a test is started or any attribute of the Setup group is set.')
atmIfVptVccTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTestIndex"))
if mibBuilder.loadTexts: atmIfVptVccTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestResultsEntry.setDescription('An entry in the atmIfVptVccTestResultsTable.')
atmIfVptVccTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestElapsedTime.setDescription('This attribute displays the number of minutes that the test has been running.')
atmIfVptVccTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestTimeRemaining.setDescription('This attribute displays the number of minutes that the test will continue to run before stopping automatically.')
atmIfVptVccTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("neverStarted", 2), ("testRunning", 3))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestCauseOfTermination.setDescription('This attribute displays the reason the test ended. It contains one fo the following values. testTimeExpired: the test ran for the specified duration stoppedByOperator: a STOP command was issued neverStarted: the test has not been started testRunning: the test is currently running')
atmIfVptVccTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestBytesTx.setDescription('This attribute displays the number of bytes sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestBytesRx.setDescription('This attribute displays the number of bytes received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestLoadingFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmTx.setDescription('This attribute displays the number of loading frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestLoadingFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmRx.setDescription('This attribute displays the number of loading frames received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestLoadingFrmLost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmLost.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestLoadingFrmLost.setDescription('This attribute displays the number of loading frames that were lost during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestVerificationFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmTx.setDescription('This attribute displays the number of verification frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTestVerificationFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmRx.setDescription('This attribute displays the number of verification frames received during the test (including errored verification frames). The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of verification frames lost during the test can be computed by the expression verificationFrmTx - verificationFrmRx.')
atmIfVptVccTestVerificationFrmBad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 110), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmBad.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestVerificationFrmBad.setDescription('This attribute displays the number of errored verification frames received during the test. A verification frame is considered to be errored if it contains a recognizable verification frame header, but does not match the transmitted frame bit for bit. (Thus, a verification frame that returns after the succeeding verification frame has been transmitted is considered to be errored.) The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of correct verification frames received during the test can be computed by the expression verificationFrmRx - verificationFrmBad.')
atmIfVptVccTestUnrecognizableFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 6, 120, 1, 120), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTestUnrecognizableFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTestUnrecognizableFrmRx.setDescription('This attribute displays the number of frames received during the test which do not contain a valid loading frame header or verification frame header. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
atmIfVptVccTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7))
atmIfVptVccTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1), )
if mibBuilder.loadTexts: atmIfVptVccTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccTm components.')
atmIfVptVccTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccTm component.')
atmIfVptVccTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccTm components. These components cannot be added nor deleted.')
atmIfVptVccTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccTm tables.')
atmIfVptVccTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmIndex.setDescription('This variable represents the index for the atmIfVptVccTm tables.')
atmIfVptVccTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100), )
if mibBuilder.loadTexts: atmIfVptVccTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
atmIfVptVccTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmOperEntry.setDescription('An entry in the atmIfVptVccTmOperTable.')
atmIfVptVccTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
atmIfVptVccTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. This attribute does not apply to basic Vpts.')
atmIfVptVccTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
atmIfVptVccTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
atmIfVptVccTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
atmIfVptVccTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. This attribute does not apply to Virtual Link VPTs and will always be displayed as constantBitRate. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
atmIfVptVccTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6), ("dynamic", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is dynamic. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
atmIfVptVccTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
atmIfVptVccTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts.')
atmIfVptVccTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
atmIfVptVccTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
atmIfVptVccTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth, or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
atmIfVptVccTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4, 5, 6))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4), ("abrMonitored", 5), ("abrEnforced", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc, or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrEnforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection and that violating cells are discarded. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection. If the atmServiceCategory for this connection indicates availableBitRate, a value of abrMonitored indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection but that violating cells are counted only. The cell rate which is in effect at any particular instant is indicated in rxTrafficDescParm 4 of the connection.")
atmIfVptVccTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
atmIfVptVccTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
atmIfVptVccTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
atmIfVptVccTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
atmIfVptVccTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, or if the connection is not active, this attribute value is displayed as notApplicable. For CQC-based ATM cards, the only possible values are notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards, if the connectionPointType is displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
atmIfVptVccTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 451), )
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
atmIfVptVccTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 451, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmTxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpEntry.setDescription('An entry in the atmIfVptVccTmTxTdpTable.')
atmIfVptVccTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpIndex.setDescription('This variable represents the atmIfVptVccTmTxTdpTable specific index for the atmIfVptVccTmTxTdpTable.')
atmIfVptVccTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccTmTxTdpTable.')
atmIfVptVccTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 452), )
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
atmIfVptVccTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 452, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmTxQThreshIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshEntry.setDescription('An entry in the atmIfVptVccTmTxQThreshTable.')
atmIfVptVccTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshIndex.setDescription('This variable represents the atmIfVptVccTmTxQThreshTable specific index for the atmIfVptVccTmTxQThreshTable.')
atmIfVptVccTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTxQThreshValue.setDescription('This variable represents an individual value for the atmIfVptVccTmTxQThreshTable.')
atmIfVptVccTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 453), )
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 indicates the instantaneous rate at which dynamic generic cell rate algorithm (DGCRA) is in effect. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
atmIfVptVccTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 453, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmRxTdpIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpEntry.setDescription('An entry in the atmIfVptVccTmRxTdpTable.')
atmIfVptVccTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpIndex.setDescription('This variable represents the atmIfVptVccTmRxTdpTable specific index for the atmIfVptVccTmRxTdpTable.')
atmIfVptVccTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRxTdpValue.setDescription('This variable represents an individual value for the atmIfVptVccTmRxTdpTable.')
atmIfVptVccTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 454), )
if mibBuilder.loadTexts: atmIfVptVccTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptVccTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 454, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmTqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTqpEntry.setDescription('An entry in the atmIfVptVccTmTqpTable.')
atmIfVptVccTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTqpIndex.setDescription('This variable represents the atmIfVptVccTmTqpTable specific index for the atmIfVptVccTmTqpTable.')
atmIfVptVccTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmTqpValue.setDescription('This variable represents an individual value for the atmIfVptVccTmTqpTable.')
atmIfVptVccTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 455), )
if mibBuilder.loadTexts: atmIfVptVccTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
atmIfVptVccTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 455, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmRqpIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRqpEntry.setDescription('An entry in the atmIfVptVccTmRqpTable.')
atmIfVptVccTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: atmIfVptVccTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRqpIndex.setDescription('This variable represents the atmIfVptVccTmRqpTable specific index for the atmIfVptVccTmRqpTable.')
atmIfVptVccTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmRqpValue.setDescription('This variable represents an individual value for the atmIfVptVccTmRqpTable.')
atmIfVptVccTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2))
atmIfVptVccTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1), )
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfVptVccTmAbr components.')
atmIfVptVccTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single atmIfVptVccTmAbr component.')
atmIfVptVccTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfVptVccTmAbr components. These components cannot be added nor deleted.')
atmIfVptVccTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfVptVccTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrStorageType.setDescription('This variable represents the storage type value for the atmIfVptVccTmAbr tables.')
atmIfVptVccTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: atmIfVptVccTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrIndex.setDescription('This variable represents the index for the atmIfVptVccTmAbr tables.')
atmIfVptVccTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110), )
if mibBuilder.loadTexts: atmIfVptVccTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
atmIfVptVccTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfVptVccTmAbrIndex"))
if mibBuilder.loadTexts: atmIfVptVccTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrOperEntry.setDescription('An entry in the atmIfVptVccTmAbrOperTable.')
atmIfVptVccTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrInitialCellRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
atmIfVptVccTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrTransientBufferExposure.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptVccTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrFixedRoundTripTime.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptVccTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRateDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptVccTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRateIncreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
atmIfVptVccTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrMaxCellPerRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptVccTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrMaxTimeBetweenRmCell.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptVccTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrCutoffDecreaseFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptVccTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrAcrDecreaseTimeFactor.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
atmIfVptVccTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrForwardRmCellLimit.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
atmIfVptVccTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrTxRateChangeInfo.setStatus('obsolete')
if mibBuilder.loadTexts: atmIfVptVccTmAbrTxRateChangeInfo.setDescription('THIS ATTRIBUTE IS HISTORICAL:This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
atmIfVptVccTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrAcrRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
atmIfVptVccTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrTxFwdRmCells.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
atmIfVptVccTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrRxEfci.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest or virtualSourceDest. This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
atmIfVptVccTmAbrBrmRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrBrmRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrBrmRateChangeInfo.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the values of key fields which affect the rate change. These fields are from the most recent Backward Resource Management (B-RM) cell on this connection. These fields may have been set by a connection point at some switch prior to the B-RM cell arriving at this connection point. A value of ci indicates that the Congestion Indication (CI) field is set in the B-RM cell. A value of ni indicates that the No Increase (NI) field is set in the B-RM cell. A value of er indicates that a rate decrease is indicated by the Explicit Rate in the B-RM cell having a value lower than the Current Cell Rate (CCR) field in the B-RM cell. The actual explicit rate from the B-RM cell is shown in the brmEr attribute of this component. Description of bits: ci(0) ni(1) er(2)')
atmIfVptVccTmAbrBrmExplicitRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 9, 20, 7, 2, 110, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfVptVccTmAbrBrmExplicitRate.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfVptVccTmAbrBrmExplicitRate.setDescription('This attribute is applicable and is displayed only for connections for which the operational Tm abrConnectionType is displayed as sourceDest, virtualSourceDest or explicitRate. This attribute indicates the value of the Explicit Rate field from the most recent Backward Resource Management (B-RM) cell on this connection. This is the rate from the B-RM cell which may be different from the explicit rate (ER) offered at this connection point. Specifically, this attribute may indicate the ER which has been set in the B-RM cell by some connection point before the B-RM cell arrived at this connection point.')
atmIfEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10))
atmIfEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1), )
if mibBuilder.loadTexts: atmIfEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpRowStatusTable.setDescription('This entry controls the addition and deletion of atmIfEp components.')
atmIfEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfEpIndex"))
if mibBuilder.loadTexts: atmIfEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpRowStatusEntry.setDescription('A single entry in the table represents a single atmIfEp component.')
atmIfEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of atmIfEp components. These components can be added and deleted.')
atmIfEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
atmIfEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmIfEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpStorageType.setDescription('This variable represents the storage type value for the atmIfEp tables.')
atmIfEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 7)))
if mibBuilder.loadTexts: atmIfEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpIndex.setDescription('This variable represents the index for the atmIfEp tables.')
atmIfEpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 100), )
if mibBuilder.loadTexts: atmIfEpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpProvTable.setDescription('This group contains provisioned attributes which specify the behavior of an emission priority for the ATM interface.')
atmIfEpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 100, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfIndex"), (0, "Nortel-Magellan-Passport-AtmCoreMIB", "atmIfEpIndex"))
if mibBuilder.loadTexts: atmIfEpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpProvEntry.setDescription('An entry in the atmIfEpProvTable.')
atmIfEpMinimumBandwidthGuarantee = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 114, 10, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 49), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmIfEpMinimumBandwidthGuarantee.setStatus('mandatory')
if mibBuilder.loadTexts: atmIfEpMinimumBandwidthGuarantee.setDescription('This attribute specifies the minimum bandwidth guarantee associated with this EmissionPriority. A minimum bandwidth guarantee is designed to prevent starvation of traffic at this EP by traffic at higher EPs. Minimum bandwidth guarantees only operate for EPs within the guaranteed bandwidth range 2 through 7. The minimum bandwidth guarantee specified is a percentage of the bandwidth which remains after all traffic at EP 0 and EP 1 is served. For example, if EP 0 and EP 1 traffic consumes 20% of link bandwidth, the minimum bandwidth guarantee applies to the remaining 80% of the link bandwidth. A minimum bandwidth guarantee of 2% would actually result in this EP getting 2% of 80% (total 1.6%) of the link bandwidth. The sum of minimumBandwidthGuarantee values for all Eps under an AtmIf must not exceed 100%. The value priority specifies that this Ep gets the bandwidth guarantee which is applicable based on the hierarchy of emission priorities. In this case, there is no minimum bandwidth guarantee. A value between 1 and 49 specifies that from 1% to 49% of the remaining link bandwidth is reserved for traffic at this EP. Given a value n of minimumBandwidthGuarantee, then for n% of transmit cell opportunities in the guaranteed bandwidth range, this EP get first opportunity to send a cell. If this EP uses less than n% of the link bandwidth, the extra opportunities are allocated in priority. Due to scheduling and cell arrival times, traffic at this EP may not necessarily achieve full utilization of its minimum bandwidth guarantee. When specifying a value for minimumBandwidthGuarantee, consider the effect on cell delay variation (CDV) of traffic which would normally be of higher priority. For example, if RtVbr service category traffic is assigned to Ep/2 and Ubr traffic is assigned on Ep/7 where Ep/7 has a minimumBandwidthGuarantee of 25%, there can be a large impact on CDV of the RtVbr traffic. Traffic of the Cbr or RtVbr service category which is sensitive to CDV and is of known volume, can be assigned on EP 0 or EP 1 which are independent of the effects of minimum bandwidth guarantee. VALUES ( 0 = priority )')
atmCoreGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 1))
atmCoreGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 1, 5))
atmCoreGroupBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 1, 5, 2))
atmCoreGroupBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 1, 5, 2, 2))
atmCoreCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 3))
atmCoreCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 3, 5))
atmCoreCapabilitiesBE01 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 3, 5, 2))
atmCoreCapabilitiesBE01A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 123, 3, 5, 2, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfVpcTxDiscardClp=atmIfVpcTxDiscardClp, atmIfVpcVpdTransferCapabilityBbc=atmIfVpcVpdTransferCapabilityBbc, atmIfVptTmRqpIndex=atmIfVptTmRqpIndex, atmIfVccTmTqpTable=atmIfVccTmTqpTable, atmIfVptCAMaxVccs=atmIfVptCAMaxVccs, atmIfTxCellMemory=atmIfTxCellMemory, atmIfVccTxQueueCongestionState=atmIfVccTxQueueCongestionState, atmIfVptCAAbrProvTable=atmIfVptCAAbrProvTable, atmIfVptVccStatsRxCellClp=atmIfVptVccStatsRxCellClp, atmIfCARtVbrRowStatusEntry=atmIfCARtVbrRowStatusEntry, atmIfVptVccVcdTmAtmServiceCategory=atmIfVptVccVcdTmAtmServiceCategory, atmIfCARtVbrCdv=atmIfCARtVbrCdv, atmIfVptVccTmAbrTransientBufferExposure=atmIfVptVccTmAbrTransientBufferExposure, atmIfVpcTmTxQThreshIndex=atmIfVpcTmTxQThreshIndex, atmIfCAVirtualLinkAdmittedBandwidth=atmIfCAVirtualLinkAdmittedBandwidth, atmIfVccVcdAtmServiceCategory=atmIfVccVcdAtmServiceCategory, atmIfVpcVpdTmAbrDgcraMinimumDelay=atmIfVpcVpdTmAbrDgcraMinimumDelay, atmIfVccVcdAcctTable=atmIfVccVcdAcctTable, atmIfVptRdiState=atmIfVptRdiState, atmIfVptVpdRxTrafficDescType=atmIfVptVpdRxTrafficDescType, atmIfCAPoolProvBwIndex=atmIfCAPoolProvBwIndex, atmIfVccVcdTmAtmServiceCategory=atmIfVccVcdTmAtmServiceCategory, atmIfVccTestBytesTx=atmIfVccTestBytesTx, atmIfVccTestOperationalState=atmIfVccTestOperationalState, atmIfVptVccVcdTmProvEntry=atmIfVptVccVcdTmProvEntry, atmIfVccVcdTmFqpIndex=atmIfVccVcdTmFqpIndex, atmIfVpcBqpTable=atmIfVpcBqpTable, atmIfVptCASwitchedVccs=atmIfVptCASwitchedVccs, atmIfVptVccBandwidthReduction=atmIfVptVccBandwidthReduction, atmIfVptStatsTxCell=atmIfVptStatsTxCell, atmIfVptTxDiscard=atmIfVptTxDiscard, atmIfVptVpdTmTxPacketWiseDiscard=atmIfVptVpdTmTxPacketWiseDiscard, atmIfVptVccTestRowStatusEntry=atmIfVptVccTestRowStatusEntry, atmIfVptVccVcd=atmIfVptVccVcd, atmIfVpcTmComponentName=atmIfVpcTmComponentName, atmIfVptVpdTrafficShaping=atmIfVptVpdTrafficShaping, atmIfVptVccVcdTmRxTdpValue=atmIfVptVccVcdTmRxTdpValue, atmIfTxCellDiscard=atmIfTxCellDiscard, atmIfVccOperTable=atmIfVccOperTable, atmIfVptVccConnectionPointType=atmIfVptVccConnectionPointType, atmIfVpcTmTxTrafficDescType=atmIfVpcTmTxTrafficDescType, atmIfVptVpdTmRxTdpIndex=atmIfVptVpdTmRxTdpIndex, atmIfVptVccOperStatus=atmIfVptVccOperStatus, atmIfVpcVpdHoldingPriority=atmIfVpcVpdHoldingPriority, atmIfVpcVpdTmRowStatusTable=atmIfVpcVpdTmRowStatusTable, atmIfTxCellEfci=atmIfTxCellEfci, atmIfCACbrOperEntry=atmIfCACbrOperEntry, atmIfVptCAPoolAdmConnsValue=atmIfVptCAPoolAdmConnsValue, atmIfVpcTmTxQueueLength=atmIfVpcTmTxQueueLength, atmIfVpcVpdTmBestEffort=atmIfVpcVpdTmBestEffort, atmIfVptCARtVbrRowStatusEntry=atmIfVptCARtVbrRowStatusEntry, atmIfVptVpdIndex=atmIfVptVpdIndex, atmIfVccTmAbrOperEntry=atmIfVccTmAbrOperEntry, atmIfVptVpdTmAbrComponentName=atmIfVptVpdTmAbrComponentName, atmIfVpcTmRowStatusTable=atmIfVpcTmRowStatusTable, atmIfVptStatsRxFrameDiscard=atmIfVptStatsRxFrameDiscard, atmIfCAMinAutoSelectedVci=atmIfCAMinAutoSelectedVci, atmIfNAcctStorageType=atmIfNAcctStorageType, atmIfVpcVpdTmRxTdpIndex=atmIfVpcVpdTmRxTdpIndex, atmIfVptVpdTmBwdQosClass=atmIfVptVpdTmBwdQosClass, atmIfVccTmRqpIndex=atmIfVccTmRqpIndex, atmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor=atmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor, atmIfVptVccVcdTmBqpValue=atmIfVptVccVcdTmBqpValue, atmIfVccVcdRxTdpEntry=atmIfVccVcdRxTdpEntry, atmIfVpcBqpEntry=atmIfVpcBqpEntry, atmIfVpcVpdTmTxPacketWiseDiscard=atmIfVpcVpdTmTxPacketWiseDiscard, atmIfCARtVbrEpdOffset=atmIfCARtVbrEpdOffset, atmIfVptVccVcdTmFwdQosClass=atmIfVptVccVcdTmFwdQosClass, atmIfVptVccTmAbrTxRateChangeInfo=atmIfVptVccTmAbrTxRateChangeInfo, atmIfVptHoldingPriority=atmIfVptHoldingPriority, atmIfVccTmAbrTxRateChangeInfo=atmIfVccTmAbrTxRateChangeInfo, atmIfVpcTmRxTdpTable=atmIfVpcTmRxTdpTable, atmIfVpcRowStatusEntry=atmIfVpcRowStatusEntry, atmIfVptVccTestOverrideHoldingPriority=atmIfVptVccTestOverrideHoldingPriority, atmIfVpcBqpValue=atmIfVpcBqpValue, atmIfVpcFqpEntry=atmIfVpcFqpEntry, atmIfConnMapVccProvEntry=atmIfConnMapVccProvEntry, atmIfVptVccVcdTmAbrRowStatusEntry=atmIfVptVccVcdTmAbrRowStatusEntry, atmIfCAConnectionPoolUsage=atmIfCAConnectionPoolUsage, atmIfTxCellMemoryThresholdIndex=atmIfTxCellMemoryThresholdIndex, atmIfVpcTransferCapabilityBbc=atmIfVpcTransferCapabilityBbc, atmIfCANrtVbrUnshapedTransmitQueueing=atmIfCANrtVbrUnshapedTransmitQueueing, atmIfVccTmRqpValue=atmIfVccTmRqpValue, atmIfVpcTmRqpIndex=atmIfVpcTmRqpIndex, atmIfVccNepApplicationName=atmIfVccNepApplicationName, atmIfVptVccTmTxTdpTable=atmIfVptVccTmTxTdpTable, atmIfCAVbrNrtCellLossRatio=atmIfCAVbrNrtCellLossRatio, atmIfCAPoolAvailBwIndex=atmIfCAPoolAvailBwIndex, atmIfVccVcdTxQosClass=atmIfVccVcdTxQosClass, atmIfLastAal5RxErrorConnection=atmIfLastAal5RxErrorConnection, atmIfCAVbrRtCdvt=atmIfCAVbrRtCdvt, atmIfStandbyStatus=atmIfStandbyStatus, atmIfVpcVpdTmAbrComponentName=atmIfVpcVpdTmAbrComponentName, atmIfVpcVpdTmBqpIndex=atmIfVpcVpdTmBqpIndex, atmIfVptVpdTmAbrConnectionType=atmIfVptVpdTmAbrConnectionType, atmIfVptVccTestVerificationFrmTx=atmIfVptVccTestVerificationFrmTx, atmIfVccTmTrafficShaping=atmIfVccTmTrafficShaping, atmIfVptBandwidthElastic=atmIfVptBandwidthElastic, atmIfVccVcdTmAbrComponentName=atmIfVccVcdTmAbrComponentName, atmIfVptVccVcdTmAbrAcrDecreaseTimeFactor=atmIfVptVccVcdTmAbrAcrDecreaseTimeFactor, atmIfVptVccVcdRowStatusEntry=atmIfVptVccVcdRowStatusEntry, atmIfVptVpdTmAbrCutoffDecreaseFactor=atmIfVptVpdTmAbrCutoffDecreaseFactor, atmIf=atmIf, atmIfVptVccClippingBbc=atmIfVptVccClippingBbc, atmIfVccVcdTmUsageParameterControl=atmIfVccVcdTmUsageParameterControl, atmIfVccVcdComponentName=atmIfVccVcdComponentName, atmIfVpcTmRqpTable=atmIfVpcTmRqpTable, atmIfVpcStatsTxCellDiscardClp=atmIfVpcStatsTxCellDiscardClp, atmIfVptVccRxDiscard=atmIfVptVccRxDiscard, atmIfVptVpdTmTxTdpTable=atmIfVptVpdTmTxTdpTable, atmIfVptTxQThreshValue=atmIfVptTxQThreshValue, atmIfRowStatusTable=atmIfRowStatusTable, atmIfVptVccTmOperTable=atmIfVptVccTmOperTable, atmIfVptVccTmAbrConnectionType=atmIfVptVccTmAbrConnectionType, atmIfVptCARtVbrProvEntry=atmIfVptCARtVbrProvEntry, atmIfVpcVpdRxTdpEntry=atmIfVpcVpdRxTdpEntry, atmIfVptVccVcdEndToEndLoopback=atmIfVptVccVcdEndToEndLoopback, atmIfVptTmAbrBrmRateChangeInfo=atmIfVptTmAbrBrmRateChangeInfo, atmIfVccTmStorageType=atmIfVccTmStorageType, atmIfVccTmRxTdpValue=atmIfVccTmRxTdpValue, atmIfVpcUsageState=atmIfVpcUsageState, atmIfAal5RxAborts=atmIfAal5RxAborts, atmIfVccVcdRxQosClass=atmIfVccVcdRxQosClass, atmIfVptVccStorageType=atmIfVptVccStorageType, atmIfVccRxQosClass=atmIfVccRxQosClass, atmIfVpcVpdRowStatusEntry=atmIfVpcVpdRowStatusEntry, atmIfVptCAUbr=atmIfVptCAUbr, atmIfVpcVpdFqpIndex=atmIfVpcVpdFqpIndex, atmIfVptVccLoopRowStatusEntry=atmIfVptVccLoopRowStatusEntry, atmIfVpcRxTdpIndex=atmIfVpcRxTdpIndex, atmIfConnMapOvFirstNonZeroVpiForVccs=atmIfConnMapOvFirstNonZeroVpiForVccs, atmIfVptVccCallDirection=atmIfVptVccCallDirection, atmIfVpcTmTxTdpEntry=atmIfVpcTmTxTdpEntry, atmIfCACbrCdvt=atmIfCACbrCdvt, atmIfVptVpdSegLinkSideLoopback=atmIfVptVpdSegLinkSideLoopback, atmIfVccUnshapedTransmitQueueing=atmIfVccUnshapedTransmitQueueing, atmIfLastLrcFrameErrorConnection=atmIfLastLrcFrameErrorConnection, atmIfVpcVpdTmFqpValue=atmIfVpcVpdTmFqpValue, atmIfCAAbrTxQueueLimit=atmIfCAAbrTxQueueLimit, atmCoreCapabilitiesBE01A=atmCoreCapabilitiesBE01A, atmIfVptTmAbrRateDecreaseFactor=atmIfVptTmAbrRateDecreaseFactor, atmIfVptVccTmAbrComponentName=atmIfVptVccTmAbrComponentName, atmIfCARtVbrRowStatusTable=atmIfCARtVbrRowStatusTable, atmIfVptStatsTxFrameDiscard=atmIfVptStatsTxFrameDiscard, atmIfVptVpdTmComponentName=atmIfVptVpdTmComponentName, atmIfTxFrameDiscard=atmIfTxFrameDiscard, atmIfVptVpdTmBqpTable=atmIfVptVpdTmBqpTable, atmIfVptVccTmHoldingPriority=atmIfVptVccTmHoldingPriority, atmIfVptCACbrStorageType=atmIfVptCACbrStorageType, atmIfCASwitchedMulticastBranches=atmIfCASwitchedMulticastBranches, atmIfVccTmAbrForwardRmCellLimit=atmIfVccTmAbrForwardRmCellLimit, atmIfVccTestAdminState=atmIfVccTestAdminState, atmIfVpcLocalFailureCause=atmIfVpcLocalFailureCause, atmIfVpcTmAbrAcrDecreaseTimeFactor=atmIfVpcTmAbrAcrDecreaseTimeFactor, atmIfVptVccTmTxTdpEntry=atmIfVptVccTmTxTdpEntry, atmIfConnMapOperTable=atmIfConnMapOperTable, atmIfVptTxTrafficDescType=atmIfVptTxTrafficDescType, atmIfCARtVbrOperTable=atmIfCARtVbrOperTable, atmIfVccVcdTmRxPacketWiseDiscard=atmIfVccVcdTmRxPacketWiseDiscard, atmIfVptTmTxQThreshIndex=atmIfVptTmTxQThreshIndex, atmIfVptTmHoldingPriority=atmIfVptTmHoldingPriority, atmIfVptVpdTmBqpIndex=atmIfVptVpdTmBqpIndex, atmIfVptVccLoopIndex=atmIfVptVccLoopIndex, atmIfCAMaxMulticastBranches=atmIfCAMaxMulticastBranches, atmIfVptVccVcdTmAbrDgcraMinimumDelay=atmIfVptVccVcdTmAbrDgcraMinimumDelay, atmIfVccTmAbrTxFwdRmCells=atmIfVccTmAbrTxFwdRmCells, atmIfVptVccSegLinkSideLoopbackState=atmIfVptVccSegLinkSideLoopbackState, atmIfCAPoolWaitAdmConnsIndex=atmIfCAPoolWaitAdmConnsIndex, atmIfVptVpdAtmServiceCategory=atmIfVptVpdAtmServiceCategory, atmIfVccTxQosClass=atmIfVccTxQosClass, atmIfVccStatsRxCellDiscard=atmIfVccStatsRxCellDiscard, atmIfVptVccVcdTmAbrInitialCellRate=atmIfVptVccVcdTmAbrInitialCellRate, atmIfVptVccVcdTmTxTdpIndex=atmIfVptVccVcdTmTxTdpIndex, atmIfVptTmTqpIndex=atmIfVptTmTqpIndex, atmIfVpcVpdTmBqpEntry=atmIfVpcVpdTmBqpEntry, atmIfVccTestCauseOfTermination=atmIfVccTestCauseOfTermination, atmIfVccTmAbrAcrRateChangeInfo=atmIfVccTmAbrAcrRateChangeInfo, atmIfVpcTmBandwidthReduction=atmIfVpcTmBandwidthReduction, atmIfVptVccRxQosClass=atmIfVptVccRxQosClass, atmIfCAMinAutoSelectedVpi=atmIfCAMinAutoSelectedVpi, atmIfVpcVpdTmFqpTable=atmIfVpcVpdTmFqpTable, atmIfCACbrProvPool=atmIfCACbrProvPool, atmIfVptCANrtVbrRowStatusTable=atmIfVptCANrtVbrRowStatusTable, atmIfVptVccStatsEntry=atmIfVptVccStatsEntry, atmIfVpcVpdRxQosClass=atmIfVpcVpdRxQosClass, atmIfVptVpdBwdFrameDiscard=atmIfVptVpdBwdFrameDiscard, atmIfCANrtVbrEpdOffset=atmIfCANrtVbrEpdOffset, atmIfVptTxQThreshIndex=atmIfVptTxQThreshIndex, atmIfVptVccNepRowStatusTable=atmIfVptVccNepRowStatusTable, atmIfVccBearerClassBbc=atmIfVccBearerClassBbc, atmIfCANrtVbrComponentName=atmIfCANrtVbrComponentName, atmIfVptVpdTmAbrFarEndInitialCellRate=atmIfVptVpdTmAbrFarEndInitialCellRate, atmIfVccTxUtilization=atmIfVccTxUtilization, atmIfVptTmBestEffort=atmIfVptTmBestEffort, atmIfVccTmTqpEntry=atmIfVccTmTqpEntry, atmIfVptVpdUsageParameterControl=atmIfVptVpdUsageParameterControl, atmIfVpcTmRowStatus=atmIfVpcTmRowStatus, atmIfVptCAUbrMinimumCellRate=atmIfVptCAUbrMinimumCellRate, atmIfNAcctProvEntry=atmIfNAcctProvEntry, atmIfVpcRowStatus=atmIfVpcRowStatus, atmIfVptVccLocalFailureCause=atmIfVptVccLocalFailureCause, atmIfVptTmOperEntry=atmIfVptTmOperEntry, atmIfCANrtVbrProvTable=atmIfCANrtVbrProvTable, atmIfVpcStatsRxAal5FrameAbort=atmIfVpcStatsRxAal5FrameAbort, atmIfConnMapOvStorageType=atmIfConnMapOvStorageType, atmIfVpcTmIndex=atmIfVpcTmIndex, atmIfVptCARtVbrComponentName=atmIfVptCARtVbrComponentName, atmIfVccTmAbrAcrDecreaseTimeFactor=atmIfVccTmAbrAcrDecreaseTimeFactor, atmIfVptVccTmAbrStorageType=atmIfVptVccTmAbrStorageType, atmIfCAProvEntry=atmIfCAProvEntry, atmIfCARtVbrPerVcQueueLimitReferenceRate=atmIfCARtVbrPerVcQueueLimitReferenceRate, atmIfVccVcdBestEffort=atmIfVccVcdBestEffort, atmIfVptVccVcdRxTdpEntry=atmIfVptVccVcdRxTdpEntry, atmIfCAAbrAbrConnectionType=atmIfCAAbrAbrConnectionType, atmIfVpcTmRqpValue=atmIfVpcTmRqpValue, atmIfConnMapComponentName=atmIfConnMapComponentName, atmIfVccVcdTm=atmIfVccVcdTm, atmIfVptVccTmComponentName=atmIfVptVccTmComponentName, atmIfCAPoolWaitAdmConnsEntry=atmIfCAPoolWaitAdmConnsEntry, atmIfFaultHoldOffTime=atmIfFaultHoldOffTime, atmIfVptVpdTmAbrDgcraMinimumDelay=atmIfVptVpdTmAbrDgcraMinimumDelay, atmIfVptBqpTable=atmIfVptBqpTable, atmIfVptVccVcdTmRxTdpEntry=atmIfVptVccVcdTmRxTdpEntry, atmIfCAVirtualLinkUnallocatedBandwidth=atmIfCAVirtualLinkUnallocatedBandwidth, atmIfVccStatusEntry=atmIfVccStatusEntry, atmIfCAUbrAvailableConnections=atmIfCAUbrAvailableConnections, atmIfOamSegmentBoundary=atmIfOamSegmentBoundary, atmIfVptTmComponentName=atmIfVptTmComponentName, atmIfVccTmClippingBbc=atmIfVccTmClippingBbc, atmIfCAMaxVpts=atmIfCAMaxVpts, atmIfOperTable=atmIfOperTable, atmIfVpcVpdRowStatusTable=atmIfVpcVpdRowStatusTable, atmIfVccVcdBwdQosClass=atmIfVccVcdBwdQosClass, atmIfVccVcdTmBqpIndex=atmIfVccVcdTmBqpIndex, atmIfVpcStorageType=atmIfVpcStorageType, atmIfVptRxDiscard=atmIfVptRxDiscard, atmIfVptVpdLbkEntry=atmIfVptVpdLbkEntry, atmIfVccConnInfoEntry=atmIfVccConnInfoEntry, atmIfVptVpdTmRxTrafficDescType=atmIfVptVpdTmRxTrafficDescType, atmIfConnMapOvComponentName=atmIfConnMapOvComponentName, atmIfVpcVpdFwdQosClass=atmIfVpcVpdFwdQosClass, atmIfVpcVpdBearerClassBbc=atmIfVpcVpdBearerClassBbc, atmIfVpcVpdTmRxTdpTable=atmIfVpcVpdTmRxTdpTable, atmIfVpcVpdBwdFrameDiscard=atmIfVpcVpdBwdFrameDiscard, atmIfVpcVpdBqpTable=atmIfVpcVpdBqpTable, atmIfCACbrPool=atmIfCACbrPool, atmIfProvEntry=atmIfProvEntry, atmIfCATroubledVpcs=atmIfCATroubledVpcs, atmIfVccVcdTmRowStatusTable=atmIfVccVcdTmRowStatusTable, atmIfVpcTxTdpValue=atmIfVpcTxTdpValue, atmIfVptCAPoolProvBwEntry=atmIfVptCAPoolProvBwEntry, atmIfVccTmTqpValue=atmIfVccTmTqpValue, atmIfCAUbrMaxVpts=atmIfCAUbrMaxVpts, atmIfVptVccTestResultsEntry=atmIfVptVccTestResultsEntry)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfVptVccVcdTmAbrRateIncreaseFactor=atmIfVptVccVcdTmAbrRateIncreaseFactor, atmIfEpComponentName=atmIfEpComponentName, atmIfCAUbrTrafficShaping=atmIfCAUbrTrafficShaping, atmIfCACbrEpdOffset=atmIfCACbrEpdOffset, atmIfVptTrafficTable=atmIfVptTrafficTable, atmIfVptVccTrafficShaping=atmIfVptVccTrafficShaping, atmIfCAUbrVpcUsage=atmIfCAUbrVpcUsage, atmIfVptCARtVbrIndex=atmIfVptCARtVbrIndex, atmIfCANrtVbrStorageType=atmIfCANrtVbrStorageType, atmIfVptVccVcdTmAbrIndex=atmIfVptVccVcdTmAbrIndex, atmIfVptVccVcdTxQosClass=atmIfVptVccVcdTxQosClass, atmIfVccVcdLbkEntry=atmIfVccVcdLbkEntry, atmIfVptTmTqpTable=atmIfVptTmTqpTable, atmIfVptVccTmWeight=atmIfVptVccTmWeight, atmIfVptVccStateTable=atmIfVptVccStateTable, atmIfVccVcdTmRowStatusEntry=atmIfVccVcdTmRowStatusEntry, atmIfVptVccVcdTmAbrFixedRoundTripTime=atmIfVptVccVcdTmAbrFixedRoundTripTime, atmIfVccVcdTmWeight=atmIfVccVcdTmWeight, atmIfVptVccTxTdpValue=atmIfVptVccTxTdpValue, atmIfVpcTmAbrForwardRmCellLimit=atmIfVpcTmAbrForwardRmCellLimit, atmIfIndex=atmIfIndex, atmIfCACbrIndex=atmIfCACbrIndex, atmIfVptVccTmRqpIndex=atmIfVptVccTmRqpIndex, atmIfVptCAOperEntry=atmIfVptCAOperEntry, atmIfVptVccIndex=atmIfVptVccIndex, atmIfCAPermittedAtmServiceCategories=atmIfCAPermittedAtmServiceCategories, atmIfVptVpdTmAbrRateIncreaseFactor=atmIfVptVpdTmAbrRateIncreaseFactor, atmIfVptEndToEndLoopbackState=atmIfVptEndToEndLoopbackState, atmIfVptVccTestElapsedTime=atmIfVptVccTestElapsedTime, atmIfVccTmAbrInitialCellRate=atmIfVccTmAbrInitialCellRate, atmIfConnMapRowStatusEntry=atmIfConnMapRowStatusEntry, atmIfCAAbrRowStatusEntry=atmIfCAAbrRowStatusEntry, atmIfVccTestStateTable=atmIfVccTestStateTable, atmIfCAAbrProvEntry=atmIfCAAbrProvEntry, atmIfVptVccVcdTmTxTrafficDescType=atmIfVptVccVcdTmTxTrafficDescType, atmIfVptVccTmBandwidthReduction=atmIfVptVccTmBandwidthReduction, atmIfVpcRxUtilization=atmIfVpcRxUtilization, atmIfVptClippingBbc=atmIfVptClippingBbc, atmIfVptVccVcdTmHoldingPriority=atmIfVptVccVcdTmHoldingPriority, atmIfVpcVpdRxTdpValue=atmIfVpcVpdRxTdpValue, atmIfVpcTmAbrIndex=atmIfVpcTmAbrIndex, atmIfVptBwdQosClass=atmIfVptBwdQosClass, atmIfVccVcdTmTxWredThreshold=atmIfVccVcdTmTxWredThreshold, atmIfVccVcdTmTrafficShaping=atmIfVccVcdTmTrafficShaping, atmIfVpcTrafficTable=atmIfVpcTrafficTable, atmIfVccVcdBqpValue=atmIfVccVcdBqpValue, atmIfRowStatus=atmIfRowStatus, atmIfVpcBandwidthReduction=atmIfVpcBandwidthReduction, atmIfVptTxQThreshTable=atmIfVptTxQThreshTable, atmIfUnknownStatus=atmIfUnknownStatus, atmIfVptVccStatsRxAal5FrameError=atmIfVptVccStatsRxAal5FrameError, atmIfVptRxTdpValue=atmIfVptRxTdpValue, atmIfVpcTmTxTdpValue=atmIfVpcTmTxTdpValue, atmIfVpcTmAbrOperTable=atmIfVpcTmAbrOperTable, atmIfVptCARtVbrCellLossRatio=atmIfVptCARtVbrCellLossRatio, atmIfVptVcc=atmIfVptVcc, atmIfVptVccVcdTmAbrMaxCellPerRmCell=atmIfVptVccVcdTmAbrMaxCellPerRmCell, atmIfVccVcdTransferCapabilityBbc=atmIfVccVcdTransferCapabilityBbc, atmIfCidDataTable=atmIfCidDataTable, atmIfVpcStatsTable=atmIfVpcStatsTable, atmIfVptVccEndToEndLoopbackState=atmIfVptVccEndToEndLoopbackState, atmIfVptCANrtVbrProvTable=atmIfVptCANrtVbrProvTable, atmIfVptCAPoolRequBwValue=atmIfVptCAPoolRequBwValue, atmIfVptCAIndex=atmIfVptCAIndex, atmIfVccVcdUnshapedTransmitQueueing=atmIfVccVcdUnshapedTransmitQueueing, atmIfVptVccTrafficTable=atmIfVptVccTrafficTable, atmIfVccVcdTmAbrDgcraMinimumDelay=atmIfVccVcdTmAbrDgcraMinimumDelay, atmIfVptVccVcdTmAbrRowStatusTable=atmIfVptVccVcdTmAbrRowStatusTable, atmIfVptUsageState=atmIfVptUsageState, atmIfCAPoolAdmConnsIndex=atmIfCAPoolAdmConnsIndex, atmIfVptVccTmTransferCapabilityBbc=atmIfVptVccTmTransferCapabilityBbc, atmIfVptCABwPoolIndex=atmIfVptCABwPoolIndex, atmIfVccVcdTmAbrRowStatusEntry=atmIfVccVcdTmAbrRowStatusEntry, atmIfRxCellEfci=atmIfRxCellEfci, atmIfVptVccStatsTxFrameDiscardClp=atmIfVptVccStatsTxFrameDiscardClp, atmIfVpcVpdTmRxTdpEntry=atmIfVpcVpdTmRxTdpEntry, atmIfVptFqpEntry=atmIfVptFqpEntry, atmIfVptTmTransferCapabilityBbc=atmIfVptTmTransferCapabilityBbc, atmIfVccTrafficTable=atmIfVccTrafficTable, atmIfConnMapFirstNonZeroVpiForVccsOper=atmIfConnMapFirstNonZeroVpiForVccsOper, atmIfCABwPoolTable=atmIfCABwPoolTable, atmIfDroppedRxCells=atmIfDroppedRxCells, atmIfVptVccNepIndex=atmIfVptVccNepIndex, atmIfVptCAComponentName=atmIfVptCAComponentName, atmIfVptVpdTmAbrRowStatus=atmIfVptVpdTmAbrRowStatus, atmIfVptVccVcdCorrelationTag=atmIfVptVccVcdCorrelationTag, atmIfVccVcdSegSwitchSideLoopback=atmIfVccVcdSegSwitchSideLoopback, atmIfVptVccStatsRxFrameDiscardClp=atmIfVptVccStatsRxFrameDiscardClp, atmIfCARtVbrForceTagging=atmIfCARtVbrForceTagging, atmIfVptVccTmRowStatus=atmIfVptVccTmRowStatus, atmIfVpcUsageParameterControl=atmIfVpcUsageParameterControl, atmIfVptVccTmAbrAcrRateChangeInfo=atmIfVptVccTmAbrAcrRateChangeInfo, atmIfVpcTmHoldingPriority=atmIfVpcTmHoldingPriority, atmIfCARtVbrEmissionPriority=atmIfCARtVbrEmissionPriority, atmIfCAAbrEpdOffset=atmIfCAAbrEpdOffset, atmIfVptTmWeight=atmIfVptTmWeight, atmIfCACbrCellLossRatio=atmIfCACbrCellLossRatio, atmIfVptTmRqpTable=atmIfVptTmRqpTable, atmIfVptVpdTmBqpEntry=atmIfVptVpdTmBqpEntry, atmIfVptTmAbrIndex=atmIfVptTmAbrIndex, atmIfCAUbrWeightPolicy=atmIfCAUbrWeightPolicy, atmIfCAPoolRequBwTable=atmIfCAPoolRequBwTable, atmIfVptVpdRowStatus=atmIfVptVpdRowStatus, atmIfVpcVpdTrafficTable=atmIfVpcVpdTrafficTable, atmIfVpcTmTxQosClass=atmIfVpcTmTxQosClass, atmIfVpcTmRqpEntry=atmIfVpcTmRqpEntry, atmIfVptTxFrameDiscard=atmIfVptTxFrameDiscard, atmIfLastDroppedRxCellConnection=atmIfLastDroppedRxCellConnection, atmIfVptVccAdminState=atmIfVptVccAdminState, atmIfVptVccTestVerificationFrmRx=atmIfVptVccTestVerificationFrmRx, atmIfCAUbrEmissionPriority=atmIfCAUbrEmissionPriority, atmIfReceivedCells=atmIfReceivedCells, atmIfVccTmWeight=atmIfVccTmWeight, atmIfCAVirtualLinkRequestedBandwidth=atmIfCAVirtualLinkRequestedBandwidth, atmIfVpcBandwidthElastic=atmIfVpcBandwidthElastic, atmIfVptVccStatsRxUpcViolationOnEnforcer1=atmIfVptVccStatsRxUpcViolationOnEnforcer1, atmIfVpcTmBandwidthElastic=atmIfVpcTmBandwidthElastic, atmIfVptVccTmAbrRowStatus=atmIfVptVccTmAbrRowStatus, atmIfRxCell=atmIfRxCell, atmIfVccTestRowStatus=atmIfVccTestRowStatus, atmIfVptVccVcdTmTxQueueLimit=atmIfVptVccVcdTmTxQueueLimit, atmIfVccTmRowStatusTable=atmIfVccTmRowStatusTable, atmIfVptCAPoolAvailBwIndex=atmIfVptCAPoolAvailBwIndex, atmIfVptVpdFqpEntry=atmIfVptVpdFqpEntry, atmIfVpcVpdTmTransferCapabilityBbc=atmIfVpcVpdTmTransferCapabilityBbc, atmIfVptCACbrComponentName=atmIfVptCACbrComponentName, atmIfCAAbrInitialCellRate=atmIfCAAbrInitialCellRate, atmIfVptVpdLbkTable=atmIfVptVpdLbkTable, atmIfVptVccVcdTmTxWredMode=atmIfVptVccVcdTmTxWredMode, atmIfCACbrProvClr=atmIfCACbrProvClr, atmIfVccTmTxTdpValue=atmIfVccTmTxTdpValue, atmIfVptStatsTxCellClp=atmIfVptStatsTxCellClp, atmIfVccNepRowStatus=atmIfVccNepRowStatus, atmIfVccVcdTmBwdQosClass=atmIfVccVcdTmBwdQosClass, atmIfVptVccTmTxTdpValue=atmIfVptVccTmTxTdpValue, atmIfVptVpdTmTxTdpIndex=atmIfVptVpdTmTxTdpIndex, atmIfVptVccTestLoadingFrmTx=atmIfVptVccTestLoadingFrmTx, atmIfVptVccStateEntry=atmIfVptVccStateEntry, atmIfVptVpdTmTxWredThreshold=atmIfVptVpdTmTxWredThreshold, atmIfVptVccHoldingPriority=atmIfVptVccHoldingPriority, atmIfVptVccTestAdminState=atmIfVptVccTestAdminState, atmIfVptVccTmAbrTxFwdRmCells=atmIfVptVccTmAbrTxFwdRmCells, atmIfVptVccTmRxTrafficDescType=atmIfVptVccTmRxTrafficDescType, atmIfCAAbrRateIncreaseFactor=atmIfCAAbrRateIncreaseFactor, atmIfVccOperEntry=atmIfVccOperEntry, atmIfVptVccTestComponentName=atmIfVptVccTestComponentName, atmIfCABwPoolValue=atmIfCABwPoolValue, atmIfVptVccVcdBqpTable=atmIfVptVccVcdBqpTable, atmIfVptVccTmAbrMaxCellPerRmCell=atmIfVptVccTmAbrMaxCellPerRmCell, atmIfVpcStatsTxFrameDiscard=atmIfVpcStatsTxFrameDiscard, atmIfNAcctProvTable=atmIfNAcctProvTable, atmIfCANrtVbrHoldingPriority=atmIfCANrtVbrHoldingPriority, atmIfVccFqpIndex=atmIfVccFqpIndex, atmIfVccVcdTmAbrTransientBufferExposure=atmIfVccVcdTmAbrTransientBufferExposure, atmIfVccStatsTxCellDiscard=atmIfVccStatsTxCellDiscard, atmIfVptTmTxTdpIndex=atmIfVptTmTxTdpIndex, atmIfVptVccVcdTm=atmIfVptVccVcdTm, atmIfVptVccVcdTmAbrConnectionType=atmIfVptVccVcdTmAbrConnectionType, atmIfVccTestResultsEntry=atmIfVccTestResultsEntry, atmIfCAPermittedSvcAtmServiceCategories=atmIfCAPermittedSvcAtmServiceCategories, atmIfVpcRxDiscardClp=atmIfVpcRxDiscardClp, atmIfVptVccVcdTxTdpValue=atmIfVptVccVcdTxTdpValue, atmIfVpcHoldingPriority=atmIfVpcHoldingPriority, atmIfVccVcdAcctEntry=atmIfVccVcdAcctEntry, atmIfVccNepStorageType=atmIfVccNepStorageType, atmIfVpcVpdTmForceTagging=atmIfVpcVpdTmForceTagging, atmIfVptTxQueueCongestionState=atmIfVptTxQueueCongestionState, atmIfVpcStatsTxCellDiscard=atmIfVpcStatsTxCellDiscard, atmIfVptVccVcdTmTxTdpValue=atmIfVptVccVcdTmTxTdpValue, atmIfVptTmUnshapedTransmitQueueing=atmIfVptTmUnshapedTransmitQueueing, atmIfVccStatsRxFrameDiscardClp=atmIfVccStatsRxFrameDiscardClp, atmIfVptVccTmAbrCutoffDecreaseFactor=atmIfVptVccTmAbrCutoffDecreaseFactor, atmIfVccTxTdpValue=atmIfVccTxTdpValue, atmIfVptVccVcdAcctEntry=atmIfVptVccVcdAcctEntry, atmIfEpIndex=atmIfEpIndex, atmIfAvailabilityStatus=atmIfAvailabilityStatus, atmIfVptTmRxPacketWiseDiscard=atmIfVptTmRxPacketWiseDiscard, atmIfVccTxQThreshIndex=atmIfVccTxQThreshIndex, atmIfVptCAAbrRowStatusTable=atmIfVptCAAbrRowStatusTable, atmIfCACbrStorageType=atmIfCACbrStorageType, atmIfVptVccRxTdpIndex=atmIfVptVccRxTdpIndex, atmIfVptVccVcdIndex=atmIfVptVccVcdIndex, atmIfCAPoolAdmitBwEntry=atmIfCAPoolAdmitBwEntry, atmIfVptVccTroubled=atmIfVptVccTroubled, atmIfVccVcdRowStatus=atmIfVccVcdRowStatus, atmIfVpcTrafficShaping=atmIfVpcTrafficShaping, atmIfVptVccVcdTmFqpIndex=atmIfVptVccVcdTmFqpIndex, atmIfVptVccTmUnshapedTransmitQueueing=atmIfVptVccTmUnshapedTransmitQueueing, atmIfVpcVpdTmAbrRowStatusTable=atmIfVpcVpdTmAbrRowStatusTable, atmIfVptCACbrRowStatusTable=atmIfVptCACbrRowStatusTable, atmIfVptRowStatusEntry=atmIfVptRowStatusEntry, atmIfVccVcdRxTdpTable=atmIfVccVcdRxTdpTable, atmIfVccVcdLbkTable=atmIfVccVcdLbkTable, atmIfVccTmTxQosClass=atmIfVccTmTxQosClass, atmIfTxCellMemoryUsage=atmIfTxCellMemoryUsage, atmIfCANrtVbrRowStatus=atmIfCANrtVbrRowStatus, atmIfVptVpdClippingBbc=atmIfVptVpdClippingBbc, atmIfVccVcdTmAbrProvTable=atmIfVccVcdTmAbrProvTable, atmIfVptVccNepProvEntry=atmIfVptVccNepProvEntry, atmIfVpcVpdTmAbrAcrDecreaseTimeFactor=atmIfVpcVpdTmAbrAcrDecreaseTimeFactor, atmIfVpc=atmIfVpc, atmIfVptVpdTmProvTable=atmIfVptVpdTmProvTable, atmIfVpcTmAbrInitialCellRate=atmIfVpcTmAbrInitialCellRate, atmIfVccStatsRxCellClp=atmIfVccStatsRxCellClp, atmIfVptCAPoolProvBwValue=atmIfVptCAPoolProvBwValue, atmIfLoopbackMonitoring=atmIfLoopbackMonitoring, atmIfVccLoopIndex=atmIfVccLoopIndex, atmIfVptVpdTmAbr=atmIfVptVpdTmAbr, atmIfVptCACbrIndex=atmIfVptCACbrIndex, atmIfVptCANrtVbrStorageType=atmIfVptCANrtVbrStorageType, atmIfVptVccVcdTmRowStatusTable=atmIfVptVccVcdTmRowStatusTable, atmIfVccTransferCapabilityBbc=atmIfVccTransferCapabilityBbc, atmIfVccVcdTmAbrInitialCellRate=atmIfVccVcdTmAbrInitialCellRate, atmIfVptStatsRxAal5FrameError=atmIfVptStatsRxAal5FrameError, atmIfConnMapOvRowStatusTable=atmIfConnMapOvRowStatusTable, atmIfVccTestVerificationFrmBad=atmIfVccTestVerificationFrmBad, atmIfConnMapVccProvTable=atmIfConnMapVccProvTable, atmIfVptVccTmAbrAcrDecreaseTimeFactor=atmIfVptVccTmAbrAcrDecreaseTimeFactor, atmIfVptTmAbrFixedRoundTripTime=atmIfVptTmAbrFixedRoundTripTime, atmIfVptVccBqpIndex=atmIfVptVccBqpIndex, atmIfVccVcdRxTdpIndex=atmIfVccVcdRxTdpIndex, atmIfCACbrProvTable=atmIfCACbrProvTable, atmIfVptVccVcdBqpValue=atmIfVptVccVcdBqpValue, atmIfCAAbrStorageType=atmIfCAAbrStorageType, atmIfVptVpdTmAbrMaxTimeBetweenRmCells=atmIfVptVpdTmAbrMaxTimeBetweenRmCells, atmIfCAVbrRtPool=atmIfCAVbrRtPool, atmIfVpcVpdSegSwitchSideLoopback=atmIfVpcVpdSegSwitchSideLoopback, atmIfVptIndex=atmIfVptIndex, atmIfVccRxTrafficDescType=atmIfVccRxTrafficDescType, atmIfVptVccVcdTmRxTrafficDescType=atmIfVptVccVcdTmRxTrafficDescType, atmIfVptVccTestResultsTable=atmIfVptVccTestResultsTable, atmIfVptVccVcdTmIndex=atmIfVptVccVcdTmIndex, atmIfVccTestSetupEntry=atmIfVccTestSetupEntry, atmIfVpcVpdRxTrafficDescType=atmIfVpcVpdRxTrafficDescType, atmIfCANrtVbrOpUnshapedTransmitQueueing=atmIfCANrtVbrOpUnshapedTransmitQueueing, atmIfVptVccStatusEntry=atmIfVptVccStatusEntry, atmIfVptVpdTxTdpIndex=atmIfVptVpdTxTdpIndex, atmIfVptCAPoolAvailBwEntry=atmIfVptCAPoolAvailBwEntry, atmIfVccBestEffort=atmIfVccBestEffort, atmIfVccVcdTmAbrStorageType=atmIfVccVcdTmAbrStorageType, atmIfVpcTmAbrComponentName=atmIfVpcTmAbrComponentName, atmIfVptVccTest=atmIfVptVccTest, atmIfVptTmBearerClassBbc=atmIfVptTmBearerClassBbc, atmIfVptVccVcdTmProvTable=atmIfVptVccVcdTmProvTable, atmIfConnMapOvNumVccsForVpiZero=atmIfConnMapOvNumVccsForVpiZero, atmIfCAPermanentVccs=atmIfCAPermanentVccs, atmIfCAPoolAdmConnsTable=atmIfCAPoolAdmConnsTable, atmIfVpcStatsTxCellClp=atmIfVpcStatsTxCellClp, atmIfVccLocalFailureCause=atmIfVccLocalFailureCause, atmIfVccTmTxQThreshTable=atmIfVccTmTxQThreshTable, atmIfVccBwdQosClass=atmIfVccBwdQosClass, atmIfVptTmForceTagging=atmIfVptTmForceTagging, atmIfVccVcdLoopbackMonitoring=atmIfVccVcdLoopbackMonitoring, atmIfVptVpdTmRowStatus=atmIfVptVpdTmRowStatus)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfVptLocalFailureCause=atmIfVptLocalFailureCause, atmIfVpcTmTxQThreshValue=atmIfVpcTmTxQThreshValue, atmIfVptVccRxOamCellCongestionState=atmIfVptVccRxOamCellCongestionState, atmIfVccVcdTmBqpEntry=atmIfVccVcdTmBqpEntry, atmIfVpcTmOperEntry=atmIfVpcTmOperEntry, atmIfVpcTxFrameDiscard=atmIfVpcTxFrameDiscard, atmIfVpcTmTqpTable=atmIfVpcTmTqpTable, atmIfVpcVpdLbkEntry=atmIfVpcVpdLbkEntry, atmIfCidDataEntry=atmIfCidDataEntry, atmIfVptTmRqpValue=atmIfVptTmRqpValue, atmIfVccVcdTmRxTrafficDescType=atmIfVccVcdTmRxTrafficDescType, atmIfVpcBwdQosClass=atmIfVpcBwdQosClass, atmIfVptVpdTxTrafficDescType=atmIfVptVpdTxTrafficDescType, atmIfVptCAPoolAdmitBwIndex=atmIfVptCAPoolAdmitBwIndex, atmIfEndToEndLoopback=atmIfEndToEndLoopback, atmIfVccVcdTrafficEntry=atmIfVccVcdTrafficEntry, atmIfVpcStatusEntry=atmIfVpcStatusEntry, atmIfVccStatsRxAal5FrameAbort=atmIfVccStatsRxAal5FrameAbort, atmIfVccStatsTxCell=atmIfVccStatsTxCell, atmIfCATroubledVpts=atmIfCATroubledVpts, atmIfCABwPoolIndex=atmIfCABwPoolIndex, atmIfAdminState=atmIfAdminState, atmIfRxCellDiscardClp=atmIfRxCellDiscardClp, atmIfVccVcdStorageType=atmIfVccVcdStorageType, atmIfStatsEntry=atmIfStatsEntry, atmIfVptVccLoop=atmIfVptVccLoop, atmIfCAAbrMaxCellPerRmCell=atmIfCAAbrMaxCellPerRmCell, atmIfVptTmAbrOperTable=atmIfVptTmAbrOperTable, atmIfVccTxQThreshTable=atmIfVccTxQThreshTable, atmIfVpcVpdAcctTable=atmIfVpcVpdAcctTable, atmIfVptTmAbrConnectionType=atmIfVptTmAbrConnectionType, atmIfVptCARtVbrMaxCtd=atmIfVptCARtVbrMaxCtd, atmIfVccSegLinkSideLoopbackState=atmIfVccSegLinkSideLoopbackState, atmIfVptCAPoolProvBwIndex=atmIfVptCAPoolProvBwIndex, atmIfVccTxDiscard=atmIfVccTxDiscard, atmIfVccHoldingPriority=atmIfVccHoldingPriority, atmIfVptVpdTmClippingBbc=atmIfVptVpdTmClippingBbc, atmIfVptCAAbrRowStatusEntry=atmIfVptCAAbrRowStatusEntry, atmIfVptVpdTmTransferCapabilityBbc=atmIfVptVpdTmTransferCapabilityBbc, atmIfCAAbrPool=atmIfCAAbrPool, atmIfVptTmBandwidthElastic=atmIfVptTmBandwidthElastic, atmIfVptVccTmRxTdpEntry=atmIfVptVccTmRxTdpEntry, atmIfVptCAPoolRequBwTable=atmIfVptCAPoolRequBwTable, atmIfConnMapOvIndex=atmIfConnMapOvIndex, atmIfVpcVpdTmTxTdpValue=atmIfVpcVpdTmTxTdpValue, atmIfMaxVpcs=atmIfMaxVpcs, atmIfVptVccAisState=atmIfVptVccAisState, atmIfVptVccTmTqpIndex=atmIfVptVccTmTqpIndex, atmIfVptVccRxTrafficDescType=atmIfVptVccRxTrafficDescType, atmIfVptCARtVbrStorageType=atmIfVptCARtVbrStorageType, atmIfVptCAPoolProvBwTable=atmIfVptCAPoolProvBwTable, atmIfVptVpdTmFqpEntry=atmIfVptVpdTmFqpEntry, atmIfVptVccConnInfoTable=atmIfVptVccConnInfoTable, atmIfVccStateEntry=atmIfVccStateEntry, atmIfVptVccVcdTmAbrTransientBufferExposure=atmIfVptVccVcdTmAbrTransientBufferExposure, atmIfVccNumLeaves=atmIfVccNumLeaves, atmIfCAAbrAcrDecreaseTimeFactor=atmIfCAAbrAcrDecreaseTimeFactor, atmIfVptVccVcdSegSwitchSideLoopback=atmIfVptVccVcdSegSwitchSideLoopback, atmIfVccVcdBearerClassBbc=atmIfVccVcdBearerClassBbc, atmIfRxFrameDiscard=atmIfRxFrameDiscard, atmIfVptVccTxQueueLength=atmIfVptVccTxQueueLength, atmIfVptVccConnInfoEntry=atmIfVptVccConnInfoEntry, atmIfVccEndToEndLoopbackState=atmIfVccEndToEndLoopbackState, atmIfVpcVpdTxTdpIndex=atmIfVpcVpdTxTdpIndex, atmIfVptVccTxQThreshIndex=atmIfVptVccTxQThreshIndex, atmIfCACbrSvcMpHoldingPriority=atmIfCACbrSvcMpHoldingPriority, atmIfVptVpdLoopbackMonitoring=atmIfVptVpdLoopbackMonitoring, atmIfVccTmRxQosClass=atmIfVccTmRxQosClass, atmIfConnMapOvNumNonZeroVpisForVccs=atmIfConnMapOvNumNonZeroVpisForVccs, atmIfVpcTxQThreshTable=atmIfVpcTxQThreshTable, atmIfVptStatsRxFrameDiscardClp=atmIfVptStatsRxFrameDiscardClp, atmIfVpcVpdIndex=atmIfVpcVpdIndex, atmIfCACbrHoldingPriority=atmIfCACbrHoldingPriority, atmIfVptVccTrafficEntry=atmIfVptVccTrafficEntry, atmIfVptTmRxQosClass=atmIfVptTmRxQosClass, atmIfCAUbrMaxVccs=atmIfCAUbrMaxVccs, atmIfVccNep=atmIfVccNep, atmIfVptCAPoolWaitAdmConnsEntry=atmIfVptCAPoolWaitAdmConnsEntry, atmIfVptVccRowStatusTable=atmIfVptVccRowStatusTable, atmIfCAPoolAvailBwEntry=atmIfCAPoolAvailBwEntry, atmIfVpcVpdTmTrafficShaping=atmIfVpcVpdTmTrafficShaping, atmIfVptVccStatsTxCellDiscardClp=atmIfVptVccStatsTxCellDiscardClp, atmIfVptVpdTmTxTdpValue=atmIfVptVpdTmTxTdpValue, atmIfVpcVpdTmFqpIndex=atmIfVpcVpdTmFqpIndex, atmIfVccVcdHoldingPriority=atmIfVccVcdHoldingPriority, atmIfVptVccSegSwitchSideLoopbackState=atmIfVptVccSegSwitchSideLoopbackState, atmIfVptVccTestIndex=atmIfVptVccTestIndex, atmIfVptTrafficEntry=atmIfVptTrafficEntry, atmIfCAMinAutoSelectedVciForVpiZero=atmIfCAMinAutoSelectedVciForVpiZero, atmIfVccVcdEndToEndLoopback=atmIfVccVcdEndToEndLoopback, atmIfVpcTmAtmServiceCategory=atmIfVpcTmAtmServiceCategory, atmIfConnMapNumVccsPerNonZeroVpiOper=atmIfConnMapNumVccsPerNonZeroVpiOper, atmIfVptVccVcdFqpTable=atmIfVptVccVcdFqpTable, atmIfVpcVpdTmAbrRowStatusEntry=atmIfVpcVpdTmAbrRowStatusEntry, atmIfVptVpdTxQosClass=atmIfVptVpdTxQosClass, atmIfCACbrOperTable=atmIfCACbrOperTable, atmIfVccTxTrafficDescType=atmIfVccTxTrafficDescType, atmIfVptVccRxDiscardClp=atmIfVptVccRxDiscardClp, atmIfVpcVpdFqpTable=atmIfVpcVpdFqpTable, atmIfVccTestStateEntry=atmIfVccTestStateEntry, atmIfCAAbrPerVcQueueLimitReferenceRate=atmIfCAAbrPerVcQueueLimitReferenceRate, atmIfVptCAPoolAdmitBwValue=atmIfVptCAPoolAdmitBwValue, atmIfUnshapedTransmitQueueing=atmIfUnshapedTransmitQueueing, atmIfVptVpdTmAbrDgcraMaximumDelay=atmIfVptVpdTmAbrDgcraMaximumDelay, atmIfCAPoolRequBwEntry=atmIfCAPoolRequBwEntry, atmIfVccTmAbrCutoffDecreaseFactor=atmIfVccTmAbrCutoffDecreaseFactor, atmIfVccStatsRxUpcViolationOnEnforcer2=atmIfVccStatsRxUpcViolationOnEnforcer2, atmIfVccVcdTmTxWredMode=atmIfVccVcdTmTxWredMode, atmIfVpcStateEntry=atmIfVpcStateEntry, atmIfAlarmStatus=atmIfAlarmStatus, atmIfVpcUnshapedTransmitQueueing=atmIfVpcUnshapedTransmitQueueing, atmIfVpcVpdFwdFrameDiscard=atmIfVpcVpdFwdFrameDiscard, atmIfVccAtmServiceCategory=atmIfVccAtmServiceCategory, atmIfVptTmRowStatus=atmIfVptTmRowStatus, atmIfVptRxOamCellCongestionState=atmIfVptRxOamCellCongestionState, atmIfVccNepIndex=atmIfVccNepIndex, atmIfVptCANrtVbrIndex=atmIfVptCANrtVbrIndex, atmIfConnMapOvProvEntry=atmIfConnMapOvProvEntry, atmIfCATroubledVccs=atmIfCATroubledVccs, atmIfCAPermanentVpts=atmIfCAPermanentVpts, atmIfVptVccVcdBestEffort=atmIfVptVccVcdBestEffort, atmIfCAAbrProvTable=atmIfCAAbrProvTable, atmIfVptVccTestFrmTypes=atmIfVptVccTestFrmTypes, atmIfVccVcdTmIndex=atmIfVccVcdTmIndex, atmIfTxCellDiscardClp=atmIfTxCellDiscardClp, atmIfVccTmAbrComponentName=atmIfVccTmAbrComponentName, atmIfVptVccVcdTmAbrDgcraMaximumDelay=atmIfVptVccVcdTmAbrDgcraMaximumDelay, atmIfCAUbrMinimumCellRate=atmIfCAUbrMinimumCellRate, atmIfVptCAUbrComponentName=atmIfVptCAUbrComponentName, atmIfVpcTmAbrRowStatus=atmIfVpcTmAbrRowStatus, atmIfTxCellMemoryCongestionState=atmIfTxCellMemoryCongestionState, atmIfCACbrSvcHoldingPriority=atmIfCACbrSvcHoldingPriority, atmIfCAUbrOperTable=atmIfCAUbrOperTable, atmIfVptVccStatsRxCell=atmIfVptVccStatsRxCell, atmIfVptTmIndex=atmIfVptTmIndex, atmIfVptVccTestTimeRemaining=atmIfVptVccTestTimeRemaining, atmIfVptVccTmAbrBrmExplicitRate=atmIfVptVccTmAbrBrmExplicitRate, atmIfVccTestLoadingFrmRx=atmIfVccTestLoadingFrmRx, atmIfVptVccTmTrafficShaping=atmIfVptVccTmTrafficShaping, atmIfRowStatusEntry=atmIfRowStatusEntry, atmIfVptVccTmRxQosClass=atmIfVptVccTmRxQosClass, atmIfVptVccTmUsageParameterControl=atmIfVptVccTmUsageParameterControl, atmIfVptStatsTable=atmIfVptStatsTable, atmIfVptRxTrafficDescType=atmIfVptRxTrafficDescType, atmIfVccTmTransferCapabilityBbc=atmIfVccTmTransferCapabilityBbc, atmIfVccTmAbrRowStatusTable=atmIfVccTmAbrRowStatusTable, atmIfVptVccTestStateTable=atmIfVptVccTestStateTable, atmIfVptVccStatsTxCellDiscard=atmIfVptVccStatsTxCellDiscard, atmIfNAcctRowStatus=atmIfNAcctRowStatus, atmIfVptRxTdpIndex=atmIfVptRxTdpIndex, atmIfVccVcdTmAbrMaxTimeBetweenRmCells=atmIfVccVcdTmAbrMaxTimeBetweenRmCells, atmIfCAAbrRowStatus=atmIfCAAbrRowStatus, atmIfVptVccTmAbrInitialCellRate=atmIfVptVccTmAbrInitialCellRate, atmIfVptVccTmStorageType=atmIfVptVccTmStorageType, atmIfVccVcdRowStatusTable=atmIfVccVcdRowStatusTable, atmIfVptCAAbrIndex=atmIfVptCAAbrIndex, atmIfVptVccVcdTrafficShaping=atmIfVptVccVcdTrafficShaping, atmIfVccFqpTable=atmIfVccFqpTable, atmIfVptVccTm=atmIfVptVccTm, atmIfVpcIndex=atmIfVpcIndex, atmIfVptCAPoolAdmitBwEntry=atmIfVptCAPoolAdmitBwEntry, atmIfUsageState=atmIfUsageState, atmIfVccTmRxPacketWiseDiscard=atmIfVccTmRxPacketWiseDiscard, atmIfVptVccTxTrafficDescType=atmIfVptVccTxTrafficDescType, atmIfEpRowStatus=atmIfEpRowStatus, atmIfVptVccTestStateEntry=atmIfVptVccTestStateEntry, atmIfCANrtVbrOperEntry=atmIfCANrtVbrOperEntry, atmIfVptVpdTmUnshapedTransmitQueueing=atmIfVptVpdTmUnshapedTransmitQueueing, atmIfVptVccTmForceTagging=atmIfVptVccTmForceTagging, atmIfVccVcdTxTdpEntry=atmIfVccVcdTxTdpEntry, atmIfVccVcdBqpIndex=atmIfVccVcdBqpIndex, atmIfVptVccVcdTmTxTdpTable=atmIfVptVccVcdTmTxTdpTable, atmIfVptOperStatus=atmIfVptOperStatus, atmIfVccTestFrmTypes=atmIfVccTestFrmTypes, atmIfVptCATroubledVccs=atmIfVptCATroubledVccs, atmIfVpcComponentName=atmIfVpcComponentName, atmIfCAUbrTxQueueLimit=atmIfCAUbrTxQueueLimit, atmIfVccFqpEntry=atmIfVccFqpEntry, atmIfVpcRxDiscard=atmIfVpcRxDiscard, atmIfVccTmUsageParameterControl=atmIfVccTmUsageParameterControl, atmIfVpcTmBearerClassBbc=atmIfVpcTmBearerClassBbc, atmIfCANrtVbr=atmIfCANrtVbr, atmIfVptTmTrafficShaping=atmIfVptTmTrafficShaping, atmIfVptVccTmAtmServiceCategory=atmIfVptVccTmAtmServiceCategory, atmIfVptVccTmAbrRxEfci=atmIfVptVccTmAbrRxEfci, atmIfVptTmAbrRateIncreaseFactor=atmIfVptTmAbrRateIncreaseFactor, atmIfCABwPoolEntry=atmIfCABwPoolEntry, atmIfCASwitchedVccs=atmIfCASwitchedVccs, atmIfVpcTmAbrStorageType=atmIfVpcTmAbrStorageType, atmIfCACbrMaxCtd=atmIfCACbrMaxCtd, atmIfVptCANrtVbr=atmIfVptCANrtVbr, atmCoreMIB=atmCoreMIB, atmIfVccConnInfoTable=atmIfVccConnInfoTable, atmIfVptVccNumLeaves=atmIfVptVccNumLeaves, atmIfVccVcdFwdQosClass=atmIfVccVcdFwdQosClass, atmIfVpcConnectionPointType=atmIfVpcConnectionPointType, atmIfVptVccNepProvTable=atmIfVptVccNepProvTable, atmIfTxCellMemoryThresholdValue=atmIfTxCellMemoryThresholdValue, atmIfCAUbrPerVcQueueLimitReferenceRate=atmIfCAUbrPerVcQueueLimitReferenceRate, atmIfVccAdminState=atmIfVccAdminState, atmIfVptTmAbrAcrDecreaseTimeFactor=atmIfVptTmAbrAcrDecreaseTimeFactor, atmIfVptCAAbrStorageType=atmIfVptCAAbrStorageType, atmIfVptTmTxQueueCongestionState=atmIfVptTmTxQueueCongestionState, atmIfVptCANrtVbrComponentName=atmIfVptCANrtVbrComponentName, atmIfVptVccVcdTmAbr=atmIfVptVccVcdTmAbr, atmIfVpcVpdLoopbackMonitoring=atmIfVpcVpdLoopbackMonitoring, atmIfVpcVpdTmAbrIndex=atmIfVpcVpdTmAbrIndex, atmIfVccOperStatus=atmIfVccOperStatus, atmIfVccStatsEntry=atmIfVccStatsEntry, atmIfCAMaxCaVpts=atmIfCAMaxCaVpts, atmIfVptVccAtmServiceCategory=atmIfVptVccAtmServiceCategory, atmIfVptTmAbrTxRateChangeInfo=atmIfVptTmAbrTxRateChangeInfo, atmIfCAVbrNrtPool=atmIfCAVbrNrtPool, atmIfVccTmForceTagging=atmIfVccTmForceTagging, atmIfVccLoop=atmIfVccLoop, atmIfVptVpdTmTxWredMode=atmIfVptVpdTmTxWredMode, atmIfCARtVbrProvEntry=atmIfCARtVbrProvEntry, atmIfCANrtVbrOperTable=atmIfCANrtVbrOperTable, atmIfVptStatsTxCellDiscard=atmIfVptStatsTxCellDiscard, atmIfEpMinimumBandwidthGuarantee=atmIfEpMinimumBandwidthGuarantee, atmIfVptAtmServiceCategory=atmIfVptAtmServiceCategory, atmIfVptVccTmTxQueueCongestionState=atmIfVptVccTmTxQueueCongestionState, atmIfVptVccStatsTxCell=atmIfVptVccStatsTxCell, atmIfVccVcdFwdFrameDiscard=atmIfVccVcdFwdFrameDiscard, atmIfVccTestLoadingFrmLost=atmIfVccTestLoadingFrmLost, atmIfVpcStatsRxCellClp=atmIfVpcStatsRxCellClp, atmIfVccTmIndex=atmIfVccTmIndex, atmIfCAUbrOperEntry=atmIfCAUbrOperEntry, atmIfVpcVpdTmUnshapedTransmitQueueing=atmIfVpcVpdTmUnshapedTransmitQueueing, atmIfVptVccStatsRxCellDiscard=atmIfVptVccStatsRxCellDiscard, atmIfVpcVpdStorageType=atmIfVpcVpdStorageType, atmIfVptCABwPoolValue=atmIfVptCABwPoolValue, atmIfVptCARtVbrCdv=atmIfVptCARtVbrCdv, atmIfVpcTmStorageType=atmIfVpcTmStorageType, atmIfCANrtVbrIndex=atmIfCANrtVbrIndex, atmIfVptVccTxTdpTable=atmIfVptVccTxTdpTable, atmIfVptVccLoopComponentName=atmIfVptVccLoopComponentName, atmIfVptStatsRxUpcViolationOnEnforcer1=atmIfVptStatsRxUpcViolationOnEnforcer1, atmIfCAAbrRateDecreaseFactor=atmIfCAAbrRateDecreaseFactor, atmIfVptVccTmAbrRowStatusTable=atmIfVptVccTmAbrRowStatusTable, atmIfVpcTmTqpValue=atmIfVpcTmTqpValue, atmIfVptTmAtmServiceCategory=atmIfVptTmAtmServiceCategory, atmIfVptCACbrProvTable=atmIfVptCACbrProvTable, atmIfVptVccVcdTmBestEffort=atmIfVptVccVcdTmBestEffort, atmIfCAProvTable=atmIfCAProvTable, atmIfVccConnectionPointType=atmIfVccConnectionPointType, atmIfVptVpdTxTdpEntry=atmIfVptVpdTxTdpEntry, atmIfVptVccRxTdpTable=atmIfVptVccRxTdpTable, atmIfVptVpdEndToEndLoopback=atmIfVptVpdEndToEndLoopback, atmIfVptVccTmBandwidthElastic=atmIfVptVccTmBandwidthElastic, atmIfCAPoolRequBwIndex=atmIfCAPoolRequBwIndex, atmIfVptVccVcdTxTdpEntry=atmIfVptVccVcdTxTdpEntry, atmIfStorageType=atmIfStorageType, atmIfVpcStatsRxCellDiscardClp=atmIfVpcStatsRxCellDiscardClp)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfCAAbrDgcraMinimumDelay=atmIfCAAbrDgcraMinimumDelay, atmIfVptVccVcdTmRowStatusEntry=atmIfVptVccVcdTmRowStatusEntry, atmIfVccStateTable=atmIfVccStateTable, atmIfVpcVpdTrafficEntry=atmIfVpcVpdTrafficEntry, atmIfVpcVpdTmAbrInitialCellRate=atmIfVpcVpdTmAbrInitialCellRate, atmIfCAMaxVccs=atmIfCAMaxVccs, atmIfCAUbrStorageType=atmIfCAUbrStorageType, atmIfVccLoopRowStatusTable=atmIfVccLoopRowStatusTable, atmIfVptVpdTmStorageType=atmIfVptVpdTmStorageType, atmIfCANrtVbrPerVcQueueLimitReferenceRate=atmIfCANrtVbrPerVcQueueLimitReferenceRate, atmIfVccRxTdpIndex=atmIfVccRxTdpIndex, atmIfVccVcdTmTransferCapabilityBbc=atmIfVccVcdTmTransferCapabilityBbc, atmIfVccVcdTmRxTdpEntry=atmIfVccVcdTmRxTdpEntry, atmIfVptVccOperEntry=atmIfVptVccOperEntry, atmIfVptVpdTmFwdQosClass=atmIfVptVpdTmFwdQosClass, atmIfVccTmAbrRateDecreaseFactor=atmIfVccTmAbrRateDecreaseFactor, atmIfVptFqpIndex=atmIfVptFqpIndex, atmIfVpcVpdTmTxTdpIndex=atmIfVpcVpdTmTxTdpIndex, atmIfVptVccFqpEntry=atmIfVptVccFqpEntry, atmIfEp=atmIfEp, atmIfVptCAUbrStorageType=atmIfVptCAUbrStorageType, atmIfVptVpdTmTxTrafficDescType=atmIfVptVpdTmTxTrafficDescType, atmIfVptVccTmAbrBrmRateChangeInfo=atmIfVptVccTmAbrBrmRateChangeInfo, atmIfVptVccTestOperationalState=atmIfVptVccTestOperationalState, atmIfVptVccVcdLbkEntry=atmIfVptVccVcdLbkEntry, atmIfComponentName=atmIfComponentName, atmIfVptVccTmAbrMaxTimeBetweenRmCell=atmIfVptVccTmAbrMaxTimeBetweenRmCell, atmIfVpcTrafficEntry=atmIfVpcTrafficEntry, atmIfLbkEntry=atmIfLbkEntry, atmIfVptVccNepComponentName=atmIfVptVccNepComponentName, atmIfVptVccTestVerificationFrmBad=atmIfVptVccTestVerificationFrmBad, atmIfVptVpdTxTdpTable=atmIfVptVpdTxTdpTable, atmIfVpcVpdTmTxTdpTable=atmIfVpcVpdTmTxTdpTable, atmIfVptTmTxPacketWiseDiscard=atmIfVptTmTxPacketWiseDiscard, atmIfCAAbrDgcraMaximumDelay=atmIfCAAbrDgcraMaximumDelay, atmIfVptVccTxQThreshTable=atmIfVptVccTxQThreshTable, atmIfVptVpdTmFqpValue=atmIfVptVpdTmFqpValue, atmIfCAUbrMaxVpcs=atmIfCAUbrMaxVpcs, atmIfVccVcdTmRxTdpIndex=atmIfVccVcdTmRxTdpIndex, atmIfVccTmAbrBrmExplicitRate=atmIfVccTmAbrBrmExplicitRate, atmIfVccStatsTxFrameDiscard=atmIfVccStatsTxFrameDiscard, atmIfVptCAAbrComponentName=atmIfVptCAAbrComponentName, atmIfVccTxTdpTable=atmIfVccTxTdpTable, atmIfVpcTmRxTdpValue=atmIfVpcTmRxTdpValue, atmIfVptVccVcdRowStatusTable=atmIfVptVccVcdRowStatusTable, atmIfCAPoolAdmitBwTable=atmIfCAPoolAdmitBwTable, atmIfVccVcdTmFwdQosClass=atmIfVccVcdTmFwdQosClass, atmIfConnMapOvRowStatusEntry=atmIfConnMapOvRowStatusEntry, atmIfVptVpdRxTdpIndex=atmIfVptVpdRxTdpIndex, atmIfRemoteAtmInterfaceLabel=atmIfRemoteAtmInterfaceLabel, atmIfVptVccTmAbr=atmIfVptVccTmAbr, atmIfCAMaxAutoSelectedVpi=atmIfCAMaxAutoSelectedVpi, atmIfVptVccVcdTmTxWredThreshold=atmIfVptVccVcdTmTxWredThreshold, atmIfVccTmAbrMaxTimeBetweenRmCell=atmIfVccTmAbrMaxTimeBetweenRmCell, atmIfVptCACbrCellLossRatio=atmIfVptCACbrCellLossRatio, atmIfVccTxFrameDiscard=atmIfVccTxFrameDiscard, atmIfCAAbrCdvt=atmIfCAAbrCdvt, atmIfVpcLoopRowStatusTable=atmIfVpcLoopRowStatusTable, atmIfVptCAUbrPool=atmIfVptCAUbrPool, atmIfVptTmRxTdpValue=atmIfVptTmRxTdpValue, atmIfCACbrMinPerVcQueueLimit=atmIfCACbrMinPerVcQueueLimit, atmIfVptVpdTmAbrIndex=atmIfVptVpdTmAbrIndex, atmIfVptVpdTmAtmServiceCategory=atmIfVptVpdTmAtmServiceCategory, atmIfCAAbr=atmIfCAAbr, atmIfVccRowStatus=atmIfVccRowStatus, atmIfVptVpdRxTdpValue=atmIfVptVpdRxTdpValue, atmIfVptVccTxUtilization=atmIfVptVccTxUtilization, atmIfControlStatus=atmIfControlStatus, atmIfCACbrRowStatus=atmIfCACbrRowStatus, atmIfVptCANrtVbrRowStatus=atmIfVptCANrtVbrRowStatus, atmIfVptVccTestFrmPatternType=atmIfVptVccTestFrmPatternType, atmIfVpcStatsEntry=atmIfVpcStatsEntry, atmIfVptVccBqpEntry=atmIfVptVccBqpEntry, atmIfVptCACbrRowStatusEntry=atmIfVptCACbrRowStatusEntry, atmIfVptCACbrRowStatus=atmIfVptCACbrRowStatus, atmIfVpcTmAbrTxFwdRmCells=atmIfVpcTmAbrTxFwdRmCells, atmIfVptCAUbrRowStatusTable=atmIfVptCAUbrRowStatusTable, atmIfVptVccTxDiscard=atmIfVptVccTxDiscard, atmIfVpcVpdTxTdpTable=atmIfVpcVpdTxTdpTable, atmIfVptStateEntry=atmIfVptStateEntry, atmIfVptFqpValue=atmIfVptFqpValue, atmIfCARtVbrStorageType=atmIfCARtVbrStorageType, atmIfVptVpdBwdQosClass=atmIfVptVpdBwdQosClass, atmIfVptCAPoolAdmitBwTable=atmIfVptCAPoolAdmitBwTable, atmIfCAPoolAdmitBwValue=atmIfCAPoolAdmitBwValue, atmIfVptVccTmRowStatusTable=atmIfVptVccTmRowStatusTable, atmIfTrafficShaping=atmIfTrafficShaping, atmIfCAPoolAvailableBwEntry=atmIfCAPoolAvailableBwEntry, atmIfStateEntry=atmIfStateEntry, atmIfCAMinAutoSelectedVciForNonZeroVpi=atmIfCAMinAutoSelectedVciForNonZeroVpi, atmIfVpcLoopStorageType=atmIfVpcLoopStorageType, atmIfVccRdiState=atmIfVccRdiState, atmIfVptVccVcdTmFqpTable=atmIfVptVccVcdTmFqpTable, atmIfVpcVpdTmComponentName=atmIfVpcVpdTmComponentName, atmIfVpcVpdTmAbrStorageType=atmIfVpcVpdTmAbrStorageType, atmIfVptTmAbrTxFwdRmCells=atmIfVptTmAbrTxFwdRmCells, atmIfCACbrShapeRecoupPolicy=atmIfCACbrShapeRecoupPolicy, atmIfCAUbrProvTable=atmIfCAUbrProvTable, atmIfVccTxQThreshEntry=atmIfVccTxQThreshEntry, atmIfVptTmClippingBbc=atmIfVptTmClippingBbc, atmIfVpcVpdSegLinkSideLoopback=atmIfVpcVpdSegLinkSideLoopback, atmIfVptVpdTmAbrMaxCellPerRmCell=atmIfVptVpdTmAbrMaxCellPerRmCell, atmIfVptVccUnshapedTransmitQueueing=atmIfVptVccUnshapedTransmitQueueing, atmIfVccVcdCorrelationTag=atmIfVccVcdCorrelationTag, atmIfVptVpdTmRxTdpTable=atmIfVptVpdTmRxTdpTable, atmIfEpRowStatusEntry=atmIfEpRowStatusEntry, atmIfVpcRxTrafficDescType=atmIfVpcRxTrafficDescType, atmIfVccVcdRowStatusEntry=atmIfVccVcdRowStatusEntry, atmIfVpcOperStatus=atmIfVpcOperStatus, atmIfVpcStatsRxAal5FrameError=atmIfVpcStatsRxAal5FrameError, atmIfVptBqpIndex=atmIfVptBqpIndex, atmIfCAMinMulticastBranches=atmIfCAMinMulticastBranches, atmIfVptTxTdpEntry=atmIfVptTxTdpEntry, atmIfVptVpdCorrelationTag=atmIfVptVpdCorrelationTag, atmIfVpcAdminState=atmIfVpcAdminState, atmIfVpcTmAbrRowStatusTable=atmIfVpcTmAbrRowStatusTable, atmIfVccStatsRxCell=atmIfVccStatsRxCell, atmIfVptVccRxTdpEntry=atmIfVptVccRxTdpEntry, atmIfVptVccTmRxTdpIndex=atmIfVptVccTmRxTdpIndex, atmIfCAMaxAutoSelectedVciForNonZeroVpi=atmIfCAMaxAutoSelectedVciForNonZeroVpi, atmIfCAPoolAvailBwValue=atmIfCAPoolAvailBwValue, atmIfVptVpdAcctTable=atmIfVptVpdAcctTable, atmIfVptTmUsageParameterControl=atmIfVptTmUsageParameterControl, atmIfCACbr=atmIfCACbr, atmIfVptVccVcdBqpEntry=atmIfVptVccVcdBqpEntry, atmIfVptCAAbr=atmIfVptCAAbr, atmIfVccRowStatusTable=atmIfVccRowStatusTable, atmIfVpcVpdTmBearerClassBbc=atmIfVpcVpdTmBearerClassBbc, atmIfRxCellClp=atmIfRxCellClp, atmIfVpcVpdTmTxWredThreshold=atmIfVpcVpdTmTxWredThreshold, atmIfVptCAPoolAdmConnsTable=atmIfVptCAPoolAdmConnsTable, atmIfVpcVpdTmAbrFarEndInitialCellRate=atmIfVpcVpdTmAbrFarEndInitialCellRate, atmIfNAcctServiceExchange=atmIfNAcctServiceExchange, atmIfVptVccVcdTmBqpIndex=atmIfVptVccVcdTmBqpIndex, atmIfVccTmOperTable=atmIfVccTmOperTable, atmIfVccTestFrmSize=atmIfVccTestFrmSize, atmIfCANrtVbrWeightPolicy=atmIfCANrtVbrWeightPolicy, atmIfVptTmTxQosClass=atmIfVptTmTxQosClass, atmIfVpcStatsTxCell=atmIfVpcStatsTxCell, atmIfCARtVbrMaxCtd=atmIfCARtVbrMaxCtd, atmIfVptVccRowStatusEntry=atmIfVptVccRowStatusEntry, atmIfVptVccTestRowStatus=atmIfVptVccTestRowStatus, atmIfVpcTxQosClass=atmIfVpcTxQosClass, atmIfVptVccVcdRxQosClass=atmIfVptVccVcdRxQosClass, atmIfProvTable=atmIfProvTable, atmIfVptAisState=atmIfVptAisState, atmIfVptVpdBqpTable=atmIfVptVpdBqpTable, atmIfVccTrafficEntry=atmIfVccTrafficEntry, atmIfVptVccVcdRxTdpIndex=atmIfVptVccVcdRxTdpIndex, atmIfVccTmRxTdpIndex=atmIfVccTmRxTdpIndex, atmIfVccFwdQosClass=atmIfVccFwdQosClass, atmIfVptBandwidthReduction=atmIfVptBandwidthReduction, atmIfVccVcdTxTrafficDescType=atmIfVccVcdTxTrafficDescType, atmIfVptVccVcdRxTdpTable=atmIfVptVccVcdRxTdpTable, atmIfOperEntry=atmIfOperEntry, atmIfVpcRxTdpValue=atmIfVpcRxTdpValue, atmIfVpcVpdTxTdpValue=atmIfVpcVpdTxTdpValue, atmIfVpcTmAbrMaxCellPerRmCell=atmIfVpcTmAbrMaxCellPerRmCell, atmIfVptVccTmRqpTable=atmIfVptVccTmRqpTable, atmIfVptVccTxQueueCongestionState=atmIfVptVccTxQueueCongestionState, atmIfVptCAUbrOperEntry=atmIfVptCAUbrOperEntry, atmIfVpcVpdClippingBbc=atmIfVpcVpdClippingBbc, atmIfCACbrComponentName=atmIfCACbrComponentName, atmIfVpcTmAbrBrmRateChangeInfo=atmIfVpcTmAbrBrmRateChangeInfo, atmIfVpcVpdAcctEntry=atmIfVpcVpdAcctEntry, atmIfVpcVpdTmAtmServiceCategory=atmIfVpcVpdTmAtmServiceCategory, atmIfCAUbrComponentName=atmIfCAUbrComponentName, atmIfCARowStatusTable=atmIfCARowStatusTable, atmIfCAUbrRowStatus=atmIfCAUbrRowStatus, atmIfVccRxOamCellCongestionState=atmIfVccRxOamCellCongestionState, atmIfVptVpdTm=atmIfVptVpdTm, atmIfVptVccTransferCapabilityBbc=atmIfVptVccTransferCapabilityBbc, atmIfCAUbrIndex=atmIfCAUbrIndex, atmIfVptTxDiscardClp=atmIfVptTxDiscardClp, atmIfVccVcdRxTdpValue=atmIfVccVcdRxTdpValue, atmIfVptVccVcdStorageType=atmIfVptVccVcdStorageType, atmIfVpcVpdTmTxQueueLimit=atmIfVpcVpdTmTxQueueLimit, atmIfTxCellMemoryThresholdEntry=atmIfTxCellMemoryThresholdEntry, atmIfVptStatsRxCellClp=atmIfVptStatsRxCellClp, atmIfVptVpdTmBearerClassBbc=atmIfVptVpdTmBearerClassBbc, atmIfVccUsageParameterControl=atmIfVccUsageParameterControl, atmIfVpcOperationalState=atmIfVpcOperationalState, atmIfVccClippingBbc=atmIfVccClippingBbc, atmIfVpcVpdComponentName=atmIfVpcVpdComponentName, atmIfVptFwdQosClass=atmIfVptFwdQosClass, atmIfVptVccTxTdpIndex=atmIfVptVccTxTdpIndex, atmIfVccTmTxQThreshIndex=atmIfVccTmTxQThreshIndex, atmIfVccVcdRxTrafficDescType=atmIfVccVcdRxTrafficDescType, atmIfVptTxTdpIndex=atmIfVptTxTdpIndex, atmIfVccFqpValue=atmIfVccFqpValue, atmIfVptUsageParameterControl=atmIfVptUsageParameterControl, atmIfCACbrTrafficShaping=atmIfCACbrTrafficShaping, atmIfVptVpdTmAbrProvTable=atmIfVptVpdTmAbrProvTable, atmIfVptVccTxTdpEntry=atmIfVptVccTxTdpEntry, atmIfVptVccTmTxQThreshTable=atmIfVptVccTmTxQThreshTable, atmIfVpcVpdBestEffort=atmIfVpcVpdBestEffort, atmIfAal5RxErrors=atmIfAal5RxErrors, atmIfVptVccVcdTmBearerClassBbc=atmIfVptVccVcdTmBearerClassBbc, atmIfVptVccTmAbrForwardRmCellLimit=atmIfVptVccTmAbrForwardRmCellLimit, atmIfVccTmTxQueueCongestionState=atmIfVccTmTxQueueCongestionState, atmIfVccOperationalState=atmIfVccOperationalState, atmIfVptTmRxTdpIndex=atmIfVptTmRxTdpIndex, atmIfCANrtVbrRowStatusEntry=atmIfCANrtVbrRowStatusEntry, atmIfVccRxDiscardClp=atmIfVccRxDiscardClp, atmIfVpcRxFrameDiscard=atmIfVpcRxFrameDiscard, atmIfVptVccTestBytesRx=atmIfVptVccTestBytesRx, atmIfVptVccStatsRxCellDiscardClp=atmIfVptVccStatsRxCellDiscardClp, atmIfConnMapOvProvTable=atmIfConnMapOvProvTable, atmIfVccTestVerificationFrmRx=atmIfVccTestVerificationFrmRx, atmIfVptSegLinkSideLoopbackState=atmIfVptSegLinkSideLoopbackState, atmIfConnMapOvRowStatus=atmIfConnMapOvRowStatus, atmIfVptTmAbrStorageType=atmIfVptTmAbrStorageType, atmIfVccVcdTmStorageType=atmIfVccVcdTmStorageType, atmIfCARtVbrSvcMpHoldingPriority=atmIfCARtVbrSvcMpHoldingPriority, atmIfTxCell=atmIfTxCell, atmIfVptVccVcdFqpIndex=atmIfVptVccVcdFqpIndex, atmIfVccStatsTxFrameDiscardClp=atmIfVccStatsTxFrameDiscardClp, atmIfCAPermanentVpcs=atmIfCAPermanentVpcs, atmIfVccVcdTmComponentName=atmIfVccVcdTmComponentName, atmIfVptTmOperTable=atmIfVptTmOperTable, atmIfVptTmRowStatusTable=atmIfVptTmRowStatusTable, atmIfVccLoopRowStatus=atmIfVccLoopRowStatus, atmIfVptVpdBearerClassBbc=atmIfVptVpdBearerClassBbc, atmIfVccBandwidthReduction=atmIfVccBandwidthReduction, atmIfVptVccTestLoadingFrmRx=atmIfVptVccTestLoadingFrmRx, atmIfTxCellMemoryAvailable=atmIfTxCellMemoryAvailable, atmIfVccTroubled=atmIfVccTroubled, atmIfVptCAUbrMaxVccs=atmIfVptCAUbrMaxVccs, atmIfVpcTmBestEffort=atmIfVpcTmBestEffort, atmIfVptVccTxFrameDiscard=atmIfVptVccTxFrameDiscard, atmIfVpcVpdTmAbrRowStatus=atmIfVpcVpdTmAbrRowStatus, atmIfVptVccTmTxPacketWiseDiscard=atmIfVptVccTmTxPacketWiseDiscard, atmIfVpcClippingBbc=atmIfVpcClippingBbc, atmIfVpcOperTable=atmIfVpcOperTable, atmIfVpcTxQThreshIndex=atmIfVpcTxQThreshIndex, atmIfVptVpdRowStatusEntry=atmIfVptVpdRowStatusEntry, atmIfVptTmTxQThreshTable=atmIfVptTmTxQThreshTable, atmIfVptCAProvEntry=atmIfVptCAProvEntry, atmIfVpcAisState=atmIfVpcAisState, atmIfVptTxQosClass=atmIfVptTxQosClass, atmIfVccTmTxTdpEntry=atmIfVccTmTxTdpEntry, atmIfVptVccVcdHoldingPriority=atmIfVptVccVcdHoldingPriority, atmIfVccTmTqpIndex=atmIfVccTmTqpIndex, atmIfTxFrameDiscardClp=atmIfTxFrameDiscardClp, atmIfVpcRxQosClass=atmIfVpcRxQosClass, atmIfCAIndex=atmIfCAIndex, atmIfVpcStatsTxFrameDiscardClp=atmIfVpcStatsTxFrameDiscardClp, atmIfVpcTmAbrOperEntry=atmIfVpcTmAbrOperEntry, atmIfStatsTable=atmIfStatsTable, atmIfVptTmAbrRowStatusTable=atmIfVptTmAbrRowStatusTable, atmIfVpcTmTxQThreshEntry=atmIfVpcTmTxQThreshEntry, atmIfVccVcdTmTxTdpTable=atmIfVccVcdTmTxTdpTable, atmIfCARtVbrMinPerVcQueueLimit=atmIfCARtVbrMinPerVcQueueLimit, atmIfVptVccVcdFwdQosClass=atmIfVptVccVcdFwdQosClass)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfVccTmRxTdpTable=atmIfVccTmRxTdpTable, atmIfVccTestRowStatusEntry=atmIfVccTestRowStatusEntry, atmIfVpcTxQThreshValue=atmIfVpcTxQThreshValue, atmIfVptVccVcdTrafficTable=atmIfVptVccVcdTrafficTable, atmIfCAUbrCdvt=atmIfCAUbrCdvt, atmIfVpcVpdTmAbrRateDecreaseFactor=atmIfVpcVpdTmAbrRateDecreaseFactor, atmIfVccTm=atmIfVccTm, atmIfVccVcdTmAbrCutoffDecreaseFactor=atmIfVccVcdTmAbrCutoffDecreaseFactor, atmIfVpcTxQThreshEntry=atmIfVpcTxQThreshEntry, atmIfVpcVpdBqpIndex=atmIfVpcVpdBqpIndex, atmIfVccStatsRxUpcViolationOnEnforcer1=atmIfVccStatsRxUpcViolationOnEnforcer1, atmIfVccVcdFqpTable=atmIfVccVcdFqpTable, atmIfProceduralStatus=atmIfProceduralStatus, atmIfSegSwitchSideLoopback=atmIfSegSwitchSideLoopback, atmIfCANrtVbrCellLossRatio=atmIfCANrtVbrCellLossRatio, atmIfVccTestElapsedTime=atmIfVccTestElapsedTime, atmIfVptTmAbr=atmIfVptTmAbr, atmIfVccTmTxTdpIndex=atmIfVccTmTxTdpIndex, atmIfVptVpdTmRxPacketWiseDiscard=atmIfVptVpdTmRxPacketWiseDiscard, atmIfVptCAUbrIndex=atmIfVptCAUbrIndex, atmIfVccTmUnshapedTransmitQueueing=atmIfVccTmUnshapedTransmitQueueing, atmIfVccVcdTmAbrDgcraMaximumDelay=atmIfVccVcdTmAbrDgcraMaximumDelay, atmIfVccTmTxPacketWiseDiscard=atmIfVccTmTxPacketWiseDiscard, atmIfVptTmAbrBrmExplicitRate=atmIfVptTmAbrBrmExplicitRate, atmIfVpcVpdTrafficShaping=atmIfVpcVpdTrafficShaping, atmIfVptCACbrProvEntry=atmIfVptCACbrProvEntry, atmIfVptVccFqpIndex=atmIfVptVccFqpIndex, atmIfVccVcdSegLinkSideLoopback=atmIfVccVcdSegLinkSideLoopback, atmIfCAUbrMinPerVcQueueLimit=atmIfCAUbrMinPerVcQueueLimit, atmIfVpcTmTrafficShaping=atmIfVpcTmTrafficShaping, atmIfVptCACbrMaxCtd=atmIfVptCACbrMaxCtd, atmIfVptVccComponentName=atmIfVptVccComponentName, atmIfVptTmStorageType=atmIfVptTmStorageType, atmIfVccRxFrameDiscard=atmIfVccRxFrameDiscard, atmIfVptVccVcdTmWeight=atmIfVptVccVcdTmWeight, atmIfVpcVpdTxTdpEntry=atmIfVpcVpdTxTdpEntry, atmIfVptVccVcdUnshapedTransmitQueueing=atmIfVptVccVcdUnshapedTransmitQueueing, atmIfVptVpdTmBestEffort=atmIfVptVpdTmBestEffort, atmIfVptTm=atmIfVptTm, atmIfConnMapNumNonZeroVpisForVccsOper=atmIfConnMapNumNonZeroVpisForVccsOper, atmIfVccBqpEntry=atmIfVccBqpEntry, atmIfVccNepRowStatusTable=atmIfVccNepRowStatusTable, atmIfVpcStatusTable=atmIfVpcStatusTable, atmIfMaxVccs=atmIfMaxVccs, atmIfVptVccUsageParameterControl=atmIfVptVccUsageParameterControl, atmIfVccTmAbrStorageType=atmIfVccTmAbrStorageType, atmIfVccTmAbrRxEfci=atmIfVccTmAbrRxEfci, atmIfVptVccTmAbrRowStatusEntry=atmIfVptVccTmAbrRowStatusEntry, atmIfVptTmRxTdpTable=atmIfVptTmRxTdpTable, atmIfVptCARtVbrRowStatus=atmIfVptCARtVbrRowStatus, atmIfVptTmTxQThreshValue=atmIfVptTmTxQThreshValue, atmIfVpcEndToEndLoopbackState=atmIfVpcEndToEndLoopbackState, atmIfVccTmAbrOperTable=atmIfVccTmAbrOperTable, atmIfVpcVpdTmIndex=atmIfVpcVpdTmIndex, atmIfVptVccTmRxTdpTable=atmIfVptVccTmRxTdpTable, atmIfVccTmBandwidthReduction=atmIfVccTmBandwidthReduction, atmIfVccTestBytesRx=atmIfVccTestBytesRx, atmIfVptVpdComponentName=atmIfVptVpdComponentName, atmIfVccBandwidthElastic=atmIfVccBandwidthElastic, atmIfVccTrafficShaping=atmIfVccTrafficShaping, atmIfVptVpdTmTxTdpEntry=atmIfVptVpdTmTxTdpEntry, atmIfCANrtVbrPool=atmIfCANrtVbrPool, atmIfVccRxUtilization=atmIfVccRxUtilization, atmIfVptVpdTransferCapabilityBbc=atmIfVptVpdTransferCapabilityBbc, atmIfVccTmTxQThreshValue=atmIfVccTmTxQThreshValue, atmIfCANrtVbrForceTagging=atmIfCANrtVbrForceTagging, atmIfVccVcdTmFqpEntry=atmIfVccVcdTmFqpEntry, atmIfConnMapRowStatus=atmIfConnMapRowStatus, atmIfVptBqpValue=atmIfVptBqpValue, atmIfVptVccRxTdpValue=atmIfVptVccRxTdpValue, atmIfVpcVpdTmAbrFixedRoundTripTime=atmIfVpcVpdTmAbrFixedRoundTripTime, atmIfVpcTxUtilization=atmIfVpcTxUtilization, atmIfVptVpdTmWeight=atmIfVptVpdTmWeight, atmIfVptVccVcdTmUnshapedTransmitQueueing=atmIfVptVccVcdTmUnshapedTransmitQueueing, atmIfVptTmTxTdpEntry=atmIfVptTmTxTdpEntry, atmIfVptTmAbrCutoffDecreaseFactor=atmIfVptTmAbrCutoffDecreaseFactor, atmIfVpcVpdTm=atmIfVpcVpdTm, atmIfVptVccOperationalState=atmIfVptVccOperationalState, atmIfVpcTmAbrCutoffDecreaseFactor=atmIfVpcTmAbrCutoffDecreaseFactor, atmIfVccBqpTable=atmIfVccBqpTable, atmIfCAPoolAvailableBwTable=atmIfCAPoolAvailableBwTable, atmIfVptVccVcdTmFqpValue=atmIfVptVccVcdTmFqpValue, atmIfVptVpdFqpTable=atmIfVptVpdFqpTable, atmIfVccTmAbrRowStatusEntry=atmIfVccTmAbrRowStatusEntry, atmIfVpcVpdTmAbrDgcraMaximumDelay=atmIfVpcVpdTmAbrDgcraMaximumDelay, atmIfVccVcdTmProvEntry=atmIfVccVcdTmProvEntry, atmIfVpcFwdQosClass=atmIfVpcFwdQosClass, atmIfCACbrRowStatusTable=atmIfCACbrRowStatusTable, atmIfVptVpdProvEntry=atmIfVptVpdProvEntry, atmIfVptVccTestRowStatusTable=atmIfVptVccTestRowStatusTable, atmIfVptVccVcdLbkTable=atmIfVptVccVcdLbkTable, atmIfVpcVpd=atmIfVpcVpd, atmIfVpcVpdEndToEndLoopback=atmIfVpcVpdEndToEndLoopback, atmIfCAPoolAdmitBwIndex=atmIfCAPoolAdmitBwIndex, atmIfVpcLoopRowStatusEntry=atmIfVpcLoopRowStatusEntry, atmIfVptVpdRxTdpEntry=atmIfVptVpdRxTdpEntry, atmIfVccTmTxTdpTable=atmIfVccTmTxTdpTable, atmIfVptVccBqpTable=atmIfVptVccBqpTable, atmIfVptVpdTmAbrRowStatusEntry=atmIfVptVpdTmAbrRowStatusEntry, atmIfVptCAConnectionPoolUsage=atmIfVptCAConnectionPoolUsage, atmIfVccTestUnrecognizableFrmRx=atmIfVccTestUnrecognizableFrmRx, atmIfCAAbrOperTable=atmIfCAAbrOperTable, atmIfCACbrForceTagging=atmIfCACbrForceTagging, atmIfVpcFqpTable=atmIfVpcFqpTable, atmIfVccVcdTmClippingBbc=atmIfVccVcdTmClippingBbc, atmIfVccTxTdpEntry=atmIfVccTxTdpEntry, atmIfVpcTmTxPacketWiseDiscard=atmIfVpcTmTxPacketWiseDiscard, atmIfVptCAUbrRowStatusEntry=atmIfVptCAUbrRowStatusEntry, atmIfVptVccNepApplicationName=atmIfVptVccNepApplicationName, atmIfCARtVbrUsageParameterControl=atmIfCARtVbrUsageParameterControl, atmIfVpcTmAbrFixedRoundTripTime=atmIfVpcTmAbrFixedRoundTripTime, atmIfVptTmRqpEntry=atmIfVptTmRqpEntry, atmIfConnMap=atmIfConnMap, atmIfVptCAPoolAvailBwValue=atmIfVptCAPoolAvailBwValue, atmIfCAAbrMinPerVcQueueLimit=atmIfCAAbrMinPerVcQueueLimit, atmIfVccTmRowStatus=atmIfVccTmRowStatus, atmIfCACbrUnshapedTransmitQueueing=atmIfCACbrUnshapedTransmitQueueing, atmIfVccTestOverrideHoldingPriority=atmIfVccTestOverrideHoldingPriority, atmIfVccUsageState=atmIfVccUsageState, atmIfVptVpdTmAbrRowStatusTable=atmIfVptVpdTmAbrRowStatusTable, atmIfSegLinkSideLoopback=atmIfSegLinkSideLoopback, atmIfNAcctComponentName=atmIfNAcctComponentName, atmIfVptCAUbrOperTable=atmIfVptCAUbrOperTable, atmIfCANrtVbrSvcMpHoldingPriority=atmIfCANrtVbrSvcMpHoldingPriority, atmIfVptVccRowStatus=atmIfVptVccRowStatus, atmIfVccVcdTmRowStatus=atmIfVccVcdTmRowStatus, atmIfVccTmTxTrafficDescType=atmIfVccTmTxTrafficDescType, atmIfVccCallDirection=atmIfVccCallDirection, atmIfVpcVpdLbkTable=atmIfVpcVpdLbkTable, atmIfCAUbrUnshapedTransmitQueueing=atmIfCAUbrUnshapedTransmitQueueing, atmIfVpcVpdBqpEntry=atmIfVpcVpdBqpEntry, atmIfVccTestResultsTable=atmIfVccTestResultsTable, atmIfVccVcdTmFqpValue=atmIfVccVcdTmFqpValue, atmIfVpcBqpIndex=atmIfVpcBqpIndex, atmIfVpcVpdBqpValue=atmIfVpcVpdBqpValue, atmIfVptTmRowStatusEntry=atmIfVptTmRowStatusEntry, atmIfVptTmAbrMaxTimeBetweenRmCell=atmIfVptTmAbrMaxTimeBetweenRmCell, atmIfVptStatsRxCellDiscard=atmIfVptStatsRxCellDiscard, atmIfVptVccBwdQosClass=atmIfVptVccBwdQosClass, atmIfVccVcdTxTdpIndex=atmIfVccVcdTxTdpIndex, atmIfVpcVpdTmRxPacketWiseDiscard=atmIfVpcVpdTmRxPacketWiseDiscard, atmIfVccSegSwitchSideLoopbackState=atmIfVccSegSwitchSideLoopbackState, atmIfVccTmAbrRowStatus=atmIfVccTmAbrRowStatus, atmIfVptVccStatsRxFrameDiscard=atmIfVptVccStatsRxFrameDiscard, atmIfVpcLoopIndex=atmIfVpcLoopIndex, atmIfVccVcdTmAbrProvEntry=atmIfVccVcdTmAbrProvEntry, atmCoreGroupBE=atmCoreGroupBE, atmIfCAAbrHoldingPriority=atmIfCAAbrHoldingPriority, atmIfVpcRdiState=atmIfVpcRdiState, atmIfVpcTxTdpIndex=atmIfVpcTxTdpIndex, atmIfVccTxQueueLength=atmIfVccTxQueueLength, atmIfVptVccDistributionType=atmIfVptVccDistributionType, atmIfVptVccVcdBqpIndex=atmIfVptVccVcdBqpIndex, atmIfVpcStatsRxCell=atmIfVpcStatsRxCell, atmIfVpcVpdFqpValue=atmIfVpcVpdFqpValue, atmIfVptVccVcdTransferCapabilityBbc=atmIfVptVccVcdTransferCapabilityBbc, atmIfCAAbrOperEntry=atmIfCAAbrOperEntry, atmIfVccTmRxTrafficDescType=atmIfVccTmRxTrafficDescType, atmIfVptVpdRxQosClass=atmIfVptVpdRxQosClass, atmIfVptTmTxTrafficDescType=atmIfVptTmTxTrafficDescType, atmIfCAMaxVpcs=atmIfCAMaxVpcs, atmIfVccVcdTmAbrFarEndInitialCellRate=atmIfVccVcdTmAbrFarEndInitialCellRate, atmIfVptBestEffort=atmIfVptBestEffort, atmIfCAAbrEmissionPriority=atmIfCAAbrEmissionPriority, atmIfVptVccVcdTmAbrComponentName=atmIfVptVccVcdTmAbrComponentName, atmIfVpcVpdAtmServiceCategory=atmIfVpcVpdAtmServiceCategory, atmIfRxCellDiscard=atmIfRxCellDiscard, atmIfVptVccTmTqpValue=atmIfVptVccTmTqpValue, atmIfVptCAPoolAvailBwTable=atmIfVptCAPoolAvailBwTable, atmIfVptCARtVbrProvTable=atmIfVptCARtVbrProvTable, atmIfVptVccVcdRxTrafficDescType=atmIfVptVccVcdRxTrafficDescType, atmIfVpcStatsRxUpcViolationOnEnforcer2=atmIfVpcStatsRxUpcViolationOnEnforcer2, atmIfVptCACbr=atmIfVptCACbr, atmIfVptVpdBestEffort=atmIfVptVpdBestEffort, atmIfVptVpdTmTrafficShaping=atmIfVptVpdTmTrafficShaping, atmIfVptVccTmRxPacketWiseDiscard=atmIfVptVccTmRxPacketWiseDiscard, atmIfVptTxQueueLength=atmIfVptTxQueueLength, atmIfVptVccNepRowStatusEntry=atmIfVptVccNepRowStatusEntry, atmIfVptCAStorageType=atmIfVptCAStorageType, atmIfVptComponentName=atmIfVptComponentName, atmIfVccVcdUsageParameterControl=atmIfVccVcdUsageParameterControl, atmIfVccTmAbrTransientBufferExposure=atmIfVccTmAbrTransientBufferExposure, atmIfVpcVpdRxTdpTable=atmIfVpcVpdRxTdpTable, atmIfVpcTmRowStatusEntry=atmIfVpcTmRowStatusEntry, atmIfVptVccVcdBwdFrameDiscard=atmIfVptVccVcdBwdFrameDiscard, atmIfCACbrTxQueueLimit=atmIfCACbrTxQueueLimit, atmIfVptStatusEntry=atmIfVptStatusEntry, atmIfVccRxTdpTable=atmIfVccRxTdpTable, atmIfVptVccVcdTmBwdQosClass=atmIfVptVccVcdTmBwdQosClass, atmCoreGroup=atmCoreGroup, atmIfCARtVbrHoldingPriority=atmIfCARtVbrHoldingPriority, atmIfVptVpdStorageType=atmIfVptVpdStorageType, atmIfCAAbrCutoffDecreaseFactor=atmIfCAAbrCutoffDecreaseFactor, atmIfVpcVpdBwdQosClass=atmIfVpcVpdBwdQosClass, atmIfVpcVpdTmAbrCutoffDecreaseFactor=atmIfVpcVpdTmAbrCutoffDecreaseFactor, atmIfLbkTable=atmIfLbkTable, atmIfCAPoolWaitAdmConnsTable=atmIfCAPoolWaitAdmConnsTable, atmIfVpcVpdTmBqpValue=atmIfVpcVpdTmBqpValue, atmIfVptCAAbrProvEntry=atmIfVptCAAbrProvEntry, atmIfVptVccTxQThreshValue=atmIfVptVccTxQThreshValue, atmIfVccVcd=atmIfVccVcd, atmIfVccTest=atmIfVccTest, atmIfVptVccTestSetupEntry=atmIfVptVccTestSetupEntry, atmIfVptVccVcdTmComponentName=atmIfVptVccVcdTmComponentName, atmIfVpcStatsRxFrameDiscard=atmIfVpcStatsRxFrameDiscard, atmIfVpcTmAbrAcrRateChangeInfo=atmIfVpcTmAbrAcrRateChangeInfo, atmIfVccTestUsageState=atmIfVccTestUsageState, atmIfVptTroubled=atmIfVptTroubled, atmIfVptVccBearerClassBbc=atmIfVptVccBearerClassBbc, atmIfCARtVbrOperEntry=atmIfCARtVbrOperEntry, atmIfVpcVpdRowStatus=atmIfVpcVpdRowStatus, atmIfVccVcdTmTxQueueLimit=atmIfVccVcdTmTxQueueLimit, atmIfVccBqpIndex=atmIfVccBqpIndex, atmIfVccTmTxQThreshEntry=atmIfVccTmTxQThreshEntry, atmIfCARtVbr=atmIfCARtVbr, atmIfVptVccVcdTmRxTdpIndex=atmIfVptVccVcdTmRxTdpIndex, atmIfVccTxDiscardClp=atmIfVccTxDiscardClp, atmIfVccVcdTmAbrAcrDecreaseTimeFactor=atmIfVccVcdTmAbrAcrDecreaseTimeFactor, atmIfCAAbrRowStatusTable=atmIfCAAbrRowStatusTable, atmIfCAVbrRtCellLossRatio=atmIfCAVbrRtCellLossRatio, atmIfVptVccStatsTxCellClp=atmIfVptVccStatsTxCellClp, atmIfVccTmRqpTable=atmIfVccTmRqpTable, atmIfVccVcdTmTxTdpValue=atmIfVccVcdTmTxTdpValue, atmIfVptUnshapedTransmitQueueing=atmIfVptUnshapedTransmitQueueing, atmIfCARtVbrUnshapedTransmitQueueing=atmIfCARtVbrUnshapedTransmitQueueing, atmIfVptVpdTmAbrInitialCellRate=atmIfVptVpdTmAbrInitialCellRate, atmIfVptVpdTrafficTable=atmIfVptVpdTrafficTable, atmIfVptConnectionPointType=atmIfVptConnectionPointType, atmIfVptVpdTmIndex=atmIfVptVpdTmIndex, atmIfVccTestDuration=atmIfVccTestDuration, atmIfVccVcdClippingBbc=atmIfVccVcdClippingBbc, atmIfVptRxUtilization=atmIfVptRxUtilization, atmIfVptVpdTmAbrStorageType=atmIfVptVpdTmAbrStorageType, atmIfCASvcCbrHoldingPriority=atmIfCASvcCbrHoldingPriority, atmIfVptVccVcdTmClippingBbc=atmIfVptVccVcdTmClippingBbc, atmIfVptVpdBqpValue=atmIfVptVpdBqpValue, atmIfVccVcdTmBestEffort=atmIfVccVcdTmBestEffort, atmIfCASvcVbrNrtHoldingPriority=atmIfCASvcVbrNrtHoldingPriority, atmIfLrcFrameErrors=atmIfLrcFrameErrors, atmIfVccTestRowStatusTable=atmIfVccTestRowStatusTable, atmIfVccLoopStorageType=atmIfVccLoopStorageType, atmIfCustomerIdentifier=atmIfCustomerIdentifier, atmIfVpcRxOamCellCongestionState=atmIfVpcRxOamCellCongestionState, atmIfNAcct=atmIfNAcct, atmIfNAcctRowStatusTable=atmIfNAcctRowStatusTable, atmIfCANrtVbrTxQueueLimit=atmIfCANrtVbrTxQueueLimit, atmIfVptTmTxQThreshEntry=atmIfVptTmTxQThreshEntry, atmIfNAcctRowStatusEntry=atmIfNAcctRowStatusEntry, atmIfVptVccTestLoadingFrmLost=atmIfVptVccTestLoadingFrmLost, atmIfVptVccVcdTrafficEntry=atmIfVptVccVcdTrafficEntry, atmIfVptVccTmAbrOperTable=atmIfVptVccTmAbrOperTable, atmIfVpcVpdTmRowStatusEntry=atmIfVpcVpdTmRowStatusEntry, atmIfVptVccRdiState=atmIfVptVccRdiState, atmCoreGroupBE01A=atmCoreGroupBE01A)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfVptVccTmTxQosClass=atmIfVptVccTmTxQosClass, atmIfVptVccVcdTmRxPacketWiseDiscard=atmIfVptVccVcdTmRxPacketWiseDiscard, atmIfVccStatsRxCellDiscardClp=atmIfVccStatsRxCellDiscardClp, atmIfCARtVbrRowStatus=atmIfCARtVbrRowStatus, atmIfVccVcdIndex=atmIfVccVcdIndex, atmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor=atmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor, atmIfVpcVpdTmProvEntry=atmIfVpcVpdTmProvEntry, atmIfVptVpdFqpValue=atmIfVptVpdFqpValue, atmIfVpcVpdRxTdpIndex=atmIfVpcVpdRxTdpIndex, atmIfVpcVpdTmRowStatus=atmIfVpcVpdTmRowStatus, atmIfVpcTmAbrConnectionType=atmIfVpcTmAbrConnectionType, atmIfVccTestStorageType=atmIfVccTestStorageType, atmIfCAMaxAutoSelectedVciForVpiZero=atmIfCAMaxAutoSelectedVciForVpiZero, atmIfVpcBearerClassBbc=atmIfVpcBearerClassBbc, atmIfVptVccTestSetupTable=atmIfVptVccTestSetupTable, atmIfVptBqpEntry=atmIfVptBqpEntry, atmIfVptCACbrCdv=atmIfVptCACbrCdv, atmIfVccStatsTable=atmIfVccStatsTable, atmIfVccTmTxQueueLength=atmIfVccTmTxQueueLength, atmIfCAUbrMaxConnections=atmIfCAUbrMaxConnections, atmIfCAUbrSvcMpHoldingPriority=atmIfCAUbrSvcMpHoldingPriority, atmIfVccAisState=atmIfVccAisState, atmIfVptVpdAcctEntry=atmIfVptVpdAcctEntry, atmIfCAAbrIndex=atmIfCAAbrIndex, atmIfVptVpdTmAbrTransientBufferExposure=atmIfVptVpdTmAbrTransientBufferExposure, atmIfCAPoolAvailableBwValue=atmIfCAPoolAvailableBwValue, atmIfVptCAUbrRowStatus=atmIfVptCAUbrRowStatus, atmIfVpcVpdTmClippingBbc=atmIfVpcVpdTmClippingBbc, atmIfVpcTmAbrRateIncreaseFactor=atmIfVpcTmAbrRateIncreaseFactor, atmIfRxLinkUtilization=atmIfRxLinkUtilization, atmIfVptStatsTxCellDiscardClp=atmIfVptStatsTxCellDiscardClp, atmIfVptFqpTable=atmIfVptFqpTable, atmIfConnMapNumVccsForVpiZero=atmIfConnMapNumVccsForVpiZero, atmIfVptVccTmAbrOperEntry=atmIfVptVccTmAbrOperEntry, atmIfVptTmRxTrafficDescType=atmIfVptTmRxTrafficDescType, atmIfVptVccVcdTmAbrRowStatus=atmIfVptVccVcdTmAbrRowStatus, atmIfVptRxTdpTable=atmIfVptRxTdpTable, atmIfCAAbrFairnessPolicy=atmIfCAAbrFairnessPolicy, atmIfVptVccLoopRowStatusTable=atmIfVptVccLoopRowStatusTable, atmIfVccDistributionType=atmIfVccDistributionType, atmIfVpcVpdTmTxTrafficDescType=atmIfVpcVpdTmTxTrafficDescType, atmIfVptVccOperTable=atmIfVptVccOperTable, atmIfConnMapOperEntry=atmIfConnMapOperEntry, atmIfVpcVpdTmAbrProvTable=atmIfVpcVpdTmAbrProvTable, atmIfVpcRowStatusTable=atmIfVpcRowStatusTable, atmIfCAUbrPool=atmIfCAUbrPool, atmIfCACbrUsageParameterControl=atmIfCACbrUsageParameterControl, atmIfVccTestSetupTable=atmIfVccTestSetupTable, atmIfVptVccVcdTmForceTagging=atmIfVptVccVcdTmForceTagging, atmIfVpcTmTxQThreshTable=atmIfVpcTmTxQThreshTable, atmIfVptVpdTxTdpValue=atmIfVptVpdTxTdpValue, atmIfVptCAAbrRowStatus=atmIfVptCAAbrRowStatus, atmIfVpcVpdTmHoldingPriority=atmIfVpcVpdTmHoldingPriority, atmIfVptStatsRxCellDiscardClp=atmIfVptStatsRxCellDiscardClp, atmIfVptVccVcdTmUsageParameterControl=atmIfVptVccVcdTmUsageParameterControl, atmIfVccTmAbrMaxCellPerRmCell=atmIfVccTmAbrMaxCellPerRmCell, atmIfVccStorageType=atmIfVccStorageType, atmIfVccVcdTmTxPacketWiseDiscard=atmIfVccVcdTmTxPacketWiseDiscard, atmIfCAPoolProvBwTable=atmIfCAPoolProvBwTable, atmIfCAAbrMaxTimeBetweenRmCells=atmIfCAAbrMaxTimeBetweenRmCells, atmIfVptVpdTmAbrFixedRoundTripTime=atmIfVptVpdTmAbrFixedRoundTripTime, atmIfVptVccVcdAtmServiceCategory=atmIfVptVccVcdAtmServiceCategory, atmCoreCapabilities=atmCoreCapabilities, atmIfVccRxTdpEntry=atmIfVccRxTdpEntry, atmIfTransmittedCells=atmIfTransmittedCells, atmIfVpcTmTxTdpIndex=atmIfVpcTmTxTdpIndex, atmIfVpcTmRxTrafficDescType=atmIfVpcTmRxTrafficDescType, atmIfEpStorageType=atmIfEpStorageType, atmIfVpcTmWeight=atmIfVpcTmWeight, atmIfVptCARowStatus=atmIfVptCARowStatus, atmIfVccRowStatusEntry=atmIfVccRowStatusEntry, atmIfVccVcdTmAbr=atmIfVccVcdTmAbr, atmIfVpcVpdTmBqpTable=atmIfVpcVpdTmBqpTable, atmIfVptVpdTmTxQueueLimit=atmIfVptVpdTmTxQueueLimit, atmIfVptVccRxFrameDiscard=atmIfVptVccRxFrameDiscard, atmIfCAUbrVccUsage=atmIfCAUbrVccUsage, atmIfVptVccTmTxTdpIndex=atmIfVptVccTmTxTdpIndex, atmIfVpcTmForceTagging=atmIfVpcTmForceTagging, atmIfVccVcdTmFqpTable=atmIfVccVcdTmFqpTable, atmIfVptVccVcdTmFqpEntry=atmIfVptVccVcdTmFqpEntry, atmIfVccNepRowStatusEntry=atmIfVccNepRowStatusEntry, atmIfVptVccBestEffort=atmIfVptVccBestEffort, atmIfVptVccVcdRowStatus=atmIfVptVccVcdRowStatus, atmIfVptVccVcdTmTxPacketWiseDiscard=atmIfVptVccVcdTmTxPacketWiseDiscard, atmIfVpcTmAbrBrmExplicitRate=atmIfVpcTmAbrBrmExplicitRate, atmIfVccStatusTable=atmIfVccStatusTable, atmIfVccVcdTmProvTable=atmIfVccVcdTmProvTable, atmIfVptCANrtVbrCellLossRatio=atmIfVptCANrtVbrCellLossRatio, atmIfVptCAUbrProvTable=atmIfVptCAUbrProvTable, atmIfVpcTmAbrRateDecreaseFactor=atmIfVpcTmAbrRateDecreaseFactor, atmIfVptVpdSegSwitchSideLoopback=atmIfVptVpdSegSwitchSideLoopback, atmIfVptVccTestUsageState=atmIfVptVccTestUsageState, atmIfVccTmBearerClassBbc=atmIfVccTmBearerClassBbc, atmIfVpt=atmIfVpt, atmIfVptCAPoolRequBwEntry=atmIfVptCAPoolRequBwEntry, atmIfVptVccTmAbrRateIncreaseFactor=atmIfVptVccTmAbrRateIncreaseFactor, atmIfVccVcdTmBqpValue=atmIfVccVcdTmBqpValue, atmIfVptVccStatsRxUpcViolationOnEnforcer2=atmIfVptVccStatsRxUpcViolationOnEnforcer2, atmIfVpcTmAbrRowStatusEntry=atmIfVpcTmAbrRowStatusEntry, atmIfVpcTmRxQosClass=atmIfVpcTmRxQosClass, atmIfCARtVbrPool=atmIfCARtVbrPool, atmIfVptVccTmTxQThreshValue=atmIfVptVccTmTxQThreshValue, atmIfVccVcdTmUnshapedTransmitQueueing=atmIfVccVcdTmUnshapedTransmitQueueing, atmIfCARowStatus=atmIfCARowStatus, atmIfCAUbrHoldingPriority=atmIfCAUbrHoldingPriority, atmIfCACbrEmissionPriority=atmIfCACbrEmissionPriority, atmIfVpcVpdTmAbrMaxCellPerRmCell=atmIfVpcVpdTmAbrMaxCellPerRmCell, atmIfVccTxTdpIndex=atmIfVccTxTdpIndex, atmIfVccVcdBwdFrameDiscard=atmIfVccVcdBwdFrameDiscard, atmIfVptCAPoolRequBwIndex=atmIfVptCAPoolRequBwIndex, atmIfVptVccTmTxQThreshEntry=atmIfVptVccTmTxQThreshEntry, atmIfVptVpdFwdFrameDiscard=atmIfVptVpdFwdFrameDiscard, atmIfVptVccFqpTable=atmIfVptVccFqpTable, atmIfVccTestComponentName=atmIfVccTestComponentName, atmIfConnMapRowStatusTable=atmIfConnMapRowStatusTable, atmIfCAUbrEpdOffset=atmIfCAUbrEpdOffset, atmIfVptCANrtVbrPool=atmIfVptCANrtVbrPool, atmIfVccLoopRowStatusEntry=atmIfVccLoopRowStatusEntry, atmIfVptVccTestCauseOfTermination=atmIfVptVccTestCauseOfTermination, atmIfTxCellMemoryThresholdTable=atmIfTxCellMemoryThresholdTable, atmIfVccVcdTmTxTdpEntry=atmIfVccVcdTmTxTdpEntry, atmIfVptTmTxQueueLength=atmIfVptTmTxQueueLength, atmIfVptStorageType=atmIfVptStorageType, atmIfVptVccVcdTmTxTdpEntry=atmIfVptVccVcdTmTxTdpEntry, atmIfVptTmTxTdpTable=atmIfVptTmTxTdpTable, atmIfVpcOperEntry=atmIfVpcOperEntry, atmIfVpcTmAbrRxEfci=atmIfVpcTmAbrRxEfci, atmIfVccStatsRxFrameDiscard=atmIfVccStatsRxFrameDiscard, atmIfVptVccTmRowStatusEntry=atmIfVptVccTmRowStatusEntry, atmIfStateTable=atmIfStateTable, atmIfVptVpdTmRowStatusTable=atmIfVptVpdTmRowStatusTable, atmIfCARtVbrComponentName=atmIfCARtVbrComponentName, atmIfCACbrProvCdvt=atmIfCACbrProvCdvt, atmIfVccTmAtmServiceCategory=atmIfVccTmAtmServiceCategory, atmIfVccVcdTmAbrRowStatus=atmIfVccVcdTmAbrRowStatus, atmIfCARtVbrCdvt=atmIfCARtVbrCdvt, atmIfVpcTmUsageParameterControl=atmIfVpcTmUsageParameterControl, atmIfVpcVpdTmRxTrafficDescType=atmIfVpcVpdTmRxTrafficDescType, atmIfVpcTxTdpEntry=atmIfVpcTxTdpEntry, atmIfEpProvTable=atmIfEpProvTable, atmIfVccTmAbrFixedRoundTripTime=atmIfVccTmAbrFixedRoundTripTime, atmIfCAPoolAvailableBwIndex=atmIfCAPoolAvailableBwIndex, atmIfVptVpdTmHoldingPriority=atmIfVptVpdTmHoldingPriority, atmIfVpcStatsRxCellDiscard=atmIfVpcStatsRxCellDiscard, atmIfVccIndex=atmIfVccIndex, atmIfVptVccStatsTable=atmIfVptVccStatsTable, atmIfVptVccTestDuration=atmIfVptVccTestDuration, atmIfVpcTmAbr=atmIfVpcTmAbr, atmIfVpcSegSwitchSideLoopbackState=atmIfVpcSegSwitchSideLoopbackState, atmIfVpcLoopComponentName=atmIfVpcLoopComponentName, atmIfVccTmAbrRateIncreaseFactor=atmIfVccTmAbrRateIncreaseFactor, atmIfVpcTmTxTdpTable=atmIfVpcTmTxTdpTable, atmIfVptOperEntry=atmIfVptOperEntry, atmIfCAUbrRowStatusEntry=atmIfCAUbrRowStatusEntry, atmIfVptVpdFwdQosClass=atmIfVptVpdFwdQosClass, atmIfVccTmRqpEntry=atmIfVccTmRqpEntry, atmIfVccVcdTmBearerClassBbc=atmIfVccVcdTmBearerClassBbc, atmIfRxFrameDiscardClp=atmIfRxFrameDiscardClp, atmIfVccTmHoldingPriority=atmIfVccTmHoldingPriority, atmIfVptVccTmTxQThreshIndex=atmIfVptVccTmTxQThreshIndex, atmIfVptVccTmAbrRateDecreaseFactor=atmIfVptVccTmAbrRateDecreaseFactor, atmIfVptVpdUnshapedTransmitQueueing=atmIfVptVpdUnshapedTransmitQueueing, atmIfVpcVpdUnshapedTransmitQueueing=atmIfVpcVpdUnshapedTransmitQueueing, atmIfVpcVpdTmAbr=atmIfVpcVpdTmAbr, atmIfVptVccNepStorageType=atmIfVptVccNepStorageType, atmIfCARtVbrTxQueueLimit=atmIfCARtVbrTxQueueLimit, atmIfVptVccTmRxTdpValue=atmIfVptVccTmRxTdpValue, atmIfCAPoolProvBwValue=atmIfCAPoolProvBwValue, atmIfVpcFqpValue=atmIfVpcFqpValue, atmIfVptVpdTmForceTagging=atmIfVptVpdTmForceTagging, atmIfVpcTmTransferCapabilityBbc=atmIfVpcTmTransferCapabilityBbc, atmIfVccVcdTmAbrRateIncreaseFactor=atmIfVccVcdTmAbrRateIncreaseFactor, atmIfVptTxUtilization=atmIfVptTxUtilization, atmIfVptVpdTmBqpValue=atmIfVptVpdTmBqpValue, atmIfCANrtVbrSvcHoldingPriority=atmIfCANrtVbrSvcHoldingPriority, atmIfUnshapedTransmitQueueingOper=atmIfUnshapedTransmitQueueingOper, atmIfVptVccVcdTxTdpIndex=atmIfVptVccVcdTxTdpIndex, atmIfVccStatsTxCellDiscardClp=atmIfVccStatsTxCellDiscardClp, atmIfConnMapStorageType=atmIfConnMapStorageType, atmIfCAPoolAdmConnsEntry=atmIfCAPoolAdmConnsEntry, atmIfVptCAUbrProvEntry=atmIfVptCAUbrProvEntry, atmIfVptTmTxTdpValue=atmIfVptTmTxTdpValue, atmIfVptCAPoolWaitAdmConnsValue=atmIfVptCAPoolWaitAdmConnsValue, atmIfVptVccVcdTxTrafficDescType=atmIfVptVccVcdTxTrafficDescType, atmIfCASwitchedVpcs=atmIfCASwitchedVpcs, atmIfVccTmBandwidthElastic=atmIfVccTmBandwidthElastic, atmIfCANrtVbrTrafficShaping=atmIfCANrtVbrTrafficShaping, atmIfVptStateTable=atmIfVptStateTable, atmIfVptVccVcdRxTdpValue=atmIfVptVccVcdRxTdpValue, atmIfVpcVpdFqpEntry=atmIfVpcVpdFqpEntry, atmIfVptVccVcdFqpEntry=atmIfVptVccVcdFqpEntry, atmIfVpcAtmServiceCategory=atmIfVpcAtmServiceCategory, atmIfVccTestIndex=atmIfVccTestIndex, atmIfCAComponentName=atmIfCAComponentName, atmIfVccVcdFqpValue=atmIfVccVcdFqpValue, atmIfVptVccVcdTxTdpTable=atmIfVptVccVcdTxTdpTable, atmIfVccTxQThreshValue=atmIfVccTxQThreshValue, atmIfVptVpdTmRowStatusEntry=atmIfVptVpdTmRowStatusEntry, atmIfVptVccTxQThreshEntry=atmIfVptVccTxQThreshEntry, atmIfVptVccTmAbrIndex=atmIfVptVccTmAbrIndex, atmIfVptVccTmTxQueueLength=atmIfVptVccTmTxQueueLength, atmIfVccVcdTrafficShaping=atmIfVccVcdTrafficShaping, atmIfVpcVpdTxTrafficDescType=atmIfVpcVpdTxTrafficDescType, atmIfEpProvEntry=atmIfEpProvEntry, atmIfVccTmRxTdpEntry=atmIfVccTmRxTdpEntry, atmIfCAUbrForceTagging=atmIfCAUbrForceTagging, atmIfVptVccUsageState=atmIfVptVccUsageState, atmIfVptStatsEntry=atmIfVptStatsEntry, atmIfVptVpdTmAbrAcrDecreaseTimeFactor=atmIfVptVpdTmAbrAcrDecreaseTimeFactor, atmIfVptVccVcdTmAbrProvEntry=atmIfVptVccVcdTmAbrProvEntry, atmIfVptVccTestCustomizedPattern=atmIfVptVccTestCustomizedPattern, atmIfVpcRxTdpTable=atmIfVpcRxTdpTable, atmIfVccTmRowStatusEntry=atmIfVccTmRowStatusEntry, atmIfCAUbrVptUsage=atmIfCAUbrVptUsage, atmIfVccTestFrmPatternType=atmIfVccTestFrmPatternType, atmIfVpcTmRxTdpIndex=atmIfVpcTmRxTdpIndex, atmIfVccVcdBqpEntry=atmIfVccVcdBqpEntry, atmIfVptVccVcdBearerClassBbc=atmIfVptVccVcdBearerClassBbc, atmIfCARtVbrWeightPolicy=atmIfCARtVbrWeightPolicy, atmIfVptVccVcdTmAbrFarEndInitialCellRate=atmIfVptVccVcdTmAbrFarEndInitialCellRate, atmIfVccTestLoadingFrmTx=atmIfVccTestLoadingFrmTx, atmIfVptVccVcdTmAbrStorageType=atmIfVptVccVcdTmAbrStorageType, atmIfCACbrWeightPolicy=atmIfCACbrWeightPolicy, atmIfVpcVpdTmRxTdpValue=atmIfVpcVpdTmRxTdpValue, atmIfVptVpdTmAbrRateDecreaseFactor=atmIfVptVpdTmAbrRateDecreaseFactor, atmIfVccVcdTmAbrMaxCellPerRmCell=atmIfVccVcdTmAbrMaxCellPerRmCell, atmIfVpcVpdTmStorageType=atmIfVpcVpdTmStorageType, atmIfVptTxTdpValue=atmIfVptTxTdpValue, atmIfVpcTmTxQueueCongestionState=atmIfVpcTmTxQueueCongestionState, atmIfVpcLoop=atmIfVpcLoop, atmIfVccVcdTmRxTdpTable=atmIfVccVcdTmRxTdpTable, atmIfVccVcdTxTdpTable=atmIfVccVcdTxTdpTable, atmIfVptVccStatsRxAal5FrameAbort=atmIfVptVccStatsRxAal5FrameAbort, atmIfVptVccTestStorageType=atmIfVptVccTestStorageType, atmIfVccTmAbrIndex=atmIfVccTmAbrIndex, atmIfVptCARtVbr=atmIfVptCARtVbr, atmIfVptVccTmBearerClassBbc=atmIfVptVccTmBearerClassBbc, atmIfVpcBestEffort=atmIfVpcBestEffort, atmIfVccVcdTmTxTrafficDescType=atmIfVccVcdTmTxTrafficDescType, atmIfVpcTmOperTable=atmIfVpcTmOperTable, atmIfVptCANrtVbrRowStatusEntry=atmIfVptCANrtVbrRowStatusEntry, atmIfVptCARtVbrPool=atmIfVptCARtVbrPool, atmIfVptVccLoopRowStatus=atmIfVptVccLoopRowStatus, atmIfCAMaxCaVpcs=atmIfCAMaxCaVpcs, atmIfVptVpdRxTdpTable=atmIfVptVpdRxTdpTable, atmIfVptCARowStatusEntry=atmIfVptCARowStatusEntry, atmIfVpcLoopRowStatus=atmIfVpcLoopRowStatus, atmIfVccVcdTmAbrIndex=atmIfVccVcdTmAbrIndex, atmIfVptStatsRxCell=atmIfVptStatsRxCell, atmIfCARtVbrIndex=atmIfCARtVbrIndex, atmIfVptVccVcdBwdQosClass=atmIfVptVccVcdBwdQosClass, atmIfVptTmRxTdpEntry=atmIfVptTmRxTdpEntry, atmIfVptVccStatusTable=atmIfVptVccStatusTable, atmIfVptTmAbrTransientBufferExposure=atmIfVptTmAbrTransientBufferExposure)
mibBuilder.exportSymbols("Nortel-Magellan-Passport-AtmCoreMIB", atmIfCAUbrProvEntry=atmIfCAUbrProvEntry, atmIfVpcSegLinkSideLoopbackState=atmIfVpcSegLinkSideLoopbackState, atmIfInterfaceName=atmIfInterfaceName, atmIfVptVpdBqpIndex=atmIfVptVpdBqpIndex, atmIfVpcStatsRxUpcViolationOnEnforcer1=atmIfVpcStatsRxUpcViolationOnEnforcer1, atmIfVptVccVcdSegLinkSideLoopback=atmIfVptVccVcdSegLinkSideLoopback, atmIfVptVccFqpValue=atmIfVptVccFqpValue, atmIfVptVccStatsTxFrameDiscard=atmIfVptVccStatsTxFrameDiscard, atmIfVptTransferCapabilityBbc=atmIfVptTransferCapabilityBbc, atmIfVptCAPoolAdmConnsEntry=atmIfVptCAPoolAdmConnsEntry, atmIfVccTmOperEntry=atmIfVccTmOperEntry, atmIfVptVpdProvTable=atmIfVptVpdProvTable, atmIfVpcVpdTmProvTable=atmIfVpcVpdTmProvTable, atmIfVpcTmRxTdpEntry=atmIfVpcTmRxTdpEntry, atmIfVptStatsRxAal5FrameAbort=atmIfVptStatsRxAal5FrameAbort, atmIfVptTrafficShaping=atmIfVptTrafficShaping, atmIfVptVpdTmAbrProvEntry=atmIfVptVpdTmAbrProvEntry, atmIfVptCAPoolAdmConnsIndex=atmIfVptCAPoolAdmConnsIndex, atmIfVccVcdTmTxTdpIndex=atmIfVccVcdTmTxTdpIndex, atmIfVpcTmClippingBbc=atmIfVpcTmClippingBbc, atmIfVpcTmUnshapedTransmitQueueing=atmIfVpcTmUnshapedTransmitQueueing, atmIfVptTmAbrInitialCellRate=atmIfVptTmAbrInitialCellRate, atmIfCA=atmIfCA, atmIfVpcTmAbrTxRateChangeInfo=atmIfVpcTmAbrTxRateChangeInfo, atmIfVptRxQosClass=atmIfVptRxQosClass, atmIfCACbrProvEntry=atmIfCACbrProvEntry, atmIfVccComponentName=atmIfVccComponentName, atmIfVpcTmAbrTransientBufferExposure=atmIfVpcTmAbrTransientBufferExposure, atmIfCAOperTable=atmIfCAOperTable, atmIfVptRxTdpEntry=atmIfVptRxTdpEntry, atmIfVpcVpdTmTxWredMode=atmIfVpcVpdTmTxWredMode, atmIfVptOperTable=atmIfVptOperTable, atmIfVpcStatsRxFrameDiscardClp=atmIfVpcStatsRxFrameDiscardClp, atmIfVpcTroubled=atmIfVpcTroubled, atmIfVptVccVcdTmRxTdpTable=atmIfVptVccVcdTmRxTdpTable, atmIfVptVpdTrafficEntry=atmIfVptVpdTrafficEntry, atmIfTxLinkUtilization=atmIfTxLinkUtilization, atmIfVpcVpdTmAbrTransientBufferExposure=atmIfVpcVpdTmAbrTransientBufferExposure, atmIfVptStatsTxFrameDiscardClp=atmIfVptStatsTxFrameDiscardClp, atmIfCANrtVbrRowStatusTable=atmIfCANrtVbrRowStatusTable, atmIfVptVccVcdTmTransferCapabilityBbc=atmIfVptVccVcdTmTransferCapabilityBbc, atmIfVccTestTimeRemaining=atmIfVccTestTimeRemaining, atmIfVptVccBqpValue=atmIfVptVccBqpValue, atmIfVptVccVcdTmTrafficShaping=atmIfVptVccVcdTmTrafficShaping, atmIfCAUbrOpUnshapedTransmitQueueing=atmIfCAUbrOpUnshapedTransmitQueueing, atmIfVptVpdTmProvEntry=atmIfVptVpdTmProvEntry, atmIfVptVccVcdLoopbackMonitoring=atmIfVptVccVcdLoopbackMonitoring, atmIfVptCA=atmIfVptCA, atmIfVcc=atmIfVcc, atmIfVptCACbrPool=atmIfVptCACbrPool, atmIfVccRxDiscard=atmIfVccRxDiscard, atmIfConnMapFirstNonZeroVpiForVccs=atmIfConnMapFirstNonZeroVpiForVccs, atmIfConnMapNumNonZeroVpisForVccs=atmIfConnMapNumNonZeroVpisForVccs, atmIfVptCABwPoolTable=atmIfVptCABwPoolTable, atmIfVptVccTmClippingBbc=atmIfVptVccTmClippingBbc, atmIfConnMapOvNumVccsPerNonZeroVpi=atmIfConnMapOvNumVccsPerNonZeroVpi, atmIfCARtVbrSvcHoldingPriority=atmIfCARtVbrSvcHoldingPriority, atmIfVpcTmTqpIndex=atmIfVpcTmTqpIndex, atmIfCAUbrUsageParameterControl=atmIfCAUbrUsageParameterControl, atmIfVccTmAbrConnectionType=atmIfVccTmAbrConnectionType, atmIfVptVccTestBytesTx=atmIfVptVccTestBytesTx, atmIfVptCAPermittedAtmServiceCategories=atmIfVptCAPermittedAtmServiceCategories, atmIfCARtVbrShapeRecoupPolicy=atmIfCARtVbrShapeRecoupPolicy, atmIfVccNepProvTable=atmIfVccNepProvTable, atmIfVccVcdTmRxTdpValue=atmIfVccVcdTmRxTdpValue, atmIfVptVccTmBestEffort=atmIfVptVccTmBestEffort, atmIfCARtVbrProvTable=atmIfCARtVbrProvTable, atmIfVpcStateTable=atmIfVpcStateTable, atmIfVptAdminState=atmIfVptAdminState, atmIfVptVccVcdTmAbrProvTable=atmIfVptVccVcdTmAbrProvTable, atmIfVptVccVcdTmBqpEntry=atmIfVptVccVcdTmBqpEntry, atmIfConnMapOv=atmIfConnMapOv, atmIfVccVcdTmHoldingPriority=atmIfVccVcdTmHoldingPriority, atmIfVpcFqpIndex=atmIfVpcFqpIndex, atmIfVptVccVcdTmAbrMaxTimeBetweenRmCells=atmIfVptVccVcdTmAbrMaxTimeBetweenRmCells, atmIfVccVcdTmForceTagging=atmIfVccVcdTmForceTagging, atmIfVptRxFrameDiscard=atmIfVptRxFrameDiscard, atmIfVpcTmRxPacketWiseDiscard=atmIfVpcTmRxPacketWiseDiscard, atmIfVptVccTxDiscardClp=atmIfVptVccTxDiscardClp, atmIfVccBqpValue=atmIfVccBqpValue, atmIfVptCAPermanentVccs=atmIfVptCAPermanentVccs, atmIfVccVcdTmAbrFixedRoundTripTime=atmIfVccVcdTmAbrFixedRoundTripTime, atmIfCAPoolAvailBwTable=atmIfCAPoolAvailBwTable, atmIfVptVccRxUtilization=atmIfVptVccRxUtilization, atmIfVptCARtVbrRowStatusTable=atmIfVptCARtVbrRowStatusTable, atmIfVpcVpdTmFwdQosClass=atmIfVpcVpdTmFwdQosClass, atmIfVccStatsTxCellClp=atmIfVccStatsTxCellClp, atmIfCANrtVbrUsageParameterControl=atmIfCANrtVbrUsageParameterControl, atmIfOperationalState=atmIfOperationalState, atmIfVpcVpdTmAbrRateIncreaseFactor=atmIfVpcVpdTmAbrRateIncreaseFactor, atmIfVptVccNep=atmIfVptVccNep, atmIfVccVcdTmAbrRateDecreaseFactor=atmIfVccVcdTmAbrRateDecreaseFactor, atmIfCANrtVbrMinPerVcQueueLimit=atmIfCANrtVbrMinPerVcQueueLimit, atmIfVccVcdTmBqpTable=atmIfVccVcdTmBqpTable, atmIfVccTmAbr=atmIfVccTmAbr, atmIfCAUbr=atmIfCAUbr, atmIfConnMapNumVccsPerNonZeroVpi=atmIfConnMapNumVccsPerNonZeroVpi, atmIfVptVccTmRqpEntry=atmIfVptVccTmRqpEntry, atmIfVptTmTqpEntry=atmIfVptTmTqpEntry, atmIfVccVcdTmAbrConnectionType=atmIfVccVcdTmAbrConnectionType, atmIfCAStorageType=atmIfCAStorageType, atmIfVccTestCustomizedPattern=atmIfVccTestCustomizedPattern, atmIfTxCellClp=atmIfTxCellClp, atmIfCAAbrFrttPortion=atmIfCAAbrFrttPortion, atmIfNAcctAccountConnectionType=atmIfNAcctAccountConnectionType, atmIfCARtVbrCellLossRatio=atmIfCARtVbrCellLossRatio, atmIfCAOperEntry=atmIfCAOperEntry, atmCoreGroupBE01=atmCoreGroupBE01, atmIfVptTmAbrForwardRmCellLimit=atmIfVptTmAbrForwardRmCellLimit, atmIfVptVccVcdTmAbrCutoffDecreaseFactor=atmIfVptVccVcdTmAbrCutoffDecreaseFactor, atmIfVptTmAbrComponentName=atmIfVptTmAbrComponentName, atmIfVptVccTestBandwidthElastic=atmIfVptVccTestBandwidthElastic, atmIfVptVccTmIndex=atmIfVptVccTmIndex, atmIfNAcctAccountCollection=atmIfNAcctAccountCollection, atmIfVpcTm=atmIfVpcTm, atmIfVccTestBandwidthElastic=atmIfVccTestBandwidthElastic, atmIfVccLoopComponentName=atmIfVccLoopComponentName, atmIfVptVpdTmFqpIndex=atmIfVptVpdTmFqpIndex, atmIfVptTmAbrMaxCellPerRmCell=atmIfVptTmAbrMaxCellPerRmCell, atmIfVptVccTxQosClass=atmIfVptVccTxQosClass, atmIfVpcVpdTmBwdQosClass=atmIfVpcVpdTmBwdQosClass, atmIfVpcVpdTmTxTdpEntry=atmIfVpcVpdTmTxTdpEntry, atmIfNAcctIndex=atmIfNAcctIndex, atmIfVptVccTmRqpValue=atmIfVptVccTmRqpValue, atmIfVptVccTmTqpTable=atmIfVptVccTmTqpTable, atmIfVptVccVcdTmAbrRateDecreaseFactor=atmIfVptVccVcdTmAbrRateDecreaseFactor, atmIfVptVpdTmRxTdpValue=atmIfVptVpdTmRxTdpValue, atmIfEpRowStatusTable=atmIfEpRowStatusTable, atmIfVptTxTdpTable=atmIfVptTxTdpTable, atmIfVptOperationalState=atmIfVptOperationalState, atmIfVptVpdFqpIndex=atmIfVptVpdFqpIndex, atmIfVptCARowStatusTable=atmIfVptCARowStatusTable, atmIfVptTmAbrOperEntry=atmIfVptTmAbrOperEntry, atmIfVptTmBandwidthReduction=atmIfVptTmBandwidthReduction, atmIfVptVccVcdUsageParameterControl=atmIfVptVccVcdUsageParameterControl, atmIfVccVcdTrafficTable=atmIfVccVcdTrafficTable, atmIfConnMapIndex=atmIfConnMapIndex, atmIfLastAal5RxAbortConnection=atmIfLastAal5RxAbortConnection, atmIfVptVccVcdAcctTable=atmIfVptVccVcdAcctTable, atmIfVptVccTmOperEntry=atmIfVptVccTmOperEntry, atmIfCAAbrComponentName=atmIfCAAbrComponentName, atmIfVccTmBestEffort=atmIfVccTmBestEffort, atmIfVptTmTqpValue=atmIfVptTmTqpValue, atmIfVptStatsRxUpcViolationOnEnforcer2=atmIfVptStatsRxUpcViolationOnEnforcer2, atmIfVptTmAbrRowStatus=atmIfVptTmAbrRowStatus, atmIfVpcVpdTxQosClass=atmIfVpcVpdTxQosClass, atmIfCASvcVbrRtHoldingPriority=atmIfCASvcVbrRtHoldingPriority, atmIfVccNepComponentName=atmIfVccNepComponentName, atmIfVptCAUbrVccUsage=atmIfVptCAUbrVccUsage, atmIfVptVccTmAbrFixedRoundTripTime=atmIfVptVccTmAbrFixedRoundTripTime, atmIfVptCANrtVbrProvEntry=atmIfVptCANrtVbrProvEntry, atmIfVptVccVcdClippingBbc=atmIfVptVccVcdClippingBbc, atmIfVptVccTestFrmSize=atmIfVptVccTestFrmSize, atmIfVpcVpdTmUsageParameterControl=atmIfVpcVpdTmUsageParameterControl, atmIfVptVpdTmUsageParameterControl=atmIfVptVpdTmUsageParameterControl, atmIfCANrtVbrProvEntry=atmIfCANrtVbrProvEntry, atmIfVptVccVcdTmStorageType=atmIfVptVccVcdTmStorageType, atmIfVccVcdTxTdpValue=atmIfVccVcdTxTdpValue, atmIfVptVpdTmRxTdpEntry=atmIfVptVpdTmRxTdpEntry, atmIfVccStatsRxAal5FrameError=atmIfVccStatsRxAal5FrameError, atmIfCARtVbrTrafficShaping=atmIfCARtVbrTrafficShaping, atmIfVptBearerClassBbc=atmIfVptBearerClassBbc, atmIfCAVbrNrtCdvt=atmIfCAVbrNrtCdvt, atmIfCAPoolProvBwEntry=atmIfCAPoolProvBwEntry, atmIfCAAbrUsageParameterControl=atmIfCAAbrUsageParameterControl, atmIfVptRxDiscardClp=atmIfVptRxDiscardClp, atmIfVptVccVcdComponentName=atmIfVptVccVcdComponentName, atmIfVptStatusTable=atmIfVptStatusTable, atmIfVptVccLoopStorageType=atmIfVptVccLoopStorageType, atmIfVpcTxQueueLength=atmIfVpcTxQueueLength, atmIfVccRxTdpValue=atmIfVccRxTdpValue, atmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor=atmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor, atmIfVptCAOperTable=atmIfVptCAOperTable, atmIfVccTmComponentName=atmIfVccTmComponentName, atmIfVptVccFwdQosClass=atmIfVptVccFwdQosClass, atmIfVptVpdTmFqpTable=atmIfVptVpdTmFqpTable, atmIfVptTmAbrRowStatusEntry=atmIfVptTmAbrRowStatusEntry, atmIfVpcRxTdpEntry=atmIfVpcRxTdpEntry, atmIfVccVcdFqpIndex=atmIfVccVcdFqpIndex, atmIfVptVpdVptType=atmIfVptVpdVptType, atmIfCAPoolAdmConnsValue=atmIfCAPoolAdmConnsValue, atmIfVpcVpdTmWeight=atmIfVpcVpdTmWeight, atmIfCACbrPerVcQueueLimitReferenceRate=atmIfCACbrPerVcQueueLimitReferenceRate, atmIfNAcctAccountClass=atmIfNAcctAccountClass, atmIfVptTxQThreshEntry=atmIfVptTxQThreshEntry, atmIfVptCAProvTable=atmIfVptCAProvTable, atmCoreCapabilitiesBE01=atmCoreCapabilitiesBE01, atmIfVpcVpdUsageParameterControl=atmIfVpcVpdUsageParameterControl, atmIfCAUbrShapeRecoupPolicy=atmIfCAUbrShapeRecoupPolicy, atmIfVptVccTmTqpEntry=atmIfVptVccTmTqpEntry, atmIfVpcTxTrafficDescType=atmIfVpcTxTrafficDescType, atmIfVptRowStatusTable=atmIfVptRowStatusTable, atmIfCARtVbrOpUnshapedTransmitQueueing=atmIfCARtVbrOpUnshapedTransmitQueueing, atmIfVpcVpdCorrelationTag=atmIfVpcVpdCorrelationTag, atmIfVpcTmTqpEntry=atmIfVpcTmTqpEntry, atmIfVptVpd=atmIfVptVpd, atmIfVptCACbrCdvt=atmIfVptCACbrCdvt, atmIfVptCABwPoolEntry=atmIfVptCABwPoolEntry, atmIfVptVccTmTxTrafficDescType=atmIfVptVccTmTxTrafficDescType, atmIfVptTmAbrAcrRateChangeInfo=atmIfVptTmAbrAcrRateChangeInfo, atmIfVccVcdFqpEntry=atmIfVccVcdFqpEntry, atmIfVptRowStatus=atmIfVptRowStatus, atmIfVptVpdHoldingPriority=atmIfVptVpdHoldingPriority, atmIfVptVccBandwidthElastic=atmIfVptVccBandwidthElastic, atmCoreCapabilitiesBE=atmCoreCapabilitiesBE, atmIfCANrtVbrEmissionPriority=atmIfCANrtVbrEmissionPriority, atmIfVpcTxQueueCongestionState=atmIfVpcTxQueueCongestionState, atmIfVptCAPoolWaitAdmConnsIndex=atmIfVptCAPoolWaitAdmConnsIndex, atmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor=atmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor, atmIfVptSegSwitchSideLoopbackState=atmIfVptSegSwitchSideLoopbackState, atmIfVptVccVcdTmRowStatus=atmIfVptVccVcdTmRowStatus, atmIfCAPoolWaitAdmConnsValue=atmIfCAPoolWaitAdmConnsValue, atmIfCAUbrRowStatusTable=atmIfCAUbrRowStatusTable, atmIfVpcTxDiscard=atmIfVpcTxDiscard, atmIfVpcVpdTmAbrMaxTimeBetweenRmCells=atmIfVpcVpdTmAbrMaxTimeBetweenRmCells, atmIfVpcTmAbrMaxTimeBetweenRmCell=atmIfVpcTmAbrMaxTimeBetweenRmCell, atmIfVpcTxTdpTable=atmIfVpcTxTdpTable, atmIfVptTmAbrRxEfci=atmIfVptTmAbrRxEfci, atmIfVptVccTestUnrecognizableFrmRx=atmIfVptVccTestUnrecognizableFrmRx, atmIfVptVccVcdFwdFrameDiscard=atmIfVptVccVcdFwdFrameDiscard, atmIfCANrtVbrCdvt=atmIfCANrtVbrCdvt, atmIfCACbrRowStatusEntry=atmIfCACbrRowStatusEntry, atmIfVpcVpdTmAbrProvEntry=atmIfVpcVpdTmAbrProvEntry, atmIfCACbrCdv=atmIfCACbrCdv, atmIfMaxVpiBits=atmIfMaxVpiBits, atmIfVptVccVcdFqpValue=atmIfVptVccVcdFqpValue, atmIfVptCAPoolWaitAdmConnsTable=atmIfVptCAPoolWaitAdmConnsTable, atmIfVptVccNepRowStatus=atmIfVptVccNepRowStatus, atmIfCAPoolRequBwValue=atmIfCAPoolRequBwValue, atmIfVccTestVerificationFrmTx=atmIfVccTestVerificationFrmTx, atmIfVptCAAbrPool=atmIfVptCAAbrPool, atmIfUsageParameterControl=atmIfUsageParameterControl, atmIfVptVpdBqpEntry=atmIfVptVpdBqpEntry, atmIfVccTmAbrBrmRateChangeInfo=atmIfVccTmAbrBrmRateChangeInfo, atmIfVccVcdTmAbrRowStatusTable=atmIfVccVcdTmAbrRowStatusTable, atmIfCANrtVbrShapeRecoupPolicy=atmIfCANrtVbrShapeRecoupPolicy, atmIfVpcVpdTmFqpEntry=atmIfVpcVpdTmFqpEntry, atmIfVptVpdRowStatusTable=atmIfVptVpdRowStatusTable, atmIfType=atmIfType, atmIfCARowStatusEntry=atmIfCARowStatusEntry, atmIfVptVccVcdTmBqpTable=atmIfVptVccVcdTmBqpTable, atmIfVpcVpdTmAbrConnectionType=atmIfVpcVpdTmAbrConnectionType, atmIfVccVcdBqpTable=atmIfVccVcdBqpTable, atmIfVccNepProvEntry=atmIfVccNepProvEntry, atmIfConnMapNumVccsForVpiZeroOper=atmIfConnMapNumVccsForVpiZeroOper)

#
# PySNMP MIB module EICON-MIB-CARD (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EICON-MIB-CARD
# Produced by pysmi-0.3.4 at Wed May  1 12:59:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
MibIdentifier, enterprises, iso, Bits, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ObjectIdentity, Counter64, Gauge32, NotificationType, IpAddress, NotificationType, Integer32, Unsigned32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "enterprises", "iso", "Bits", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "ObjectIdentity", "Counter64", "Gauge32", "NotificationType", "IpAddress", "NotificationType", "Integer32", "Unsigned32", "ModuleIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
eicon = MibIdentifier((1, 3, 6, 1, 4, 1, 434))
management = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2))
mibv2 = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2))
module = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 4))
card = MibIdentifier((1, 3, 6, 1, 4, 1, 434, 2, 2, 2))
class OperState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("other", 1), ("disabled", 2), ("ready", 3), ("active", 4), ("busy", 5))

class CardAdminState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("start", 1), ("stop", 2), ("dump", 3), ("test", 4), ("invalid", 5), ("reset", 6))

class ActionState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("done", 1), ("failed", 2), ("in-progress", 3))

class EiconCardType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37))
    namedValues = NamedValues(("ect-NONE", 1), ("ect-PC-NA", 2), ("ect-PC-DNA", 3), ("ect-PC-SPNA", 4), ("ect-MC-SPCC", 5), ("ect-PC-DPNA", 6), ("ect-PC-EC", 7), ("ect-PC-ECHSI", 8), ("ect-PC-QPNA", 9), ("ect-PC-MPNA", 10), ("ect-MC-EC", 11), ("ect-MC-HSI", 12), ("ect-XX-DIGI", 13), ("ect-MC-IMC", 14), ("ect-PC-IMC", 15), ("ect-MC-MPNA", 16), ("ect-PC-HSI1M", 17), ("ect-MC-HSI1M", 18), ("ect-NB-HSI1M", 19), ("ect-PC-EC1M", 20), ("ect-MC-EC1M", 21), ("ect-NB-EC1M", 22), ("ect-NB-IMC", 23), ("ect-NB-SPCC", 24), ("ect-NB-EC", 25), ("ect-PC-ACC8", 26), ("ect-PC-ISDN", 27), ("ect-PC-DPNA2M", 28), ("ect-PC-MPNA2M", 29), ("ect-MC-MPNA2M", 30), ("ect-MC-SPCC2", 31), ("ect-PP-IMC", 32), ("ect-MC-ISDN", 33), ("ect-PP-EC", 34), ("ect-PC-HSI2", 35), ("ect-PC-S51", 36), ("ect-PC-S52", 37))

class CardRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 6)

class PortRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 48)

class PositiveInteger(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

cardNumberOfCards = MibScalar((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 1), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardNumberOfCards.setStatus('mandatory')
if mibBuilder.loadTexts: cardNumberOfCards.setDescription('The number of EiconCards seen by the Agent.')
cardTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2), )
if mibBuilder.loadTexts: cardTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardTable.setDescription('The table of EiconCards as seen by the agent.')
cardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1), ).setIndexNames((0, "EICON-MIB-CARD", "cardIndex"))
if mibBuilder.loadTexts: cardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardEntry.setDescription('The set of attributes for one EiconCard.')
cardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cardIndex.setDescription('The ID of the EiconCard provided by the local administrator')
cardName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardName.setStatus('mandatory')
if mibBuilder.loadTexts: cardName.setDescription('The name of the EiconCard given by the local administration.')
cardType = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 3), EiconCardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardType.setStatus('mandatory')
if mibBuilder.loadTexts: cardType.setDescription("The type of the EiconCard. The value '0' indicates that the row is invalid.")
cardOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 4), OperState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardOperState.setStatus('mandatory')
if mibBuilder.loadTexts: cardOperState.setDescription('The EiconCard operational state.')
cardAdminStateCtr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 5), CardAdminState()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardAdminStateCtr.setStatus('mandatory')
if mibBuilder.loadTexts: cardAdminStateCtr.setDescription("The administrative state of the EiconCard. Management station can modify the value of that parameter in order to perform a specific action on the EiconCard. Value 'start' is used to start the EiconCard, value 'stop' is used to stop the EiconCard. Value 'dump' is used to dump the EiconCard and value 'test' is used to test the EiconCard hardware. Before the EiconCard is started, the Agent will read the name of the configuration file directory to be used from the srvDomainConfigDir. Agent will respond to that request immediately and start the action. The Management station will poll the cardActionState variable to find out the results of the action and the cardActionError variable to find the error code in the case of the action failure. If the action produces an output file, then the mib variable cardActionOutputFile has to be initialized by the Management station.")
cardDomainConfigDirName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardDomainConfigDirName.setStatus('mandatory')
if mibBuilder.loadTexts: cardDomainConfigDirName.setDescription('The name of the directory in the ESS from which the current configuration file of the card has been taken. The Agent will intialize this value (equal to srvDomainConfigDir) after the card has been successfully started.')
cardLoadTime = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardLoadTime.setStatus('mandatory')
if mibBuilder.loadTexts: cardLoadTime.setDescription('The time elapsed in seconds since the card was loaded.')
cardActionState = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 8), ActionState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardActionState.setStatus('mandatory')
if mibBuilder.loadTexts: cardActionState.setDescription('The state of the operation performed on the card by the Agent as a result of setting the values to the cardAdminStateCtr. The Management station will poll that variable after initiating an action on the card. The value done(1) indicates that the action terminated successfully. The value failed(2) indicates that the action terminated with an error. In this case the variable cardActionError indicates the error code.')
cardActionError = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardActionError.setStatus('mandatory')
if mibBuilder.loadTexts: cardActionError.setDescription('The error code displayed by an unsuccessful operation.')
cardActionOutputFile = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cardActionOutputFile.setStatus('mandatory')
if mibBuilder.loadTexts: cardActionOutputFile.setDescription("The name of file which contains the output of the requested action, ex. 'dump' or 'test'. The default filename is dump<x> or test<x>; where <x> is the card number")
cardProtocols = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardProtocols.setStatus('mandatory')
if mibBuilder.loadTexts: cardProtocols.setDescription('The mask indicating which protocols are installed on the card. snapc=0x10, snafm=0x20, appc=0x40, llc=0x80, xport_iso=0x200, xport_tgx=0x400, netview=0x800')
cardHardwareTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3), )
if mibBuilder.loadTexts: cardHardwareTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardwareTable.setDescription('The table of the EiconCards as seen by the Agent.')
cardHardwareEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1), ).setIndexNames((0, "EICON-MIB-CARD", "cardHardCardRef"))
if mibBuilder.loadTexts: cardHardwareEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardwareEntry.setDescription('The set of hardware attributes for each card.')
cardHardCardRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardCardRef.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardCardRef.setDescription('The ID of the EiconCard that should match the cardIndex from the cardTable.')
cardHardMemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardMemAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardMemAddr.setDescription('The EiconCard memory segment address.')
cardHardIoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardIoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardIoAddr.setDescription('The EiconCard IO address.')
cardHardIntrLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardIntrLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardIntrLevel.setDescription('The EiconCard interrupt level.')
cardHardNbOfPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 5), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardNbOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardNbOfPorts.setDescription('The number of ports on the EiconCard.')
cardHardSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardSlotNumber.setDescription('The slot number for MicroChannel.')
cardHardVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardVersion.setDescription('The hardware version of the EiconCard.')
cardHardSerialNb = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 8), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardSerialNb.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardSerialNb.setDescription('The EiconCard serial number.')
cardHardComponents = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 3, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardHardComponents.setStatus('mandatory')
if mibBuilder.loadTexts: cardHardComponents.setDescription('The names of special hardware components.')
cardSoftwareTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4), )
if mibBuilder.loadTexts: cardSoftwareTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftwareTable.setDescription('The table of all software modules (.elm) that are configured for all EiconCards seen by the Agent. The configuration file from the directory srvProductLocalDirName will be used by the Agent to provide that information')
cardSoftwareEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1), ).setIndexNames((0, "EICON-MIB-CARD", "cardSoftCardRef"), (0, "EICON-MIB-CARD", "cardSoftModuleIndex"))
if mibBuilder.loadTexts: cardSoftwareEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftwareEntry.setDescription('The set of attributes for one software module and one card.')
cardSoftCardRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftCardRef.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftCardRef.setDescription('The ID of the EiconCard; should match the cardIndex from the cardTable.')
cardSoftModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 2), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftModuleIndex.setDescription('The module index number given by the Agent.')
cardSoftModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftModuleName.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftModuleName.setDescription('The module name.')
cardSoftVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftVersion.setDescription('The module version string found inside the module.')
cardSoftDateProd = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftDateProd.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftDateProd.setDescription('The module production date found inside the module.')
cardSoftRealSize = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 4, 1, 6), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardSoftRealSize.setStatus('mandatory')
if mibBuilder.loadTexts: cardSoftRealSize.setDescription("The module size (in bytes). If the value is '0' then this entry is invalid.")
cardBiosSessionTable = MibTable((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5), )
if mibBuilder.loadTexts: cardBiosSessionTable.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSessionTable.setDescription('The table of all sessions handled by the BIOS task for all cards.')
cardBiosSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1), ).setIndexNames((0, "EICON-MIB-CARD", "cardBiosSsnCardRef"), (0, "EICON-MIB-CARD", "cardBiosSsnIndex"))
if mibBuilder.loadTexts: cardBiosSessionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSessionEntry.setDescription('The set of attributes for one session and one card.')
cardBiosSsnCardRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 1), CardRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnCardRef.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnCardRef.setDescription('The ID of the EiconCard; should match the cardIndex from the cardTable.')
cardBiosSsnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 2), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnIndex.setDescription('The session index given by the Agent.')
cardBiosSsnLsn = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 3), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnLsn.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnLsn.setDescription('The logical (BIOS) session number.')
cardBiosSsnPortRef = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 4), PortRef()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnPortRef.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnPortRef.setDescription('The reference of the port where the session is established; should match the portIndex from the portTable.')
cardBiosSsnOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("listening", 2), ("calling", 3), ("connected", 4), ("hangingup", 5), ("hungup", 6), ("aborted", 7), ("wait-for-user", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnOperState.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnOperState.setDescription('The state of the session.')
cardBiosSsnProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("other", 1), ("sdlc", 2), ("snapc", 3), ("snafm", 4), ("appc", 5), ("dlc", 6), ("dialer", 7), ("xportiso", 8), ("xporttgx", 9), ("sndcf", 10), ("x25", 11), ("hdlc", 12), ("frbs", 13), ("conmgr", 14), ("remoteec", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnProtocol.setDescription('The protocol used by the session.')
cardBiosSsnApplName = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnApplName.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnApplName.setDescription('The session Application Name')
cardBiosSsnStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 434, 2, 2, 2, 5, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cardBiosSsnStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: cardBiosSsnStartTime.setDescription('The time elapsed in seconds since session esablishment time.')
cardTrapHeartbeatLost = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,21)).setObjects(("SNMPv2-MIB", "sysName"), ("EICON-MIB-CARD", "cardIndex"))
if mibBuilder.loadTexts: cardTrapHeartbeatLost.setDescription("The 'cardTrapHeartbeatLost' trap indicates that a EiconCard stopped sending statics to the Agent.")
cardTrapStateChange = NotificationType((1, 3, 6, 1, 4, 1, 434) + (0,22)).setObjects(("SNMPv2-MIB", "sysName"), ("EICON-MIB-CARD", "cardIndex"), ("EICON-MIB-CARD", "cardOperState"))
if mibBuilder.loadTexts: cardTrapStateChange.setDescription('The generic Internal trap indicates that the EiconCard has changed state.')
mibBuilder.exportSymbols("EICON-MIB-CARD", cardSoftModuleIndex=cardSoftModuleIndex, cardBiosSsnStartTime=cardBiosSsnStartTime, cardHardNbOfPorts=cardHardNbOfPorts, cardSoftRealSize=cardSoftRealSize, PortRef=PortRef, management=management, cardHardVersion=cardHardVersion, cardHardSerialNb=cardHardSerialNb, cardSoftwareTable=cardSoftwareTable, cardTrapHeartbeatLost=cardTrapHeartbeatLost, CardAdminState=CardAdminState, cardSoftCardRef=cardSoftCardRef, cardProtocols=cardProtocols, cardBiosSsnIndex=cardBiosSsnIndex, EiconCardType=EiconCardType, cardOperState=cardOperState, eicon=eicon, ActionState=ActionState, cardTable=cardTable, cardDomainConfigDirName=cardDomainConfigDirName, cardLoadTime=cardLoadTime, cardSoftModuleName=cardSoftModuleName, cardHardwareTable=cardHardwareTable, cardBiosSsnProtocol=cardBiosSsnProtocol, cardActionState=cardActionState, cardBiosSsnLsn=cardBiosSsnLsn, cardType=cardType, cardBiosSsnPortRef=cardBiosSsnPortRef, cardEntry=cardEntry, card=card, CardRef=CardRef, OperState=OperState, cardHardCardRef=cardHardCardRef, cardHardIntrLevel=cardHardIntrLevel, cardHardMemAddr=cardHardMemAddr, cardSoftwareEntry=cardSoftwareEntry, cardBiosSessionEntry=cardBiosSessionEntry, cardActionOutputFile=cardActionOutputFile, mibv2=mibv2, cardSoftDateProd=cardSoftDateProd, cardHardSlotNumber=cardHardSlotNumber, cardHardIoAddr=cardHardIoAddr, PositiveInteger=PositiveInteger, cardBiosSsnCardRef=cardBiosSsnCardRef, module=module, cardIndex=cardIndex, cardHardwareEntry=cardHardwareEntry, cardBiosSessionTable=cardBiosSessionTable, cardHardComponents=cardHardComponents, cardBiosSsnApplName=cardBiosSsnApplName, cardName=cardName, cardAdminStateCtr=cardAdminStateCtr, cardTrapStateChange=cardTrapStateChange, cardBiosSsnOperState=cardBiosSsnOperState, cardNumberOfCards=cardNumberOfCards, cardActionError=cardActionError, cardSoftVersion=cardSoftVersion)

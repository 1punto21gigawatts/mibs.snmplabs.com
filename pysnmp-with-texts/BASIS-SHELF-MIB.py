#
# PySNMP MIB module BASIS-SHELF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BASIS-SHELF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:34:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
axisRedundancy, basisShelf = mibBuilder.importSymbols("BASIS-MIB", "axisRedundancy", "basisShelf")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, TimeTicks, Counter64, iso, Unsigned32, Integer32, ModuleIdentity, IpAddress, ObjectIdentity, MibIdentifier, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "TimeTicks", "Counter64", "iso", "Unsigned32", "Integer32", "ModuleIdentity", "IpAddress", "ObjectIdentity", "MibIdentifier", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
shelfTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1), )
if mibBuilder.loadTexts: shelfTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTable.setDescription('The table has the Physical slot number and state of the cards ')
shelfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1), ).setIndexNames((0, "BASIS-SHELF-MIB", "shelfNum"), (0, "BASIS-SHELF-MIB", "shelfSlotNum"))
if mibBuilder.loadTexts: shelfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfEntry.setDescription('An entry for the slot ')
shelfNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfNum.setStatus('mandatory')
if mibBuilder.loadTexts: shelfNum.setDescription('A unique value for each shelf. Its value ranges between 1 and the maxvalue of shelfNumber. ')
shelfSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 33))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: shelfSlotNum.setDescription('Slot number of a card. BASIS can have maximum 16 slots in one shelf. 17 is used to reset the whole shelf. Some MGX Series can have maximum 32 slots in one shelf. 33 is used to reset the whole shelf. For MGX8220: INTEGER (1..17) For other selected MGX series: INTEGER (1..33) ')
shelfBkplnSerialNumDeprecated = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBkplnSerialNumDeprecated.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBkplnSerialNumDeprecated.setDescription('This entry has been deprecated. It is available as the 9th entry in basisShelf. It is included here to prevent a hole in the shelfEntry table. ')
shelfFunctionModuleState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 17))).clone(namedValues=NamedValues(("nocard", 1), ("standby", 2), ("active", 3), ("failed", 4), ("selfTest", 5), ("heldInReset", 6), ("boot", 7), ("mismatch", 8), ("unknown", 9), ("coreCardMismatch", 10), ("blocked", 11), ("reserved", 12), ("hold", 13), ("notResponding", 14), ("cardinit", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfFunctionModuleState.setStatus('mandatory')
if mibBuilder.loadTexts: shelfFunctionModuleState.setDescription("This object holds the status of a card in a particular shelf-slot. The hold state is applicable only to MGX8800 Platform. The Slave PXM assumes the hold state during PXM Upgrades. In this state the Slave PXM will be running a different fw but will be receiving all Standby updates(BRAM and Database). The description for the two new states is as follows: 'notResponding' - Response from the Service module has become slow probably due to overloading of CPU. No recovery action is required on user part. At present, this state is implemented only for RPM card. 'cardinit' - When the physical presence of card has been detected but the communication hasn't yet been established between the controller card (PXM) and Service Module. ")
shelfFunctionModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 11, 12, 20, 21, 22, 23, 24, 25, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 50, 51, 52, 53, 60, 61, 70, 71, 72, 73, 80, 90, 91, 100, 101, 110, 111, 120, 121, 130, 131, 132, 133, 134, 135, 136, 137, 140, 141, 150, 151, 563, 564, 787, 1000, 1001, 1002, 1003, 2000, 2001))).clone(namedValues=NamedValues(("other", 1), ("asc", 2), ("bnm-T3", 10), ("bnm-E3", 11), ("bnm-155", 12), ("srm-4T1E1", 20), ("srm-3T3", 21), ("srme-1OC3", 22), ("srme-1STS3", 23), ("srme-NOBC", 24), ("srm-3T3-NOBC", 25), ("frsm-4T1", 30), ("frsm-4E1", 31), ("frsm-4T1-C", 32), ("frsm-4E1-C", 33), ("frsm-hs1", 34), ("frsm-8T1", 35), ("frsm-8E1", 36), ("frsm-hs1b", 37), ("ausm-4T1", 40), ("ausm-4E1", 41), ("ausm-8T1", 50), ("ausm-8E1", 51), ("ausmB-8T1", 52), ("ausmB-8E1", 53), ("cesm-4T1", 60), ("cesm-4E1", 61), ("imatm-T3T1", 70), ("imatm-E3E1", 71), ("imatmB-T1", 72), ("imatmB-E1", 73), ("frasm-8T1", 80), ("cesm-8T1", 90), ("cesm-8E1", 91), ("bscsm-2", 100), ("bscsm-4", 101), ("atmt-8T1", 110), ("atmt-8E1", 111), ("frt-8T1", 120), ("frt-8E1", 121), ("frsm-2ct3", 130), ("frsm-2t3", 131), ("frsm-2e3", 132), ("frsm-hs2", 133), ("frsm-2t3b", 134), ("frsm-2e3b", 135), ("frsm-hs2b-hssi", 136), ("frsm-hs2b-12In1", 137), ("cesm-T3", 140), ("cesm-E3", 141), ("vism-8T1", 150), ("vism-8E1", 151), ("vism-pr-8T1", 563), ("vism-pr-8E1", 564), ("cesmB-8T1", 787), ("pxm1", 1000), ("pxm1-2t3e3", 1001), ("pxm1-4oc3", 1002), ("pxm1-oc12", 1003), ("rpm", 2000), ("rpm-pr", 2001))).clone('other')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfFunctionModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfFunctionModuleType.setDescription('This object holds the type of a card in a particular shelf-slot. ')
shelfFunctionModuleHoldReset = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("doNotHold", 1), ("holdInReset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfFunctionModuleHoldReset.setStatus('mandatory')
if mibBuilder.loadTexts: shelfFunctionModuleHoldReset.setDescription("This object holds the card in a particular shelf-slot, in reset, If the object is set to holdInReset. If the object is set to doNotHold, then it only reset the card in the specified slot, if slot number is 17 then it'll reset the whole shelf. ")
shelfNumOfValidEntries = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfNumOfValidEntries.setStatus('mandatory')
if mibBuilder.loadTexts: shelfNumOfValidEntries.setDescription('Number of rows in shelfTable. In some MGX series, it is equal to the number of slots in the shelf. ')
shelfNodeName = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfNodeName.setStatus('mandatory')
if mibBuilder.loadTexts: shelfNodeName.setDescription('Has the node name of BASIS for MGX8220 only. For others NodeName supplied by PAR will be returned, A set on this MIB is not allowed. The NodeName of the shelf can be set using the PAR MIB. ')
shelfDate = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10).clone('01/01/1994')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfDate.setStatus('mandatory')
if mibBuilder.loadTexts: shelfDate.setDescription('This object sets/gets the DATE. The syntax is mm/dd/yyyy ')
shelfTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8).clone('12:00:00')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfTime.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTime.setDescription('This object sets/gets the TIME. The syntax is hh:mm:ss ')
shelfTmZn = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("gmt", 1), ("est", 2), ("cst", 3), ("mst", 4), ("pst", 5), ("edt", 6), ("cdt", 7), ("mdt", 8), ("pdt", 9))).clone('pst')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfTmZn.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTmZn.setDescription('Object defines standard time. GMT for greenwich mean time, est for Eastern std time (USA EST). cst for Central std time (USA CST). mst for Mountain std time (USA MST). pst for Pacific std time (USA PST). edt for Eastern daylight time (USA EDT). cdt for Central daylight time (USA CDT). mdt for Mountain daylight time (USA MDT). pdt for Pacific daylight time (USA PDT). To define a std time that are not defined in here use the GMT and set the offset from the GMT in the shelfTmZnGMTOff object. ')
shelfTmZnGMTOff = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-12, 12))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: shelfTmZnGMTOff.setStatus('mandatory')
if mibBuilder.loadTexts: shelfTmZnGMTOff.setDescription('This object contains the offset from greenwich mean time in hours, if configuring for std time in shelfTmZn object, set this object to 0. If configuring for non standard times use this object as an offset from the GMT. ')
shelfBkPlnType = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBkPlnType.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBkPlnType.setDescription('This object contains the back plane type. The possible values are : 1 - For 336Mbps backplane 2 - For 1.2Gbps backplane 3 - For 45Gbps backplane ')
shelfBkplnSerialNum = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 11))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfBkplnSerialNum.setStatus('mandatory')
if mibBuilder.loadTexts: shelfBkplnSerialNum.setDescription('A unique value for each shelf, entered in nvram by manf. The serial No. is on the non-volatile RAM on the backplane. ')
statsMasterIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsMasterIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: statsMasterIpAddress.setDescription('IP address of the Stats Master. ')
statsCollectionInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsCollectionInterval.setStatus('mandatory')
if mibBuilder.loadTexts: statsCollectionInterval.setDescription('Statistics collection interval (in minutes). ')
statsBucketInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statsBucketInterval.setStatus('mandatory')
if mibBuilder.loadTexts: statsBucketInterval.setDescription('Statistics bucket interval (in minutes). ')
userName = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('mandatory')
if mibBuilder.loadTexts: userName.setDescription('username of the person logging in or logging out. used only in traps currently only limit to 12 chars ')
shelfIntegratedAlarm = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("critical", 4))).clone('clear')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfIntegratedAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: shelfIntegratedAlarm.setDescription('Alarm status of the shelf.An implementation may not support all the values. possible values are : clear (1) : shelf is not in alarm minor (2) : Indicates that a non-service affecting condition has occurred and that corrective action should be taken in order to prevent a more serious fault. major (3) : Indicates that a service affecting condition has occurred and urgent corrective action is required. critical (4) : Indicates that a service affecting condition has occurred and immediate corrective action is required. The definition for minor(2),major(3),critical(4) are taken from Bell Core document : GR-1248-CORE. ')
shelfAlarmCardBitMap = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfAlarmCardBitMap.setStatus('mandatory')
if mibBuilder.loadTexts: shelfAlarmCardBitMap.setDescription(' default value is 0, none of the cards is in alarm bit position represents the card physical slot number which is in alarm ')
apsIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 19), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: apsIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: apsIpAddress.setDescription('the IP address of the APS')
redundantApsIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundantApsIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: redundantApsIpAddress.setDescription('the IP address of the redundant APS')
axisFeederTkNo = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisFeederTkNo.setStatus('mandatory')
if mibBuilder.loadTexts: axisFeederTkNo.setDescription('ASC creates its cell/frame file based on the feeder trunk number.')
axisSvcBillingColInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("a0minutes", 1), ("a15minutes", 2), ("a30minutes", 3))).clone('a30minutes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisSvcBillingColInterval.setStatus('mandatory')
if mibBuilder.loadTexts: axisSvcBillingColInterval.setDescription('SVC billing collection interval (in 0, 15, 30 minute steps). ')
axisSvcBillingBucketInterval = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("a0minutes", 1), ("a5minutes", 2), ("a15minutes", 3), ("a30minutes", 4))).clone('a15minutes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisSvcBillingBucketInterval.setStatus('mandatory')
if mibBuilder.loadTexts: axisSvcBillingBucketInterval.setDescription('SVC billing bucket interval (in 0, 5, 15, 30 minute steps). ')
axisSvcBilling = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: axisSvcBilling.setStatus('mandatory')
if mibBuilder.loadTexts: axisSvcBilling.setDescription('SVC billing feature. ')
shelfCBClkRateTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 22), )
if mibBuilder.loadTexts: shelfCBClkRateTable.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCBClkRateTable.setDescription('The table has the Clock Rates of each Cell Bus ')
shelfCBClkRateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 22, 1), ).setIndexNames((0, "BASIS-SHELF-MIB", "cBNum"))
if mibBuilder.loadTexts: shelfCBClkRateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: shelfCBClkRateEntry.setDescription('An entry for the Cell Bus ')
cBNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 22, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cBNum.setStatus('mandatory')
if mibBuilder.loadTexts: cBNum.setDescription('The number (1-8) designation for the Cell Bus. ')
clkRate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twentyOne-Mhz", 1), ("fortyTwo-Mhz", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: clkRate.setStatus('mandatory')
if mibBuilder.loadTexts: clkRate.setDescription('The Cell Bus Clock Rate designation. ')
shelfPowerSupplyVoltage = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("two-twenty", 1), ("one-ten", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfPowerSupplyVoltage.setStatus('mandatory')
if mibBuilder.loadTexts: shelfPowerSupplyVoltage.setDescription('Power Supply voltage rating for some selected MGX Series. two-twenty (1): 220Volts AC. one-ten (2): 110Volts AC. ')
shelfFilteredAlarm = MibScalar((1, 3, 6, 1, 4, 1, 351, 110, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("clear", 1), ("minor", 2), ("major", 3), ("critical", 4))).clone('clear')).setMaxAccess("readonly")
if mibBuilder.loadTexts: shelfFilteredAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: shelfFilteredAlarm.setDescription('Alarm status of the shelf that allows only a filtered subset of the shelf alarms to be considered in the alarm status. An implementation may not support all the values. Possible values are : clear (1) : shelf is not in alarm minor (2) : Indicates that a non-service affecting condition has occurred and that corrective action should be taken in order to prevent a more serious fault. major (3) : Indicates that a service affecting condition has occurred and urgent corrective action is required. critical (4) : Indicates that a service affecting condition has occurred and immediate corrective action is required. The definition for minor(2),major(3),critical(4) are taken from Bell Core document : GR-1248-CORE. ')
smRedMapTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1), )
if mibBuilder.loadTexts: smRedMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: smRedMapTable.setDescription('The table has the redundancy map for a service module. This table is for configuring redundancy for service modules. This table might contain entries for Core-Card set,in some implementations. ')
smRedMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1), ).setIndexNames((0, "BASIS-SHELF-MIB", "redPrimarySlotNum"))
if mibBuilder.loadTexts: smRedMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: smRedMapEntry.setDescription('An entry for module(Service Module,Core-Card set) redundancy. Some implementations might have entries for the core-card set. The entries for core-card set may not be added , modified or deleted. An entry has to be created in this table to configure Service Modules in redundant configuration. For a 1:1 (Y cable ) redundancy configuration,an entry exists for each redundant pair with redPrimarySlotNum as the index. For 1:N Redundancy configuration,an entry exists with different primary slot numbers(redPrimarySlot value) with the same secondary slot numbers(redSecondarySlot value). ')
redPrimarySlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redPrimarySlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: redPrimarySlotNum.setDescription(' The index to the table. This is the slot number of the primary module in the redundant configuration. For MGX8850 Release 1.x,skip PXM slot 7,8,23,24, SRM slot 15,16,31,32. For MGX8220(Formerly known as AXIS), values 5-14 are supported. For systems, where the entries are created by the agent for the Core-Card set, the implied slot numbers are used for this object. The implied slot number values are depend on the system. ')
redRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3))).clone('del')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: redRowStatus.setDescription('This will add, delete or modify the redundancy Note that mod is NOT used but it is there for consistency. This object is for creating and deleting an entry in smRedMapTable. This object is set to add(1) to create an entry in the table. The values of redPrimarySlot and redSecondarySlot objects constitute the redundant Pairs. The slot numbers specified for redPrimarySlot and redSecondarySlot should be in the same half of the shelf for half-height service modules. This object is set to del(2) to delete an entry from the table. ')
redPrimaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 20, 30, 31, 34, 35, 36, 37, 40, 41, 50, 51, 52, 53, 60, 61, 70, 71, 72, 73, 80, 90, 91, 100, 101, 130, 131, 132, 133, 134, 135, 136, 137, 140, 141, 110, 111, 120, 121, 150, 151, 563, 564, 787, 1000, 1001, 1002, 1003, 2000, 2001))).clone(namedValues=NamedValues(("other", 1), ("bsc", 2), ("aum-T3", 10), ("tim", 20), ("frsm-4T1", 30), ("frsm-4E1", 31), ("frsm-hs1", 34), ("frsm-8T1", 35), ("frsm-8E1", 36), ("frsm-hs1b", 37), ("ausm-4T1", 40), ("ausm-4E1", 41), ("ausm-8T1", 50), ("ausm-8E1", 51), ("ausmB-8T1", 52), ("ausmB-8E1", 53), ("cesm-4T1", 60), ("cesm-4E1", 61), ("imatm-T3T1", 70), ("imatm-E3E1", 71), ("imatmB-T1", 72), ("imatmB-E1", 73), ("frasm-8T1", 80), ("cesm-8T1", 90), ("cesm-8E1", 91), ("bscsm-2", 100), ("bscsm-4", 101), ("frsm-2ct3", 130), ("frsm-2t3", 131), ("frsm-2e3", 132), ("frsm-hs2", 133), ("frsm-2t3b", 134), ("frsm-2e3b", 135), ("frsm-hs2b-hssi", 136), ("frsm-hs2b-12In1", 137), ("cesm-T3", 140), ("cesm-E3", 141), ("atmt-8T1", 110), ("atmt-8E1", 111), ("frt-8T1", 120), ("frt-8E1", 121), ("vism-8T1", 150), ("vism-8E1", 151), ("vism-pr-8T1", 563), ("vism-pr-8E1", 564), ("cesmB-8T1", 787), ("pxm1", 1000), ("pxm1-2t3e3", 1001), ("pxm1-4oc3", 1002), ("pxm1-oc12", 1003), ("rpm", 2000), ("rpm-pr", 2001)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redPrimaryType.setStatus('mandatory')
if mibBuilder.loadTexts: redPrimaryType.setDescription('This object holds the type of the primary card Some of the card types are not supported in the table but they are defined here for consistency with the shelf card types. ')
redPrimaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 17))).clone(namedValues=NamedValues(("nocard", 1), ("standby", 2), ("active", 3), ("failed", 4), ("selfTest", 5), ("heldInReset", 6), ("boot", 7), ("mismatch", 8), ("unknown", 9), ("unusedCoreCardMisMatch", 10), ("blocked", 11), ("reserved", 12), ("unusedHold", 13), ("notResponding", 14), ("cardinit", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redPrimaryState.setStatus('mandatory')
if mibBuilder.loadTexts: redPrimaryState.setDescription("This object holds the state of the primary card Some of the states are not supported in the table but they are defined here for consistency with the cardStates. heldInReset, boot and unknown are not supported. Supported values are : nocard (1) : Module not present in the slot standby (2) : Module is in 'standby' state active (3) : Module is in 'active' state failed (4) : Module is in 'failed' state due to some condition selfTest(5) : Module is performing selftest mismatch(8) : Module is not compatible with the current configuration or a wrong type of back-card/line-module is plugged in. notResponding(14) : Response from the Service module has become slow probably due to overloading of CPU. No recovery action is required on user part. At present, this state is implemented only for RPM card. cardinit(17) : When the physical presence of card has been detected but the communication hasn't yet been established between the controller card (PXM) and Service Module. ")
redSecondarySlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redSecondarySlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: redSecondarySlotNum.setDescription(' This is the slot number of the redundant card for the primary card. SecondarySlotNum will be 0 when no secondary card covering the primary card. SecondarySlotNum in case of MGX8850 shloud be from the same half of the shelf. Like if primary card is in the top then secondary card also should be in the top and will be covered by top SRM. ')
redSecondaryType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 10, 20, 30, 31, 34, 35, 36, 37, 40, 41, 50, 51, 52, 53, 60, 61, 70, 71, 72, 73, 80, 90, 91, 100, 101, 130, 131, 132, 133, 134, 135, 136, 137, 140, 141, 110, 111, 120, 121, 150, 151, 563, 564, 787, 1000, 1001, 1002, 1003, 2000, 2001))).clone(namedValues=NamedValues(("other", 1), ("bsc", 2), ("aum-T3", 10), ("tim", 20), ("frsm-4T1", 30), ("frsm-4E1", 31), ("frsm-hs1", 34), ("frsm-8T1", 35), ("frsm-8E1", 36), ("frsm-hs1b", 37), ("ausm-4T1", 40), ("ausm-4E1", 41), ("ausm-8T1", 50), ("ausm-8E1", 51), ("ausmB-8T1", 52), ("ausmB-8E1", 53), ("cesm-4T1", 60), ("cesm-4E1", 61), ("imatm-T3T1", 70), ("imatm-E3E1", 71), ("imatmB-T1", 72), ("imatmB-E1", 73), ("frasm-8T1", 80), ("cesm-8T1", 90), ("cesm-8E1", 91), ("bscsm-2", 100), ("bscsm-4", 101), ("frsm-2ct3", 130), ("frsm-2t3", 131), ("frsm-2e3", 132), ("frsm-hs2", 133), ("frsm-2t3b", 134), ("frsm-2e3b", 135), ("frsm-hs2b-hssi", 136), ("frsm-hs2b-12In1", 137), ("cesm-T3", 140), ("cesm-E3", 141), ("atmt-8T1", 110), ("atmt-8E1", 111), ("frt-8T1", 120), ("frt-8E1", 121), ("vism-8T1", 150), ("vism-8E1", 151), ("vism-pr-8T1", 563), ("vism-pr-8E1", 564), ("cesmB-8T1", 787), ("pxm1", 1000), ("pxm1-2t3e3", 1001), ("pxm1-4oc3", 1002), ("pxm1-oc12", 1003), ("rpm", 2000), ("rpm-pr", 2001)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redSecondaryType.setStatus('mandatory')
if mibBuilder.loadTexts: redSecondaryType.setDescription('This object holds the type of the redundant card Note that redSecondaryType is the same as redPrimaryType unless it is changed for a new service module. Some of the card types are not supported in the table but they are defined here for consistency with the shelf card types. ')
redSecondaryState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 17))).clone(namedValues=NamedValues(("nocard", 1), ("standby", 2), ("active", 3), ("failed", 4), ("selfTest", 5), ("heldInReset", 6), ("boot", 7), ("mismatch", 8), ("unknown", 9), ("unusedCoreCardMisMatch", 10), ("blocked", 11), ("reserved", 12), ("unusedHold", 13), ("notResponding", 14), ("cardinit", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redSecondaryState.setStatus('mandatory')
if mibBuilder.loadTexts: redSecondaryState.setDescription("This object holds the state of the secondary card Supported values are : nocard (1) : Module not present in the slot standby (2) : Module is in 'standby' state active (3) : Module is in 'active' state failed (4) : Module is in 'failed' state due to some condition selfTest(5) : Module is performing selftest mismatch(8) : Module is not compatible with the current configuration or a wrong type of back-card/line-module is plugged in. notResponding(14) : Response from the Service module has become slow probably due to overloading of CPU. No recovery action is required on user part. At present, this state is implemented only for RPM card. cardinit(17) : When the physical presence of card has been detected but the communication hasn't yet been established between the controller card (PXM) and Service Module. ")
redType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yCable", 1), ("oneToN", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redType.setStatus('mandatory')
if mibBuilder.loadTexts: redType.setDescription('This object describes the type of redundancy. The supported values are : yCable (1) : 1:1 (y cable) redundancy configuration. In this configuration,there is only one module which acts as the backup for the other. oneToN (2) : 1:N redundancy configuration. In this configuration, there is one module(secondary)which acts as the backup for other primary modules. There are multiple primary modules and one secondary module in this configuration. At any point of time, the secondary module is backup for only one failed primary module. If more than one primary module fails, then the failed primary modules are not covered by the secondary module. ')
redCoveringSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redCoveringSlot.setStatus('mandatory')
if mibBuilder.loadTexts: redCoveringSlot.setDescription(' This is the slot number of the primary card for which the secondary card is covering Note that redCoveringSlot is set to 0 when the primary is not being protected. If this primary card is being protected by its redundant card then this object would be the primary slot number. ')
redFeature = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redFeature.setStatus('mandatory')
if mibBuilder.loadTexts: redFeature.setDescription('This is the feature of the primary card. ')
redLineModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 48, 49, 50, 60, 61, 62, 63))).clone(namedValues=NamedValues(("lm-DB15-4T1", 16), ("lm-DB15-4E1", 17), ("lm-BNC-4E1", 18), ("lm-DB15-4T1-R", 19), ("lm-DB15-4E1-R", 20), ("lm-BNC-4E1-R", 21), ("lm-RJ48-8T1", 22), ("lm-RJ48-8E1", 23), ("lm-SMB-8E1", 24), ("lm-RJ48-T3T1", 25), ("lm-RJ48-E3E1", 26), ("lm-RJ48-T3E1", 27), ("lm-SMB-E3E1", 28), ("lm-RJ48-E3T1", 29), ("lm-SMB-T3E1", 30), ("lm-T3E3-D", 32), ("lm-T3E3-B", 33), ("lm-RJ48-8T1-R", 48), ("lm-RJ48-8E1-R", 49), ("lm-SMB-8E1-R", 50), ("lm-HS1-4X21", 60), ("lm-HS1-3HSSI", 61), ("lm-HS1-4V35", 62), ("lm-12In1-8s", 63)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: redLineModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: redLineModuleType.setDescription('This is the line module type for the primary card. This object is NOT configurable and it only has the type of the current line module that is present in this slot. Note that the types that end with a -R are of redundant back card type which do not have a connector on the its faceplate and they are used for the redundant card but they can be plugged into the primary by mistake and this object would show its type. ')
mibBuilder.exportSymbols("BASIS-SHELF-MIB", shelfNumOfValidEntries=shelfNumOfValidEntries, redRowStatus=redRowStatus, shelfFunctionModuleHoldReset=shelfFunctionModuleHoldReset, axisSvcBillingColInterval=axisSvcBillingColInterval, shelfBkplnSerialNum=shelfBkplnSerialNum, redType=redType, redPrimarySlotNum=redPrimarySlotNum, axisFeederTkNo=axisFeederTkNo, shelfCBClkRateTable=shelfCBClkRateTable, shelfCBClkRateEntry=shelfCBClkRateEntry, redSecondarySlotNum=redSecondarySlotNum, shelfSlotNum=shelfSlotNum, statsMasterIpAddress=statsMasterIpAddress, axisSvcBillingBucketInterval=axisSvcBillingBucketInterval, cBNum=cBNum, statsCollectionInterval=statsCollectionInterval, shelfBkplnSerialNumDeprecated=shelfBkplnSerialNumDeprecated, shelfFunctionModuleType=shelfFunctionModuleType, shelfTable=shelfTable, shelfAlarmCardBitMap=shelfAlarmCardBitMap, apsIpAddress=apsIpAddress, redSecondaryType=redSecondaryType, shelfIntegratedAlarm=shelfIntegratedAlarm, statsBucketInterval=statsBucketInterval, clkRate=clkRate, shelfFilteredAlarm=shelfFilteredAlarm, shelfEntry=shelfEntry, axisSvcBilling=axisSvcBilling, redPrimaryState=redPrimaryState, shelfTime=shelfTime, shelfPowerSupplyVoltage=shelfPowerSupplyVoltage, shelfNodeName=shelfNodeName, redFeature=redFeature, shelfBkPlnType=shelfBkPlnType, redPrimaryType=redPrimaryType, smRedMapTable=smRedMapTable, redSecondaryState=redSecondaryState, shelfTmZnGMTOff=shelfTmZnGMTOff, smRedMapEntry=smRedMapEntry, redCoveringSlot=redCoveringSlot, redLineModuleType=redLineModuleType, userName=userName, shelfTmZn=shelfTmZn, shelfDate=shelfDate, redundantApsIpAddress=redundantApsIpAddress, shelfFunctionModuleState=shelfFunctionModuleState, shelfNum=shelfNum)

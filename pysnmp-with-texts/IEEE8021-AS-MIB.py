#
# PySNMP MIB module IEEE8021-AS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IEEE8021-AS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:52:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
IEEE8021BridgePortNumber, = mibBuilder.importSymbols("IEEE8021-TC-MIB", "IEEE8021BridgePortNumber")
InterfaceIndexOrZero, ifGeneralInformationGroup = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "ifGeneralInformationGroup")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
IpAddress, iso, Bits, ObjectIdentity, TimeTicks, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter32, Integer32, Gauge32, MibIdentifier, Counter64, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "iso", "Bits", "ObjectIdentity", "TimeTicks", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter32", "Integer32", "Gauge32", "MibIdentifier", "Counter64", "ModuleIdentity")
DisplayString, TextualConvention, TimeStamp, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeStamp", "RowStatus", "TruthValue")
ieee8021AsTimeSyncMib = ModuleIdentity((1, 3, 111, 2, 802, 1, 1, 20))
ieee8021AsTimeSyncMib.setRevisions(('2012-12-12 00:00', '2010-11-11 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ieee8021AsTimeSyncMib.setRevisionsDescriptions(('Published as part of IEEE Std 802.1AS Cor-1 ieee8021AsPortDSAsIfIndex SYNTAX corrected to InterfaceIndexOrZero, from Integer32. ieee8021AsPortDSAnnounceReceiptTimeout DESCRIPTION and default value corrected. ieee8021AsPortDSSyncReceiptTimeout DESCRIPTION corrected, ieee8021AsDefaultDSOffsetScaledLogVariance and ieee8021AsParentDSGrandmasterOffsetScaledLogVariance SYNTAX corrected to Unsigned32 (from Integer32), and corresponding range to reflect unsigned integer 16. ieee8021AsComplianceCor1 added. Other editorial and corrections made.', 'Published as part of IEEE Std 802.1AS Copyright (C) IEEE (2012).',))
if mibBuilder.loadTexts: ieee8021AsTimeSyncMib.setLastUpdated('201212120000Z')
if mibBuilder.loadTexts: ieee8021AsTimeSyncMib.setOrganization('IEEE 802.1 Working Group')
if mibBuilder.loadTexts: ieee8021AsTimeSyncMib.setContactInfo('WG-URL: http://www.ieee802.org/1/index.html WG-EMail: STDS-802-1@IEEE.ORG Contact: Geoffrey M. Garner Postal: 196 Ambassador Drive Red Bank, NJ 07701 USA E-mail: gmgarner@alum.mit.edu')
if mibBuilder.loadTexts: ieee8021AsTimeSyncMib.setDescription('The Management Information Base module for IEEE 802.1AS time synchronization protocol.')
ieee8021AsMIBObjects = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1))
ieee8021AsConformance = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 2))
class ClockIdentity(TextualConvention, OctetString):
    reference = '6.3.3.6 and 8.5.2.2.1'
    description = "Represents an IEEE 802 MAC address represented in the `canonical' order defined by IEEE 802.1a, EUI-64. EUI-48 converts to EUI-64 as specified by IEEE. The conversion assigns values 255 and 254 to octets 3 and 4 respectively, where octet 0 is the most significant and octet 7 the least. For example, EUI-48 of AC:DE:48:23:45:67 would extend to AC:DE:48:FF:FE:23:45:67."
    status = 'current'
    displayHint = '1x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class IEEE8021ASClockClassValue(TextualConvention, Integer32):
    reference = '14.2.3 and IEEE Std 1588-2008 7.6.2.4'
    description = 'Clock Class Value from IEEE Std 1588-2008 7.6.2.4, with the following interpretation placed on the value: 6: A clock that is synchronized to a primary reference time source, 7: A clock that has previously been designated as clockClass 6 but that has lost the ability to synchronize to a primary reference time source and is in holdover mode and within holdover specifications, 13: A clock that is synchronized to an application-specific source of time, 14: A clock that has previously been designated as clockClass 13 but that has lost the ability to synchronize to an application-specific source of time and is in holdover mode and within holdover specifications, 52: Degradation alternative A for a clock of clockClass 7 that is not within holdover specification, 58: Degradation alternative A for a clock of clockClass 14 that is not within holdover specification, 68..122: For use by alternate PTP profiles (68..122), 133..170: For use by alternate PTP profiles (133..170), 187: Degradation alternative B for a clock of clockClass 7 that is not within holdover specification, 193: Degradation alternative B for a clock of clockClass 14 that is not within holdover specification, 216..232: For use by alternate PTP profiles, 248: Default none of the other clockClass definitions apply, 255: A slave-only clock(255).'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(6, 7, 13, 14, 52, 58, 187, 193, 248, 255))
    namedValues = NamedValues(("primarySync", 6), ("primarySyncLost", 7), ("applicationSpecificSync", 13), ("applicationSpecficSyncLost", 14), ("primarySyncAlternativeA", 52), ("applicationSpecificAlternativeA", 58), ("primarySyncAlternativeB", 187), ("applicationSpecficAlternativeB", 193), ("defaultClock", 248), ("slaveOnlyClock", 255))

class IEEE8021ASClockAccuracyValue(TextualConvention, Integer32):
    reference = '8.6.2.3'
    description = 'Clock Accuracy Value from 8.6.2.3, with the following interpretation placed on the value: 32: The time is accurate to within 25 ns, 33: The time is accurate to within 100 ns, 34: The time is accurate to within 250 ns, 35: The time is accurate to within 1 us, 36: The time is accurate to within 2.5 us, 37: The time is accurate to within 10 us, 38: The time is accurate to within 25 us, 39: The time is accurate to within 100 us, 40: The time is accurate to within 250 us, 41: The time is accurate to within 1 ms, 42: The time is accurate to within 2.5 ms, 43: The time is accurate to within 10 ms, 44: The time is accurate to within 25 ms, 45: The time is accurate to within 100 ms, 46: The time is accurate to within 250 ms, 47: The time is accurate to within 1 s, 48: The time is accurate to within 10 s, 49: The time is accurate to within > 10 s, 254: Default indicating unknown'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 254))
    namedValues = NamedValues(("timeAccurateTo25ns", 32), ("timeAccurateTo100ns", 33), ("timeAccurateTo250ns", 34), ("timeAccurateTo1us", 35), ("timeAccurateTo2dot5us", 36), ("timeAccurateTo10us", 37), ("timeAccurateTo25us", 38), ("timeAccurateTo100us", 39), ("timeAccurateTo250us", 40), ("timeAccurateTo1ms", 41), ("timeAccurateTo2dot5ms", 42), ("timeAccurateTo10ms", 43), ("timeAccurateTo25ms", 44), ("timeAccurateTo100ms", 45), ("timeAccurateTo250ms", 46), ("timeAccurateTo1s", 47), ("timeAccurateTo10s", 48), ("timeAccurateToGT10s", 49), ("timeAccurateToUnknown", 254))

class IEEE8021ASTimeSourceValue(TextualConvention, Integer32):
    reference = '8.6.2.7 and Table 8-3'
    description = 'The timeSource is an information only attribute indicating the type of source of time used by a ClockMaster, representing categories. For example, the GPS entry would include not only the GPS system of the U.S. Department of Defense but the European Galileo system and other present and future satellite-based timing systems. In the absence of a default value set by a user of this standard, the default value of timeSource shall be OTHER. See 7.6.2.6 of IEEE Std 1588 - 2008 for more detailed description of timeSourceIndicates the source of time used by the grandmaster clock. The following interpretation placed on the value: 16: Atomic Clock, 32: GPS, 48: Terrestrial Radio, 64: PTP, 80: NTP, 96: Hand Set, 144: Other, 160: Internal Oscillator '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(16, 32, 48, 64, 80, 96, 144, 160))
    namedValues = NamedValues(("atomicClock", 16), ("gps", 32), ("terrestrialRadio", 48), ("ptp", 64), ("ntp", 80), ("handSet", 96), ("other", 144), ("internalOscillator", 160))

ieee8021AsDefaultDS = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 1))
ieee8021AsDefaultDSClockIdentity = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 1), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockIdentity.setReference('14.2.1')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockIdentity.setDescription('Globally unique manufacturer-assigned clock identifier for the local clock. The identifier is based on an EUI-64.')
ieee8021AsDefaultDSNumberPorts = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSNumberPorts.setReference('14.2.2')
if mibBuilder.loadTexts: ieee8021AsDefaultDSNumberPorts.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSNumberPorts.setDescription('The number of PTP ports on the device. For an end station the value is 1.')
ieee8021AsDefaultDSClockClass = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 3), IEEE8021ASClockClassValue().clone('defaultClock')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockClass.setReference('14.2.3')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockClass.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockClass.setDescription('Denotes the traceability of the time or frequency of the local clock. The value shall be selected as follows: a) If the Default Parameter Data Set member gmCapable is TRUE, then clockClass is set to the value that reflects the combination of the LocalClock and ClockSource entities; else if the value that reflects the LocalClock and ClockSource entities is not specified or not known,clockClass is set to 248; b) If the Default Parameter Data Set member gmCapable is FALSE (see 8.6.2.1), clockClass is set to 255. ')
ieee8021AsDefaultDSClockAccuracy = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 4), IEEE8021ASClockAccuracyValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockAccuracy.setReference('14.2.4')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSClockAccuracy.setDescription('Characterizes local clock for the purpose of the best master clock algorithm. The value shall be selected as follows: a) clockAccuracy is set to the value that reflects the combination of the LocalClock and ClockSource entities if specified or known; b) if the value that reflects the LocalClock and ClockSource entities is not specified or unknown, clockAccuracy is set to 254. ')
ieee8021AsDefaultDSOffsetScaledLogVariance = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSOffsetScaledLogVariance.setReference('14.2.5')
if mibBuilder.loadTexts: ieee8021AsDefaultDSOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSOffsetScaledLogVariance.setDescription('The offsetScaledLogVariance is scaled, offset representation of an estimate of the PTP variance. The PTP variance characterizes the precision and frequency stability of the ClockMaster. The PTP variance is the square of PTPDEV (see B.1.3.2). The value shall be selected as follows: a) offsetScaledLogVariance is set to the value that reflects the combination of the LocalClock and ClockSource entities; else b) if the value that reflects these entities is not specified or not known, offsetScaledLogVariance is set to 16640 (0x4100). This value corresponds to the value of PTPDEV for observation interval equal to the default Sync message transmission interval (i.e., observation interval of 0.125 s, see 11.5.2.3 and B.1.3.2). A value of 65535 (0xFFFF) indicates value is too large to be represented or has not been computed. ')
ieee8021AsDefaultDSPriority1 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority1.setReference('14.2.6')
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority1.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority1.setDescription('Most-significant priority declaration in the execution of the best master clock algorithm. Lower values take precedence. The value of priority1 shall be 255 for a time-aware system that is not grandmaster-capable. The value of priority1 shall be less than 255 for a time-aware system that is grandmaster-capable. The value 0 shall be reserved for future management use, i.e., the valueof priority1 shall be set to 0 only via management action, and shall not be specified as a default value by a user of this standard. In the absence of a default value set by a user of this standard, the default value shall be set as below: a) system type of network infrastructure time-aware system to value 246; b) portable time-aware system, 250; c) other time-aware systems, 248.')
ieee8021AsDefaultDSPriority2 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(248)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority2.setReference('14.2.7')
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority2.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSPriority2.setDescription('Least-significant priority declaration in the execution of the best master clock algorithm. Lower values take precedence. The default value is 248')
ieee8021AsDefaultDSGmCapable = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSGmCapable.setReference('14.2.8')
if mibBuilder.loadTexts: ieee8021AsDefaultDSGmCapable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSGmCapable.setDescription('True (1) if master clock capable; false (2) otherwise.')
ieee8021AsDefaultDSCurrentUTCOffset = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffset.setReference('14.2.9')
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffset.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffset.setDescription('The value is the offset between TAI and UTC, relative to the ClockMaster entity of this time-aware system. It is equal to the global variable sysCurrentUtcOffset (see 10.3.8.16). The value is in units of seconds. The initialization default value is selected as follows: a) the value is the value obtained from a primary reference if the value is known at the at the time of initialization, b) else the value is the current number ofleap seconds, see 8.2.3, when the time-aware system is designed.')
ieee8021AsDefaultDSCurrentUTCOffsetValid = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffsetValid.setReference('14.2.10')
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffsetValid.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSCurrentUTCOffsetValid.setDescription('True (1) if ieee8021AsDefaultDSCurrentUTCOffset is known to be correct; false (2) otherwise.')
ieee8021AsDefaultDSLeap59 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap59.setReference('14.2.11')
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap59.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap59.setDescription('A true (1) value indicates that the last minute of the current UTC day, relative to the ClockMaster entity of this time-aware system, will contain 59 seconds. It is equal to the global variable sysLeap59 (see 10.3.8.12). The initialization value is selected as follows: a) Set to true (1) if the value is obtained from a primary reference if known at the at the time of initialization, else b) The value is set to false (2).')
ieee8021AsDefaultDSLeap61 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap61.setReference('14.2.12')
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap61.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSLeap61.setDescription('A true (1) value indicates that the last minute of the current UTC day, relative to the ClockMaster entity of this time-aware system, will contain 59 seconds. It is equal to the global variable sysLeap61 (see 10.3.8.11). The initialization value is selected as follows: a) Set to true (1) if the value is obtained from a primary reference if known at the at the time of initialization, else b) The value is set to false (2).')
ieee8021AsDefaultDSTimeTraceable = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 13), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeTraceable.setReference('14.2.13')
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeTraceable.setDescription('The value is set to true (1) if the timescale and the value of Ieee8021AsCurrentUtcOffset, relative to the ClockMaster entity of this time-aware system, are traceable to a primary reference standard; otherwise the value is set to false (2). It is equal to the global variable sysTimeTraceable (see 10.3.8.14). The initialization value is selected as follows: a) If the time and the value of currentUtcOffset are traceable to a primary reference standard at the time of initialization, the value is set to true (1), else b) The value is set to false (2).')
ieee8021AsDefaultDSFrequencyTraceable = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 14), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSFrequencyTraceable.setReference('14.2.14')
if mibBuilder.loadTexts: ieee8021AsDefaultDSFrequencyTraceable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSFrequencyTraceable.setDescription('The value is set to true (1) if the frequency determining the timescale of the ClockMaster Entity of this time- aware system is traceable to a primary reference standard; otherwise the value is set to false (2). It is equal to the global variable sysFrequencyTraceable (see 10.3.8.15). The initialization value is selected as follows: a) If the frequency is traceable to a primary reference standard at the time of initialization, the value is set to true (1), else b) The value is set to false (2)..')
ieee8021AsDefaultDSTimeSource = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 1, 15), IEEE8021ASTimeSourceValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeSource.setReference('14.2.15')
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeSource.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsDefaultDSTimeSource.setDescription('The timeSource is an information-only attribute indicating the type of source of time used by a ClockMaster. The value is not used in the selection of the grandmaster. The values shall be as specified in Table 8-3. These represent categories. For example, the GPS entry would include not only the GPS system of the U.S. Department of Defense but the European Galileo system and other present and future satellite-based timing systems. All unused values in Table 8-3 are reserved. The initialization value is selected as follows: a) If the timeSource (8.6.2.7 and Table 8-3), is known at the time of initialization, the value is derived from the table, else b) The value is set to INTERNAL_OSCILLATOR (160). ')
ieee8021AsCurrentDS = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 2))
ieee8021AsCurrentDSStepsRemoved = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSStepsRemoved.setReference('14.3.1')
if mibBuilder.loadTexts: ieee8021AsCurrentDSStepsRemoved.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSStepsRemoved.setDescription('The number of communication paths traversed between the local clock and the grandmaster clock (see Table 10.3.3). For example, stepsRemoved for a slave clock on the same PTP communication path as the grandmaster clock will have a value of 1, indicating that a single path was traversed. ')
ieee8021AsCurrentDSOffsetFromMasterHs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 2), Integer32()).setUnits('2**-16 ns * 2**64').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterHs.setReference('14.3.2')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterHs.setDescription('The most significant 32 bits of the offset, signed 96 bit number in 2**-16 ns, an implementation-specific computation of the current value of the time difference between a master and a slave as computed by the slave. This object MUST be read at the same time as ieee8021AsCurrentDSOffsetFromMasterMs, and ieee8021AsCurrentDSOffsetFromMasterLs, which represents middle and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSOffsetFromMasterMs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 3), Integer32()).setUnits('2**-16 ns * 2**32').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterMs.setReference('14.3.2')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterMs.setDescription('The middle significant 32 bits of the offset, signed 96 bit number in 2**-16 ns, an implementation-specific computation of the current value of the time difference between a master and a slave as computed by the slave. This object MUST be read at the same time as ieee8021AsCurrentDSOffsetFromMasterHs, and ieee8021AsCurrentDSOffsetFromMasterLs, which represents most (highest) and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSOffsetFromMasterLs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 4), Integer32()).setUnits('2**-16 ns').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterLs.setReference('14.3.2')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSOffsetFromMasterLs.setDescription('The least significant 32 bits of the offset, signed 96 bit number in 2**-16 ns, an implementation-specific computation of the current value of the time difference between a master and a slave as computed by the slave. This object MUST be read at the same time as ieee8021AsCurrentDSOffsetFromMasterHs, and ieee8021AsCurrentDSOffsetFromMasterMs, which represents most (highest) and middle significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSLastGmPhaseChangeHs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeHs.setReference('14.3.3')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeHs.setDescription('The value (see 10.2.3.16) is the phase change that occurred on the most recent change in either grandmaster or gmTimeBaseIndicator (see 9.2.2.2). This object MUST be read at the same time as ieee8021AsCurrentDSLastGmPhaseChangeMs, and ieee8021AsCurrentDSLastGmPhaseChangeLs, which represents middle and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSLastGmPhaseChangeMs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeMs.setReference('14.3.3')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeMs.setDescription('The value (see 10.2.3.16) is the phase change that occurred on the most recent change in either grandmaster or gmTimeBaseIndicator (see 9.2.2.2). This object MUST be read at the same time as ieee8021AsCurrentDSLastGmPhaseChangeHs, and ieee8021AsCurrentDSLastGmPhaseChangeLs, which represents most and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSLastGmPhaseChangeLs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeLs.setReference('14.3.3')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmPhaseChangeLs.setDescription('The value (see 10.2.3.16) is the phase change that occurred on the most recent change in either grandmaster or gmTimeBaseIndicator (see 9.2.2.2). This object MUST be read at the same time as ieee8021AsCurrentDSLastGmPhaseChangeMs, and ieee8021AsCurrentDSLastGmPhaseChangeLs, which represents middle and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsCurrentDSLastGmFreqChangeMs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeMs.setReference('14.3.4')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeMs.setDescription('The value (see 10.2.3.17) is the frequency change that occurred on the most recent change in either grandmaster or gmTimeBaseIndicator (see 9.2.2.2). This object MUST be read at the same time as ieee8021AsCurrentDSLastGmFreqChangeLs, which represents least significant 32 bits of the value in order for the read operation to succeed. ')
ieee8021AsCurrentDSLastGmFreqChangeLs = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeLs.setReference('14.3.4')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSLastGmFreqChangeLs.setDescription('The value (see 10.2.3.17) is the frequency change that occurred on the most recent change in either grandmaster or gmTimeBaseIndicator (see 9.2.2.2). This object MUST be read at the same time as ieee8021AsCurrentDSLastGmFreqChangeMs, which represents most significant 32 bits of the value in order for the read operation to succeed. ')
ieee8021AsCurrentDSGmTimebaseIndicator = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmTimebaseIndicator.setReference('14.3.5')
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmTimebaseIndicator.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmTimebaseIndicator.setDescription("This reports the grandmaster's time base change value conveyed in the Sync message. The value is the value of timeBaseIndicator of the current grandmaster (see 9.2.2.2 and 9.6.2.2) ")
ieee8021AsCurrentDSGmChangeCount = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmChangeCount.setReference('14.3.6')
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmChangeCount.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSGmChangeCount.setDescription('This statistics counter tracks the number of times the grandmaster has changed in a gPTP domain. This counter increments when the PortAnnounceInformation state machine enters the SUPERIOR_MASTER_PORT state or the INFERIOR_MASTER_OR_OTHER_PORT state (see 10.3.11 and Figure 10-13). ')
ieee8021AsCurrentDSTimeOfLastGmChangeEvent = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 12), TimeStamp()).setUnits('0.01 seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmChangeEvent.setReference('14.3.7')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmChangeEvent.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmChangeEvent.setDescription('This timestamp denotes the system time when the most recent grandmaster change occurred in a gPTP domain. This timestamp is updated when the PortAnnounceInformation state machine enters the SUPERIOR_MASTER_PORT state or the INFERIOR_MASTER_OR_OTHER_PORT state (see 10.3.11 and Figure 10-13). ')
ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 13), TimeStamp()).setUnits('0.01 seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent.setReference('14.3.8')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent.setDescription('This timestamp denotes the system time when the most recent change in grandmaster phase occured, due to a change of either the grandmaster or the grandmaster time base. This timestamp is updated when the PortAnnounceInformation state machine enters the SUPERIOR_MASTER_PORT state or the INFERIOR_MASTER_OR_OTHER_PORT state (see 10.3.11 and Figure 10-13), and when the ieee802AsCurrentDSGmTimebaseIndicator managed object (see 14.3.5) changes. ')
ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 2, 14), TimeStamp()).setUnits('0.01 seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent.setReference('14.3.9')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent.setDescription('This timestamp denotes the system time when the most recent change in grandmaster frequency occured, due to a change of either the grandmaster or the grandmaster time base. This timestamp is updated when the PortAnnounceInformation state machine enters the SUPERIOR_MASTER_PORT state or the INFERIOR_MASTER_OR_OTHER_PORT state (see 10.3.11 and Figure 10-13), and when the ieee802AsCurrentDSGmTimebaseIndicator managed object (see 14.3.5) changes. ')
ieee8021AsParentDS = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 3))
ieee8021AsParentDSParentClockIdentity = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 1), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSParentClockIdentity.setReference('14.4.1')
if mibBuilder.loadTexts: ieee8021AsParentDSParentClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSParentClockIdentity.setDescription("Clock identifier (clockIdentity) of the local clock's parent clock. The default value is set to ieee8021AsDefaultDSClockIdentity. If this time-aware system is the grandmaster, the value is the clockIdentity of this time-aware system. If this time-aware system is not the grandmaster, the value is the clockIdentity of the MasterPort (see Table 10-1) of the gPTP communication path attached to the single slave port of this time-aware system. ")
ieee8021AsParentDSParentPortNumber = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSParentPortNumber.setReference('14.4.1')
if mibBuilder.loadTexts: ieee8021AsParentDSParentPortNumber.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSParentPortNumber.setDescription("Port number (portNumber) of the local clock's parent gPTP port number. If this time-aware system is the grandmaster, the value is the gPTP portNumber of this time-aware system. If this time-aware system is not the grandmaster, the value is the portNumber of the MasterPort (see Table 10-1) of the gPTP communication path attached to the single gPTP slave port of this time-aware system. ")
ieee8021AsParentDSCumlativeRateRatio = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSCumlativeRateRatio.setReference('14.4.2')
if mibBuilder.loadTexts: ieee8021AsParentDSCumlativeRateRatio.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSCumlativeRateRatio.setDescription('The value is an estimate of the ratio of the frequency of the grandmaster to the frequency of the LocalClock entity of this time-aware system. Cumulative rate ratio is expressed as the fractional frequency offset multiplied by 2**41, i.e., the quantity (rateRatio - 1.0)(2**41), where rateRatio is computed by the PortSyncSyncReceive state machine (see 10.2.7.1.4). ')
ieee8021AsParentDSGrandmasterIdentity = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 4), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterIdentity.setReference('14.4.3')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterIdentity.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterIdentity.setDescription('Clock identifier (clockIdentity) of the grandmaster. The default value is set to ieee8021AsDefaultDSClockIdentity.')
ieee8021AsParentDSGrandmasterClockClass = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 5), IEEE8021ASClockClassValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockClass.setReference('14.4.4')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockClass.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockClass.setDescription('Denotes the traceability of the time or frequency of the grandmaster. The default value is set to ieee8021AsDefaultDSClockClass.')
ieee8021AsParentDSGrandmasterClockAccuracy = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 6), IEEE8021ASClockAccuracyValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockAccuracy.setReference('14.4.5')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockAccuracy.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterClockAccuracy.setDescription('Characterizes the grandmaster clock for the purpose of the best master clock algorithm. The default value is set to ieee8021AsDefaultDSClockAccuracy.')
ieee8021AsParentDSGrandmasterOffsetScaledLogVariance = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterOffsetScaledLogVariance.setReference('14.4.6')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterOffsetScaledLogVariance.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterOffsetScaledLogVariance.setDescription('Clock Allan variance of the local clock expressed as a base-2 logarithm multiplied by a scale factor of 256. Hysteresis is applied requiring the underlying computed variance to move by at least 128 before a change is reported. A value of 65535 (0xFFFF) indicates value is too large to be represented or has not been computed. The default value is set to ieee8021AsDefaultDSOffsetScaledLogVariance.')
ieee8021AsParentDSGrandmasterPriority1 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority1.setReference('14.4.7')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority1.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority1.setDescription("Grandmaster's most-significant priority declaration in the execution of the best master clock algorithm. Lower values take precedence. The default value is set to ieee8021AsDefaultDSPriority1.")
ieee8021AsParentDSGrandmasterPriority2 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 3, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority2.setReference('14.4.8')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority2.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsParentDSGrandmasterPriority2.setDescription("Grandmaster's least-significant priority declaration in the execution of the best master clock algorithm. Lower values take precedence. The default value is set to ieee8021AsDefaultDSDSPriority2.")
ieee8021AsTimePropertiesDS = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 4))
ieee8021AsTimePropertiesDSCurrentUtcOffset = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffset.setReference('14.5.1')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffset.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffset.setDescription('The value is currentUtcOffset for the current grandmaster (see Table 14.2.9). It is equal to the value of the global variable currentUtcOffset (see 10.3.8.9). The value is in units of seconds. The default value is set to ieee8021AsDefaultDSCurrentUTCOffset.')
ieee8021AsTimePropertiesDSCurrentUtcOffsetValid = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffsetValid.setReference('14.5.2')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffsetValid.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSCurrentUtcOffsetValid.setDescription('True (1) if ieee8021AsTimePropertiesDSCurrentUTCOffset is known to be correct; false (2) otherwise. The default value is set to ieee8021AsDefaultDSCurrentUTCOffsetValid. ')
ieee8021AsTimePropertiesDSLeap59 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap59.setReference('14.5.3')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap59.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap59.setDescription('The value is leap59 for the current grandmaster (see 14.2.11). It is equal to the global variable leap59 (see 10.3.8.5). A true (1) value indicates that the last minute of the current UTC day, relative to the ClockMaster entity of this time-aware system, will contain 59 seconds. The default value is set to ieee8021AsDefaultDSLeap59.')
ieee8021AsTimePropertiesDSLeap61 = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap61.setReference('14.5.4')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap61.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSLeap61.setDescription('The value is leap61 for the current grandmaster (see 14.2.12). It is equal to the global variable leap59 (see 10.3.8.4). A true (1) value indicates that the last minute of the current UTC day, relative to the ClockMaster entity of this time-aware system, will contain 61 seconds.The default value is set to ieee8021AsDefaultDSLeap61.')
ieee8021AsTimePropertiesDSTimeTraceable = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeTraceable.setReference('14.5.5')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeTraceable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeTraceable.setDescription('The value is timeTraceable for the current grandmaster (see 14.2.13). It is equal to the global variable timeTraceable (see 10.3.8.7). True (1) if the timescale and the value of timePropertiesDSCurrentUTCOffset are traceable to a primary reference; false (2) otherwise. The default value is set to ieee8021AsDefaultDSTimeTraceable.')
ieee8021AsTimePropertiesDSFrequencyTraceable = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSFrequencyTraceable.setReference('14.5.6')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSFrequencyTraceable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSFrequencyTraceable.setDescription('The value is frequencyTraceable for the current grandmaster (see 14.2.14). It is equal to the global variable frequencyTraceable (see 10.3.8.8). True (1) if the frequency determining the timescale is traceable to a primary reference; false (2) otherwise. The default value is set to ieee8021AsDefaultDSFrequencyTraceable.')
ieee8021AsTimePropertiesDSTimeSource = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 4, 7), IEEE8021ASTimeSourceValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeSource.setReference('14.5.7')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeSource.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsTimePropertiesDSTimeSource.setDescription('The value is timeSource for the current grandmaster (see 14.2.15). It is equal to the global variable timeTraceable (see 10.3.8.10). Indicates the source of time used by the grandmaster clock. The default value is set to ieee8021AsDefaultDSTimeSource.')
ieee8021AsPortDSIfTable = MibTable((1, 3, 111, 2, 802, 1, 1, 20, 1, 5), )
if mibBuilder.loadTexts: ieee8021AsPortDSIfTable.setReference('IEEE 802.1AS clause 14.6')
if mibBuilder.loadTexts: ieee8021AsPortDSIfTable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSIfTable.setDescription('A table of gPTP port related variables in a time-aware Bridge or for a time-aware end station. A value of 1 is used in a bridge or an end station that does not have multiple components. For a given media port of a Bridge or an end station, there may be one or more gPTP port, and depends whether a media port supports point to point link (e.g. IEEE 802.3 Ethernet) or point to multi-point (e.g. CSN, IEEE 802.3 EPON, etc) links on the media port. ')
ieee8021AsPortDSIfEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1), ).setIndexNames((0, "IEEE8021-AS-MIB", "ieee8021AsBridgeBasePort"), (0, "IEEE8021-AS-MIB", "ieee8021AsPortDSAsIfIndex"))
if mibBuilder.loadTexts: ieee8021AsPortDSIfEntry.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSIfEntry.setDescription('A list of objects pertaining to a gPTP port of a time-aware bridge component or a time-aware end station. ')
ieee8021AsBridgeBasePort = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 1), IEEE8021BridgePortNumber())
if mibBuilder.loadTexts: ieee8021AsBridgeBasePort.setReference('IEEE Std 802.1AS PortDS Group gPTP Port Index')
if mibBuilder.loadTexts: ieee8021AsBridgeBasePort.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsBridgeBasePort.setDescription('This object identifies the bridge port number of the port for which this entry contains bridge management information. For end stations, this port number shall be (1).')
ieee8021AsPortDSAsIfIndex = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 2), InterfaceIndexOrZero())
if mibBuilder.loadTexts: ieee8021AsPortDSAsIfIndex.setReference('IEEE Std 802.1AS PortDS Group gPTP Port Index')
if mibBuilder.loadTexts: ieee8021AsPortDSAsIfIndex.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSAsIfIndex.setDescription('This object identifies the gPTP interface group within the system for which this entry contains information. It is the value of the instance of the IfIndex object, defined in the IF-MIB, for the gPTP interface group corresponding to this port, or the value 0 if the port has not been bound to an underlying frame source and sink. For a given media port of a Bridge or an end station, there may be one or more gPTP port, and depends whether a media port supports point to point link (e.g. IEEE 802.3 Ethernet) or point to multi-point (e.g. CSN, IEEE 802.3 EPON, etc) links on the media port.')
ieee8021AsPortDSClockIdentity = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 3), ClockIdentity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSClockIdentity.setReference('14.6.2')
if mibBuilder.loadTexts: ieee8021AsPortDSClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSClockIdentity.setDescription('The clockIdentity is an 8 octet array formed by mapping an IEEE EUI-48 assigned to the time-aware system to IEEE EUI-64 format (i.e., to an array of 8 octets). The EUI-48 shall be an Ethernet MAC address owned by the organization creating the instance of a clockIdentity under the terms of this subclause. The organization owning the MAC address shall ensure that the MAC address is used in generating only a single instance of a clockIdentity, for example by requiring that the MAC address be a MAC address embedded in the device identified by the clockIdentity. The mapping rules for constructing the EUI-64 from the EUI-48 shall be those specified by the IEEE [B2]. The 8 octets of the created IEEE EUI-64 shall be assigned in order to the 8 octet array clockIdentity with most significant octet of the IEEE EUI-64 assigned to the clockIdentity octet array member with index 0.(see 8.5.2.2).')
ieee8021AsPortDSPortNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSPortNumber.setReference('14.6.2')
if mibBuilder.loadTexts: ieee8021AsPortDSPortNumber.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSPortNumber.setDescription('The portNumber value for a port on a time-aware end station (i.e., a time-aware system supporting a single gPTP port) shall be 1. The portNumber values for the gPTP ports on a time-aware bridgeBridge supporting N ports shall be 1, 2, ?, N, respectively (see 8.5.2.3) .')
ieee8021AsPortDSPortRole = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 6, 7, 9))).clone(namedValues=NamedValues(("disabledPort", 3), ("masterPort", 6), ("passivePort", 7), ("slavePort", 9))).clone(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSPortRole.setReference('14.6.3')
if mibBuilder.loadTexts: ieee8021AsPortDSPortRole.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSPortRole.setDescription('The value is the value of the port role of this port (see Table 10-1), and is taken from the enumeration in Table 14-5. All other values reserved. The enumeration values are consistent with IEEE Std 1588TM-2008, Table 8. The default value is 3 (DisabledPort).')
ieee8021AsPortDSPttPortEnabled = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 6), TruthValue().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSPttPortEnabled.setReference('14.6.4')
if mibBuilder.loadTexts: ieee8021AsPortDSPttPortEnabled.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSPttPortEnabled.setDescription('802.1AS function enable for a given port. True (1) if the time-synchronization and best master selection functions of the port are enabled; False (2) otherwise (see 10.2.4.12). The contents of this table SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSIsMeasuringDelay = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 7), TruthValue().clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSIsMeasuringDelay.setReference('14.6.5')
if mibBuilder.loadTexts: ieee8021AsPortDSIsMeasuringDelay.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSIsMeasuringDelay.setDescription('True (1) if the port is measuring link propagation delay; The value is equal to the value of the Boolean isMeasuringPdDelay (see 11.2.12.5 and E.4.3.2) False (2) otherwise.')
ieee8021AsPortDSAsCapable = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 8), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSAsCapable.setReference('14.6.6')
if mibBuilder.loadTexts: ieee8021AsPortDSAsCapable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSAsCapable.setDescription('True (1) if and only if it is determined that this time-aware system and the time-aware system at the other ends of the link attached to this port can interoperate with each other via the IEEE 802.1AS protocol; False (2) otherwise.')
ieee8021AsPortDSNeighborPropDelayHs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 9), Unsigned32()).setUnits('2**-16 ns * 2**64').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayHs.setReference('14.6.7')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayHs.setDescription('The most (highest) significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelay (see 10.2.4.6). It is an estimate of the current one-way propagation time on the link attached to this port, measured as specified for the respective medium (see 11.2.15, 12.5, and E.4). The value is zero for ports attached to IEEE 802.3 EPON links and for the master port of an IEEE 802.11 link, because one-way propagation delay is not measured on the latter and not directly measured on the former. It is recommended that the data type be scaled in ns. The initialization value is zero. This object MUST be read at the same time as ieee8021AsPortDSNeighborPropDelayMs, and ieee8021AsPortDSNeighborPropDelayLs, which represents middle and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsPortDSNeighborPropDelayMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 10), Unsigned32()).setUnits('2**-16 ns * 2**32').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayMs.setReference('14.6.7')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayMs.setDescription('The second most (middle) significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelay (see 10.2.4.6). It is an estimate of the current one-way propagation time on the link attached to this port, measured as specified for the respective medium (see 11.2.15, 12.5, and E.4). The value is zero for ports attached to IEEE 802.3 EPON links and for the master port of an IEEE 802.11 link, because one-way propagation delay is not measured on the latter and not directly measured on the former. It is recommended that the data type be scaled in ns. The initialization value is zero. This object MUST be read at the same time as ieee8021AsPortDSNeighborPropDelayHs, and ieee8021AsPortDSNeighborPropDelayLs, which represents most (highest) and least significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsPortDSNeighborPropDelayLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 11), Unsigned32()).setUnits('2**-16 ns').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayLs.setReference('14.6.7')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayLs.setDescription('The least significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelay (see 10.2.4.6). It is an estimate of the current one-way propagation time on the link attached to this port, measured as specified for the respective medium (see 11.2.15, 12.5, and E.4). The value is zero for ports attached to IEEE 802.3 EPON links and for the master port of an IEEE 802.11 link, because one-way propagation delay is not measured on the latter and not directly measured on the former. It is recommended that the data type be scaled in ns. The initialization value is zero. This object MUST be read at the same time as ieee8021AsPortDSNeighborPropDelayHs, and ieee8021AsPortDSNeighborPropDelayMs, which represents most (highest) and middle significant 32 bits of values, respectively, in order for the read operation to succeed. ')
ieee8021AsPortDSNeighborPropDelayThreshHs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 12), Unsigned32()).setUnits('2**-16 ns * 2 ** 64').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshHs.setReference('14.6.8')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshHs.setDescription('The most (highest) significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelayThresh (see 11.2.12.5). It is the propagation time threshold, above which a port is not considered capable of participating in the 802.1AS protocol This object MUST be read or written at the same time as ieee8021AsPortDSNeighborPropDelayThreshMs, and ieee8021AsPortDSNeighborPropDelayThreshLs, which represents middle and least significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNeighborPropDelayThreshMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 13), Unsigned32()).setUnits('2**-16 ns * 2 ** 32').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshMs.setReference('14.6.8')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshMs.setDescription('The middle significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelayThresh (see 11.2.12.5). It is the propagation time threshold, above which a port is not considered capable of participating in the 802.1AS protocol This object MUST be read or written at the same time as ieee8021AsPortDSNeighborPropDelayThreshHs, and ieee8021AsPortDSNeighborPropDelayThreshLs, which represents most (highest) and least significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNeighborPropDelayThreshLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 14), Unsigned32()).setUnits('2**-16 ns').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshLs.setReference('14.6.8')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborPropDelayThreshLs.setDescription('The least significant 32 bits, unsigned 96 bit number in 2**-16 ns, the value is equal to the value of the per-port global variable neighborPropDelayThresh (see 11.2.12.5). It is the propagation time threshold, above which a port is not considered capable of participating in the 802.1AS protocol This object MUST be read at the same time as ieee8021AsPortDSNeighborPropDelayThreshHs, and ieee8021AsPortDSNeighborPropDelayThreshMs, which represents most (highest) and middle significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSDelayAsymmetryHs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 15), Integer32()).setUnits('2**-16 ns * 2**64').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryHs.setReference('14.6.9 and 8.3')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryHs.setDescription('The most (highest) significant 32 bits, signed 96 bit number in 2**-16 ns. The value is the asymmetry in the propagation delay on the link attached to this port relative to the grandmaster time base, as defined in 8.3. If propagation delay asymmetry is not modeled, then delayAsymmetry is 0. This object MUST be read or written at the same time as ieee8021AsPortDSDelayAsymmetryMs, and ieee8021AsPortDSDelayAsymmetryLs, which represents middle and least significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSDelayAsymmetryMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 16), Unsigned32()).setUnits('2**-16 ns * 2**32').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryMs.setReference('14.6.9 and 8.3')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryMs.setDescription('The middle significant 32 bits, signed 96 bit number in 2**-16 ns. The value is the asymmetry in the propagation delay on the link attached to this port relative to the grandmaster time base, as defined in 8.3. If propagation delay asymmetry is not modeled, then delayAsymmetry is 0. This object MUST be read or written at the same time as ieee8021AsPortDSDelayAsymmetryHs, and ieee8021AsPortDSDelayAsymmetryLs, which represents middle and least significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSDelayAsymmetryLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 17), Unsigned32()).setUnits('2**-16 ns').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryLs.setReference('14.6.9 and 8.3')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSDelayAsymmetryLs.setDescription('The least significant 32 bits, signed 96 bit number in 2**-16 ns. The value is the asymmetry in the propagation delay on the link attached to this port relative to the grandmaster time base, as defined in 8.3. If propagation delay asymmetry is not modeled, then delayAsymmetry is 0. This object MUST be read or written at the same time as ieee8021AsPortDSDelayAsymmetryHs, and ieee8021AsPortDSDelayAsymmetryLs, which represents most (highest) and least significant 32 bits of values, respectively, in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNeighborRateRatio = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborRateRatio.setReference('14.6.10')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborRateRatio.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNeighborRateRatio.setDescription('The value is an estimate of the ratio of the frequency of the LocalClock entity of the time-aware system at the other end of the link attached to this port, to the frequency of the LocalClock entity of this time-aware system (see 10.2.4.6). Neighbor rate ratio is expressed as the fractional frequency offset multiplied by 2**41, i.e., the quantity (neighborRateRatio - 1.0)(2**41).')
ieee8021AsPortDSInitialLogAnnounceInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogAnnounceInterval.setReference('14.6.11')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogAnnounceInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogAnnounceInterval.setDescription('The value is the logarithm to the base 2 of the of the announce interval used when (a) the port is initialized, or (b) a message interval request TLV is received with announceInterval field set to 126 (see 10.6.2.2 and and the AnnounceIntervalSetting state machine 10.3.14) The default value is 0. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSCurrentLogAnnounceInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogAnnounceInterval.setReference('14.6.12')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogAnnounceInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogAnnounceInterval.setDescription('The value is the logarithm to the base 2 of the of the current announce transmission interval. The currentLogAnnounceInterval specifies the current value of the announce interval. Every port supports the value 127; the port does not send Announce messages when currentLogAnnounceInterval has this value (see 10.3.14). A port may support other values, except for the reserved values -128 through - 125, inclusive, and 124 through 126, inclusive. A port ignores requests (see 10.3.14) for unsupported values. ')
ieee8021AsPortDSAnnounceReceiptTimeout = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSAnnounceReceiptTimeout.setReference('14.6.13')
if mibBuilder.loadTexts: ieee8021AsPortDSAnnounceReceiptTimeout.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSAnnounceReceiptTimeout.setDescription("The value is the number of Announce message transmission intervals that a slave port waits without receiving an Announce message, before assuming that the master is no longer transmitting Announce messages, and that the BMC algorithm needs to be run, if appropriate. The condition of the slave port not receiving an Announce message for announceReceiptTimeout announce intervals is referred to as 'announce receipt timeout'. The default value is 3 (see 10.6.3.2). The contents of this variable SHALL be maintained across a restart of the system. ")
ieee8021AsPortDSInitialLogSyncInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127)).clone(-3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogSyncInterval.setReference('14.6.14')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogSyncInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogSyncInterval.setDescription('The value is the logarithm to the base 2 of the sync interval used when, (a) the port is initialized, or (b) a message interval request TLV is received with the timeSyncInterval field set to 126 (see 10.6.2.3, 11.5.2.3, 12.6.2, 13.9.2, and the LinkDelaySyncIntervalSetting state machine, 11.2.17). The initialization value is -3 (see 10.6.2.3). The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSCurrentLogSyncInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127)).clone(-3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogSyncInterval.setReference('14.6.15')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogSyncInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogSyncInterval.setDescription('The value is the logarithm to the base 2 of the current time-synchronization transmission interval, see 10.6.2.3. The initialization value is -3. ')
ieee8021AsPortDSSyncReceiptTimeout = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeout.setReference('14.6.16')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeout.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeout.setDescription("The value of this attribute tells a slave port the number of sync intervals to wait without receiving synchronization information, before assuming that the master is no longer transmitting synchronization information, and that the BMC algorithm needs to be run, if appropriate. The condition of the slave port not receiving synchronization information for syncReceiptTimeout sync intervals is referred to as 'sync receipt timeout'. The initialization value is 3 (see 10.6.3.1). The contents of this variable SHALL be maintained across a restart of the system. ")
ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 25), Unsigned32().clone(0)).setUnits('2**-16 ns').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs.setReference('14.6.17')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs.setDescription("The most (highest) significant 32 bits, of unsigned 96 bit number in 2**-16 ns. The value is equal to the value of the per port global variable syncReceiptTimeoutTimeInterval (see 10.2.4.2). It is the time interval after which sync receipt timeout occurs if time-synchronization information has not been received during the interval. This object MUST be read at the same time as ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs, and ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs, which represents middle and least significant 32 bits of values, respectively, in order for the read operation to succeed. Default value is calculated per 10.2.4.2, or '0000 0000 0000 165A 0BC0 0000'h. The contents of this variable SHALL be maintained across a restart of the system. ")
ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 26), Unsigned32().clone(5722)).setUnits('2**-16 ns * 2**32').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs.setReference('14.6.17')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs.setDescription("The middle significant 32 bits, unsigned 96 bit number in 2**-16 ns. The value is equal to the value of the per port global variable syncReceiptTimeoutTimeInterval (see 10.2.4.2). It is the time interval after which sync receipt timeout occurs if time-synchronization information has not been received during the interval. This object MUST be read at the same time as ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs, and ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs, which represents most (highest) and least significant 32 bits of values, respectively, in order for the read operation to succeed. Default value is calculated per 10.2.4.2, or '0000 0000 0000 165A 0BC0 0000'h. The contents of this variable SHALL be maintained across a restart of the system. ")
ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 27), Unsigned32().clone(197132288)).setUnits('2**-16 ns').setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs.setReference('14.6.17')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs.setDescription("The least significant 32 bits, unsigned 96 bit number in 2**-16 ns. The value is equal to the value of the per port global variable syncReceiptTimeoutTimeInterval (see 10.2.4.2). It is the time interval after which sync receipt timeout occurs if time-synchronization information has not been received during the interval. This object MUST be read at the same time as ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs, and ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs, which represents most (highest) and middle significant 32 bits of values, respectively, in order for the read operation to succeed. Default value is calculated per 10.2.4.2, or '0000 0000 0000 165A 0BC0 0000'h. The contents of this variable SHALL be maintained across a restart of the system. ")
ieee8021AsPortDSInitialLogPdelayReqInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogPdelayReqInterval.setReference('14.6.18')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSInitialLogPdelayReqInterval.setDescription('For full-duplex, IEEE 802.3 media and CSN media that use the peer delay mechanism to measure path delay (see E.4.3.1), the value is the logarithm to the base 2 of the Pdelay_Req message transmission interval used when, (a) the port is initialized, or (b) a message interval request TLV is received with the linkDelayInterval field set to 126 (see 11.5.2.2 and the LinkDelaySyncIntervalSetting state machine, 11.2.17). For these media, the initialization value is 0. For all other media, the value is 127. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSCurrentLogPdelayReqInterval = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-128, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogPdelayReqInterval.setReference('14.6.19')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogPdelayReqInterval.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSCurrentLogPdelayReqInterval.setDescription('For full-duplex, IEEE 802.3 media and CSN media that use the peer delay mechanism to measure path delay (see E.4.3.1), the value is the logarithm to the base 2 of the current Pdelay_Req message transmission interval, see 11.5.2.2. For all other media, the value is 127. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSAllowedLostResponses = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSAllowedLostResponses.setReference('14.6.20 and 11.5.3')
if mibBuilder.loadTexts: ieee8021AsPortDSAllowedLostResponses.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSAllowedLostResponses.setDescription('The value is equal to the value of the per-port global variable allowedLostResponses (see 11.2.12.4). It is the number of Pdelay_Req messages for which a valid response is not received, above which a port is considered to not be exchanging peer delay messages with its neighbor. ')
ieee8021AsPortDSVersionNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortDSVersionNumber.setReference('14.6.21')
if mibBuilder.loadTexts: ieee8021AsPortDSVersionNumber.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSVersionNumber.setDescription('Indicates the PTP version in use on the port. The version number for this standard is set to the value 2 (see 10.5.2.2.3). The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNupMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 32), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNupMs.setReference('14.6.22')
if mibBuilder.loadTexts: ieee8021AsPortDSNupMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNupMs.setDescription('The most significant 32 bits, of unsigned 64 bit fixed point number between 0 and less than 2. For an OLT port of an IEEE 802.3 EPON link, the value is the effective index of refraction for the EPON upstream wavelength light of the optical path (see 13.1.4 and 13.8.1.2). The default value is 1.46770 for 1 Gb/s upstream links, and 1.46773 for 10 Gb/s upstream links. For all other ports, the value is 0. This object MUST be read or written at the same time as ieee8021AsPortDSNupLs, which represents least significant 32 bits of the value in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNupLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 33), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNupLs.setReference('14.6.22')
if mibBuilder.loadTexts: ieee8021AsPortDSNupLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNupLs.setDescription('The least significant 32 bits, of unsigned 64 bit fixed point number between 0 and less than 2. For an OLT port of an IEEE 802.3 EPON link, the value is the effective index of refraction for the EPON upstream wavelength light of the optical path (see 13.1.4 and 13.8.1.2). The default value is 1.46770 for 1 Gb/s upstream links, and 1.46773 for 10 Gb/s upstream links. For all other ports, the value is 0. This object MUST be read or written at the same time as ieee8021AsPortDSNupMs, which represents the most significant 32 bits of the value in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNdownMs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 34), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNdownMs.setReference('14.6.23')
if mibBuilder.loadTexts: ieee8021AsPortDSNdownMs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNdownMs.setDescription('The least significant 32 bits, of unsigned 64 bit fixed point number between 0 and less than 2. For an OLT port of an IEEE 802.3 EPON link, the value is the effective index of refraction for the EPON downstream wavelength light of the optical path (see 13.1.4 and 13.8.1.2.2). The default value is 1.46805 for 1 Gb/s downstream links, and 1.46851 for 10 Gb/s downstream links. For all other ports, the value is 0. This object MUST be read or written at the same time as ieee8021AsPortDSNdownLs, which represents the least significant 32 bits of the value in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSNdownLs = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 35), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSNdownLs.setReference('14.6.23')
if mibBuilder.loadTexts: ieee8021AsPortDSNdownLs.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSNdownLs.setDescription('The least significant 32 bits, of unsigned 64 bit fixed point number between 0 and less than 2. For an OLT port of an IEEE 802.3 EPON link, the value is the effective index of refraction for the EPON downstream wavelength light of the optical path (see 13.1.4 and 13.8.1.2.1). The default value is 1.46805 for 1 Gb/s downstream links, and 1.46851 for 10 Gb/s downstream links. For all other ports, the value is 0. This object MUST be read or written at the same time as ieee8021AsPortDSNdownMs, which represents the most significant 32 bits of the value in order for the read or write operation to succeed. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortDSAcceptableMasterTableEnabled = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 5, 1, 36), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsPortDSAcceptableMasterTableEnabled.setReference('14.6.24')
if mibBuilder.loadTexts: ieee8021AsPortDSAcceptableMasterTableEnabled.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDSAcceptableMasterTableEnabled.setDescription('True (1) if acceptableMasterTableEnabled (see 13.1.3.1) and 13.1.3.5) is true and an ONU port attached to an IEEE 802.3 EPON link in a time-aware system. False (2), otherwise. The default value is FALSE. The contents of this variable SHALL be maintained across a restart of the system. ')
ieee8021AsPortStatIfTable = MibTable((1, 3, 111, 2, 802, 1, 1, 20, 1, 6), )
if mibBuilder.loadTexts: ieee8021AsPortStatIfTable.setReference('IEEE 802.1AS clause 14.7')
if mibBuilder.loadTexts: ieee8021AsPortStatIfTable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatIfTable.setDescription('A table of time-aware port related counters in a gPTP domain. A value of 1 is used in a bridge or an end station that does not have multiple components. ')
ieee8021AsPortStatIfEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1), ).setIndexNames((0, "IEEE8021-AS-MIB", "ieee8021AsBridgeBasePort"), (0, "IEEE8021-AS-MIB", "ieee8021AsPortDSAsIfIndex"))
if mibBuilder.loadTexts: ieee8021AsPortStatIfEntry.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatIfEntry.setDescription('A list of statistics pertaining to a port of a gPTP domain. This statistics table uses ieee8021AsPortDSAsIfIndex, and corresponds to ieee8021ASPortDSTable entries. ')
ieee8021AsPortStatRxSyncCount = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncCount.setReference('14.7.2')
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncCount.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncCount.setDescription('A counter that increments every time synchronization information is received, denoted by a transition to TRUE from FALSE of the rcvdSync variable of the MDSyncReceiveSM state machine (see 11.2.13.1.2 and Figure 11-6), when in the DISCARD or WAITING_FOR_SYNC states; or rcvdIndication transitions to TRUE (see Figure 12-3). ')
ieee8021AsPortStatRxFollowUpCount = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxFollowUpCount.setReference('14.7.3')
if mibBuilder.loadTexts: ieee8021AsPortStatRxFollowUpCount.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxFollowUpCount.setDescription('A counter that increments every time a Follow_Up message is received, denoted by a transition to TRUE from FALSE of the rcvdFollowUp variable of the MDSyncReceiveSM state machine (see 11.2.13.1.3 and Figure 11-6) when in the WAITING_FOR_FOLLOW_UP state. ')
ieee8021AsPortStatRxPdelayRequest = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayRequest.setReference('14.7.4')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayRequest.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayRequest.setDescription('A counter that increments every time a Pdelay_Req message is received, denoted by a transition to TRUE from FALSE of the rcvdPdelayReq variable of the MDPdelayResp state machine (see 11.2.16.1.1 and Figure 11-9) when in the WAITING_FOR_PDELAY_REQ or INITIAL_WAITING_FOR_PDELAY_REQ states. ')
ieee8021AsPortStatRxPdelayResponse = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponse.setReference('14.7.5')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponse.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponse.setDescription('A counter that increments every time a Pdelay_Resp message is received, denoted by a transition to TRUE from FALSE of the rcvdPdelayResp variable of the MDPdelayReq state machine (see 11.2.15.1.2 and Figure 11-8) when in the WAITING_FOR_PDELAY_RESP state. ')
ieee8021AsPortStatRxPdelayResponseFollowUp = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponseFollowUp.setReference('14.7.6')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponseFollowUp.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPdelayResponseFollowUp.setDescription('A counter that increments every time a Pdelay_Resp_Follow_Up message is received, denoted by a transition to TRUE from FALSE of the rcvdPdelayRespFollowUp variable of the MDPdelayReq state machine (see 11.2.15.1.4 and Figure 11-8) when in the WAITING_FOR_PDELAY_RESP_FOLLOW_UP state. ')
ieee8021AsPortStatRxAnnounce = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxAnnounce.setReference('14.7.7')
if mibBuilder.loadTexts: ieee8021AsPortStatRxAnnounce.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxAnnounce.setDescription('A counter that increments every time an Announce message is received, denoted by a transition to TRUE from FALSE of the rcvdAnnounce variable of the PortAnnounceReceive state machine (see 10.3.10 and Figure 10-12) when in the DISCARD or RECEIVE states. ')
ieee8021AsPortStatRxPTPPacketDiscard = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxPTPPacketDiscard.setReference('14.7.8')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPTPPacketDiscard.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxPTPPacketDiscard.setDescription('A counter that increments every time a PTP message is discarded, caused by the occurrence of any of the following conditions: a) A received Announce message is not qualified, denoted by the function qualifyAnnounce (see 10.3.10.2.1 and 13.1.3.4) of the PortAnnounceReceive state machine (see 10.3.10 and Figure 10-12) returning FALSE; b) A Follow_Up message corresponding to a received Sync message is not received, denoted by a transition of the condition (currentTime greater or equal to followUpReceiptTimeoutTime) to TRUE from FALSE when in the WAITING_FOR_FOLLOW_UP state of the MDSyncReceiveSM state machine (see 11.2.13 and Figure 11-6); c) A Pdelay_Resp message corresponding to a transmitted Pdelay_Req message is not received, denoted by a transition from the WAITING_FOR_PDELAY_RESP state to the RESET state of the MDPdelayReq state machine (see 11.2.15 and Figure 11-8); d) A Pdelay_Resp_Follow_Up message corresponding to a transmitted Pdelay_Req message is not received, denoted by a transition from the WAITING_FOR_PDELAY_RESP_FOLLOW_UP state to the RESET state of the MDPdelayReq state machine (see 11.2.15 and Figure 11-8). ')
ieee8021AsPortStatRxSyncReceiptTimeouts = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncReceiptTimeouts.setReference('14.7.9')
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncReceiptTimeouts.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatRxSyncReceiptTimeouts.setDescription('A counter that increments every time sync receipt timeout occurs, denoted by entering the AGED state of the PortAnnounceInformation state machine (see 10.3.11 and Figure 10-13), with the condition (currentTime greater or equual to announceReceiptTimeoutTime) TRUE ')
ieee8021AsPortStatAnnounceReceiptTimeouts = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatAnnounceReceiptTimeouts.setReference('14.7.10')
if mibBuilder.loadTexts: ieee8021AsPortStatAnnounceReceiptTimeouts.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatAnnounceReceiptTimeouts.setDescription('A counter that increments every time announce receipt timeout occurs, denoted by entering the AGED state of the PortAnnounceInformation state machine (see 10.3.11 and Figure 10-13), with the condition ((currentTime greater than or equal to syncReceiptTimeoutTime) AND gmPresent)) TRUE. ')
ieee8021AsPortStatPdelayAllowedLostResponsesExceeded = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatPdelayAllowedLostResponsesExceeded.setReference('14.7.11')
if mibBuilder.loadTexts: ieee8021AsPortStatPdelayAllowedLostResponsesExceeded.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatPdelayAllowedLostResponsesExceeded.setDescription('A counter that increments everytime the value of the variable lostResponses (see, 11.2.15.1.10) exceeds the value of the variable allowedLostResponses (see 11.2.12.4), in the RESET state of the MDPdelayReq state machine (see 11.2.15 and Figure 11-8) ')
ieee8021AsPortStatTxSyncCount = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxSyncCount.setReference('14.7.12')
if mibBuilder.loadTexts: ieee8021AsPortStatTxSyncCount.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxSyncCount.setDescription('A counter that increments every time synchronization information is transmitted, denoted by a transition to TRUE from FALSE of the rcvdMDSync variable of the MDSyncSendSM state machine (see 11.2.14.1.1 and Figure 11-7), when in the INITIALIZING or SEND_FOLLOW_UP states; or the INITIATE_REQUEST_WAIT_CONFIRM state is entered in Figure 12-3. ')
ieee8021AsPortStatTxFollowUpCount = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxFollowUpCount.setReference('14.7.13')
if mibBuilder.loadTexts: ieee8021AsPortStatTxFollowUpCount.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxFollowUpCount.setDescription('A counter that increments every time a Follow_Up message is transmitted, denoted by a transition to TRUE from FALSE of the rcvdMDTimestampReceive variable of the MDSyncSendSM state machine (see 11.2.14.1.3 and Figure 11-7), when in the SEND_SYNC state increments every time a Follow_Up packet is transmitted. ')
ieee8021AsPortStatTxPdelayRequest = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayRequest.setReference('14.7.14')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayRequest.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayRequest.setDescription('A counter that increments every time a Pdelay_Req message is transmitted, denoted by entering the INITIAL_SEND_PDELAY_REQ or SEND_PDELAY_REQ states of the MDPdelayReq state machine (see 11.2.15 and Figure 11-8). ')
ieee8021AsPortStatTxPdelayResponse = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponse.setReference('14.7.15')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponse.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponse.setDescription('A counter that increments every time a Pdelay_Resp message is transmitted, denoted by a transition to TRUE from FALSE of the rcvdPdelayReq variable of the MDPdelayResp state machine (see 11.2.16.1.1 and Figure 11-9) when in the WAITING_FOR_PDELAY_REQ or INITIAL_WAITING_FOR_PDELAY_REQ states, and resulting entry to the SENT_PDELAY_RESP_WAITING_FOR_TIMESTAMP state. ')
ieee8021AsPortStatTxPdelayResponseFollowUp = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponseFollowUp.setReference('14.7.16')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponseFollowUp.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxPdelayResponseFollowUp.setDescription('A counter that increments every time a Pdelay_Resp_Follow_Up message is transmitted, denoted by a transition to TRUE from FALSE of the rcvdMDTimestampReceive variable of the MDPdelayResp state machine (see 11.2.16.1.2 and Figure 11-9) when in the SENT_PDELAY_RESP_WAITING_FOR_TIMESTAMP state, and resulting entry to the WAITING_FOR_PDELAY_REQ state. ')
ieee8021AsPortStatTxAnnounce = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsPortStatTxAnnounce.setReference('14.7.17')
if mibBuilder.loadTexts: ieee8021AsPortStatTxAnnounce.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortStatTxAnnounce.setDescription('A counter that increments every time an Announce message is transmitted, denoted by entering the TRANSMIT_ANNOUNCE state of the PortAnnounceReceive state machine (see 10.3.13 and Figure 10-15). ')
ieee8021AsAcceptableMasterTableDS = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 7))
ieee8021AsAcceptableMasterTableDSBase = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 1))
ieee8021AsAcceptableMasterTableDSMaster = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2))
ieee8021AsAcceptableMasterTableDSMaxTableSize = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMaxTableSize.setReference('14.8.1 and 13.1.3.2')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMaxTableSize.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMaxTableSize.setDescription('The value is the maximum size of the AcceptableMasterTable. It is equal to the maxTableSize member of the AcceptableMasterTable structure (see 13.1.3.2)')
ieee8021AsAcceptableMasterTableDSActualTableSize = MibScalar((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSActualTableSize.setReference('14.8.2 and 13.1.3.2')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSActualTableSize.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSActualTableSize.setDescription('The value is the actual size of the AcceptableMasterTable. It is equal to the actualTableSize member of the AcceptableMasterTable structure (see 13.1.3.2 and 13.1.3.5), i.e., the current number of elements in the acceptable master array. The actual table size is less than or equal to the max table size. This value SHOULD be reflect the number of entries in the ieee8021AsAcceptableMasterTableDSMasterTable. For a time-aware system that contains an ONU attached to an IEEE 802.3 EPON link, the initialization value is 1. For a time-aware system that does not contain an ONU attached to an IEEE 802.3 EPON link, the initialization value is 0.')
ieee8021AsAcceptableMasterTableDSMasterTable = MibTable((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1), )
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterTable.setReference('IEEE 802.1AS clause 14.8')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterTable.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterTable.setDescription('A table of time-aware port related variables in a time-aware bridge or for a time-aware end station. A value of 1 is used in a bridge or an end station that does not have multiple components. The contents of this table SHALL be maintained across a restart of the system. ')
ieee8021AsAcceptableMasterTableDSMasterEntry = MibTableRow((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1), ).setIndexNames((0, "IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterTableDSMasterId"))
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterEntry.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterEntry.setDescription('A list of objects pertaining to a port of a time-aware bridge component or a time-aware end station. ')
ieee8021AsAcceptableMasterTableDSMasterId = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1, 1), Unsigned32())
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterId.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableDSMasterId.setDescription('Acceptable Master row entry index in this ieee8021AsAcceptableMasterTabdDSMaster Entry applies. If the does not contain Media type of EPON, this variable (index) MUST be equal to 0.')
ieee8021AsAcceptableMasterClockIdentity = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1, 2), ClockIdentity()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterClockIdentity.setReference('14.8.3')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterClockIdentity.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterClockIdentity.setDescription('Globally unique manufacturer-assigned clock identifier for the local clock port. The identifier is based on an EUI-64.')
ieee8021AsAcceptableMasterPortNumber = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterPortNumber.setReference('14.8.3')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterPortNumber.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterPortNumber.setDescription('This object represents a Port or aggregated port on a bridge component or end-station. This object and ieee8021AsAcceptableMasterClockIdentity together forms AcceptableMasterDS Port Identity.')
ieee8021AsAcceptableMasterAlternatePriority1 = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(244)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterAlternatePriority1.setReference('14.8.3 and 13.1.3.4')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterAlternatePriority1.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterAlternatePriority1.setDescription('If the alternatePriority1 member of the AcceptableMaster array element that corresponds to the sourcePortIdentity of a received Announce message is greater than 0, the value of the grandmasterPriority1 field of the Announce message is replaced by the value of alternatePriority1 of this AcceptableMaster array element for use in the invocation of BMCA')
ieee8021AsAcceptableMasterRowStatus = MibTableColumn((1, 3, 111, 2, 802, 1, 1, 20, 1, 7, 2, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterRowStatus.setReference('14.8.3')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterRowStatus.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterRowStatus.setDescription('This object indicates the status of an entry, and is used to create/delete entries. ')
ieee8021AsCompliances = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 2, 1))
ieee8021AsGroups = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 2, 2))
ieee8021AsCompliancesCor1 = MibIdentifier((1, 3, 111, 2, 802, 1, 1, 20, 2, 3))
ieee8021ASSystemDefaultReqdGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 1)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsDefaultDSClockIdentity"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSNumberPorts"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSClockClass"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSClockAccuracy"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSOffsetScaledLogVariance"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSPriority1"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSPriority2"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSGmCapable"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSCurrentUTCOffset"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSCurrentUTCOffsetValid"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSLeap59"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSLeap61"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSTimeTraceable"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSFrequencyTraceable"), ("IEEE8021-AS-MIB", "ieee8021AsDefaultDSTimeSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021ASSystemDefaultReqdGroup = ieee8021ASSystemDefaultReqdGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021ASSystemDefaultReqdGroup.setDescription('Objects in the System Default required global group.')
ieee8021ASSystemCurrentGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 2)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsCurrentDSStepsRemoved"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSOffsetFromMasterHs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSOffsetFromMasterMs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSOffsetFromMasterLs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSLastGmPhaseChangeHs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSLastGmPhaseChangeMs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSLastGmPhaseChangeLs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSLastGmFreqChangeMs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSLastGmFreqChangeLs"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSGmTimebaseIndicator"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSGmChangeCount"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSTimeOfLastGmChangeEvent"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent"), ("IEEE8021-AS-MIB", "ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021ASSystemCurrentGroup = ieee8021ASSystemCurrentGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021ASSystemCurrentGroup.setDescription('Objects in the System Current global group.')
ieee8021AsSystemClockParentGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 3)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsParentDSParentClockIdentity"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSParentPortNumber"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSCumlativeRateRatio"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterIdentity"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterClockClass"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterClockAccuracy"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterOffsetScaledLogVariance"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterPriority1"), ("IEEE8021-AS-MIB", "ieee8021AsParentDSGrandmasterPriority2"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsSystemClockParentGroup = ieee8021AsSystemClockParentGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsSystemClockParentGroup.setDescription('Objects in the Clock Parent global group.')
ieee8021AsSystemTimePropertiesGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 4)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSCurrentUtcOffset"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSCurrentUtcOffsetValid"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSLeap59"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSLeap61"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSTimeTraceable"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSFrequencyTraceable"), ("IEEE8021-AS-MIB", "ieee8021AsTimePropertiesDSTimeSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsSystemTimePropertiesGroup = ieee8021AsSystemTimePropertiesGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsSystemTimePropertiesGroup.setDescription('Objects for the Time Properties Global group.')
ieee8021AsPortDataSetGlobalGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 5)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsPortDSClockIdentity"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSPortNumber"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSPortRole"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSPttPortEnabled"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSIsMeasuringDelay"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSAsCapable"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayHs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayThreshHs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayThreshMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborPropDelayThreshLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSDelayAsymmetryHs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSDelayAsymmetryMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSDelayAsymmetryLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNeighborRateRatio"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSInitialLogAnnounceInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSCurrentLogAnnounceInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSAnnounceReceiptTimeout"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSInitialLogSyncInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSCurrentLogSyncInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSSyncReceiptTimeout"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSInitialLogPdelayReqInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSCurrentLogPdelayReqInterval"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSAllowedLostResponses"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSVersionNumber"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNupMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNupLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNdownMs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSNdownLs"), ("IEEE8021-AS-MIB", "ieee8021AsPortDSAcceptableMasterTableEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsPortDataSetGlobalGroup = ieee8021AsPortDataSetGlobalGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsPortDataSetGlobalGroup.setDescription('Objects for the port dataset global group.')
ieee8021ASPortStatisticsGlobalGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 6)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsPortStatRxSyncCount"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxFollowUpCount"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxPdelayRequest"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxPdelayResponse"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxPdelayResponseFollowUp"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxAnnounce"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxPTPPacketDiscard"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatRxSyncReceiptTimeouts"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatAnnounceReceiptTimeouts"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatPdelayAllowedLostResponsesExceeded"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxSyncCount"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxFollowUpCount"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxPdelayRequest"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxPdelayResponse"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxPdelayResponseFollowUp"), ("IEEE8021-AS-MIB", "ieee8021AsPortStatTxAnnounce"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021ASPortStatisticsGlobalGroup = ieee8021ASPortStatisticsGlobalGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021ASPortStatisticsGlobalGroup.setDescription('Objects in the Port statistics global group.')
ieee8021AsAcceptableMasterBaseGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 7)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterTableDSMaxTableSize"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterTableDSActualTableSize"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsAcceptableMasterBaseGroup = ieee8021AsAcceptableMasterBaseGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterBaseGroup.setDescription('Objects for the Acceptable Master group.')
ieee8021AsAcceptableMasterTableGroup = ObjectGroup((1, 3, 111, 2, 802, 1, 1, 20, 2, 2, 8)).setObjects(("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterClockIdentity"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterPortNumber"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterAlternatePriority1"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsAcceptableMasterTableGroup = ieee8021AsAcceptableMasterTableGroup.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsAcceptableMasterTableGroup.setDescription('Objects for the Acceptable Master group.')
ieee8021AsCompliance = ModuleCompliance((1, 3, 111, 2, 802, 1, 1, 20, 2, 1, 1)).setObjects(("SNMPv2-MIB", "systemGroup"), ("IF-MIB", "ifGeneralInformationGroup"), ("IEEE8021-AS-MIB", "ieee8021ASSystemDefaultReqdGroup"), ("IEEE8021-AS-MIB", "ieee8021ASSystemCurrentGroup"), ("IEEE8021-AS-MIB", "ieee8021AsSystemClockParentGroup"), ("IEEE8021-AS-MIB", "ieee8021AsSystemTimePropertiesGroup"), ("IEEE8021-AS-MIB", "ieee8021AsPortDataSetGlobalGroup"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterBaseGroup"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsCompliance = ieee8021AsCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ieee8021AsCompliance.setDescription('The compliance statement for support of the IEEE8021-AS-MIB module.')
ieee8021AsComplianceCor1 = ModuleCompliance((1, 3, 111, 2, 802, 1, 1, 20, 2, 1, 2)).setObjects(("SNMPv2-MIB", "systemGroup"), ("IF-MIB", "ifGeneralInformationGroup"), ("IEEE8021-AS-MIB", "ieee8021ASSystemDefaultReqdGroup"), ("IEEE8021-AS-MIB", "ieee8021ASSystemCurrentGroup"), ("IEEE8021-AS-MIB", "ieee8021AsSystemClockParentGroup"), ("IEEE8021-AS-MIB", "ieee8021AsSystemTimePropertiesGroup"), ("IEEE8021-AS-MIB", "ieee8021AsPortDataSetGlobalGroup"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterBaseGroup"), ("IEEE8021-AS-MIB", "ieee8021AsAcceptableMasterTableGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ieee8021AsComplianceCor1 = ieee8021AsComplianceCor1.setStatus('current')
if mibBuilder.loadTexts: ieee8021AsComplianceCor1.setDescription('The compliance statement for support of the IEEE8021-AS-MIB module.')
mibBuilder.exportSymbols("IEEE8021-AS-MIB", IEEE8021ASClockClassValue=IEEE8021ASClockClassValue, ieee8021AsTimePropertiesDSFrequencyTraceable=ieee8021AsTimePropertiesDSFrequencyTraceable, ieee8021AsPortStatTxPdelayResponse=ieee8021AsPortStatTxPdelayResponse, ieee8021AsTimeSyncMib=ieee8021AsTimeSyncMib, ieee8021AsDefaultDSLeap61=ieee8021AsDefaultDSLeap61, ieee8021AsSystemClockParentGroup=ieee8021AsSystemClockParentGroup, IEEE8021ASTimeSourceValue=IEEE8021ASTimeSourceValue, ieee8021AsPortDSPttPortEnabled=ieee8021AsPortDSPttPortEnabled, ieee8021AsPortDSNeighborPropDelayMs=ieee8021AsPortDSNeighborPropDelayMs, ieee8021AsPortStatAnnounceReceiptTimeouts=ieee8021AsPortStatAnnounceReceiptTimeouts, ieee8021AsAcceptableMasterClockIdentity=ieee8021AsAcceptableMasterClockIdentity, ieee8021AsPortStatIfTable=ieee8021AsPortStatIfTable, ieee8021AsPortDSNeighborPropDelayThreshMs=ieee8021AsPortDSNeighborPropDelayThreshMs, ieee8021AsDefaultDSClockIdentity=ieee8021AsDefaultDSClockIdentity, ieee8021AsCurrentDSOffsetFromMasterLs=ieee8021AsCurrentDSOffsetFromMasterLs, ieee8021AsCurrentDSGmTimebaseIndicator=ieee8021AsCurrentDSGmTimebaseIndicator, ieee8021AsAcceptableMasterTableGroup=ieee8021AsAcceptableMasterTableGroup, ieee8021AsCurrentDSLastGmPhaseChangeMs=ieee8021AsCurrentDSLastGmPhaseChangeMs, ieee8021AsPortDSInitialLogSyncInterval=ieee8021AsPortDSInitialLogSyncInterval, ieee8021AsSystemTimePropertiesGroup=ieee8021AsSystemTimePropertiesGroup, ieee8021AsPortDSClockIdentity=ieee8021AsPortDSClockIdentity, ieee8021AsCompliance=ieee8021AsCompliance, ieee8021AsAcceptableMasterBaseGroup=ieee8021AsAcceptableMasterBaseGroup, ieee8021AsPortStatRxPdelayResponseFollowUp=ieee8021AsPortStatRxPdelayResponseFollowUp, ieee8021AsPortDSNeighborPropDelayHs=ieee8021AsPortDSNeighborPropDelayHs, ieee8021AsDefaultDSPriority1=ieee8021AsDefaultDSPriority1, ieee8021AsPortDSDelayAsymmetryMs=ieee8021AsPortDSDelayAsymmetryMs, ieee8021AsPortDSAllowedLostResponses=ieee8021AsPortDSAllowedLostResponses, ieee8021AsConformance=ieee8021AsConformance, ieee8021AsPortStatPdelayAllowedLostResponsesExceeded=ieee8021AsPortStatPdelayAllowedLostResponsesExceeded, ieee8021AsAcceptableMasterAlternatePriority1=ieee8021AsAcceptableMasterAlternatePriority1, ieee8021AsAcceptableMasterTableDSMasterId=ieee8021AsAcceptableMasterTableDSMasterId, ieee8021AsParentDSGrandmasterIdentity=ieee8021AsParentDSGrandmasterIdentity, ieee8021AsParentDSGrandmasterPriority2=ieee8021AsParentDSGrandmasterPriority2, ieee8021AsPortDSInitialLogAnnounceInterval=ieee8021AsPortDSInitialLogAnnounceInterval, ieee8021AsMIBObjects=ieee8021AsMIBObjects, ieee8021ASPortStatisticsGlobalGroup=ieee8021ASPortStatisticsGlobalGroup, ieee8021AsPortStatRxFollowUpCount=ieee8021AsPortStatRxFollowUpCount, ieee8021AsPortDSCurrentLogSyncInterval=ieee8021AsPortDSCurrentLogSyncInterval, ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs=ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalHs, ieee8021AsCurrentDSLastGmFreqChangeMs=ieee8021AsCurrentDSLastGmFreqChangeMs, ieee8021AsPortDSCurrentLogPdelayReqInterval=ieee8021AsPortDSCurrentLogPdelayReqInterval, ieee8021AsCurrentDSTimeOfLastGmChangeEvent=ieee8021AsCurrentDSTimeOfLastGmChangeEvent, ieee8021AsCompliances=ieee8021AsCompliances, ieee8021AsParentDSParentClockIdentity=ieee8021AsParentDSParentClockIdentity, ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent=ieee8021AsCurrentDSTimeOfLastGmFreqChangeEvent, ieee8021AsParentDSGrandmasterPriority1=ieee8021AsParentDSGrandmasterPriority1, ieee8021AsAcceptableMasterTableDSMaxTableSize=ieee8021AsAcceptableMasterTableDSMaxTableSize, ieee8021AsCompliancesCor1=ieee8021AsCompliancesCor1, ieee8021AsDefaultDSTimeTraceable=ieee8021AsDefaultDSTimeTraceable, ieee8021AsTimePropertiesDSLeap61=ieee8021AsTimePropertiesDSLeap61, ieee8021AsAcceptableMasterTableDSBase=ieee8021AsAcceptableMasterTableDSBase, ieee8021AsCurrentDSLastGmPhaseChangeHs=ieee8021AsCurrentDSLastGmPhaseChangeHs, ieee8021AsDefaultDSOffsetScaledLogVariance=ieee8021AsDefaultDSOffsetScaledLogVariance, ieee8021AsTimePropertiesDSLeap59=ieee8021AsTimePropertiesDSLeap59, ieee8021AsParentDSGrandmasterClockAccuracy=ieee8021AsParentDSGrandmasterClockAccuracy, ieee8021AsPortDSAsIfIndex=ieee8021AsPortDSAsIfIndex, ieee8021AsPortDSNeighborPropDelayThreshHs=ieee8021AsPortDSNeighborPropDelayThreshHs, ieee8021AsParentDS=ieee8021AsParentDS, ieee8021AsPortDSNeighborPropDelayLs=ieee8021AsPortDSNeighborPropDelayLs, ieee8021AsDefaultDSNumberPorts=ieee8021AsDefaultDSNumberPorts, ieee8021AsPortStatRxPdelayResponse=ieee8021AsPortStatRxPdelayResponse, ieee8021AsPortDSPortNumber=ieee8021AsPortDSPortNumber, IEEE8021ASClockAccuracyValue=IEEE8021ASClockAccuracyValue, ieee8021AsPortStatRxSyncCount=ieee8021AsPortStatRxSyncCount, ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs=ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalMs, ieee8021AsDefaultDSClockAccuracy=ieee8021AsDefaultDSClockAccuracy, ieee8021AsPortStatIfEntry=ieee8021AsPortStatIfEntry, ieee8021AsCurrentDSOffsetFromMasterMs=ieee8021AsCurrentDSOffsetFromMasterMs, ieee8021AsPortDSAsCapable=ieee8021AsPortDSAsCapable, ieee8021AsDefaultDSTimeSource=ieee8021AsDefaultDSTimeSource, ieee8021AsPortDataSetGlobalGroup=ieee8021AsPortDataSetGlobalGroup, ieee8021AsTimePropertiesDSCurrentUtcOffset=ieee8021AsTimePropertiesDSCurrentUtcOffset, ieee8021AsPortDSNeighborPropDelayThreshLs=ieee8021AsPortDSNeighborPropDelayThreshLs, ieee8021AsPortStatTxPdelayResponseFollowUp=ieee8021AsPortStatTxPdelayResponseFollowUp, ieee8021AsPortDSNdownLs=ieee8021AsPortDSNdownLs, ieee8021AsComplianceCor1=ieee8021AsComplianceCor1, PYSNMP_MODULE_ID=ieee8021AsTimeSyncMib, ieee8021AsPortStatTxSyncCount=ieee8021AsPortStatTxSyncCount, ieee8021AsAcceptableMasterTableDSActualTableSize=ieee8021AsAcceptableMasterTableDSActualTableSize, ieee8021AsDefaultDSClockClass=ieee8021AsDefaultDSClockClass, ieee8021AsPortDSDelayAsymmetryLs=ieee8021AsPortDSDelayAsymmetryLs, ieee8021AsPortStatRxPTPPacketDiscard=ieee8021AsPortStatRxPTPPacketDiscard, ieee8021AsParentDSParentPortNumber=ieee8021AsParentDSParentPortNumber, ieee8021AsPortDSCurrentLogAnnounceInterval=ieee8021AsPortDSCurrentLogAnnounceInterval, ieee8021AsPortStatTxFollowUpCount=ieee8021AsPortStatTxFollowUpCount, ieee8021AsPortDSAnnounceReceiptTimeout=ieee8021AsPortDSAnnounceReceiptTimeout, ieee8021AsPortDSNupMs=ieee8021AsPortDSNupMs, ieee8021AsDefaultDSFrequencyTraceable=ieee8021AsDefaultDSFrequencyTraceable, ieee8021AsGroups=ieee8021AsGroups, ieee8021AsDefaultDS=ieee8021AsDefaultDS, ieee8021AsPortStatRxAnnounce=ieee8021AsPortStatRxAnnounce, ieee8021AsPortDSIsMeasuringDelay=ieee8021AsPortDSIsMeasuringDelay, ieee8021AsPortDSVersionNumber=ieee8021AsPortDSVersionNumber, ieee8021AsCurrentDSStepsRemoved=ieee8021AsCurrentDSStepsRemoved, ieee8021AsCurrentDSOffsetFromMasterHs=ieee8021AsCurrentDSOffsetFromMasterHs, ieee8021AsCurrentDSLastGmPhaseChangeLs=ieee8021AsCurrentDSLastGmPhaseChangeLs, ieee8021AsPortStatRxPdelayRequest=ieee8021AsPortStatRxPdelayRequest, ieee8021AsPortDSNeighborRateRatio=ieee8021AsPortDSNeighborRateRatio, ieee8021AsPortStatRxSyncReceiptTimeouts=ieee8021AsPortStatRxSyncReceiptTimeouts, ieee8021AsAcceptableMasterTableDSMaster=ieee8021AsAcceptableMasterTableDSMaster, ieee8021AsDefaultDSCurrentUTCOffset=ieee8021AsDefaultDSCurrentUTCOffset, ieee8021AsDefaultDSPriority2=ieee8021AsDefaultDSPriority2, ieee8021AsBridgeBasePort=ieee8021AsBridgeBasePort, ieee8021AsCurrentDSGmChangeCount=ieee8021AsCurrentDSGmChangeCount, ieee8021AsPortStatTxAnnounce=ieee8021AsPortStatTxAnnounce, ieee8021AsPortDSDelayAsymmetryHs=ieee8021AsPortDSDelayAsymmetryHs, ieee8021AsPortDSSyncReceiptTimeout=ieee8021AsPortDSSyncReceiptTimeout, ieee8021AsPortDSNupLs=ieee8021AsPortDSNupLs, ieee8021AsCurrentDS=ieee8021AsCurrentDS, ieee8021AsAcceptableMasterPortNumber=ieee8021AsAcceptableMasterPortNumber, ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs=ieee8021AsPortDSSyncReceiptTimeoutTimeIntervalLs, ieee8021AsTimePropertiesDSTimeTraceable=ieee8021AsTimePropertiesDSTimeTraceable, ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent=ieee8021AsCurrentDSTimeOfLastGmPhaseChangeEvent, ieee8021AsPortDSNdownMs=ieee8021AsPortDSNdownMs, ieee8021AsPortDSAcceptableMasterTableEnabled=ieee8021AsPortDSAcceptableMasterTableEnabled, ieee8021AsAcceptableMasterTableDSMasterTable=ieee8021AsAcceptableMasterTableDSMasterTable, ieee8021AsDefaultDSCurrentUTCOffsetValid=ieee8021AsDefaultDSCurrentUTCOffsetValid, ieee8021AsPortDSInitialLogPdelayReqInterval=ieee8021AsPortDSInitialLogPdelayReqInterval, ieee8021ASSystemCurrentGroup=ieee8021ASSystemCurrentGroup, ieee8021AsPortDSIfTable=ieee8021AsPortDSIfTable, ieee8021AsPortDSPortRole=ieee8021AsPortDSPortRole, ClockIdentity=ClockIdentity, ieee8021AsDefaultDSLeap59=ieee8021AsDefaultDSLeap59, ieee8021AsAcceptableMasterRowStatus=ieee8021AsAcceptableMasterRowStatus, ieee8021AsDefaultDSGmCapable=ieee8021AsDefaultDSGmCapable, ieee8021AsCurrentDSLastGmFreqChangeLs=ieee8021AsCurrentDSLastGmFreqChangeLs, ieee8021AsAcceptableMasterTableDS=ieee8021AsAcceptableMasterTableDS, ieee8021AsParentDSGrandmasterOffsetScaledLogVariance=ieee8021AsParentDSGrandmasterOffsetScaledLogVariance, ieee8021AsTimePropertiesDSTimeSource=ieee8021AsTimePropertiesDSTimeSource, ieee8021AsPortDSIfEntry=ieee8021AsPortDSIfEntry, ieee8021AsParentDSGrandmasterClockClass=ieee8021AsParentDSGrandmasterClockClass, ieee8021ASSystemDefaultReqdGroup=ieee8021ASSystemDefaultReqdGroup, ieee8021AsParentDSCumlativeRateRatio=ieee8021AsParentDSCumlativeRateRatio, ieee8021AsTimePropertiesDSCurrentUtcOffsetValid=ieee8021AsTimePropertiesDSCurrentUtcOffsetValid, ieee8021AsTimePropertiesDS=ieee8021AsTimePropertiesDS, ieee8021AsAcceptableMasterTableDSMasterEntry=ieee8021AsAcceptableMasterTableDSMasterEntry, ieee8021AsPortStatTxPdelayRequest=ieee8021AsPortStatTxPdelayRequest)

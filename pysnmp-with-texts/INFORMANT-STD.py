#
# PySNMP MIB module INFORMANT-STD (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INFORMANT-STD
# Produced by pysmi-0.3.4 at Wed May  1 13:53:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Gauge32, Integer32, MibIdentifier, Counter32, IpAddress, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, TimeTicks, Unsigned32, NotificationType, iso, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Gauge32", "Integer32", "MibIdentifier", "Counter32", "IpAddress", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "TimeTicks", "Unsigned32", "NotificationType", "iso", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
InstanceName, informant = mibBuilder.importSymbols("WTCS", "InstanceName", "informant")
standard = ModuleIdentity((1, 3, 6, 1, 4, 1, 9600, 1, 1))
standard.setRevisions(('2008-07-11 23:59', '2008-03-21 23:08', '2005-07-19 18:26', '2004-02-29 06:27', '2004-01-17 16:02',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: standard.setRevisionsDescriptions(('Multiplied lDiskAvgDiskSecPerRead, lDiskAvgDiskSecPerTransfer, lDiskAvgDiskSecPerWrite by 1000000 and lDiskAvgDiskQueueLength, lDiskAvgDiskReadQueueLength, lDiskAvgDiskWriteQueueLength by 1000 since these values are commonly fractional (less than 1).', 'Added memory OIDs in kilobytes and megabytes to support 64-bit values in Gauge32.', 'Added the systemSystemUpTime OID to provide access how long the computer has been up in seconds.', 'Changed the syntax of the datapoints from integer to gauge.', 'The initial revision of this MIB module.',))
if mibBuilder.loadTexts: standard.setLastUpdated('200807112359Z')
if mibBuilder.loadTexts: standard.setOrganization('Informant Systems, Inc.')
if mibBuilder.loadTexts: standard.setContactInfo('Garth Williams 11135-23A Ave Edmonton, AB T6J4W5 Canada Tel: +1 780 434 4113 E-mail: garth.williams@wtcs.org')
if mibBuilder.loadTexts: standard.setDescription('The MIB module for SNMP Informant Standard performance counter entries.')
logicalDiskTable = MibTable((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1), )
if mibBuilder.loadTexts: logicalDiskTable.setStatus('current')
if mibBuilder.loadTexts: logicalDiskTable.setDescription("The Logical Disk performance object consists of counters that monitor logical partitions of hard or fixed disk drives. System Monitor identifies logical disks by their drive letter, such as 'C.' To monitor Logical Disk object counters, you must activate them by typing the following at the command prompt: diskperf -yv")
logicalDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1), ).setIndexNames((0, "INFORMANT-STD", "lDiskInstance"))
if mibBuilder.loadTexts: logicalDiskEntry.setStatus('current')
if mibBuilder.loadTexts: logicalDiskEntry.setDescription("Performance information for one particular instance of 'LogicalDisk' object.")
lDiskInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 1), InstanceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskInstance.setStatus('current')
if mibBuilder.loadTexts: lDiskInstance.setDescription('Instance name.')
lDiskPercentDiskReadTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskPercentDiskReadTime.setStatus('current')
if mibBuilder.loadTexts: lDiskPercentDiskReadTime.setDescription('% Disk Read Time is the percentage of elapsed time that the selected disk drive is busy servicing read requests.')
lDiskPercentDiskTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskPercentDiskTime.setStatus('current')
if mibBuilder.loadTexts: lDiskPercentDiskTime.setDescription('% Disk Time is the percentage of elapsed time that the selected disk drive is busy servicing read or write requests.')
lDiskPercentDiskWriteTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskPercentDiskWriteTime.setStatus('current')
if mibBuilder.loadTexts: lDiskPercentDiskWriteTime.setDescription('% Disk Write Time is the percentage of elapsed time that the selected disk drive is busy servicing write requests.')
lDiskPercentFreeSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskPercentFreeSpace.setStatus('current')
if mibBuilder.loadTexts: lDiskPercentFreeSpace.setDescription('% Free Space is the ratio of the free space available on the logical disk unit to the total usable space provided by the selected logical disk drive.')
lDiskPercentIdleTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskPercentIdleTime.setStatus('current')
if mibBuilder.loadTexts: lDiskPercentIdleTime.setDescription('% Idle Time reports the percentage of time during the sample interval that the disk was idle.')
lDiskAvgDiskQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskQueueLength.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskQueueLength.setDescription('Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval. Multiplied by 1000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskAvgDiskReadQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskReadQueueLength.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskReadQueueLength.setDescription('Avg. Disk Read Queue Length is the average number of read requests that were queued for the selected disk during the sample interval. Multiplied by 1000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskAvgDiskWriteQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskWriteQueueLength.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskWriteQueueLength.setDescription('Avg. Disk Write Queue Length is the average number of write requests that were queued for the selected disk during the sample interval. Multiplied by 1000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskAvgDiskSecPerRead = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskSecPerRead.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskSecPerRead.setDescription('Avg. Disk sec/Read is the average time, in seconds, of a read of data from the disk. Multiplied by 1000000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskAvgDiskSecPerTransfer = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskSecPerTransfer.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskSecPerTransfer.setDescription('Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer. Multiplied by 1000000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskAvgDiskSecPerWrite = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskAvgDiskSecPerWrite.setStatus('current')
if mibBuilder.loadTexts: lDiskAvgDiskSecPerWrite.setDescription('Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. Multiplied by 1000000 to provide a useful gauge value since it is commonly a fractional value.')
lDiskCurrentDiskQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskCurrentDiskQueueLength.setStatus('current')
if mibBuilder.loadTexts: lDiskCurrentDiskQueueLength.setDescription('Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It includes requests in service at the time of the snapshot. This is an instantaneous length, not an average over the time interval. Multi-spindle disk devices can have multiple requests active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests are experiencing delays proportional to the length of this queue minus the number of spindles on the disks. This difference should average less than 2 for good performance.')
lDiskDiskBytesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskBytesPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskBytesPerSec.setDescription('Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.')
lDiskDiskReadBytesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskReadBytesPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskReadBytesPerSec.setDescription('Disk Read Bytes/sec is the rate bytes are transferred from the disk during read operations.')
lDiskDiskReadsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskReadsPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskReadsPerSec.setDescription('Disk Reads/sec is the rate of read operations on the disk.')
lDiskDiskTransfersPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskTransfersPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskTransfersPerSec.setDescription('Disk Transfers/sec is the rate of read and write operations on the disk.')
lDiskDiskWriteBytesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskWriteBytesPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskWriteBytesPerSec.setDescription('Disk Write Bytes is rate bytes are transferred to the disk during write operations.')
lDiskDiskWritesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskDiskWritesPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskDiskWritesPerSec.setDescription('Disk Writes/sec is the rate of write operations on the disk.')
lDiskFreeMegabytes = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskFreeMegabytes.setStatus('current')
if mibBuilder.loadTexts: lDiskFreeMegabytes.setDescription('Free Megabytes displays the unallocated space on the disk drive in megabytes. One megabyte = 1,048,576 bytes.')
lDiskSplitIOPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lDiskSplitIOPerSec.setStatus('current')
if mibBuilder.loadTexts: lDiskSplitIOPerSec.setDescription('Split IO/Sec reports the rate that I/Os to the disk were split into multiple I/Os. A split I/O may result from requesting data in a size that is too large to fit into a single I/O or that the disk is fragmented.')
memory = ObjectIdentity((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2))
if mibBuilder.loadTexts: memory.setStatus('current')
if mibBuilder.loadTexts: memory.setDescription('The Memory performance object consists of counters that describe the behavior of physical and virtual memory on the computer. Physical memory is the amount of random-access memory (RAM) on the computer. Virtual memory consists of space in physical memory and on disk. Many of the memory counters monitor paging, which is the movement of pages of code and data between disk and physical memory. Excessive paging, a symptom of a memory shortage, can cause delays which interfere with all system processes.')
memoryAvailableBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryAvailableBytes.setStatus('current')
if mibBuilder.loadTexts: memoryAvailableBytes.setDescription("Available Bytes is the amount of physical memory available to processes running on the computer, in bytes. It is calculated by summing space on the Zeroed, Free, and Stand by memory lists. Free memory is ready for use; Zeroed memory are pages of memory filled with zeros to prevent later processes from seeing data used by a previous process. Standby memory is memory removed from a process' working set (its physical memory) on route to disk, but is still available to be recalled. This counter displays the last observed value only; it is not an average. ")
memoryAvailableKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryAvailableKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryAvailableKBytes.setDescription("Available KBytes is the amount of physical memory available to processes running on the computer, in Kilobytes (Bytes / 1,024). It is calculated by summing space on the Zeroed, Free, and Stand by memory lists. Free memory is ready for use; Zeroed memory are pages of memory filled with zeros to prevent later processes from seeing data used by a previous process. Standby memory is memory removed from a process' working set (its physical memory) on route to disk, but is still available to be recalled. This counter displays the last observed value only; it is not an average. ")
memoryAvailableMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryAvailableMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryAvailableMBytes.setDescription("Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes (Bytes / 1,048,576). It is calculated by summing space on the Zeroed, Free, and Stand by memory lists. Free memory is ready for use; Zeroed memory are pages of memory filled with zeros to prevent later processes from seeing data used by a previous process. Standby memory is memory removed from a process' working set (its physical memory) on route to disk, but is still available to be recalled. This counter displays the last observed value only; it is not an average. ")
memoryCommittedBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCommittedBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCommittedBytes.setDescription('Committed Bytes is the amount of committed virtual memory, in bytes. (Committed memory is physical memory for which space has been reserved on the disk paging file in case it needs to be written back to disk). This counter displays the last observed value only; it is not an average. ')
memoryCacheBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCacheBytes.setDescription('Cache Bytes is the sum of the System Cache Resident Bytes, System Driver Resident Bytes, System Code Resident Bytes, and Pool Paged Resident Bytes counters. This counter displays the last observed value only; it is not an average. ')
memoryCacheBytesPeak = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheBytesPeak.setStatus('current')
if mibBuilder.loadTexts: memoryCacheBytesPeak.setDescription('Cache Bytes Peak is the maximum value of Cache Bytes since the system was last restarted. This value might be larger than the current size of the cache. Cache Bytes is the sum of the System Cache Resident Bytes, System Driver Resident Bytes, System Code Resident Bytes, and Pool Paged Resident Bytes counters. This counter displays the last observed value only; it is not an average. ')
memoryPageFaultsPerSec = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPageFaultsPerSec.setStatus('current')
if mibBuilder.loadTexts: memoryPageFaultsPerSec.setDescription('Page Faults/sec is the overall rate faulted pages are handled by the processor. It is measured in numbers of pages faulted per second. A page fault occurs when a process requires code or data that is not in its working set (its space in physical memory). This counter includes both hard faults (those that require disk access) and soft faults (where the faulted page is found elsewhere in physical memory). Most processors can handle large numbers of soft faults without consequence. However, hard faults can cause significant delays. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ')
memoryPagesInputPerSec = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPagesInputPerSec.setStatus('current')
if mibBuilder.loadTexts: memoryPagesInputPerSec.setDescription('Pages Input/sec is the number of pages read from disk to resolve hard page faults. (Hard page faults occur when a process requires code or data that is not in its working set or elsewhere in physical memory, and must be retrieved from disk). This counter was designed as a primary indicator of the kinds of faults that cause system-wide delays. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. This counter counts numbers of pages, and can be compared to other counts of pages, such as Memory: Page Faults/sec, without conversion. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ')
memoryPagesOutputPerSec = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPagesOutputPerSec.setStatus('current')
if mibBuilder.loadTexts: memoryPagesOutputPerSec.setDescription('Pages Output/sec is the number of pages written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows NT writes more pages back to disk to free up space when physical memory is in short supply. This counter counts numbers of pages, and can be compared to other counts of pages, without conversion. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ')
memoryPagesPerSec = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPagesPerSec.setStatus('current')
if mibBuilder.loadTexts: memoryPagesPerSec.setDescription('Pages/sec is the number of pages read from or written to disk to resolve hard page faults. (Hard page faults occur when a process requires code or data that is not in its working set or elsewhere in physical memory, and must be retrieved from disk). This counter was designed as a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory: Pages Input/sec and Memory: Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory: Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ')
memoryPoolNonpagedBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolNonpagedBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolNonpagedBytes.setDescription('Pool Nonpaged Bytes is the number of bytes in the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated. Memory: Pool Nonpaged Bytes is calculated differently than Process: Pool Nonpaged Bytes, so it might not equal Process: Pool Nonpaged Bytes: _Total. This counter displays the last observed value only; it is not an average. ')
memoryPoolPagedBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedBytes.setDescription('Pool Paged Bytes is the number of bytes in the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Memory: Pool Paged Bytes is calculated differently than Process: Pool Paged Bytes, so it might not equal Process: Pool Paged Bytes: _Total. This counter displays the last observed value only; it is not an average. ')
memoryPoolPagedResidentBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedResidentBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedResidentBytes.setDescription('Pool Paged Resident Bytes is the current size of paged pool in bytes. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Space used by the paged and nonpaged pools are taken from physical memory, so a pool that is too large denies memory space to processes. This counter displays the last observed value only; it is not an average. ')
memorySystemCacheResidentBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCacheResidentBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCacheResidentBytes.setDescription('System Cache Resident Bytes is the number of bytes from the file system cache that are resident in physical memory. This value includes only current physical pages and does not include any virtual memory pages not currently resident. As such this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory: System Code Resident Bytes. This counter displays the last observed value only; it is not an average. ')
memorySystemCodeResidentBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeResidentBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeResidentBytes.setDescription('System Code Resident Bytes is the number of bytes of operating system code currently in physical memory that can be written to disk when not in use. This value is a component of System Code Total Bytes, which also includes operating system code on disk. System Code Resident Bytes (and System Code Total Bytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average. ')
memorySystemCodeTotalBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeTotalBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeTotalBytes.setDescription('System Code Total Bytes is the number of bytes of pageable operating system code currently in virtual memory. It is a measure of the amount of physical memory being used by the operating system that can be written to disk when not in use. This value is calculated by summing the bytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader. This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average. ')
memorySystemDriverResidentBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverResidentBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverResidentBytes.setDescription('System Driver Resident Bytes is the number of bytes of pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory: System Driver Total Bytes, which also includes driver memory that has been written to disk. Neither System Driver Resident Bytes nor System Driver Total Bytes includes memory that cannot be written to disk.')
memorySystemDriverTotalBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverTotalBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverTotalBytes.setDescription('System Driver Total Bytes is the number of bytes of pageable virtual memory currently being used by device drivers. (Pageable memory can be written to disk when it is not being used). It includes physical memory (Memory: System Driver Resident Bytes) and code and data paged to disk. It is a component of Memory: System Code Total Bytes. This counter displays the last observed value only; it is not an average. ')
memoryCommittedKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCommittedKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCommittedKBytes.setDescription('Committed KiloBytes is the amount of committed virtual memory, in kilobytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.')
memoryCacheKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCacheKBytes.setDescription('Cache KiloBytes is the sum of the Memory\\\\System Cache Resident KiloBytes, Memory\\\\System Driver Resident KiloBytes, Memory\\\\System Code Resident KiloBytes, and Memory\\\\Pool Paged Resident KiloBytes counters. This counter displays the last observed value only; it is not an average. ')
memoryCacheKBytesPeak = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheKBytesPeak.setStatus('current')
if mibBuilder.loadTexts: memoryCacheKBytesPeak.setDescription('Cache KiloBytes Peak is the maximum number of kilobytes used by the file system cache since the system was last restarted. This might be larger than the current size of the cache. This counter displays the last observed value only; it is not an average. ')
memoryPoolNonpagedKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolNonpagedKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolNonpagedKBytes.setDescription('Pool Nonpaged KiloBytes is the size, in kilobytes, of the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated. Memory\\\\Pool Nonpaged KiloBytes is calculated differently than Process\\\\Pool Nonpaged KiloBytes, so it might not equal Process\\\\Pool Nonpaged KiloBytes\\\\_Total. This counter displays the last observed value only; it is not an average.')
memoryPoolPagedKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedKBytes.setDescription('Pool Paged KiloBytes is the size, in kilobytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Memory\\\\Pool Paged KiloBytes is calculated differently than Process\\\\Pool Paged KiloBytes, so it might not equal Process\\\\Pool Paged KiloBytes\\\\_Total. This counter displays the last observed value only; it is not an average.')
memoryPoolPagedResidentKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedResidentKBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedResidentKBytes.setDescription('Pool Paged Resident KiloBytes is the current size, in kilobytes, of the paged pool. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Space used by the paged and nonpaged pools are taken from physical memory, so a pool that is too large denies memory space to processes. This counter displays the last observed value only; it is not an average.')
memorySystemCacheResidentKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCacheResidentKBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCacheResidentKBytes.setDescription('System Cache Resident KiloBytes is the size, in kilobytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident. It does equal the System Cache value shown in Task Manager. As a result, this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory\\\\System Code Resident KiloBytes which represents all pageable operating system code that is currently in physical memory. This counter displays the last observed value only; it is not an average. ')
memorySystemCodeResidentKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeResidentKBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeResidentKBytes.setDescription('System Code Resident KiloBytes is the size, in kilobytes of the operating system code currently in physical memory that can be written to disk when not in use. This value is a component of Memory\\\\System Code Total KiloBytes, which also includes operating system code on disk. Memory\\\\System Code Resident KiloBytes (and Memory\\\\System Code Total KiloBytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.')
memorySystemCodeTotalKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeTotalKBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeTotalKBytes.setDescription('System Code Total KiloBytes is the size, in kilobytes, of the pageable operating system code currently in virtual memory. It is a measure of the amount of physical memory being used by the operating system that can be written to disk when not in use. This value is calculated by summing the kilobytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader. This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.')
memorySystemDriverResidentKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverResidentKBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverResidentKBytes.setDescription('System Driver Resident KiloBytes is the size, in kilobytes, of the pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory\\\\System Driver Total KiloBytes, which also includes driver memory that has been written to disk. Neither Memory\\\\System Driver Resident KiloBytes nor Memory\\\\System Driver Total KiloBytes includes memory that cannot be written to disk.')
memorySystemDriverTotalKBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverTotalKBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverTotalKBytes.setDescription('System Driver Total KiloBytes is the size, in kilobytes, of the pageable virtual memory currently being used by device drivers. Pageable memory can be written to disk when it is not being used. It includes physical memory (Memory\\\\System Driver Resident KiloBytes) and code and data paged to disk. It is a component of Memory\\\\System Code Total KiloBytes. This counter displays the last observed value only; it is not an average. ')
memoryCommittedMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCommittedMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCommittedMBytes.setDescription('Committed MegaBytes is the amount of committed virtual memory, in megabytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.')
memoryCacheMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 31), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryCacheMBytes.setDescription('Cache MegaBytes is the sum of the Memory\\\\System Cache Resident MegaBytes, Memory\\\\System Driver Resident MegaBytes, Memory\\\\System Code Resident MegaBytes, and Memory\\\\Pool Paged Resident MegaBytes counters. This counter displays the last observed value only; it is not an average. ')
memoryCacheMBytesPeak = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryCacheMBytesPeak.setStatus('current')
if mibBuilder.loadTexts: memoryCacheMBytesPeak.setDescription('Cache MegaBytes Peak is the maximum number of megabytes used by the file system cache since the system was last restarted. This might be larger than the current size of the cache. This counter displays the last observed value only; it is not an average. ')
memoryPoolNonpagedMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolNonpagedMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolNonpagedMBytes.setDescription('Pool Nonpaged MegaBytes is the size, in megabytes, of the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated. Memory\\\\Pool Nonpaged MegaBytes is calculated differently than Process\\\\Pool Nonpaged MegaBytes, so it might not equal Process\\\\Pool Nonpaged MegaBytes\\\\_Total. This counter displays the last observed value only; it is not an average.')
memoryPoolPagedMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedMBytes.setDescription('Pool Paged MegaBytes is the size, in megabytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Memory\\\\Pool Paged MegaBytes is calculated differently than Process\\\\Pool Paged MegaBytes, so it might not equal Process\\\\Pool Paged MegaBytes\\\\_Total. This counter displays the last observed value only; it is not an average.')
memoryPoolPagedResidentMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryPoolPagedResidentMBytes.setStatus('current')
if mibBuilder.loadTexts: memoryPoolPagedResidentMBytes.setDescription('Pool Paged Resident MegaBytes is the current size, in megabytes, of the paged pool. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Space used by the paged and nonpaged pools are taken from physical memory, so a pool that is too large denies memory space to processes. This counter displays the last observed value only; it is not an average.')
memorySystemCacheResidentMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCacheResidentMBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCacheResidentMBytes.setDescription('System Cache Resident MegaBytes is the size, in megabytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident. It does equal the System Cache value shown in Task Manager. As a result, this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory\\\\System Code Resident MegaBytes which represents all pageable operating system code that is currently in physical memory. This counter displays the last observed value only; it is not an average. ')
memorySystemCodeResidentMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 37), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeResidentMBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeResidentMBytes.setDescription('System Code Resident MegaBytes is the size, in megabytes of the operating system code currently in physical memory that can be written to disk when not in use. This value is a component of Memory\\\\System Code Total MegaBytes, which also includes operating system code on disk. Memory\\\\System Code Resident MegaBytes (and Memory\\\\System Code Total MegaBytes) does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.')
memorySystemCodeTotalMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemCodeTotalMBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemCodeTotalMBytes.setDescription('System Code Total MegaBytes is the size, in megabytes, of the pageable operating system code currently in virtual memory. It is a measure of the amount of physical memory being used by the operating system that can be written to disk when not in use. This value is calculated by summing the megabytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader. This counter does not include code that must remain in physical memory and cannot be written to disk. This counter displays the last observed value only; it is not an average.')
memorySystemDriverResidentMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 39), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverResidentMBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverResidentMBytes.setDescription('System Driver Resident MegaBytes is the size, in megabytes, of the pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory\\\\System Driver Total MegaBytes, which also includes driver memory that has been written to disk. Neither Memory\\\\System Driver Resident MegaBytes nor Memory\\\\System Driver Total MegaBytes includes memory that cannot be written to disk.')
memorySystemDriverTotalMBytes = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 2, 40), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memorySystemDriverTotalMBytes.setStatus('current')
if mibBuilder.loadTexts: memorySystemDriverTotalMBytes.setDescription('System Driver Total MegaBytes is the size, in megabytes, of the pageable virtual memory currently being used by device drivers. Pageable memory can be written to disk when it is not being used. It includes physical memory (Memory\\\\System Driver Resident MegaBytes) and code and data paged to disk. It is a component of Memory\\\\System Code Total MegaBytes. This counter displays the last observed value only; it is not an average. ')
networkInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3), )
if mibBuilder.loadTexts: networkInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: networkInterfaceTable.setDescription('The Network Interface performance object consists of counters that measure the rates at which bytes and packets are sent and received over a TCP/IP connection. It includes counters that monitor connection errors. The Network Interface counters display data about the network adapters on the server computer. The first instance of the Network Interface object (Instance 1) that you see in System Monitor represents the loopback. The loopback is a local path through the protocol driver and the network adapter. All other instances represent installed network adapters.')
networkInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1), ).setIndexNames((0, "INFORMANT-STD", "netInstance"))
if mibBuilder.loadTexts: networkInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: networkInterfaceEntry.setDescription("Performance information for one particular instance of 'Network Interface' object.")
netInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 1), InstanceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netInstance.setStatus('current')
if mibBuilder.loadTexts: netInstance.setDescription('Instance name.')
netBytesReceivedPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netBytesReceivedPerSec.setStatus('current')
if mibBuilder.loadTexts: netBytesReceivedPerSec.setDescription('Bytes Received/sec is the rate at which bytes are received on the interface, including framing characters.')
netBytesSentPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netBytesSentPerSec.setStatus('current')
if mibBuilder.loadTexts: netBytesSentPerSec.setDescription('Bytes Sent/sec is the rate at which bytes are sent on the interface, including framing characters.')
netBytesTotalPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netBytesTotalPerSec.setStatus('current')
if mibBuilder.loadTexts: netBytesTotalPerSec.setDescription('Bytes Total/sec is the rate at which bytes are sent and received on the interface, including framing characters.')
netCurrentBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netCurrentBandwidth.setStatus('current')
if mibBuilder.loadTexts: netCurrentBandwidth.setDescription("Current Bandwidth is an estimate of the interface's current bandwidth in bits per second (BPS). For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.")
netOutputQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netOutputQueueLength.setStatus('current')
if mibBuilder.loadTexts: netOutputQueueLength.setDescription('Output Queue Length is the length of the output packet queue (in packets). If this is longer than 2, delays are being experienced and the bottleneck should be found and eliminated if possible. Since the requests are queued by NDIS in this implementation, this will always be 0.')
netPacketsOutboundDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsOutboundDiscarded.setStatus('current')
if mibBuilder.loadTexts: netPacketsOutboundDiscarded.setDescription('Packets Outbound Discarded is the number of outbound packets that were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
netPacketsOutboundErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsOutboundErrors.setStatus('current')
if mibBuilder.loadTexts: netPacketsOutboundErrors.setDescription('Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.')
netPacketsReceivedDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsReceivedDiscarded.setStatus('current')
if mibBuilder.loadTexts: netPacketsReceivedDiscarded.setDescription('Packets Received Discarded is the number of inbound packets that were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.')
netPacketsReceivedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsReceivedErrors.setStatus('current')
if mibBuilder.loadTexts: netPacketsReceivedErrors.setDescription('Packets Received Errors is the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
netPacketsReceivedUnknown = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsReceivedUnknown.setStatus('current')
if mibBuilder.loadTexts: netPacketsReceivedUnknown.setDescription('Packets Received Unknown is the number of packets received via the interface that were discarded because of an unknown or unsupported protocol.')
netPacketsReceivedPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsReceivedPerSec.setStatus('current')
if mibBuilder.loadTexts: netPacketsReceivedPerSec.setDescription('Packets Received/sec is the rate at which packets are received on the network interface.')
netPacketsSentPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsSentPerSec.setStatus('current')
if mibBuilder.loadTexts: netPacketsSentPerSec.setDescription('Packets Sent/sec is the rate at which packets are sent on the network interface.')
netPacketsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 3, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: netPacketsPerSec.setStatus('current')
if mibBuilder.loadTexts: netPacketsPerSec.setDescription('Packets/sec is the rate at which packets are sent and received on the network interface.')
objects = ObjectIdentity((1, 3, 6, 1, 4, 1, 9600, 1, 1, 4))
if mibBuilder.loadTexts: objects.setStatus('current')
if mibBuilder.loadTexts: objects.setDescription('The Objects performance object consists of counters that monitor logical objects in the system, such as processes, threads, mutexes, and semaphores. This information can be used to detect the unnecessary consumption of computer resources. Each object requires memory to store basic information about the object.')
objectsProcesses = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 4, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: objectsProcesses.setStatus('current')
if mibBuilder.loadTexts: objectsProcesses.setDescription('Processes is the number of processes in the computer at the time of data collection. Notice that this is an instantaneous count, not an average over the time interval. Each process represents the running of a program.')
objectsThreads = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 4, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: objectsThreads.setStatus('current')
if mibBuilder.loadTexts: objectsThreads.setDescription('Threads is the number of threads in the computer at the time of data collection. Notice that this is an instantaneous count, not an average over the time interval. A thread is the basic executable entity that can execute instructions in a processor.')
processorTable = MibTable((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5), )
if mibBuilder.loadTexts: processorTable.setStatus('current')
if mibBuilder.loadTexts: processorTable.setDescription('The Processor performance object consists of counters that measure aspects of processor activity. The processor is the part of the computer that performs arithmetic and logical computations, initiates operations on peripherals, and runs the threads of processes. A computer can have multiple processors. The processor object represents each processor as an instance of the object.')
processorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1), ).setIndexNames((0, "INFORMANT-STD", "cpuInstance"))
if mibBuilder.loadTexts: processorEntry.setStatus('current')
if mibBuilder.loadTexts: processorEntry.setDescription("Performance information for one particular instance of 'Processor' object.")
cpuInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 1), InstanceName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuInstance.setStatus('current')
if mibBuilder.loadTexts: cpuInstance.setDescription('Instance name.')
cpuPercentDPCTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuPercentDPCTime.setStatus('current')
if mibBuilder.loadTexts: cpuPercentDPCTime.setDescription('% DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. (DPCs are interrupts that run at a lower priority than standard interrupts). % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time. ')
cpuPercentInterruptTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuPercentInterruptTime.setStatus('current')
if mibBuilder.loadTexts: cpuPercentInterruptTime.setDescription('% Interrupt Time is the percentage of time the processor spent receiving and servicing hardware interrupts during the sample interval. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the average busy time as a percentage of the sample time. ')
cpuPercentPrivilegedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuPercentPrivilegedTime.setStatus('current')
if mibBuilder.loadTexts: cpuPercentPrivilegedTime.setDescription('% Privileged Time is the percentage of non-idle processor time spent in privileged mode. (Privileged mode is a processing mode designed for operating system components and hardware-manipulating drivers. It allows direct access to hardware and all memory. The alternative, user mode, is a restricted processing mode designed for applications, environment subsystems, and integral subsystems. The operating system switches application threads to privileged mode to access operating system services). % Privileged Time includes time servicing interrupts and DPCs. A high rate of privileged time might be attributable to a large number of interrupts generated by a failing device. This counter displays the average busy time as a percentage of the sample time. ')
cpuPercentProcessorTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuPercentProcessorTime.setStatus('current')
if mibBuilder.loadTexts: cpuPercentProcessorTime.setDescription('% Processor Time is the percentage of time that the processor is executing a non-Idle thread. This counter was designed as a primary indicator of processor activity. It is calculated by measuring the time that the processor spends executing the thread of the Idle process in each sample interval, and subtracting that value from 100%. (Each processor has an Idle thread which consumes cycles when no other threads are ready to run). It can be viewed as the percentage of the sample interval spent doing useful work. This counter displays the average percentage of busy time observed during the sample interval. It is calculated by monitoring the time the service was inactive, and then subtracting that value from 100%.')
cpuPercentUserTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuPercentUserTime.setStatus('current')
if mibBuilder.loadTexts: cpuPercentUserTime.setDescription('% User Time is the percentage of non-idle processor time spent in user mode. (User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems. The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory. The operating system switches application threads to privileged mode to access operating system services). This counter displays the average busy time as a percentage of the sample time. ')
cpuAPCBypassesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAPCBypassesPerSec.setStatus('current')
if mibBuilder.loadTexts: cpuAPCBypassesPerSec.setDescription('APC Bypasses/sec is the rate at which Kernel APC interrupts were avoided. APC Bypasses/sec is the rate at which kernel APC interrupts were short-circuited. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.')
cpuDPCBypassesPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuDPCBypassesPerSec.setStatus('current')
if mibBuilder.loadTexts: cpuDPCBypassesPerSec.setDescription('DPC Bypasses/sec is the rate at which deferred procedure calls (DPCs) on all processors were avoided. (DPCs are interrupts that run at a lower priority than standard interrupts). This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.')
cpuDPCRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuDPCRate.setStatus('current')
if mibBuilder.loadTexts: cpuDPCRate.setDescription("DPC Rate is the rate at which deferred procedure calls (DPCs) are added to the processor's DPC queue between the timer ticks of the processor clock. (DPCs are interrupts that run at a lower priority than standard interrupts. Each processor has its own DPC queue). This counter measures the rate at which DPCs are added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average. ")
cpuDPCsQueuedPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuDPCsQueuedPerSec.setStatus('current')
if mibBuilder.loadTexts: cpuDPCsQueuedPerSec.setDescription("DPCs Queued/sec is the overall rate at which deferred procedure calls (DPCs) are added to the processor's DPC queue. (DPCs are interrupts that run at a lower priority than standard interrupts. Each processor has its own DPC queue). This counter measures the rate at which DPCs are added to the queue, not the number of DPCs in the queue. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ")
cpuInterruptsPerSec = MibTableColumn((1, 3, 6, 1, 4, 1, 9600, 1, 1, 5, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuInterruptsPerSec.setStatus('current')
if mibBuilder.loadTexts: cpuInterruptsPerSec.setDescription('Interrupts/sec is the average number of hardware interrupts the processor is receiving and servicing in each second. It does not include DPCs, which are counted separately. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval. ')
system = ObjectIdentity((1, 3, 6, 1, 4, 1, 9600, 1, 1, 6))
if mibBuilder.loadTexts: system.setStatus('current')
if mibBuilder.loadTexts: system.setDescription("The System performance object consists of counters that apply to more than one component of the computer. Percentage counters by default do not show values above 100 percent. See 'Overview of Performance Monitoring' in the Windows 2000 Server Resource Kit Server Operations Guide for instructions about changing this default in the registry.")
systemSystemUpTime = MibScalar((1, 3, 6, 1, 4, 1, 9600, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemSystemUpTime.setStatus('current')
if mibBuilder.loadTexts: systemSystemUpTime.setDescription('System Up Time is the elapsed time (in seconds) that the computer has been running since it was last started. This counter displays the difference between the start time and the current time. ')
mibBuilder.exportSymbols("INFORMANT-STD", memoryAvailableBytes=memoryAvailableBytes, memorySystemCodeTotalMBytes=memorySystemCodeTotalMBytes, memoryPagesOutputPerSec=memoryPagesOutputPerSec, cpuInstance=cpuInstance, memorySystemDriverResidentMBytes=memorySystemDriverResidentMBytes, netInstance=netInstance, memoryCacheBytesPeak=memoryCacheBytesPeak, memoryCommittedBytes=memoryCommittedBytes, lDiskFreeMegabytes=lDiskFreeMegabytes, memoryAvailableMBytes=memoryAvailableMBytes, PYSNMP_MODULE_ID=standard, logicalDiskTable=logicalDiskTable, lDiskPercentDiskTime=lDiskPercentDiskTime, netCurrentBandwidth=netCurrentBandwidth, netPacketsReceivedDiscarded=netPacketsReceivedDiscarded, memoryPoolPagedResidentBytes=memoryPoolPagedResidentBytes, memorySystemCacheResidentBytes=memorySystemCacheResidentBytes, objects=objects, memoryCacheKBytes=memoryCacheKBytes, system=system, memoryPagesInputPerSec=memoryPagesInputPerSec, memoryPoolPagedBytes=memoryPoolPagedBytes, memoryPoolNonpagedKBytes=memoryPoolNonpagedKBytes, memoryPoolNonpagedMBytes=memoryPoolNonpagedMBytes, netBytesSentPerSec=netBytesSentPerSec, memoryPageFaultsPerSec=memoryPageFaultsPerSec, lDiskDiskTransfersPerSec=lDiskDiskTransfersPerSec, memoryPagesPerSec=memoryPagesPerSec, memorySystemCodeTotalKBytes=memorySystemCodeTotalKBytes, processorEntry=processorEntry, memoryPoolNonpagedBytes=memoryPoolNonpagedBytes, memoryCacheMBytes=memoryCacheMBytes, memorySystemCacheResidentKBytes=memorySystemCacheResidentKBytes, lDiskDiskBytesPerSec=lDiskDiskBytesPerSec, cpuPercentPrivilegedTime=cpuPercentPrivilegedTime, memorySystemCacheResidentMBytes=memorySystemCacheResidentMBytes, lDiskDiskWriteBytesPerSec=lDiskDiskWriteBytesPerSec, lDiskPercentDiskReadTime=lDiskPercentDiskReadTime, memorySystemDriverResidentBytes=memorySystemDriverResidentBytes, memoryPoolPagedResidentMBytes=memoryPoolPagedResidentMBytes, memorySystemDriverTotalKBytes=memorySystemDriverTotalKBytes, systemSystemUpTime=systemSystemUpTime, memorySystemDriverTotalMBytes=memorySystemDriverTotalMBytes, lDiskDiskWritesPerSec=lDiskDiskWritesPerSec, netPacketsOutboundErrors=netPacketsOutboundErrors, objectsProcesses=objectsProcesses, cpuPercentDPCTime=cpuPercentDPCTime, memoryPoolPagedResidentKBytes=memoryPoolPagedResidentKBytes, lDiskAvgDiskSecPerTransfer=lDiskAvgDiskSecPerTransfer, memoryCommittedKBytes=memoryCommittedKBytes, lDiskDiskReadsPerSec=lDiskDiskReadsPerSec, memorySystemDriverTotalBytes=memorySystemDriverTotalBytes, lDiskInstance=lDiskInstance, memorySystemCodeTotalBytes=memorySystemCodeTotalBytes, lDiskPercentIdleTime=lDiskPercentIdleTime, memoryCacheKBytesPeak=memoryCacheKBytesPeak, memoryPoolPagedMBytes=memoryPoolPagedMBytes, networkInterfaceEntry=networkInterfaceEntry, objectsThreads=objectsThreads, processorTable=processorTable, memoryCommittedMBytes=memoryCommittedMBytes, lDiskAvgDiskReadQueueLength=lDiskAvgDiskReadQueueLength, lDiskAvgDiskSecPerWrite=lDiskAvgDiskSecPerWrite, cpuPercentUserTime=cpuPercentUserTime, netPacketsReceivedUnknown=netPacketsReceivedUnknown, memoryCacheBytes=memoryCacheBytes, memorySystemCodeResidentMBytes=memorySystemCodeResidentMBytes, memorySystemDriverResidentKBytes=memorySystemDriverResidentKBytes, lDiskPercentFreeSpace=lDiskPercentFreeSpace, cpuDPCsQueuedPerSec=cpuDPCsQueuedPerSec, cpuAPCBypassesPerSec=cpuAPCBypassesPerSec, netPacketsOutboundDiscarded=netPacketsOutboundDiscarded, cpuDPCBypassesPerSec=cpuDPCBypassesPerSec, memoryAvailableKBytes=memoryAvailableKBytes, lDiskSplitIOPerSec=lDiskSplitIOPerSec, netPacketsSentPerSec=netPacketsSentPerSec, cpuPercentInterruptTime=cpuPercentInterruptTime, netPacketsPerSec=netPacketsPerSec, netPacketsReceivedErrors=netPacketsReceivedErrors, netBytesTotalPerSec=netBytesTotalPerSec, memoryPoolPagedKBytes=memoryPoolPagedKBytes, netBytesReceivedPerSec=netBytesReceivedPerSec, logicalDiskEntry=logicalDiskEntry, memorySystemCodeResidentKBytes=memorySystemCodeResidentKBytes, networkInterfaceTable=networkInterfaceTable, cpuDPCRate=cpuDPCRate, netOutputQueueLength=netOutputQueueLength, cpuInterruptsPerSec=cpuInterruptsPerSec, lDiskCurrentDiskQueueLength=lDiskCurrentDiskQueueLength, lDiskPercentDiskWriteTime=lDiskPercentDiskWriteTime, standard=standard, lDiskAvgDiskQueueLength=lDiskAvgDiskQueueLength, lDiskAvgDiskSecPerRead=lDiskAvgDiskSecPerRead, lDiskDiskReadBytesPerSec=lDiskDiskReadBytesPerSec, netPacketsReceivedPerSec=netPacketsReceivedPerSec, lDiskAvgDiskWriteQueueLength=lDiskAvgDiskWriteQueueLength, memoryCacheMBytesPeak=memoryCacheMBytesPeak, memorySystemCodeResidentBytes=memorySystemCodeResidentBytes, memory=memory, cpuPercentProcessorTime=cpuPercentProcessorTime)

#
# PySNMP MIB module GDCSC616-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCSC616-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Counter64, ObjectIdentity, Unsigned32, iso, ModuleIdentity, TimeTicks, enterprises, Counter32, Bits, IpAddress, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Counter64", "ObjectIdentity", "Unsigned32", "iso", "ModuleIdentity", "TimeTicks", "enterprises", "Counter32", "Bits", "IpAddress", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
bql = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10))
bqlMIBVersion = MibScalar((1, 3, 6, 1, 4, 1, 498, 10, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlMIBVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bqlMIBVersion.setDescription('The version number of the MIB, to allow products to know which MIB is being supported. The version number will be x.yzT where x is a major revision (1-9), y is a minor revision(0-9), z is a typo revision (0-9) and T indicates the MIB is still a test revision(A-Z). When a release is complete no T should exist.')
bqlWhatAreYouTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 2), )
if mibBuilder.loadTexts: bqlWhatAreYouTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlWhatAreYouTable.setDescription('The GDC SC616, DC610, DC612, GT 128 What Are You Table.')
bqlWhatAreYouEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 2, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlWhatAreYouIndex"))
if mibBuilder.loadTexts: bqlWhatAreYouEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlWhatAreYouEntry.setDescription('An entry in the GDC SC616 What Are You table.')
bqlWhatAreYouIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlWhatAreYouIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlWhatAreYouIndex.setDescription('This object is the identifier of the SC616 What Are You table.')
bqlBaseCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4, 5, 9, 10))).clone(namedValues=NamedValues(("dc610", 2), ("dc612", 4), ("sc616", 5), ("gt128", 9), ("gt128NZ", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlBaseCardType.setStatus('mandatory')
if mibBuilder.loadTexts: bqlBaseCardType.setDescription('This function returns the value the Base Card Type.')
bqlOptionCard = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlOptionCard.setStatus('mandatory')
if mibBuilder.loadTexts: bqlOptionCard.setDescription('This indicates whether the option card is installed or not on the DC610 or DC612.')
bqlDTE2CardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 7))).clone(namedValues=NamedValues(("eia530", 1), ("x21", 2), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDTE2CardType.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE2CardType.setDescription('This object is the DTE channel 2 plug-in card type on the DC610 or DC612.')
bqlDTE1CardType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 7))).clone(namedValues=NamedValues(("eia530", 1), ("x21", 2), ("v35", 3), ("none", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDTE1CardType.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE1CardType.setDescription('This object is the DTE channel 1 plug-in card type on the DC610 or DC612 or GT 128.')
bqlCodeRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCodeRev.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCodeRev.setDescription('This function returns the firmware code level. Example A- ,B- ')
bqlAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlAlarmStatus.setDescription('The current alarms of the unit without the alarm masks.')
bqlConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 3), )
if mibBuilder.loadTexts: bqlConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfigTable.setDescription('The GDC SC616, DC610, DC612, GT 128 2B1Q configuration table.')
bqlConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 3, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlConfigIndex"), (0, "GDCSC616-MIB", "bqlConfigChnlIndex"))
if mibBuilder.loadTexts: bqlConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfigEntry.setDescription('A listing of GDC 2B1Q SC616 options.')
bqlConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfigIndex.setDescription('A unique index for the Configuration Table.')
bqlConfigChnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("channel1", 1), ("channel2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlConfigChnlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfigChnlIndex.setDescription('A unique channel index for the Configuration Table.')
bqlTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pattern2047", 1), ("pattern511", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlTestPattern.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTestPattern.setDescription('Object to select loop and channel test pattern for SC616, DC610, DC612.')
bqlRLTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noTimeout", 1), ("timeoutAfter10Min", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRLTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRLTimeout.setDescription('Object to select loop and channel remote loop time out for DC610 and DC612 only.')
bqlRespRL = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRespRL.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRespRL.setDescription('Object to select loop and channel remote loop response for DC610 and DC612 only.')
bqlRLType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v54", 1), ("pn127", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRLType.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRLType.setDescription('Object to select loop and channel remote loop type for DC610 and DC612 only.')
bqlBilateralRL = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlBilateralRL.setStatus('mandatory')
if mibBuilder.loadTexts: bqlBilateralRL.setDescription('Object to select loop and channel bilateral remote loop for DC610 and DC612 only.')
bqlInbandRTSDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlInbandRTSDCD.setStatus('mandatory')
if mibBuilder.loadTexts: bqlInbandRTSDCD.setDescription('Object to select loop and channel in-band RTS/DCD for DC610 and DC612 only.')
bqlRTS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("force", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRTS.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRTS.setDescription('Object to select loop and channel RTS for DC610 and DC612 only.')
bqlRTSCTSDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noDelay", 1), ("delay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRTSCTSDelay.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRTSCTSDelay.setDescription('Object to select loop and channel RTS/CTS delay for DC610 and DC612 only.')
bqlAntiStream = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAntistream", 1), ("antistream", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlAntiStream.setStatus('mandatory')
if mibBuilder.loadTexts: bqlAntiStream.setDescription('Object to select loop and channel Anti-streaming for DC610 and DC612 only.')
bqlTXDataElasticBufr = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlTXDataElasticBufr.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTXDataElasticBufr.setDescription('Object to select loop and channel transmit data elastic buffer for DC610 and DC612 only.')
bqlRTSCTSDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("ms0", 1), ("ms5", 2), ("ms10", 3), ("ms15", 4), ("ms20", 5), ("ms25", 6), ("ms30", 7), ("ms35", 8), ("ms40", 9), ("ms45", 10), ("ms50", 11), ("ms55", 12), ("ms60", 13), ("ms65", 14), ("ms70", 15), ("ms75", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlRTSCTSDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: bqlRTSCTSDelayTime.setDescription('Object to select loop and channel RTS to CTS delay time for DC610 and DC612 only.')
bqlAntiStreamTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("seconds0", 1), ("seconds5", 2), ("seconds10", 3), ("seconds15", 4), ("seconds20", 5), ("seconds25", 6), ("seconds30", 7), ("seconds35", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlAntiStreamTime.setStatus('mandatory')
if mibBuilder.loadTexts: bqlAntiStreamTime.setDescription('Object to select loop and channel anti-streaming time for DC610 and DC612 only.')
bqlConfig1Table = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 4), )
if mibBuilder.loadTexts: bqlConfig1Table.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig1Table.setDescription('The GDC SC616, DC610, DC612 2B1Q configuration 1 table.')
bqlConfig1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 4, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlConfig1Index"))
if mibBuilder.loadTexts: bqlConfig1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig1Entry.setDescription('A listing of GDC 2B1Q SC616 options.')
bqlConfig1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlConfig1Index.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig1Index.setDescription('A unique index for the Configuration Table.')
bqlFrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlFrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: bqlFrontPanel.setDescription('Object used to enable or disable the units front panel switches.')
bqlSoftHard = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hardmode", 1), ("softmode", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlSoftHard.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSoftHard.setDescription('Object used to read how the unit is configured.')
bqlDteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDteStatus.setDescription('Object used to read the status of the DTE interface.')
bqlConfig2Table = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 5), )
if mibBuilder.loadTexts: bqlConfig2Table.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig2Table.setDescription('The GDC SC616 2B1Q configuration 2 table.')
bqlConfig2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 5, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlConfig2Index"))
if mibBuilder.loadTexts: bqlConfig2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig2Entry.setDescription('A listing of GDC 2B1Q SC616 options.')
bqlConfig2Index = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlConfig2Index.setStatus('mandatory')
if mibBuilder.loadTexts: bqlConfig2Index.setDescription('A unique index for the Configuration Table.')
bqlMasterTXClkSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("xtc1", 1), ("xtc2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlMasterTXClkSrc.setStatus('mandatory')
if mibBuilder.loadTexts: bqlMasterTXClkSrc.setDescription('Object to option the Loop master transmit clock source. This is for the SC616 only.')
bqlDiagnosticTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 6), )
if mibBuilder.loadTexts: bqlDiagnosticTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticTable.setDescription('The GDC SC616 diagnostics table.')
bqlDiagnosticEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 6, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlDiagnosticIndex"), (0, "GDCSC616-MIB", "bqlDiagnosticChnlIndex"))
if mibBuilder.loadTexts: bqlDiagnosticEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticEntry.setDescription('A listing of GDC SC616 diagnostic tests')
bqlDiagnosticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDiagnosticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticIndex.setDescription('A unique index for the Diagnostic Table.')
bqlDiagnosticChnlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("channel1", 1), ("channel2", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDiagnosticChnlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticChnlIndex.setDescription('A unique channel index for the Channel the test will run on.')
bqlDiagnosticTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDiagnosticTest.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticTest.setDescription('This function selects or reads the test. 0 = no test currently operating 1 = remote loopback test 2 = channel loopback test 4 = data loopback test 8 = selftest 16 = line loopback test 32 = terminate test All other values are test combinations such as 9 = selftest and remote loopback.')
bqlDiagnosticLength = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDiagnosticLength.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticLength.setDescription('This function selects the test time length. Where 0 is test indefinitely and 1 to 127 are seconds.')
bqlDiagnosticActive = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notActive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDiagnosticActive.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticActive.setDescription('This function represents the test condition.')
bqlDiagnosticResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDiagnosticResults.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDiagnosticResults.setDescription('This function reads the self test results in bit errors.')
bqlSC616Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7))
bqlAlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1))
bqlNoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 1))
bqlDiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 2))
bqlPowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 3))
bqlLp2B1QOutofSyncAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 4))
bqlLpChn1ElasBufrOverUnderFlowAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 5))
bqlLpChn2ElasBufrOverUnderFlowAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 6))
bqlLpChn1ExtTxClkAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 7))
bqlLpChn2ExtTxClkAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 8))
bqlLpSealingCurrentNoContinuityAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 7, 1, 9))
bqlSC616LEDStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 8), )
if mibBuilder.loadTexts: bqlSC616LEDStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSC616LEDStatusTable.setDescription('The GDC SC616 LED Status Table.')
bqlSC616LEDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 8, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlSC616LEDIndex"))
if mibBuilder.loadTexts: bqlSC616LEDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSC616LEDEntry.setDescription('An entry in the GDC SC616 LED Status table.')
bqlSC616LEDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlSC616LEDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSC616LEDIndex.setDescription('This object is the index of the SC616 LED Status table.')
bqlSC616LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 8, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlSC616LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSC616LEDStatus.setDescription('The GDC SC616 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - alarm on 1.4 - loop 1 line loopback 1.3 - loop 1 channel 1 send data transitions 1.2 - loop 1 channel 1 receive data transitions 1.1 - loop 1 channel 2 send data transitions 1.0 - loop 1 channel 2 receive data transitions 2.7 - not used 2.6 - not used 2.5 - not used 2.4 - loop 2 line loopback 2.3 - loop 2 channel 1 send data transitions 2.2 - loop 2 channel 1 receive data transitions 2.1 - loop 2 channel 2 send data transitions 2.0 - loop 2 channel 2 receive data transitions 3.7 - not used 3.6 - not used 3.5 - not used 3.4 - loop 3 line loopback 3.3 - loop 3 channel 1 send data transitions 3.2 - loop 3 channel 1 receive data transitions 3.1 - loop 3 channel 2 send data transitions 3.0 - loop 3 channel 2 receive data transitions')
bqlDC610Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9))
bqlDC610AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9, 1))
bqlDC610PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9, 1, 1))
bqlDC610Chnl1DTRAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9, 1, 2))
bqlDC610NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9, 1, 3))
bqlDC610DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 9, 1, 4))
bqlDC610LEDStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 10), )
if mibBuilder.loadTexts: bqlDC610LEDStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDStatusTable.setDescription('The GDC DC610 LED Status Table.')
bqlDC610LEDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 10, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlDC610LEDIndex"))
if mibBuilder.loadTexts: bqlDC610LEDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDEntry.setDescription('An entry in the GDC DC610 LED Status table.')
bqlDC610LEDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 10, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC610LEDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDIndex.setDescription('This object is the index of the DC610 LED Status table.')
bqlDC610LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC610LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDStatus.setDescription('The GDC DC610 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - sync 1.4 - request to send 1.3 - clear to send 1.2 - carrier on 1.1 - send data transitions 1.0 - receive data transitions')
bqlDC612Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11))
bqlDC612AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1))
bqlDC612PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1, 1))
bqlDC612Chnl1DTRAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1, 2))
bqlDC612Chnl2DTRAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1, 3))
bqlDC612NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1, 4))
bqlDC612DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 11, 1, 5))
bqlDC612LEDStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 12), )
if mibBuilder.loadTexts: bqlDC612LEDStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC612LEDStatusTable.setDescription('The GDC DC612 LED Status Table.')
bqlDC612LEDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 12, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlDC612LEDIndex"))
if mibBuilder.loadTexts: bqlDC612LEDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC612LEDEntry.setDescription('An entry in the GDC DC612 LED Status table.')
bqlDC612LEDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 12, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC612LEDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC612LEDIndex.setDescription('This object is the index of the DC612 LED Status table.')
bqlDC612LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 12, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC612LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC612LEDStatus.setDescription('The GDC DC612 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - not used 1.5 - not used 1.4 - not used 1.3 - not used 1.2 - not used 1.1 - channel 1 selected for front panel pushbutton operation 1.0 - channel 2 selected for front panel pushbutton operation 2.7 - not used 2.6 - channel 1 test mode 2.5 - channel 1 sync 2.4 - channel 1 request to send 2.3 - channel 1 clear to send 2.2 - channel 1 carrier on 2.1 - channel 1 send data transitions 2.0 - channel 1 receive data transitions 3.7 - not used 3.6 - channel 2 test mode 3.5 - channel 2 sync 3.4 - channel 2 request to send 3.3 - channel 2 clear to send 3.2 - channel 2 carrier on 3.1 - channel 2 send data transitions 3.0 - channel 2 receive data transitionscd')
bqlControlTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 13), )
if mibBuilder.loadTexts: bqlControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlControlTable.setDescription('The GDC SC616 Control Table.')
bqlControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 13, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlControlIndex"))
if mibBuilder.loadTexts: bqlControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlControlEntry.setDescription('An entry in the GDC SC616 Control table.')
bqlControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 13, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlControlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlControlIndex.setDescription('This object is the identifier of the SC616 Control table.')
bqlSoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlSoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: bqlSoftReset.setDescription('Forces a soft reset on the network element. The reset selection is write only. The normal selection is read only.')
bqlEraseConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("erase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlEraseConfig.setStatus('mandatory')
if mibBuilder.loadTexts: bqlEraseConfig.setDescription('Forces an erase of the stored configuration in the network element. The erase selection is write only. The normal selection is read only.')
bqlCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 14), )
if mibBuilder.loadTexts: bqlCurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentTable.setDescription('The SC616 Current table.')
bqlCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 14, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlCurrentIndex"))
if mibBuilder.loadTexts: bqlCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentEntry.setDescription('An entry in the SC616 Current table.')
bqlCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentIndex.setDescription('The index value which uniquely identifies the SC616 DC610 or DC612 interface to which this entry is applicable.')
bqlCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentESs.setDescription('The number of Errored Seconds, encountered by an ISDN interface in the current 15 minute interval. This is defined as a second with at least one CRC error event or one or more out of frames (OOF).')
bqlCurrentBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentBESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by an ISDN interface in the current 15 minute interval. This is defined as a second with more than one but less than 640 CRC error events.')
bqlCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentSESs.setDescription('The number of Severely Errored Seconds encoun- tered by an ISDN interface in the current 15 minute interval. This is defined as a second with 640 or more CRC error events or one or more out of frames (OOF).')
bqlCurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentUASs.setDescription('The number of Unavailable Seconds encountered by an ISDN interface in the current 15 minute interval. This is a count of one-second intervals during which service is not available.')
bqlCurrentStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlCurrentStats.setStatus('mandatory')
if mibBuilder.loadTexts: bqlCurrentStats.setDescription('The number of ES, BES, ESE and UAS encountered by an ISDN interface in the current 15 minute interval. This is a count of one-second intervals during which service is not available.')
bqlIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 15), )
if mibBuilder.loadTexts: bqlIntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalTable.setDescription('The SC616 Interval table.')
bqlIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 15, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlIntervalIndex"), (0, "GDCSC616-MIB", "bqlIntervalNumber"))
if mibBuilder.loadTexts: bqlIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalEntry.setDescription('An entry in the SC616 Interval table.')
bqlIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalIndex.setDescription('The index value which uniquely identifies the ISDN interface to which this entry is applicable.')
bqlIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the least recently completed 15 minute inter- val (assuming that all 96 intervals are valid).')
bqlIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalESs.setDescription('The number of Errored Seconds encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals. This is defined as a second with at least one CRC error event or one or more out of frames (OOF).')
bqlIntervalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by an ISDN interface in one of the previous 96, individual 15 minute, intervals. This is defined as a second with more than one but less than 640 CRC error events.')
bqlIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by an ISDN interface in one of the previous 96, individual 15 minute, intervals. This is defined as a second with 640 or more CRC error events or one or more out of frames (OOF).')
bqlIntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalUASs.setDescription('The number of Unavailable Seconds encountered by an ISDN interface in one of the previous 96, individual 15 minute, intervals. This is a count of one-second intervals during which service is not available.')
bqlIntervalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalStats.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalStats.setDescription('The number of ES, BES, SES, and UAS encountered by an ISDN interface in one of the previous 96, individual 15 minute, intervals. This is a count of one-second intervals during which service is not available.')
bqlTotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 16), )
if mibBuilder.loadTexts: bqlTotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalTable.setDescription('The SC616 Total table. 24 hour interval.')
bqlTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 16, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlTotalIndex"))
if mibBuilder.loadTexts: bqlTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalEntry.setDescription('An entry in the SC616 Total table.')
bqlTotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalIndex.setDescription('The index value which uniquely identifies the ISDN interface to which this entry is applicable.')
bqlTotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalESs.setDescription('The number of Errored Seconds encountered by an ISDN interface in the previous 24 hour interval. This is defined as a second with at least one CRC error event or one or more out of frames (OOF).')
bqlTotalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by an ISDN interface in the previous 24 hour interval. This is defined as a second with more than one but less than 640 CRC error events.')
bqlTotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by an ISDN interface in the previous 24 hour interval. This is defined as a second with 640 or more CRC error events or one or more out of frames (OOF).')
bqlTotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalUASs.setDescription('The number of Unavailable Seconds encountered by an ISDN interface in the previous 24 hour interval. This is a count of one-second intervals during which service is not available.')
bqlTotalStats = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 16, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlTotalStats.setStatus('mandatory')
if mibBuilder.loadTexts: bqlTotalStats.setDescription('The number of ES, BES, SES and UAS encountered by an ISDN interface in the previous 24 hour interval. This is a count of one-second intervals during which service is not available.')
bqlDTERateTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 17), )
if mibBuilder.loadTexts: bqlDTERateTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTERateTable.setDescription('The DC610 DC612 DTE rate table.')
bqlDTEEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 17, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlDTEIndex"))
if mibBuilder.loadTexts: bqlDTEEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTEEntry.setDescription('An entry in the DC610 DC612 table.')
bqlDTEIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 17, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDTEIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTEIndex.setDescription('The index value which uniquely identifies the DC610 DC612 interface to which this entry is applicable.')
bqlDTE2Mapped = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("toChannel2", 1), ("toChannel1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDTE2Mapped.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE2Mapped.setDescription('Forces a DC612 to map DTE channel 2 into channel 2 or channel 1.')
bqlDTE2DataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("kBps2400", 1), ("kBps4800", 2), ("kBps9600", 3), ("kBps19200", 4), ("kBps38400", 5), ("kBps48000", 6), ("kBps56000", 7), ("kBps57600", 8), ("kBps64000", 9), ("kBps128000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDTE2DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE2DataRate.setDescription('Forces a DC612 DTE channel 2 to a K bit per second rate.')
bqlDTE1Mapped = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 17, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("toChannel1", 1), ("toChannel2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDTE1Mapped.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE1Mapped.setDescription('Forces a DC610 or DC612 to map DTE channel 1 into channel 1 or channel 2.')
bqlDTE1DataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 17, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("kBps2400", 1), ("kBps4800", 2), ("kBps9600", 3), ("kBps19200", 4), ("kBps38400", 5), ("kBps48000", 6), ("kBps56000", 7), ("kBps57600", 8), ("kBps64000", 9), ("kBps128000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlDTE1DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDTE1DataRate.setDescription('Forces a DC610 or DC612 DTE channel 1 to a K bit per second rate.')
bqlIntervalMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 18), )
if mibBuilder.loadTexts: bqlIntervalMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalMaintenanceTable.setDescription('The SC616, DC610, DC612 Loop Interval Maintenance table. ')
bqlIntervalMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 18, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlIntervalMaintenanceIndex"))
if mibBuilder.loadTexts: bqlIntervalMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalMaintenanceEntry.setDescription('The SC616, DC610, DC612 Interval Maintenance table entry. ')
bqlIntervalMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 18, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlIntervalMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlIntervalMaintenanceIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a Loop interface.')
bqlResetIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bqlResetIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: bqlResetIntervals.setDescription(' This variable is used to reset Loop performance intervals. When it is set to reset, the Loop performance tables are reset to zero.')
bqlNumberofValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 18, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlNumberofValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: bqlNumberofValidIntervals.setDescription(' This variable is used to read the number of intervals collected. Each interval is an increment of 15 minutes.')
bqlDC610LEDStatusNZTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 19), )
if mibBuilder.loadTexts: bqlDC610LEDStatusNZTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDStatusNZTable.setDescription('The GDC DC610NZ LED Status Table.')
bqlDC610LEDNZEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 19, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlDC610LEDNZIndex"))
if mibBuilder.loadTexts: bqlDC610LEDNZEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDNZEntry.setDescription('An entry in the GDC DC610NZ LED Status table.')
bqlDC610LEDNZIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 19, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC610LEDNZIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDNZIndex.setDescription('This object is the index of the DC610 LED Status table.')
bqlDC610LEDNZStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 19, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlDC610LEDNZStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlDC610LEDNZStatus.setDescription('The GDC DC610NZ front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - 128K (sync ) 1.4 - request to send 1.3 - clear to send 1.2 - network available (carrier on) 1.1 - send data transitions 1.0 - receive data transitions')
bqlGT128Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20))
bqlGT128AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20, 1))
bqlGT128NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20, 1, 1))
bqlGT128DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20, 1, 2))
bqlGT128PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20, 1, 3))
bqlGT128Chnl1DTRAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 20, 1, 4))
bqlGT128LEDStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 21), )
if mibBuilder.loadTexts: bqlGT128LEDStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDStatusTable.setDescription('The GDC GT 128 LED Status Table.')
bqlGT128LEDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 21, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlGT128LEDIndex"))
if mibBuilder.loadTexts: bqlGT128LEDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDEntry.setDescription('An entry in the GDC GT128 LED Status table.')
bqlGT128LEDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 21, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlGT128LEDIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDIndex.setDescription('This object is the index of the GT 128 LED Status table.')
bqlGT128LEDStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 21, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlGT128LEDStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDStatus.setDescription('The GDC GT128 front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - sync 1.4 - request to send 1.3 - clear to send 1.2 - carrier on 1.1 - send data transitions 1.0 - receive data transitions 2.6 - fu 2.5 - fu 2.4 - fu 2.3 - fu 2.2 - remote loopback ON 2.1 - selftest ON 2.0 - line loopback ON')
bqlGT128NZAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22))
bqlGT128NZAlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22, 1))
bqlGT128NZNoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22, 1, 1))
bqlGT128NZDiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22, 1, 2))
bqlGT128NZPowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22, 1, 3))
bqlGT128NZChnl1DTRAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 10, 22, 1, 4))
bqlGT128LEDNZStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 10, 23), )
if mibBuilder.loadTexts: bqlGT128LEDNZStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDNZStatusTable.setDescription('The GDC GT 128 NZ LED Status Table.')
bqlGT128LEDNZEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 10, 23, 1), ).setIndexNames((0, "GDCSC616-MIB", "bqlGT128LEDNZIndex"))
if mibBuilder.loadTexts: bqlGT128LEDNZEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDNZEntry.setDescription('An entry in the GDC GT128 NZ LED Status table.')
bqlGT128LEDNZIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 23, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlGT128LEDNZIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDNZIndex.setDescription('This object is the index of the GT 128 NZ LED Status table.')
bqlGT128LEDNZStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 10, 23, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bqlGT128LEDNZStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bqlGT128LEDNZStatus.setDescription('The GDC GT128 NZ front panel LED Status. A value of 1 means on, 0 is off. byte 1 bit 7 (1.7) - not used 1.6 - test mode 1.5 - 128K (sync) 1.4 - request to send 1.3 - clear to send 1.2 - network available (carrier on) 1.1 - send data transitions 1.0 - receive data transitions 2.6 - fu 2.5 - fu 2.4 - fu 2.3 - fu 2.2 - remote loopback ON 2.1 - selftest ON 2.0 - line loopback ON')
mibBuilder.exportSymbols("GDCSC616-MIB", bqlIntervalBESs=bqlIntervalBESs, bqlTestPattern=bqlTestPattern, bqlFrontPanel=bqlFrontPanel, bqlLpChn1ElasBufrOverUnderFlowAlm=bqlLpChn1ElasBufrOverUnderFlowAlm, bqlConfig2Index=bqlConfig2Index, bqlDC612AlarmData=bqlDC612AlarmData, bqlDteStatus=bqlDteStatus, bqlLp2B1QOutofSyncAlm=bqlLp2B1QOutofSyncAlm, bqlDC610LEDNZIndex=bqlDC610LEDNZIndex, bqlLpChn2ExtTxClkAlm=bqlLpChn2ExtTxClkAlm, bqlIntervalStats=bqlIntervalStats, bqlGT128LEDNZStatus=bqlGT128LEDNZStatus, bqlInbandRTSDCD=bqlInbandRTSDCD, bqlDTE1CardType=bqlDTE1CardType, bqlDC610PowerUpAlm=bqlDC610PowerUpAlm, bqlLpSealingCurrentNoContinuityAlm=bqlLpSealingCurrentNoContinuityAlm, bqlSC616LEDIndex=bqlSC616LEDIndex, bqlRespRL=bqlRespRL, bqlOptionCard=bqlOptionCard, bqlDiagnosticEntry=bqlDiagnosticEntry, bqlGT128LEDStatus=bqlGT128LEDStatus, bqlLpChn1ExtTxClkAlm=bqlLpChn1ExtTxClkAlm, bqlGT128NZAlarmData=bqlGT128NZAlarmData, bqlDC610Chnl1DTRAlm=bqlDC610Chnl1DTRAlm, bqlGT128NZChnl1DTRAlm=bqlGT128NZChnl1DTRAlm, bqlDC612DiagRxErrAlm=bqlDC612DiagRxErrAlm, bqlGT128NZAlarm=bqlGT128NZAlarm, bqlIntervalTable=bqlIntervalTable, bqlSoftReset=bqlSoftReset, bqlGT128LEDIndex=bqlGT128LEDIndex, bqlDC610DiagRxErrAlm=bqlDC610DiagRxErrAlm, bqlCurrentUASs=bqlCurrentUASs, bqlTotalStats=bqlTotalStats, bqlDC612Alarm=bqlDC612Alarm, bqlDC612Chnl1DTRAlm=bqlDC612Chnl1DTRAlm, bqlDC610Alarm=bqlDC610Alarm, bqlSC616LEDStatus=bqlSC616LEDStatus, bqlAntiStream=bqlAntiStream, bqlDTE2DataRate=bqlDTE2DataRate, bqlGT128NZPowerUpAlm=bqlGT128NZPowerUpAlm, bqlConfig1Index=bqlConfig1Index, bqlIntervalNumber=bqlIntervalNumber, bqlIntervalMaintenanceEntry=bqlIntervalMaintenanceEntry, bqlConfigTable=bqlConfigTable, bqlConfig2Entry=bqlConfig2Entry, bqlResetIntervals=bqlResetIntervals, bqlLpChn2ElasBufrOverUnderFlowAlm=bqlLpChn2ElasBufrOverUnderFlowAlm, bqlRLType=bqlRLType, bqlSC616Alarm=bqlSC616Alarm, bqlDTE1DataRate=bqlDTE1DataRate, bqlDC610LEDStatusTable=bqlDC610LEDStatusTable, bqlGT128LEDEntry=bqlGT128LEDEntry, bqlDC612NoResponseAlm=bqlDC612NoResponseAlm, bqlTotalIndex=bqlTotalIndex, bqlDC612LEDStatusTable=bqlDC612LEDStatusTable, bqlConfigIndex=bqlConfigIndex, bqlDiagnosticChnlIndex=bqlDiagnosticChnlIndex, bqlCurrentStats=bqlCurrentStats, bqlSoftHard=bqlSoftHard, bqlEraseConfig=bqlEraseConfig, bql=bql, bqlDTEIndex=bqlDTEIndex, bqlNumberofValidIntervals=bqlNumberofValidIntervals, bqlDC610LEDStatusNZTable=bqlDC610LEDStatusNZTable, bqlDC610LEDStatus=bqlDC610LEDStatus, bqlIntervalSESs=bqlIntervalSESs, bqlDiagnosticResults=bqlDiagnosticResults, bqlDiagnosticActive=bqlDiagnosticActive, bqlPowerUpAlm=bqlPowerUpAlm, bqlBaseCardType=bqlBaseCardType, bqlDC612LEDEntry=bqlDC612LEDEntry, bqlTotalUASs=bqlTotalUASs, bqlTotalESs=bqlTotalESs, bqlDTERateTable=bqlDTERateTable, bqlTotalEntry=bqlTotalEntry, bqlWhatAreYouEntry=bqlWhatAreYouEntry, bqlCurrentSESs=bqlCurrentSESs, bqlGT128LEDNZStatusTable=bqlGT128LEDNZStatusTable, bqlNoResponseAlm=bqlNoResponseAlm, bqlDC612PowerUpAlm=bqlDC612PowerUpAlm, bqlDTE2CardType=bqlDTE2CardType, bqlCodeRev=bqlCodeRev, bqlCurrentTable=bqlCurrentTable, bqlGT128PowerUpAlm=bqlGT128PowerUpAlm, bqlAlarmData=bqlAlarmData, bqlDTEEntry=bqlDTEEntry, bqlDC610LEDNZEntry=bqlDC610LEDNZEntry, bqlCurrentIndex=bqlCurrentIndex, bqlAlarmStatus=bqlAlarmStatus, bqlSC616LEDEntry=bqlSC616LEDEntry, bqlIntervalIndex=bqlIntervalIndex, bqlDiagnosticTest=bqlDiagnosticTest, bqlIntervalESs=bqlIntervalESs, bqlIntervalMaintenanceTable=bqlIntervalMaintenanceTable, bqlWhatAreYouIndex=bqlWhatAreYouIndex, bqlGT128AlarmData=bqlGT128AlarmData, bqlGT128LEDNZIndex=bqlGT128LEDNZIndex, bqlDC610LEDNZStatus=bqlDC610LEDNZStatus, bqlMIBVersion=bqlMIBVersion, bqlGT128DiagRxErrAlm=bqlGT128DiagRxErrAlm, bqlAntiStreamTime=bqlAntiStreamTime, bqlControlTable=bqlControlTable, bqlIntervalEntry=bqlIntervalEntry, gdc=gdc, bqlTXDataElasticBufr=bqlTXDataElasticBufr, bqlDC610NoResponseAlm=bqlDC610NoResponseAlm, bqlDiagnosticLength=bqlDiagnosticLength, bqlDC610AlarmData=bqlDC610AlarmData, bqlTotalTable=bqlTotalTable, bqlTotalSESs=bqlTotalSESs, bqlIntervalMaintenanceIndex=bqlIntervalMaintenanceIndex, bqlRTSCTSDelay=bqlRTSCTSDelay, bqlSC616LEDStatusTable=bqlSC616LEDStatusTable, bqlDC612LEDStatus=bqlDC612LEDStatus, bqlMasterTXClkSrc=bqlMasterTXClkSrc, bqlDiagnosticIndex=bqlDiagnosticIndex, bqlDiagnosticTable=bqlDiagnosticTable, bqlConfig1Entry=bqlConfig1Entry, bqlCurrentBESs=bqlCurrentBESs, bqlConfigChnlIndex=bqlConfigChnlIndex, bqlDiagRxErrAlm=bqlDiagRxErrAlm, bqlDC612LEDIndex=bqlDC612LEDIndex, bqlIntervalUASs=bqlIntervalUASs, bqlCurrentEntry=bqlCurrentEntry, bqlTotalBESs=bqlTotalBESs, bqlGT128NZDiagRxErrAlm=bqlGT128NZDiagRxErrAlm, bqlConfig2Table=bqlConfig2Table, bqlGT128NoResponseAlm=bqlGT128NoResponseAlm, bqlBilateralRL=bqlBilateralRL, bqlControlEntry=bqlControlEntry, bqlCurrentESs=bqlCurrentESs, bqlGT128Chnl1DTRAlm=bqlGT128Chnl1DTRAlm, bqlRTSCTSDelayTime=bqlRTSCTSDelayTime, bqlConfigEntry=bqlConfigEntry, bqlGT128LEDStatusTable=bqlGT128LEDStatusTable, bqlGT128LEDNZEntry=bqlGT128LEDNZEntry, bqlControlIndex=bqlControlIndex, bqlWhatAreYouTable=bqlWhatAreYouTable, bqlDTE2Mapped=bqlDTE2Mapped, bqlConfig1Table=bqlConfig1Table, bqlRLTimeout=bqlRLTimeout, bqlRTS=bqlRTS, bqlDC612Chnl2DTRAlm=bqlDC612Chnl2DTRAlm, bqlGT128Alarm=bqlGT128Alarm, bqlDC610LEDEntry=bqlDC610LEDEntry, bqlDC610LEDIndex=bqlDC610LEDIndex, bqlDTE1Mapped=bqlDTE1Mapped, bqlGT128NZNoResponseAlm=bqlGT128NZNoResponseAlm)

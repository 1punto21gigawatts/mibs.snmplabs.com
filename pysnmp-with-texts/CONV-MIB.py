#
# PySNMP MIB module CONV-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CONV-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:26:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
Alias, cxConv = mibBuilder.importSymbols("CXProduct-SMI", "Alias", "cxConv")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Gauge32, Integer32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, MibIdentifier, NotificationType, Unsigned32, ObjectIdentity, iso, Bits, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Gauge32", "Integer32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "MibIdentifier", "NotificationType", "Unsigned32", "ObjectIdentity", "iso", "Bits", "IpAddress")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cxConvTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1), )
if mibBuilder.loadTexts: cxConvTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvTable.setDescription("Provides configuration information and attributes of each of the module's convergence ports. The table contains two rows of default entries; some of these entries can be modified. If required, you can add additional entries.")
cxConvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1), ).setIndexNames((0, "CONV-MIB", "cxConvPort"))
if mibBuilder.loadTexts: cxConvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvEntry.setDescription('')
cxConvPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxConvPort.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvPort.setDescription('Identifies the number of a specific convergence port. This number acts as an index to this and the cxFwkCircuitTable. Range of Values: 1 - 32 Default Value: None Note: The system defines two default entries; their respective values are 1 and 2.')
cxConvPortAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 2), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxConvPortAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvPortAlias.setDescription('Determines a textual name (alias), assigned by the network administrator, which identifies a particular convergence port. The alias is used by the routing and bridging protocols when they bind to this port. Range of Values: 0-16 alphanumeric characters. (Note that the first character must be a letter, and spaces are not allowed). Default Value: none Note: The system defines two default entries; their respective values are CNV_PORT1 and CNV_PORT2. Configuration Changed: administrative')
cxConvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxConvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvRowStatus.setDescription('Determines the status of the objects in a table row. Options: valid (1): values are enabled invalid (2) row is flagged, after next reset values will be disabled and the row will be deleted from the table). Default Value: valid Configuration Changed: administrative')
cxConvIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxConvIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvIfIndex.setDescription('Identifies the table row that contains configuration or monitoring objects for a specific type of physical interface. Range of Values: 1 to the number of entries in the interface table. Default Value: None')
cxConvState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxConvState.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvState.setDescription('Determines whether the convergence port is active (on). When the object is set to on, transmission can begin over the port; when the object is set to off transmission will be stopped. Options: on (1) off (2) Default Value: on Configuration Changed: administrative')
cxConvCompression = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxConvCompression.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvCompression.setDescription('Determines whether the port is linked to a compression port. If the port is not linked to a compression port the value is 0. If the port is linked to a compression port, then the object identifies the compression port number (CompressPortNumber on CompressTable.) Range of Values: 0 to 64. Default Value: 0. Configuration Changed: administrative')
cxConvCompCompatibility = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("compatibleMemotec", 1), ("compatibleACC", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxConvCompCompatibility.setStatus('mandatory')
if mibBuilder.loadTexts: cxConvCompCompatibility.setDescription('Determines the data compression synchronization algorithm. When the CX1000 interfaces with Memotec models CL2800, CL5050, CL5200, CL5300, or CL5500, this object must be set to compatibleACC; when it interfaces with any other product the object must be set to compatibleMemotec. The CX900 must always be set to compatibleMemotec. Options: compatibleMemotec (1) compatibleACC (2) Default Value: compatibleMemotec (1) Configuration Changed: administrative ')
cxFwkCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2), )
if mibBuilder.loadTexts: cxFwkCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkCircuitTable.setDescription('Provides the attributes of the WAN service(s) used and the circuits established by each convergence port. It also identifies statistical information about the WAN circuits. The table contains two rows of default entries; some of these entries can be modified. If required, you can add additional entries.')
cxFwkCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1), ).setIndexNames((0, "CONV-MIB", "cxFwkCircuitPort"))
if mibBuilder.loadTexts: cxFwkCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkCircuitEntry.setDescription('')
cxFwkCircuitPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkCircuitPort.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkCircuitPort.setDescription('Identifies the convergence port by a unique index number. This number acts as an index for this and the cxConvTable. Range of Values: 1 to the number of convergence ports Default Values: none Note that the system defines two default entries; their respective values are 1 and 2.')
cxFwkCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(256, 1, 2, 3, 4))).clone(namedValues=NamedValues(("idle", 256), ("opened", 1), ("closed", 2), ("opening", 3), ("openFailed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkCircuitState.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkCircuitState.setDescription('Identifies the current state of the circuit between the convergence port and the destination port. Options: opened (1): The circuit is active closed (2): The circuit is not active opening (3): The circuit is being activated openFailed (4): The circuit could not be opened. idle (256): There is no activity over the circuit. Default Value: None Configuration Changed: administrative')
cxFwkCircuitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkCircuitRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkCircuitRowStatus.setDescription('Determines the status of the objects in a table row. Options: invalid (1): row is flagged, after next reset the values will be disabled and the row will be deleted from the table. valid (2): values are enabled Default Value: valid Configuration Changed: administrative')
cxFwkServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 256))).clone(namedValues=NamedValues(("frameRelay", 1), ("notSpecified", 256)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceType.setDescription('Determines the WAN service used. At the present time, frame relay is the only WAN service available. Options: frameRelay (1) notSpecified (256) Default Value: frameRelay (1) Configuration Changed: administrative ')
cxFwkServiceProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("cls", 1), ("pvc", 2), ("svc", 3), ("char", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkServiceProtocol.setReference('FRAMEWORK REQ. SPEC.')
if mibBuilder.loadTexts: cxFwkServiceProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceProtocol.setDescription('Identifies the type of connection the WAN service uses. At the present time, Permanent Virtual Circuit (PVC) is the only type of connection available. Options cls (1) pvc (2) svc (3) char (4) Default Value: pvc (2) Configuration Changed: administrative ')
cxFwkServiceName = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkServiceName.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceName.setDescription('Identifies the textual name of the WAN service used. The system updates the name automatically when it selects a WAN service for transmission. Frame Relay is the only WAN service currently available. Range of Values: 1 to 16 alphanumeric characters Default Value: None')
cxFwkDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkDestAddress.setDescription('Identifies the address used to reach the WAN service provider. Range of Values: 20 octets, each octet ranging from 00 to FF. Default Value: None')
cxFwkDestAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 8), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkDestAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkDestAlias.setDescription('Determines a unique textual name (assigned by a network administrator) identifying the destination frame relay circuit. Range of Values: 0-16 alphanumeric characters. (Note that the first character must be a letter; spaces are not allowed). Default Value: none Note: The system defines two default entries; their respective values are PRIMARY_DEST and BACKUP_DEST. Related Parameter: The name must equal a destination alias defined using the object frpCircuitAlias in the FrameRelayCicuitCfgTable. Configuration Changed: administrative ')
cxFwkServiceCircuitMdu = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8192)).clone(1600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkServiceCircuitMdu.setReference('FRAMEWORK REQ. SPEC.')
if mibBuilder.loadTexts: cxFwkServiceCircuitMdu.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceCircuitMdu.setDescription('Determines the maximum size of the data unit (in octets) that may be transmitted over the WAN circuit. Range of Values: 0 to 8192 Default Value: 1600 Configuration Changed: administrative')
cxFwkServiceCost = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkServiceCost.setReference('FRAMEWORK REQ. SPEC.')
if mibBuilder.loadTexts: cxFwkServiceCost.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceCost.setDescription('Determines the cost of the WAN service. Cost is typically inverse to the throughput. The smaller the number, the greater the throughput on the port. A value of 0 indicates that the cost is not known. Range of Values: 0 to 1000000 Default Value: 0 Configuration Changed: administrative ')
cxFwkServiceCardId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkServiceCardId.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceCardId.setDescription('Identifies the number of the chassis slot that contains the WAN service (FR600). This object is not applicable in the CX900 architecture. Range of Values: 1-16 Default Value: None')
cxFwkServiceSapId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkServiceSapId.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceSapId.setDescription("Identifies the ID of the WAN service's SAP (service access point) that the convergence port uses to establish the circuit. This object is not used if there is only one SAP on the WAN service. Range of Values: 0 to 65535 Default Value: None")
cxFwkServiceRouteRef = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxFwkServiceRouteRef.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkServiceRouteRef.setDescription("Determines a routing reference number. This number provides a reference for WAN service providers that offer multiplexing (it is required in situations where multiple convergence ports are multiplexed over the same DLCI). If the WAN provider doesn't provide multiplexing, then the object should be set to 0. If the WAN provider does provide multiplexing, a value of 0 instructs the provider not to multiplex other LAN traffic over the same circuit and the frame must be sent as received (regular RFC 1490 encapsulation in the case of frame relay service provider). If the value is set to other than 0 (1-255), the provider will use this number as a reference in its multiplexing encapsulation header. Each reference within the same WAN circuit must be unique. Range of Values: 0-255 Default Value: None Configuration Changed: administrative ")
cxFwkStatsInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkStatsInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkStatsInternalErrors.setDescription('Identifies the number of internal errors recognized by the convergence port. Range of Values: 1 to 4, 294, 967, 295 Default Value: 0')
cxFwkStatsRegistrationErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkStatsRegistrationErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkStatsRegistrationErrors.setDescription('Identifies the number of errors that occurred when the convergence port attempted to register itself to the framework. Range of Values: 1 to 4, 294, 967, 295 Default Value: 0')
cxFwkStatsQueryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkStatsQueryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkStatsQueryErrors.setDescription('Identifies the number of times the convergence port requested a service that was not available. Range of Values: 1 to 4, 294, 967, 295 Default Value: 0')
cxFwkStatsOpenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkStatsOpenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkStatsOpenErrors.setDescription('Identifies the number of errors that occurred when the convergence port attempted to establish a connection with a WAN service. A value here may indicate congestion at the WAN service, or a configuration problem. Range of Values: 1 to 4, 294, 967, 295 Default Value: 0')
cxFwkStatsResets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 8, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxFwkStatsResets.setStatus('mandatory')
if mibBuilder.loadTexts: cxFwkStatsResets.setDescription('Identifies the number of resets received from the WAN service. A large value here may signify a breakdown on the bus or the WAN circuit. Range of Values: 1 to 4, 294, 967, 295 Default Value: 0')
mibBuilder.exportSymbols("CONV-MIB", cxConvTable=cxConvTable, cxConvPort=cxConvPort, cxFwkCircuitTable=cxFwkCircuitTable, cxFwkStatsRegistrationErrors=cxFwkStatsRegistrationErrors, cxFwkServiceCircuitMdu=cxFwkServiceCircuitMdu, cxConvEntry=cxConvEntry, cxFwkDestAddress=cxFwkDestAddress, cxConvRowStatus=cxConvRowStatus, cxFwkCircuitEntry=cxFwkCircuitEntry, cxFwkServiceName=cxFwkServiceName, cxConvCompCompatibility=cxConvCompCompatibility, cxFwkDestAlias=cxFwkDestAlias, cxConvCompression=cxConvCompression, cxFwkCircuitState=cxFwkCircuitState, cxFwkServiceType=cxFwkServiceType, cxFwkServiceCost=cxFwkServiceCost, cxConvIfIndex=cxConvIfIndex, cxFwkStatsOpenErrors=cxFwkStatsOpenErrors, cxConvPortAlias=cxConvPortAlias, cxFwkServiceProtocol=cxFwkServiceProtocol, cxFwkServiceCardId=cxFwkServiceCardId, cxFwkCircuitRowStatus=cxFwkCircuitRowStatus, cxConvState=cxConvState, cxFwkServiceSapId=cxFwkServiceSapId, cxFwkStatsInternalErrors=cxFwkStatsInternalErrors, cxFwkServiceRouteRef=cxFwkServiceRouteRef, cxFwkStatsResets=cxFwkStatsResets, cxFwkCircuitPort=cxFwkCircuitPort, cxFwkStatsQueryErrors=cxFwkStatsQueryErrors)

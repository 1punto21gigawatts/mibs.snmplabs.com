#
# PySNMP MIB module CISCO-XGCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-XGCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:21:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
CCallControlProfileIndexOrZero, cmgwIndex = mibBuilder.importSymbols("CISCO-MEDIA-GATEWAY-MIB", "CCallControlProfileIndexOrZero", "cmgwIndex")
CMgcGroupIndexOrZero, = mibBuilder.importSymbols("CISCO-MGC-MIB", "CMgcGroupIndexOrZero")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoPort, = mibBuilder.importSymbols("CISCO-TC", "CiscoPort")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, ObjectIdentity, ModuleIdentity, NotificationType, MibIdentifier, Integer32, Unsigned32, iso, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Bits, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "ObjectIdentity", "ModuleIdentity", "NotificationType", "MibIdentifier", "Integer32", "Unsigned32", "iso", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Bits", "Gauge32")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
ciscoXgcpMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 318))
ciscoXgcpMIB.setRevisions(('2006-02-21 00:00', '2005-12-21 00:00', '2005-08-24 00:00', '2005-08-09 00:00', '2005-03-07 00:00', '2004-11-15 00:00', '2004-08-30 00:00', '2004-05-14 00:00', '2003-02-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoXgcpMIB.setRevisionsDescriptions(('Added 7 new MGCP Packages to cXgcpMediaGwTable.', 'Sanitized the whole MIB.', '[1] Added table for Media Gateway statistics regarding Received and transmitted network messages. [2] Added table for active connections that are controlled by the Media Gateway.', 'Added cXgcpMediaGwAnnexabSdpEnabled to cXgcpMediaGwTable.', 'Added the following objects to cXgcpMediaGwTable cXgcpMediaGwLongDurTimer, cXgcpMediaGwProfile ', 'Added the following objects to cXgcpMediaGwTable cXgcpMediaGwConfiguredPackages, cXgcpMediaGwConnOosRsipBehavior ', '[1] Added the value resetTimerForEndpoint to CXgcpRetryMethod textual convention. [2] Widened the range of cXgcpMediaGwMaxExpTimeout. [3] Added cXgcpMediaGwCaleaEnabled to cXgcpMediaGwTable. ', 'Added the following objects: cXgcpMediaGwLastFailMgcAddrType, cXgcpMediaGwLastFailMgcAddr, cXgcpMediaGwDtmfRelay ', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoXgcpMIB.setLastUpdated('200602210000Z')
if mibBuilder.loadTexts: ciscoXgcpMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoXgcpMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-voice-gateway@cisco.com')
if mibBuilder.loadTexts: ciscoXgcpMIB.setDescription("This MIB is an enhancement for existing XGCP-MIB. xGCP is a set of protocols, for example SGCP (Simple Gateway Control Protocol) and MGCP (Media Gateway Control Protocol), which are designed as a control protocol within a distributed system that appears to the outside as a single VoIP/VoATM gateway. This system is composed of a call agent (or MGC, Media Gateway Controller) and of a set of 'media gateways' that perform the conversion of media signals between circuits and packets. In the xGCP model, the gateways focus on the audio signal translation function, while the call agent handles the signaling and call processing functions. Examples of Gateway Control Protocols are: * Simple Gateway Control Protocol (SGCP) * Media Gateway Control Protocol (MGCP) xGCP assumes a connection model where the basic constructs are: Endpoints : sources or sinks of data that could be physical or virtual. Connections : an association between two or more endpoints with the purpose of transmitting data between these endpoints. Once this association is established for both endpoints, data transfer between these endpoints can take place. Connections are grouped in calls. One or more connections can belong to one call. Connections and calls are set up at the initiative of one or several call agents. Terminologies used: AAL : ATM Adaptation Layer AUCX : Audit Connection Command used by the MGC to find out the status of a given gateway connection. AUEP : Audit Endpoint Command used by the MGC to find out the status of a given endpoint. CCAPI : Call Control Application Program Interface. CID : Channel Identifier CRCX : Connection Command from a MGC to request the gateway MG : Media Gateway MGC : Media Gateway Controller DLCX : Delete Command. This command can be initiated by either the MGC or gateway. GSM : Global System for Mobile Communications GW : Gateway. HP : Hairpin MDCX : Modify Connection Command from a MGC to request the gateway NSE : Negative Stuffing Event NTFY : A Notify Command sent from a gateway to a MGC in response to a RQNT command. PSTN : Public Switched Telephone Network RQNT : Request To Nofity Command from a MGC to request the gateway to provide a notification for configuration changes. RSIP : Restart in Progress Command. This command can be initiated by either the MGC or gateway. SPRT : Simple Packet Relay Transport SSE : Silicon Switching Engine TDM : Time Division Multiplexing TGW : Target Gateway TWC : Three Way Calling VCCI : Virtual Circuit Connection Identifier VMG : Virtual Media Gateway. It is a logical representation of a module (or a set of modules) that has MG functionality. There could be multiple VMGs in a device. VoAAL2 : Voice over AAL2")
cXgcpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 0))
cXgcpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 1))
cXgcpMgcCfg = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1))
cXgcpMediaGw = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2))
cXgcpStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3))
cXgcpConnection = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4))
class CXgcpRetryMethod(TextualConvention, Integer32):
    description = 'Method of resetting retry timer in XGCP. When media gateway re-try to communication to a call agent, the timeout for each re-try is doubled. Example: re-try time is 3 initial timeout is 2 (any unit) maximum possible retry time is 256 MGC group has 2 MGC and each MGC has two IP address timeout for neverResetTimer will be as: MGC 1 IP11: 2 4 8 MGC 1 IP12: 16 32 64 MGC 2 IP21: 128 256 512 MGC 1 IP22: 1024 2048 4096 timeout for resetTimerForNewMgc will be as: MGC 1 IP11: 2 4 8 MGC 1 IP12: 16 32 64 MGC 2 IP21: 2 4 8 MGC 1 IP22: 16 32 64 timeout for resetTimerForNewAddr will be as: MGC 1 IP11: 2 4 8 MGC 1 IP12: 2 4 8 MGC 2 IP21: 2 4 8 MGC 1 IP22: 2 4 8 timeout for resetTimerForEndpoint will be as: MGC 1 IP11: 2 4 8 MGC 1 IP12: 16 32 64 MGC 2 IP21: 128 256 256 MGC 1 IP22: 256 256 256 '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("neverResetTimer", 1), ("resetTimerForNewMgc", 2), ("resetTimerForNewAddr", 3), ("resetTimerForEndpoint", 4))

class CXgcpCallEvent(TextualConvention, Integer32):
    description = 'Represents possible Gateway Control Protocol Call Events. ack - Acknowledgement msg createConn - Create connection msg deleteConn - Delete connection msg modifyConn - Modify connection msg notifyReq - Notify request msg alert - CCAPI alert event callConnect - CCAPI call connect event confReady - CCAPI conference ready confDestroy - CCAPI conference destroyed callDisconnect - CCAPI call disconnect callProceed - CCAPI call proceeding offHook - CCAPI off-hook/call setup ind onHook - CCAPI on-hook/call disconnected mediaEvent - Media Events intEven - Internal Events dissocConf - Dissociate Conf assocConf - Associate Conf modifyDone - CCAPI Call modify done event voiceModeDone - Voice Cut-thru has happened nse - CCAPI NSE events callHandoff - Handoff Call to some other app babblerAuditResp - CCAPI babbler audit response '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21))
    namedValues = NamedValues(("ack", 0), ("createConn", 1), ("deleteConn", 2), ("modifyConn", 3), ("notifyReq", 4), ("alert", 5), ("callConnect", 6), ("confReady", 7), ("confDestroy", 8), ("callDisconnect", 9), ("callProceed", 10), ("offHook", 11), ("onHook", 12), ("mediaEvent", 13), ("intEven", 14), ("dissocConf", 15), ("assocConf", 16), ("modifyDone", 17), ("voiceModeDone", 18), ("nse", 19), ("callHandoff", 20), ("babblerAuditResp", 21))

cXgcpMgcConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1), )
if mibBuilder.loadTexts: cXgcpMgcConfigTable.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigTable.setDescription('This is a table which is used to provision a MGC or MGC group for a MG. Each entry corresponds to a MGC or a MGC group for a single MG. ')
cXgcpMgcConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"))
if mibBuilder.loadTexts: cXgcpMgcConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigEntry.setDescription('Each row corresponds to a MGC or a group of MGCs for a media gateway.')
cXgcpMgcConfigMgcGrpNum = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1, 1), CMgcGroupIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMgcConfigMgcGrpNum.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigMgcGrpNum.setDescription('This object specifies which MGC Redundant Group will be used in XGCP. The value of this object refers to the object cMgcGrpIndex from MGC Redundant Group Table, cMgcGrpParamTable. There are two conditions to associate a MGC group: 1. At least one MGC is associated with the MGC group 2. At least one protocol is associated with the MGC group If the value of the object is non-zero, it means the media gateway has a MGC Redundant Group. In the call setup, the parameters of call agents within the MGC Redundant Group will be sequentially tried according to its preference. This object cXgcpMgcConfigMgcGrpNum and object cXgcpMgcConfigAddress are mutually exclusive. The object cXgcpMgcConfigAddress can be set only when the object cXgcpMgcConfigMgcGrpNum is equal to 0. If the value of the object is 0, which means there is no MGC Redundant Group associated with the media gateway. It has only one call agent (in media gateway level) to communicate with. This call agent is indicated by cXgcpMgcConfigAddress and will be used in call setup (if call set-up on media gateway level). ')
cXgcpMgcConfigAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMgcConfigAddrType.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigAddrType.setDescription('This object specifies the address type of the MGC (object cXgcpMgcConfigAddress), either ipv4 or ipv6.')
cXgcpMgcConfigAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1, 3), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMgcConfigAddress.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigAddress.setDescription('This object specifies the address of the MGC the gateway used to communicate with in call setup. This object cXgcpMgcConfigAddress and object cXgcpMgcConfigMgcGrpNum are mutually exclusive. The object cXgcpMgcConfigAddress can be set only when the object cXgcpMgcConfigMgcGrpNum is equal to 0. Otherwise, the SET will be rejected with error. ')
cXgcpMgcConfigProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMgcConfigProtocolIndex.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigProtocolIndex.setDescription('This object specifies which protocol that the MG should use to communicate with the MGC when it try to set up the call. The value of this object is the same as the value of object cMediaGwProtocolIndex from protocol table (cMediaGwProtocolTable). If the value of cXgcpMgcConfigMgcGrpNum is non-zero, this object will be ignored because the protocol will be determined by the MGC group. The initial value is 1, means the system should have at least one default protocol between the gateway and the MGC created in the cMeidaGwProtocolTable when the system is initialized. ')
cXgcpMgcConfigGatewayUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 1, 1, 1, 5), CiscoPort().clone(2427)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMgcConfigGatewayUdpPort.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 3.6 Transmission over UDP ')
if mibBuilder.loadTexts: cXgcpMgcConfigGatewayUdpPort.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigGatewayUdpPort.setDescription('The UDP port of the MG which is used to communicate with call agent in MGCP.')
cXgcpMediaGwTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1), )
if mibBuilder.loadTexts: cXgcpMediaGwTable.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwTable.setDescription('This table is used to provision xGCP configuration in a MG.')
cXgcpMediaGwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"))
if mibBuilder.loadTexts: cXgcpMediaGwEntry.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwEntry.setDescription("Each entry represents the xGCP attributes for a media gateway. An entry is created when the system detects the XGCP stack at system start-up. Accordingly, the existing entry shall be deleted when the system can't locate the XGCP stack at system start-up.")
cXgcpMediaGwRequestTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(500)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwRequestTimeOut.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 3.6.3 Computing retransmission timers')
if mibBuilder.loadTexts: cXgcpMediaGwRequestTimeOut.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwRequestTimeOut.setDescription('The request timeout is the period that the XGCP protocol waits before retransmitting an unacknowledged message. It is the responsibility of the requesting entity to provide suitable timeouts for all outstanding commands, and to retry commands when timeouts exceeded. ')
cXgcpMediaGwRequestRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(3)).setUnits('times').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwRequestRetries.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 2.1.4 Names of Call Agents and other entities')
if mibBuilder.loadTexts: cXgcpMediaGwRequestRetries.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwRequestRetries.setDescription('This object specifies the number of retries for a request that exceeds timeout without acknowledge before it tries to connect to another MGC.')
cXgcpMediaGwRequestRetryMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 3), CXgcpRetryMethod()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwRequestRetryMethod.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwRequestRetryMethod.setDescription('This object specifies command retry method.')
cXgcpMediaGwMaxExpTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60000)).clone(4000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwMaxExpTimeout.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwMaxExpTimeout.setDescription('This object specifies the maximum timeout for exponential command retry by the media gateway.')
cXgcpMediaGwRestartMwd = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600000)).clone(3000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwRestartMwd.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 4.3.4 Fighting the restart avalanche')
if mibBuilder.loadTexts: cXgcpMediaGwRestartMwd.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwRestartMwd.setDescription('The maximum waiting delay (MWD) timeout value is used for the media gateway to send the first Restart In Progress to the MGC. When a gateway is powered on, it should initiate a restart timer to a random value, uniformly distributed between 0 and a maximum waiting delay (MWD). The gateway should send the first RSIP message when the timer expires. The initial value of this object is chosen in an implementation-dependent manner by the MGCP functionality based on the call volume of the system. ')
cXgcpMediaGwRestartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwRestartDelay.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 4.3.4 Fighting the restart avalanche')
if mibBuilder.loadTexts: cXgcpMediaGwRestartDelay.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwRestartDelay.setDescription('This object specifies the Restart Delay Timeout for the restart process for a gateway to send out RestartInProgress when it is powered on or been reset. The purpose of setting the Restart Delay timer before sending the RestartInProgress notification to the media gateway controller is to avoid the network congestion during the critical period of service restoration. ')
cXgcpMediaGwDefaultPackage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))).clone(namedValues=NamedValues(("packageDC", 1), ("packageG", 2), ("packageD", 3), ("packageM", 4), ("packageT", 5), ("packageL", 6), ("packageH", 7), ("packageR", 8), ("packageN", 9), ("packageA", 10), ("packageS", 11), ("packageATM", 12), ("packageMS", 13), ("packageDT", 14), ("packageMO", 15), ("packageRES", 16), ("packageSASDI", 17), ("packageIT", 18), ("packageMT", 19), ("packageB", 20), ("packageSST", 21), ("packageMDR", 22), ("packageFXR", 23), ("packageBA", 24), ("packageMD", 25), ("packageNAS", 26), ("packageMDSTE", 27), ("packagePRE", 28), ("packageLCS", 29), ("packageSRTP", 30), ("packageFM", 31))).clone('packageG')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwDefaultPackage.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : 6.1. Basic packages')
if mibBuilder.loadTexts: cXgcpMediaGwDefaultPackage.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwDefaultPackage.setDescription("This object represents the default capability package supported in the gateway. packageDC ( 1) - Don't Care package packageG ( 2) - Generic package packageD ( 3) - DTMF package packageM ( 4) - MF package packageT ( 5) - Trunk package packageL ( 6) - Line package packageH ( 7) - Handset package packageR ( 8) - RTP package packageN ( 9) - NAS package packageA (l0) - Announcement Server package packageS (11) - Script package packageATM (12) - ATM package packageMS (13) - MF CAS package packageDT (14) - DTMF CAS package packageMO (15) - MO package packageRES (16) - RES package packageSASDI(17) - ASDI package (S) NCS packageIT (18) - IT package (S) TGCP packageMT (19) - MT package packageB (20) - B package packageSST (21) - SST package packageMDR (22) - MDR package packageFXR (23) - FAX package packageBA (24) - Bulk Audit package packageMD (25) - MD package packageNAS (26) - Network Access Server package packageMDSTE(27) - Modem relay Secure Telephone Equipment package packagePRE (28) - PRE package packageLCS (29) - MGCP Line Control Signaling package packageSRTP (30) - Secure RTP package packageFM (31) - Media Format Package ")
cXgcpMediaGwSupportedPackages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 8), Bits().clone(namedValues=NamedValues(("notFound", 0), ("packageDC", 1), ("packageG", 2), ("packageD", 3), ("packageM", 4), ("packageT", 5), ("packageL", 6), ("packageH", 7), ("packageR", 8), ("packageN", 9), ("packageA", 10), ("packageS", 11), ("packageATM", 12), ("packageMS", 13), ("packageDT", 14), ("packageMO", 15), ("packageRES", 16), ("packageSASDI", 17), ("packageIT", 18), ("packageMT", 19), ("packageB", 20), ("packageSST", 21), ("packageMDR", 22), ("packageFXR", 23), ("packageBA", 24), ("packageMD", 25), ("packageNAS", 26), ("packageMDSTE", 27), ("packagePRE", 28), ("packageLCS", 29), ("packageSRTP", 30), ("packageFM", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMediaGwSupportedPackages.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : 6.1. Basic packages ')
if mibBuilder.loadTexts: cXgcpMediaGwSupportedPackages.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwSupportedPackages.setDescription("This object represents the bit map of MGCP supported packages. Bit 0 - Not Found Bit 1 - Package DC (Don't care package) Bit 2 - Package G (Generic package) Bit 3 - Package D (DTMF package) Bit 4 - Package M (MF package) Bit 5 - Package T (Trunk package) Bit 6 - Package L (Line package) Bit 7 - Package H (Handset package) Bit 8 - Package R (RTP package) Bit 9 - Package N (NAS package) Bit 10 - Package A (Announcement Server package) Bit 11 - Package S (Script package) Bit 12 - Package ATM (ATM package) Bit 13 - Package MS (MF CAS package) Bit 14 - Package DT (DTMF CAS package) Bit 15 - Package MO (MO package) Bit 16 - Package RES (RES package) Bit 17 - Package S_ASDI (ASDI package (S) NCS) Bit 18 - Package IT (IT package (S) TGCP) Bit 19 - Package MT (MT package) Bit 20 - Package B (B package) Bit 21 - Package SST (SST package) Bit 22 - Package MDR (MDR package) Bit 23 - Package FXR (FAX package) Bit 24 - Package BA (Bulk Audit package) Bit 25 - Package MD (MD package) Bit 26 - Package NAS (Network Access Server package) Bit 27 - Package MDSTE (Modem relay Secure Telephone Equipment package) Bit 28 - Package PRE (PRE package) Bit 29 - Package LCS (MGCP Line Control Signaling package) Bit 33 - Package SRTP (Secure RTP package) Bit 31 - Package FM (Media Format Package) The value 0 means there is no supported packages. ")
cXgcpMediaGwSimpleSdpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwSimpleSdpEnabled.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwSimpleSdpEnabled.setDescription("This object is used to enable/disable building of s, t, o lines in SDP message. where o field indicates the owner/creator and session identifier s field indicates the session name t field indicates the duration while a session is valid. If this object is set to 'true'(enabled), SDP will NOT include the fields s, t, and o. If this object is set to 'false', then it indicates that the o, s, t lines be built before sending SDP (Session Description Protocol). ")
cXgcpMediaGwAckSdpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwAckSdpEnabled.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwAckSdpEnabled.setDescription("This object specifies the ACK SDP is enabled or not. If this object is set to 'true', then it sends ADP with ACK when CODEC or reportable NTE delta changed, or an attempt is made to change CODEC, VAD, Packet-period, echo cancellation during FAX/modem mode. ")
cXgcpMediaGwUndottedNotation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwUndottedNotation.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwUndottedNotation.setDescription("This object enables/disables the undotted notation for CODEC. This object is used to set CODEC notation to 'dotted' or 'undotted' in SDP between the gateway and the call agent. For example, 'G.726' is 'dotted', while 'G726' is 'undotted'. If it is set to 'true', then the 'undotted' notation for CODEC is enabled. ")
cXgcpMediaGwQuarantineProcess = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineProcess.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 3.2.2.12. QuarantineHandling')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineProcess.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineProcess.setDescription("This object is used to determine how to handle persistent events. If this object is set to 'true', the quarantined events should be processed, otherwise the quarantined events is discarded. ")
cXgcpMediaGwQuarantineLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 13), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineLoop.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 2.3.2. NotificationRequest ')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineLoop.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantineLoop.setDescription("This object controls the default quarantine mode. If this object is set to 'true', the default quarantine mode is 'loop', not 'step'. When this object is set to 'true', the gateway is expected to generate multiple notifications (loop), not at most one notification (step by step), in response to quarantined events. This object will be ignored if the object cXgcpMediaGwQuarantineProcess is set to 'false'. ")
cXgcpMediaGwQuarantinePersist = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 14), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwQuarantinePersist.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 2.3.2. NotificationRequest')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantinePersist.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwQuarantinePersist.setDescription("This object specifies how the persist events will be handled in quarantine processing. If this object is set to 'true', the persistent events bypass quarantine buffer. This object will be ignored if the object cXgcpMediaGwQuarantineProcess is set to 'false'. ")
cXgcpMediaGwPiggybackMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 15), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwPiggybackMsg.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 3.6.4. Piggy backing')
if mibBuilder.loadTexts: cXgcpMediaGwPiggybackMsg.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwPiggybackMsg.setDescription('This object enables/disables the piggyback message generating. If the piggyback message generating is enabled, a call agent can send several MGCP messages in the same UDP packets to the gateway. ')
cXgcpMediaGwMaxMsgSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwMaxMsgSize.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : Section 2.3.8 Audit Endpoint ')
if mibBuilder.loadTexts: cXgcpMediaGwMaxMsgSize.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwMaxMsgSize.setDescription('This object specifies the maximum allowed xGCP message size which is used for checking if the size will be supported by the call agent via (AuditEndPoint) response. A value of 0 means that there is no limit to the size of the XGCP message.')
cXgcpMediaGwLastFailMgcAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 17), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMediaGwLastFailMgcAddrType.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwLastFailMgcAddrType.setDescription('This object indicates the address type, either IPv4 or IPv6, of cxeCallCtrlLastFailMgcAddr.')
cXgcpMediaGwLastFailMgcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 18), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMediaGwLastFailMgcAddr.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwLastFailMgcAddr.setDescription('This object indicates the address of last MGC which the media gateway had tried to communicate with but failed.')
cXgcpMediaGwDtmfRelay = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 19), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwDtmfRelay.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwDtmfRelay.setDescription("When this object is set to 'true', the digits will be sent as peer-to-peer packet in the bearer. When this object is set to 'false', the digits will be sent as regular voice packets in the bearer. For low complexity CODECS (such as G.711), the preferred value for this object could be 'false'. For high complexity CODECS (such as G.729A), the preferred value for this object should be 'true', otherwise the digits may not get recognized properly at the remote end.")
cXgcpMediaGwCaleaEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 20), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwCaleaEnabled.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwCaleaEnabled.setDescription("CALEA, Communication Assistance for Law Enforcement Act, is a feature that allows for a lawful intercept of a call details and call contents originating or terminating on specific terminals. CALEA feature can be turned on or off. A value 'true' specifies CALEA enabled and a value 'false' specifies CALEA disabled.")
cXgcpMediaGwConfiguredPackages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 21), Bits().clone(namedValues=NamedValues(("notFound", 0), ("packageDC", 1), ("packageG", 2), ("packageD", 3), ("packageM", 4), ("packageT", 5), ("packageL", 6), ("packageH", 7), ("packageR", 8), ("packageN", 9), ("packageA", 10), ("packageS", 11), ("packageATM", 12), ("packageMS", 13), ("packageDT", 14), ("packageMO", 15), ("packageRES", 16), ("packageSASDI", 17), ("packageIT", 18), ("packageMT", 19), ("packageB", 20), ("packageSST", 21), ("packageMDR", 22), ("packageFXR", 23), ("packageBA", 24), ("packageMD", 25), ("packageNAS", 26), ("packageMDSTE", 27), ("packagePRE", 28), ("packageLCS", 29), ("packageSRTP", 30), ("packageFM", 31)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwConfiguredPackages.setReference('RFC2705 - Media Gateway Control Protocol (MGCP) version 1.0 : 6.1. Basic packages ')
if mibBuilder.loadTexts: cXgcpMediaGwConfiguredPackages.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwConfiguredPackages.setDescription("This object represents the bit map of MGCP packages configured and supported in the gateway. Bit 0 - Not Found Bit 1 - Package DC (Don't care package) Bit 2 - Package G (Generic package) Bit 3 - Package D (DTMF package) Bit 4 - Package M (MF package) Bit 5 - Package T (Trunk package) Bit 6 - Package L (Line package) Bit 7 - Package H (Handset package) Bit 8 - Package R (RTP package) Bit 9 - Package N (NAS package) Bit 10 - Package A (Announcement Server package) Bit 11 - Package S (Script package) Bit 12 - Package ATM (ATM package) Bit 13 - Package MS (MF CAS package) Bit 14 - Package DT (DTMF CAS package) Bit 15 - Package MO (MO package) Bit 16 - Package RES (RES package) Bit 17 - Package S_ASDI (ASDI package (S) NCS) Bit 18 - Package IT (IT package (S) TGCP) Bit 19 - Package MT (MT package) Bit 20 - Package B (B package) Bit 21 - Package SST (SST package) Bit 22 - Package MDR (MDR package) Bit 23 - Package FXR (FAX package) Bit 24 - Package BA (Bulk Audit package) Bit 25 - Package MD (MD package) Bit 26 - Package NAS (Network Access Server package) Bit 27 - Package MDSTE (Modem relay Secure Telephone Equipment package) Bit 28 - Package PRE (PRE package) Bit 29 - Package LCS (MGCP Line Control Signaling package) Bit 33 - Package SRTP (Secure RTP package) Bit 31 - Package FM (Media Format Package) The value 0 means there is no supported packages. ")
cXgcpMediaGwConnOosRsipBehavior = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sendDlcx", 1), ("rsipOnly", 2))).clone('sendDlcx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwConnOosRsipBehavior.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwConnOosRsipBehavior.setDescription('This object specifies the RSIP behavior of the endpoints with active calls (in connections) when they are forced to out-of-service. The following values can be set for this object: sendDlcx - The media gateway sends RSIP-graceful and then individual DLCX command to delete the endpoints of each connection and its children before it sends out RSIP-forced command when an endpoint goes into alarm or placed out-of-service forcefully through the user command if the endpoint or its children has any calls (in connections). rsipOnly - The media gateway sends out RSIP-forced command, and delete the connections without any DLCX or RSIP-graceful command. This object is applicable only if the endpoint or its children have any calls. If there are no calls on the endpoint, the media gateway sends RSIP-forced command when the endpoint is forced to out-of-service.')
cXgcpMediaGwLongDurTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65536)).clone(3600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwLongDurTimer.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwLongDurTimer.setDescription('This object specifies the long duration timer. It is used to define the long duration of a connection. Once the timer expires, a notification will be sent to the MGC to indicate that a connection has established for the defined long duration.')
cXgcpMediaGwProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 24), CCallControlProfileIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwProfile.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwProfile.setDescription('This object specifies the XGCP profile in the media gateway level. The value of 0 means the XGCP default profile is used in the media gateway level. If the value of ccasIfExtVoiceCfgCcntrlProfile is 0, then the endpoint uses the profile specified in this object.')
cXgcpMediaGwAnnexabSdpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 2, 1, 1, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cXgcpMediaGwAnnexabSdpEnabled.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwAnnexabSdpEnabled.setDescription("This object specifies the format for parsing or generating G.723 or G.729 codec in SDP message for the media gateway. The value 'true' means using Annex A and B in fmtp line complying with RFC 3555. The value 'false' means using Annex A and B in SDP attribute codec string.")
cXgcpMsgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1), )
if mibBuilder.loadTexts: cXgcpMsgStatsTable.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsTable.setDescription('This table contains statistical information on the transmitted and received network messages between MG and MGC, since the MG reset. The entries in this table are uniquly identified by the VMG index and the MGC address. This table contains statistics of the most recently received 64 MGC addressess for every VMG present in the device. When a new address is received and the number of entries for this MGC exceeds 64, then a least recently received entry is deleted.')
cXgcpMsgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"), (0, "CISCO-XGCP-MIB", "cXgcpMsgStatsIndex"))
if mibBuilder.loadTexts: cXgcpMsgStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsEntry.setDescription('This entry contains the statistical information on the received and transmitted network messages with the associated MGC address.')
cXgcpMsgStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64)))
if mibBuilder.loadTexts: cXgcpMsgStatsIndex.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsIndex.setDescription('A unique index to identify a specific MGC address for tracking xGCP statistics between MGC and MG.')
cXgcpMsgStatsMgcIPAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMsgStatsMgcIPAddressType.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsMgcIPAddressType.setDescription('This object indicates the address type of cXgcpMsgStatsMgcIPAddress. ')
cXgcpMsgStatsMgcIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMsgStatsMgcIPAddress.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsMgcIPAddress.setDescription('This object indicates IP address of the MGC. The IP address should be unique on the table.')
cXgcpMsgStatsSuccessMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMsgStatsSuccessMessages.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsSuccessMessages.setDescription('This object indicates the number of successful messages that communicate with the MGC on that IP address. Successful messages apply to both transmit and receive messages. Transmit: Positive ACK received from the MGC. Receive : Positive ACK sent to the MGC. This implies that the format of the message is correct and the request can be fulfilled.')
cXgcpMsgStatsFailMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMsgStatsFailMessages.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsFailMessages.setDescription("This object indicates the number of failed messages that communicate with the MGC on that IP address. Failed messages apply to both transmit and receive messages. Transmit: Either NAK has been received from the MGC or message times out waiting for ACK. Receive: Format of the received message is bad or the request was NAK'ed.")
cXgcpMsgStatsIncompleteMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpMsgStatsIncompleteMessages.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsIncompleteMessages.setDescription('This object indicates the number of transmit messages for which time out occurred while waiting for an ACK.')
cXgcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2), )
if mibBuilder.loadTexts: cXgcpStatsTable.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTable.setDescription('This table contains information on the received and transmitted network messages, based on each message type, for all the VMGs present in the device. The table will have one entry for every VMG present in the device. When a new MG is instantiated, the device creates an entry. The entry is destroyed if the associated VMG is terminated.')
cXgcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"))
if mibBuilder.loadTexts: cXgcpStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsEntry.setDescription("This entry contains the information on the associated VMG's received and transmitted network messages. The value of each statistical object is incremented when the MG receives or transmits an XGCP message corresponding to that object type. All these values are set to '0' upon restarting of the VMG.")
cXgcpStatsUdpRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsUdpRxPkts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsUdpRxPkts.setDescription('Number of UDP packets received from all the MGCs.')
cXgcpStatsUdpTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsUdpTxPkts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsUdpTxPkts.setDescription('Number of UDP packets sent to all the MGCs.')
cXgcpStatsUnRecRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsUnRecRxPkts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsUnRecRxPkts.setDescription('Number of unrecognized UDP packets received from all the MGCs.')
cXgcpStatsMsgParsingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsMsgParsingErrors.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsMsgParsingErrors.setDescription('Number of messages with parsing errors received from all the MGCs.')
cXgcpStatsDupAckTxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsDupAckTxMsgs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsDupAckTxMsgs.setDescription('Number of duplicate response messages sent to the MGCs.')
cXgcpStatsInvalidVerCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsInvalidVerCount.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsInvalidVerCount.setDescription('Number of invalid protocol version messages received from all the MGCs.')
cXgcpStatsUnknownMgcRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsUnknownMgcRxPkts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsUnknownMgcRxPkts.setDescription('Number of unknown message packets received from all the MGCs.')
cXgcpStatsAckTxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsAckTxMsgs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsAckTxMsgs.setDescription('Number of acknowledgment messages sent by the MG.')
cXgcpStatsNackTxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsNackTxMsgs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsNackTxMsgs.setDescription('Number of negative acknowledgment messages sent by the MG.')
cXgcpStatsAckRxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsAckRxMsgs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsAckRxMsgs.setDescription('Number of acknowledgment messages received by the MG.')
cXgcpStatsNackRxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsNackRxMsgs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsNackRxMsgs.setDescription('Number of negative acknowledgment messages received by the MG.')
cXgcpStatsRxCrcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxCrcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxCrcxs.setDescription('Number of CRCX messages received by the MG.')
cXgcpStatsRxSuccCrcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccCrcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccCrcxs.setDescription('Number of CRCX messages received, that were successful.')
cXgcpStatsRxFailCrcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailCrcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailCrcxs.setDescription('Number of CRCX messages received, that failed.')
cXgcpStatsRxDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxDlcxs.setDescription('Number of DLCX messages received.')
cXgcpStatsRxSuccDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccDlcxs.setDescription('Number of DLCX messages received, that were successful.')
cXgcpStatsRxFailDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailDlcxs.setDescription('Number of DLCX messages received, that failed.')
cXgcpStatsTxDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxDlcxs.setDescription('Number of DLCX messages sent.')
cXgcpStatsTxSuccDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxSuccDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxSuccDlcxs.setDescription('Number of DLCX messages sent, that were successful.')
cXgcpStatsTxFailDlcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxFailDlcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxFailDlcxs.setDescription('Number of DLCX messages sent, that failed.')
cXgcpStatsRxMdcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxMdcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxMdcxs.setDescription('Number of MDCX messages received.')
cXgcpStatsRxSuccMdcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccMdcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccMdcxs.setDescription('Number of MDCX messages received, that were successful.')
cXgcpStatsRxFailMdcxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailMdcxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailMdcxs.setDescription('Number of MDCX messages received, that failed.')
cXgcpStatsRxRqnts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxRqnts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxRqnts.setDescription('Number of RQNT messages received.')
cXgcpStatsRxSuccRqnts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccRqnts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccRqnts.setDescription('Number of RQNT messages received, that were successful.')
cXgcpStatsRxFailRqnts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailRqnts.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailRqnts.setDescription('Number of RQNT messages received, that failed.')
cXgcpStatsRxAucxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxAucxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxAucxs.setDescription('Number of AUCX messages received.')
cXgcpStatsRxSuccAucxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccAucxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccAucxs.setDescription('Number of AUCX messages received, that were successful.')
cXgcpStatsRxFailAucxs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailAucxs.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailAucxs.setDescription('Number of AUCX messages received, that failed.')
cXgcpStatsRxAueps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxAueps.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxAueps.setDescription('Number of AUEP messages received.')
cXgcpStatsRxSuccAueps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxSuccAueps.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxSuccAueps.setDescription('Number of AUEP messages received, that were successful.')
cXgcpStatsRxFailAueps = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsRxFailAueps.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsRxFailAueps.setDescription('Number of AUEP messages received, that failed.')
cXgcpStatsTxRsips = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxRsips.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxRsips.setDescription('Number of RSIP messages sent.')
cXgcpStatsTxSuccRsips = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxSuccRsips.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxSuccRsips.setDescription('Number of RSIP messages sent, that were successful.')
cXgcpStatsTxFailRsips = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxFailRsips.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxFailRsips.setDescription('Number of RSIP messages sent, that failed.')
cXgcpStatsTxNotifies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxNotifies.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxNotifies.setDescription('Number of NTFY messages sent.')
cXgcpStatsTxSuccNotifies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxSuccNotifies.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxSuccNotifies.setDescription('Number of NTFY messages sent, that were successful.')
cXgcpStatsTxFailNotifies = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 3, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpStatsTxFailNotifies.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsTxFailNotifies.setDescription('Number of NTFY messages sent, that failed.')
cXgcpConnectionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1), )
if mibBuilder.loadTexts: cXgcpConnectionTable.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnectionTable.setDescription('This table contains information on the active connections of all the VMGs present in the device. A MG may have zero or more number of calls at any given time. Each call consists of one or more connection. The table will have one entry per VMG per connection present in the device. When a new connection is established, the device creates an entry. The entry is destroyed if the associated connection is torn down.')
cXgcpConnectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-MEDIA-GATEWAY-MIB", "cmgwIndex"), (0, "CISCO-XGCP-MIB", "cXgcpConnId"))
if mibBuilder.loadTexts: cXgcpConnectionEntry.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnectionEntry.setDescription('This entry contains the information about an active connection.')
cXgcpConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cXgcpConnId.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnId.setDescription('Connection ID generated by the gateway and sent in the ACK message.')
cXgcpConnEndPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnEndPoint.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnEndPoint.setDescription('The physical or virtual entity that acts as a source or sink of data in the MG is called an endpoint. Every end point in the MG is assigned a textual name by the MG.')
cXgcpConnCallId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnCallId.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnCallId.setDescription('Call ID associated with this connection. Call ID is a parameter that identifies the call to which this connection belongs to. A call ID is unique within a VMG instance.')
cXgcpConnLocalUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 4), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnLocalUdpPort.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnLocalUdpPort.setDescription('The local UDP port used for the connection.')
cXgcpConnRemoteUdpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 5), CiscoPort()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnRemoteUdpPort.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnRemoteUdpPort.setDescription('The remote UDP port used for the connection.')
cXgcpConnMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("invalid", 0), ("sendOnly", 1), ("recvOnly", 2), ("sendRecv", 3), ("inActive", 4), ("loopBack", 5), ("contTest", 6), ("data", 7), ("netwLoop", 8), ("netwTest", 9), ("conference", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnMode.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnMode.setDescription('Represents possible MG connection modes. invalid - Invalid value for mode sendOnly - The GW should only send packets recvOnly - The GW should only receive packets sendRecv - The GW can send and receive packets inActive - The GW should neither send nor receive packets loopBack - The GW should place the circuit in loopback mode contTest - The GW should place the circuit in test mode data - The GW should use the circuit for network access for data netwLoop - The GW should place the connection in network loopback mode netwTest - The GW should place the connection in network continuity test mode conference - The GW should place the connection in conference mode.')
cXgcpConnVccId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnVccId.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnVccId.setDescription("VCCI used for the VoAAL2 call. The object should have a non-zero value only if the associated call is of VoAAL2 type. For all other calls the value should be '0'.")
cXgcpConnChannelId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnChannelId.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnChannelId.setDescription("CID used for the VoAAL2 call. The object should have a non-zero value only if the associated call is of VoAAL2 type. For all other calls the value should be '0'.")
cXgcpConnCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25))).clone(namedValues=NamedValues(("idle", 0), ("setting", 1), ("connecting", 2), ("conferencing", 3), ("active", 4), ("confDestroying", 5), ("disconnecting", 6), ("inactive", 7), ("voiceConnecting", 8), ("voiceActive", 9), ("confDissociating", 10), ("callLegsDissociated", 11), ("hpConnecting", 12), ("hpConnected", 13), ("hpConferencing", 14), ("hpActive", 15), ("voipConfDestroy", 16), ("erroState", 17), ("connectingInactive", 18), ("confDestroyingInactive", 19), ("confTest", 20), ("setupWait", 21), ("waitNseSent", 22), ("twcActive", 23), ("waitState", 24), ("handOver", 25)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnCallState.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnCallState.setDescription('Represents possible MG call states. idle - Idle setting - Incoming call from PSTN connecting - CRCX message received conferencing - Call connected, await conf active - Conference created confDestroying - Destroying conference disconnecting - Conf destroyed, disconnect call inactive - call in inactive mode voiceConnecting - Creating telephony call leg only voiceActive - Telephony call leg created confDissociating - Destroying conf callLegsDissociated - Conf destroyed hpConnecting - connecting TDM hair-pin call leg hpConnected - one HP call leg connected hpConferencing - Conferencing TDM Hairpin call leg hpActive - TDM hair-pinning active state voipConfDestroy - Conf destroyed, make HP call erroState - call in error state connectingInactive - creating inactive connection confDestroyingInactive - conf destroy inactive conn confTest - AAL2/IP continuity test setupWait - Waiting for setup information waitNseSent - Wait for NSE event to be sent twcActive - TWC call active waitState - App is waiting for call control handOver - App is grabbing back the control')
cXgcpConnCodec = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 128, 129, 130, 131, 132, 133, 134, 135, 200))).clone(namedValues=NamedValues(("notApplicable", 0), ("g711ulaw", 1), ("g711alaw", 2), ("g726k32", 3), ("g726k24", 4), ("g726k16", 5), ("g729", 6), ("g729a", 7), ("g729b", 8), ("g729bLowComp", 9), ("g728", 10), ("g723", 11), ("g7231HighRate", 12), ("g7231aHighRate", 13), ("g7231LowRate", 14), ("g7231aLowRate", 15), ("gsmFullRate", 16), ("gsmHalfRate", 17), ("gsmEnhancedFullRate", 18), ("gsmEnhancedHalfRate", 19), ("g729ab", 20), ("clearChannel", 128), ("nse", 129), ("xnse", 130), ("nte", 131), ("t38", 132), ("modemRelay", 133), ("mdsteModemRelay", 134), ("sse", 135), ("codecUnknown", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnCodec.setReference('RFC-3551')
if mibBuilder.loadTexts: cXgcpConnCodec.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnCodec.setDescription('Specifies the codec type to be used with the Call. The following codec types are defined: notApplicable - no Codec Type is defined g711ulaw - G.711 mu-law g711alaw - G.711 A-law g726k32 - G.726 32K g726k24 - G.726 24K g726k16 - G.726 16K g729 - G.729 g729a - G.729-A g729b - G.729-B g729bLowComp - G.729-B Low Complexity g728 - G.728 g723 - G.723 g7231HighRate - G.723.1 High Rate g7231aHighRate - G.723.1 Annex A High Rate g7231LowRate - G.723.1 Low Rate g7231aLowRate - G.723.1 Annex A Low Rate gsmFullRate - GSM full rate gsmHalfRate - GSM half rate gsmEnhancedFullRate - GSM enhanced full rate gsmEnhancedHalfRate - GSM enhanced half rate g729ab - G.729-A-B. clearChannel - Nx64 clear channel nse - For NSE xnse - For X-NSE nte - For telephone-event t38 - T-38 modemRelay - Modem Relay mdsteModemRelay - For X+mdste sse - For SSE codecUnknown - Unknown Codec')
cXgcpConnLastSuccEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 11), CXgcpCallEvent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnLastSuccEvent.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnLastSuccEvent.setDescription('A call event is defined as something that happens to a call at a given time. This object contains the latest MG call event that was successful.')
cXgcpConnLastSuccIntEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 12), CXgcpCallEvent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnLastSuccIntEvent.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnLastSuccIntEvent.setDescription('This object contains the latest MG internal call event that was successful.')
cXgcpConnLastFailedEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 13), CXgcpCallEvent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnLastFailedEvent.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnLastFailedEvent.setDescription('This object contains the latest MG call event that was failed.')
cXgcpConnLastReqEvent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 14), CXgcpCallEvent()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnLastReqEvent.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnLastReqEvent.setDescription('This object contains the latest requested MG call event.')
cXgcpConnEventResult = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 50, 51, 52, 53, 54, 55, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 90, 91, 92, 93, 94, 95, 96, 97, 98, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 115, 120, 130, 131, 132, 133, 140, 141, 142, 143, 144, 145, 146))).clone(namedValues=NamedValues(("normalOk", 0), ("invalidOk", 1), ("callRecordReleased", 2), ("invalidCallId", 10), ("invalidConnId", 11), ("duplicatedMsg", 12), ("ackFailure", 13), ("deleteFailure", 14), ("createAckFailure", 15), ("createAckMissing", 16), ("deleteAckFailure", 17), ("notifyFailure", 18), ("invalidState", 19), ("invalidProtocolVer", 20), ("tgwDown", 30), ("tgwNotReady", 31), ("callVdbFailure", 32), ("prevRtpPortLocked", 33), ("connRecordMissing", 34), ("endPointNotRdy", 35), ("memResourceError", 36), ("callCacFailure", 37), ("confRsrcError", 38), ("gwRsrcNotAvailable", 39), ("reqEventFailure", 40), ("invalidCcapiEvent", 41), ("ignoreCcapiEvent", 42), ("signalFailure", 50), ("abnormalOnhook", 51), ("invalidOffhook", 52), ("invalidCot", 53), ("cotFailure", 54), ("cotDisableFailure", 55), ("callSetupReqFailure", 60), ("callSetupIndFailure", 61), ("callContextFailure", 62), ("callPeerFailure", 63), ("callVoxCallFailure", 64), ("callVoipCallFailure", 65), ("callDiscFailure", 66), ("callModifyFailure", 67), ("callAlertFailure", 68), ("callDeleteFailure", 69), ("callUnknownFeature", 70), ("upSupportedCodec", 71), ("noDigitMap", 72), ("ignoreDigit", 73), ("digitsOverflow", 74), ("digitsNotifyFailure", 75), ("codecNotMatched", 76), ("invalidConnMode", 77), ("glare", 78), ("peerMissing", 90), ("peerNotReady", 91), ("peerInWrongState", 92), ("peerDisconnectFailure", 93), ("noConferenceId", 94), ("confCreateFailure", 95), ("confDestroyFailure", 96), ("unknownConnType", 97), ("invalidEndpoint", 98), ("invalidNseEvent", 100), ("nseRcvdOnWrongLeg", 101), ("sendNseFailure", 102), ("playToneFailure", 103), ("codecSpecInError", 104), ("mediaSpecUpsupported", 105), ("mediaChangeFail", 106), ("invalidNsePayload", 107), ("nsePayloadNotAvail", 108), ("embMdcxError", 109), ("mdcxLeg1Error", 110), ("mdcxLeg2Error", 111), ("deferMsg", 112), ("transError", 115), ("discOnWrongLeg", 120), ("invalidNteEvent", 130), ("notEnabledNteEvent", 131), ("nteEventExecuteFail", 132), ("sendNteFailure", 133), ("invalidSsePayload", 140), ("ssePayloadNotAvailable", 141), ("invalidModemRelayParam", 142), ("modemRelayNotSupported", 143), ("invalidXcapXcpar", 144), ("invalidSprtPayload", 145), ("sprtPayloadNotAvailable", 146)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnEventResult.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnEventResult.setDescription("Represents possible MG call event results. normalOk - Normal event processed OK invalidOk - Invalid event processed OK callRecordReleased - The call record is released invalidCallId - TGW find invalid call id invalidConnId - TGW find invalid connection id duplicatedMsg - TGW find duplicated sgcp msg ackFailure - TGW can't send sgcp ack msg deleteFailure - TGW can't send sgcp delete msg createAckFailure - TGW can't send create ack msg createAckMissing - TGW did't send sgcp ack msg deleteAckFailure - TGW can't send delete ack msg notifyFailure - TGW can't send sgcp notify msg invalidState - TGW find event in wrong state invalidProtocolVer - GW finds protocl ver. not supported tgwDown - TGW in graceful shutdown mode tgwNotReady - TGW not ready for the event callVdbFailure - TGW can't obtain the vdbptr prevRtpPortLocked - TGW find previous rtp port locked connRecordMissing - TGW can't find conn record endPointNotRdy - TGW not ready for the event memResourceError - TGW has transient mem alloc err callCacFailure - GW does not have the bandwidth confRsrcError - GW cannot get conf resource gwRsrcNotAvailable - GW does not have available resource reqEventFailure - TGW can't handle requested event invalidCcapiEvent - TGW can't handle the ccapi event ignoreCcapiEvent - TGW will ignore the ccapi event signalFailure - TGW can't handle the signal abnormalOnhook - TGW find abnormal onhook invalidOffhook - TGW find invalid offhook invalidCot - TGW find invalid cot cotFailure - TGW failed to do COT cotDisableFailure - TGW failed to disable COT callSetupReqFailure - TGW can't setup call request callSetupIndFailure - TGW can't handle call indication callContextFailure - TGW can't setup the context callPeerFailure - TGW can't setup the peer callVoxCallFailure - TGW can't setup the voip/voaal2 call callVoipCallFailure - TGW can't setup the voip call callDiscFailure - TGW can't disconnect the call callModifyFailure - TGW can't modify the call parm callAlertFailure - TGW can't alert the call callDeleteFailure - TGW can't delete the call callUnknownFeature - TGW can't handle unknow feature upSupportedCodec - TGW find unsupported codec noDigitMap - TGW can't find the digit map ignoreDigit - TGW can't process the digits digitsOverflow - TGW can't handle too many digits digitsNotifyFailure - TGW can't send the digits out codecNotMatched - TGW codec doesn't match rmt TGW invalidConnMode - TGW can't understand con mode glare - GW encountered a glare condition peerMissing - TGW find not find the peer peerNotReady - TGW find peer not ready peerInWrongState - TGW find the peer in wrong state peerDisconnectFailure - TGW can't disconnect the peer noConferenceId - TGW can't find the conference ID confCreateFailure - TGW can't create conference confDestroyFailure - TGW can't destroy conference unknownConnType - TGW can't handle the con type invalidEndpoint - TGW can't connect to endpoint invalidNseEvent - Invalid NSE event nseRcvdOnWrongLeg - The NSE events come to a wrong leg sendNseFailure - Cannot send an NSE event playToneFailure - Cannot play NSE-requested tone codecSpecInError - Codec list provided in error mediaSpecUpsupported - Media specified not supported mediaChangeFail - Media change failed invalidNsePayload - Invalid payload type in SDP nsePayloadNotAvail - Specified NSE payload not free embMdcxError - Emb modify connection error mdcxLeg1Error - Modify connection leg1 error mdcxLeg2Error - Modify connection leg2 error deferMsg - For deferring events transError - TGW endpoint in transition state discOnWrongLeg - Disconnection on wrong call leg invalidNteEvent - Invalid NTE event notEnabledNteEvent - The NTE event has not been enabled for use nteEventExecuteFail - NTE execution failed sendNteFailure - Cannot send an NTE event invalidSsePayload - Invalid SSE payload ssePayloadNotAvailable - SSE payload is not available invalidModemRelayParam - Invalid Modem Relay Param modemRelayNotSupported - Modem Relay not supported in endpt invalidXcapXcpar - Invalid X-Cap or X-Cpar in SDP invalidSprtPayload - Invalid SPRT payload sprtPayloadNotAvailable - SPRT payload is not available")
cXgcpConnEncrSuite = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 318, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("aes128Cm", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cXgcpConnEncrSuite.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnEncrSuite.setDescription('Specifies what type of encryption suite is used to encode the information sent through this connection. none - No Encryption suite is used aes128Cm - AES-128 countermode encryption suite is used.')
cXgcpMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 2))
cXgcpMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 1))
cXgcpMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2))
ciscoXgcpMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 1, 1)).setObjects(("CISCO-XGCP-MIB", "cXgcpMgcConfigGroup"), ("CISCO-XGCP-MIB", "cXgcpMediaGwGroup"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoXgcpMIBCompliance = ciscoXgcpMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoXgcpMIBCompliance.setDescription('The compliance statement for the SNMPv2 entities which implement XGCP. This has been replaced by ciscoXgcpMIBComplianceRev1. ')
ciscoXgcpMIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 1, 2)).setObjects(("CISCO-XGCP-MIB", "cXgcpMgcConfigGroup"), ("CISCO-XGCP-MIB", "cXgcpMediaGwGroup"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoXgcpMIBComplianceRev1 = ciscoXgcpMIBComplianceRev1.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoXgcpMIBComplianceRev1.setDescription('The compliance statement for the SNMPv2 entities which implement CISCO-XGCP-MIB. ')
ciscoXgcpMIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 1, 3)).setObjects(("CISCO-XGCP-MIB", "cXgcpMgcConfigGroup"), ("CISCO-XGCP-MIB", "cXgcpMediaGwGroup"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoXgcpMIBComplianceRev2 = ciscoXgcpMIBComplianceRev2.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoXgcpMIBComplianceRev2.setDescription('The compliance statement for the SNMPv2 entities which implement CISCO-XGCP-MIB. ')
ciscoXgcpMIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 1, 4)).setObjects(("CISCO-XGCP-MIB", "cXgcpMgcConfigGroup"), ("CISCO-XGCP-MIB", "cXgcpMediaGwGroup"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsGroup"), ("CISCO-XGCP-MIB", "cXgcpStatsGroup"), ("CISCO-XGCP-MIB", "cXgcpConnectionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoXgcpMIBComplianceRev3 = ciscoXgcpMIBComplianceRev3.setStatus('current')
if mibBuilder.loadTexts: ciscoXgcpMIBComplianceRev3.setDescription('The compliance statement for the SNMPv2 entities which implement CISCO-XGCP-MIB. ')
cXgcpMgcConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 1)).setObjects(("CISCO-XGCP-MIB", "cXgcpMgcConfigMgcGrpNum"), ("CISCO-XGCP-MIB", "cXgcpMgcConfigAddress"), ("CISCO-XGCP-MIB", "cXgcpMgcConfigAddrType"), ("CISCO-XGCP-MIB", "cXgcpMgcConfigProtocolIndex"), ("CISCO-XGCP-MIB", "cXgcpMgcConfigGatewayUdpPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpMgcConfigGroup = cXgcpMgcConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cXgcpMgcConfigGroup.setDescription('This group contains the MGC objects for SGCP/MGCP that the MG connects to.')
cXgcpMediaGwGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 2)).setObjects(("CISCO-XGCP-MIB", "cXgcpMediaGwRequestTimeOut"), ("CISCO-XGCP-MIB", "cXgcpMediaGwRequestRetries"), ("CISCO-XGCP-MIB", "cXgcpMediaGwRequestRetryMethod"), ("CISCO-XGCP-MIB", "cXgcpMediaGwMaxExpTimeout"), ("CISCO-XGCP-MIB", "cXgcpMediaGwRestartMwd"), ("CISCO-XGCP-MIB", "cXgcpMediaGwRestartDelay"), ("CISCO-XGCP-MIB", "cXgcpMediaGwDefaultPackage"), ("CISCO-XGCP-MIB", "cXgcpMediaGwSupportedPackages"), ("CISCO-XGCP-MIB", "cXgcpMediaGwSimpleSdpEnabled"), ("CISCO-XGCP-MIB", "cXgcpMediaGwAckSdpEnabled"), ("CISCO-XGCP-MIB", "cXgcpMediaGwUndottedNotation"), ("CISCO-XGCP-MIB", "cXgcpMediaGwQuarantineProcess"), ("CISCO-XGCP-MIB", "cXgcpMediaGwQuarantineLoop"), ("CISCO-XGCP-MIB", "cXgcpMediaGwQuarantinePersist"), ("CISCO-XGCP-MIB", "cXgcpMediaGwPiggybackMsg"), ("CISCO-XGCP-MIB", "cXgcpMediaGwMaxMsgSize"), ("CISCO-XGCP-MIB", "cXgcpMediaGwLastFailMgcAddrType"), ("CISCO-XGCP-MIB", "cXgcpMediaGwLastFailMgcAddr"), ("CISCO-XGCP-MIB", "cXgcpMediaGwDtmfRelay"), ("CISCO-XGCP-MIB", "cXgcpMediaGwCaleaEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpMediaGwGroup = cXgcpMediaGwGroup.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwGroup.setDescription('This group contains core objects for SGCP/MGCP on the MG.')
cXgcpMsgStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 3)).setObjects(("CISCO-XGCP-MIB", "cXgcpMsgStatsMgcIPAddressType"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsMgcIPAddress"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsSuccessMessages"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsFailMessages"), ("CISCO-XGCP-MIB", "cXgcpMsgStatsIncompleteMessages"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpMsgStatsGroup = cXgcpMsgStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cXgcpMsgStatsGroup.setDescription('This group contains statistics objects for SGCP/MGCP on the MGC and the MG.')
cXgcpMediaGwGroupSup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 4)).setObjects(("CISCO-XGCP-MIB", "cXgcpMediaGwConfiguredPackages"), ("CISCO-XGCP-MIB", "cXgcpMediaGwConnOosRsipBehavior"), ("CISCO-XGCP-MIB", "cXgcpMediaGwLongDurTimer"), ("CISCO-XGCP-MIB", "cXgcpMediaGwProfile"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpMediaGwGroupSup1 = cXgcpMediaGwGroupSup1.setStatus('deprecated')
if mibBuilder.loadTexts: cXgcpMediaGwGroupSup1.setDescription('This group contains supplimentary objects for XGCP extended provisioning in the MG.')
cXgcpMediaGwGroupSup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 5)).setObjects(("CISCO-XGCP-MIB", "cXgcpMediaGwConfiguredPackages"), ("CISCO-XGCP-MIB", "cXgcpMediaGwConnOosRsipBehavior"), ("CISCO-XGCP-MIB", "cXgcpMediaGwLongDurTimer"), ("CISCO-XGCP-MIB", "cXgcpMediaGwProfile"), ("CISCO-XGCP-MIB", "cXgcpMediaGwAnnexabSdpEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpMediaGwGroupSup2 = cXgcpMediaGwGroupSup2.setStatus('current')
if mibBuilder.loadTexts: cXgcpMediaGwGroupSup2.setDescription('This group contains supplimentary objects for XGCP extended provisioning in the MG.')
cXgcpStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 6)).setObjects(("CISCO-XGCP-MIB", "cXgcpStatsUdpRxPkts"), ("CISCO-XGCP-MIB", "cXgcpStatsUdpTxPkts"), ("CISCO-XGCP-MIB", "cXgcpStatsUnRecRxPkts"), ("CISCO-XGCP-MIB", "cXgcpStatsMsgParsingErrors"), ("CISCO-XGCP-MIB", "cXgcpStatsDupAckTxMsgs"), ("CISCO-XGCP-MIB", "cXgcpStatsInvalidVerCount"), ("CISCO-XGCP-MIB", "cXgcpStatsUnknownMgcRxPkts"), ("CISCO-XGCP-MIB", "cXgcpStatsAckTxMsgs"), ("CISCO-XGCP-MIB", "cXgcpStatsNackTxMsgs"), ("CISCO-XGCP-MIB", "cXgcpStatsAckRxMsgs"), ("CISCO-XGCP-MIB", "cXgcpStatsNackRxMsgs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxCrcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccCrcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailCrcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsTxDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsTxSuccDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsTxFailDlcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxMdcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccMdcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailMdcxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxRqnts"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccRqnts"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailRqnts"), ("CISCO-XGCP-MIB", "cXgcpStatsRxAucxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccAucxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailAucxs"), ("CISCO-XGCP-MIB", "cXgcpStatsRxAueps"), ("CISCO-XGCP-MIB", "cXgcpStatsRxSuccAueps"), ("CISCO-XGCP-MIB", "cXgcpStatsRxFailAueps"), ("CISCO-XGCP-MIB", "cXgcpStatsTxRsips"), ("CISCO-XGCP-MIB", "cXgcpStatsTxSuccRsips"), ("CISCO-XGCP-MIB", "cXgcpStatsTxFailRsips"), ("CISCO-XGCP-MIB", "cXgcpStatsTxNotifies"), ("CISCO-XGCP-MIB", "cXgcpStatsTxSuccNotifies"), ("CISCO-XGCP-MIB", "cXgcpStatsTxFailNotifies"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpStatsGroup = cXgcpStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cXgcpStatsGroup.setDescription('This group contains the received and transmitted network messages for every virtual MG present in the managed system. ')
cXgcpConnectionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 318, 2, 2, 7)).setObjects(("CISCO-XGCP-MIB", "cXgcpConnEndPoint"), ("CISCO-XGCP-MIB", "cXgcpConnCallId"), ("CISCO-XGCP-MIB", "cXgcpConnLocalUdpPort"), ("CISCO-XGCP-MIB", "cXgcpConnRemoteUdpPort"), ("CISCO-XGCP-MIB", "cXgcpConnMode"), ("CISCO-XGCP-MIB", "cXgcpConnVccId"), ("CISCO-XGCP-MIB", "cXgcpConnChannelId"), ("CISCO-XGCP-MIB", "cXgcpConnCallState"), ("CISCO-XGCP-MIB", "cXgcpConnCodec"), ("CISCO-XGCP-MIB", "cXgcpConnLastSuccEvent"), ("CISCO-XGCP-MIB", "cXgcpConnLastSuccIntEvent"), ("CISCO-XGCP-MIB", "cXgcpConnLastFailedEvent"), ("CISCO-XGCP-MIB", "cXgcpConnLastReqEvent"), ("CISCO-XGCP-MIB", "cXgcpConnEventResult"), ("CISCO-XGCP-MIB", "cXgcpConnEncrSuite"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cXgcpConnectionGroup = cXgcpConnectionGroup.setStatus('current')
if mibBuilder.loadTexts: cXgcpConnectionGroup.setDescription('This group contains active connections information that are controlled by the Gateway Control Protocol. ')
mibBuilder.exportSymbols("CISCO-XGCP-MIB", cXgcpMsgStatsIncompleteMessages=cXgcpMsgStatsIncompleteMessages, CXgcpCallEvent=CXgcpCallEvent, cXgcpConnectionEntry=cXgcpConnectionEntry, ciscoXgcpMIBComplianceRev1=ciscoXgcpMIBComplianceRev1, cXgcpStatsTable=cXgcpStatsTable, cXgcpMgcConfigGroup=cXgcpMgcConfigGroup, cXgcpStatsRxAucxs=cXgcpStatsRxAucxs, cXgcpConnection=cXgcpConnection, cXgcpMediaGwQuarantineLoop=cXgcpMediaGwQuarantineLoop, cXgcpMsgStatsSuccessMessages=cXgcpMsgStatsSuccessMessages, cXgcpMediaGwConnOosRsipBehavior=cXgcpMediaGwConnOosRsipBehavior, cXgcpMediaGwTable=cXgcpMediaGwTable, cXgcpStatsRxFailMdcxs=cXgcpStatsRxFailMdcxs, cXgcpMgcConfigTable=cXgcpMgcConfigTable, cXgcpConnLastSuccEvent=cXgcpConnLastSuccEvent, cXgcpConnChannelId=cXgcpConnChannelId, cXgcpStatsRxSuccCrcxs=cXgcpStatsRxSuccCrcxs, cXgcpMIBGroups=cXgcpMIBGroups, cXgcpStatsRxAueps=cXgcpStatsRxAueps, cXgcpMgcConfigAddrType=cXgcpMgcConfigAddrType, cXgcpStatsTxSuccDlcxs=cXgcpStatsTxSuccDlcxs, cXgcpMediaGwGroupSup2=cXgcpMediaGwGroupSup2, cXgcpMediaGwAckSdpEnabled=cXgcpMediaGwAckSdpEnabled, CXgcpRetryMethod=CXgcpRetryMethod, cXgcpConnCodec=cXgcpConnCodec, cXgcpStatsDupAckTxMsgs=cXgcpStatsDupAckTxMsgs, cXgcpConnEndPoint=cXgcpConnEndPoint, cXgcpMIBConformance=cXgcpMIBConformance, cXgcpMsgStatsMgcIPAddress=cXgcpMsgStatsMgcIPAddress, cXgcpMediaGwUndottedNotation=cXgcpMediaGwUndottedNotation, cXgcpMediaGwSimpleSdpEnabled=cXgcpMediaGwSimpleSdpEnabled, cXgcpStatsRxFailRqnts=cXgcpStatsRxFailRqnts, ciscoXgcpMIBCompliance=ciscoXgcpMIBCompliance, ciscoXgcpMIBComplianceRev2=ciscoXgcpMIBComplianceRev2, cXgcpStatsRxFailAucxs=cXgcpStatsRxFailAucxs, cXgcpStatsUnRecRxPkts=cXgcpStatsUnRecRxPkts, cXgcpConnVccId=cXgcpConnVccId, cXgcpConnCallState=cXgcpConnCallState, cXgcpStatsGroup=cXgcpStatsGroup, cXgcpStatsRxSuccMdcxs=cXgcpStatsRxSuccMdcxs, cXgcpStatsRxMdcxs=cXgcpStatsRxMdcxs, cXgcpStatsRxRqnts=cXgcpStatsRxRqnts, cXgcpStatsUnknownMgcRxPkts=cXgcpStatsUnknownMgcRxPkts, ciscoXgcpMIB=ciscoXgcpMIB, cXgcpMediaGwRequestTimeOut=cXgcpMediaGwRequestTimeOut, cXgcpConnCallId=cXgcpConnCallId, cXgcpStatsInvalidVerCount=cXgcpStatsInvalidVerCount, cXgcpMgcCfg=cXgcpMgcCfg, cXgcpMediaGwGroup=cXgcpMediaGwGroup, cXgcpStatsTxSuccNotifies=cXgcpStatsTxSuccNotifies, cXgcpStatsRxCrcxs=cXgcpStatsRxCrcxs, cXgcpStatsRxSuccAueps=cXgcpStatsRxSuccAueps, cXgcpConnId=cXgcpConnId, cXgcpMgcConfigProtocolIndex=cXgcpMgcConfigProtocolIndex, cXgcpMediaGwDefaultPackage=cXgcpMediaGwDefaultPackage, cXgcpMediaGwEntry=cXgcpMediaGwEntry, cXgcpStatsAckTxMsgs=cXgcpStatsAckTxMsgs, cXgcpMediaGwProfile=cXgcpMediaGwProfile, cXgcpStatsTxFailDlcxs=cXgcpStatsTxFailDlcxs, cXgcpMediaGwMaxMsgSize=cXgcpMediaGwMaxMsgSize, cXgcpConnLocalUdpPort=cXgcpConnLocalUdpPort, cXgcpStatsRxSuccRqnts=cXgcpStatsRxSuccRqnts, cXgcpMediaGwRestartDelay=cXgcpMediaGwRestartDelay, cXgcpMgcConfigMgcGrpNum=cXgcpMgcConfigMgcGrpNum, cXgcpStatsRxSuccAucxs=cXgcpStatsRxSuccAucxs, cXgcpConnLastReqEvent=cXgcpConnLastReqEvent, cXgcpMediaGwSupportedPackages=cXgcpMediaGwSupportedPackages, cXgcpConnLastSuccIntEvent=cXgcpConnLastSuccIntEvent, cXgcpConnEncrSuite=cXgcpConnEncrSuite, cXgcpStatsRxDlcxs=cXgcpStatsRxDlcxs, cXgcpConnMode=cXgcpConnMode, cXgcpMediaGwLastFailMgcAddr=cXgcpMediaGwLastFailMgcAddr, cXgcpStatsNackTxMsgs=cXgcpStatsNackTxMsgs, cXgcpStats=cXgcpStats, cXgcpMediaGwConfiguredPackages=cXgcpMediaGwConfiguredPackages, cXgcpStatsRxFailCrcxs=cXgcpStatsRxFailCrcxs, cXgcpStatsRxFailDlcxs=cXgcpStatsRxFailDlcxs, cXgcpMediaGwPiggybackMsg=cXgcpMediaGwPiggybackMsg, cXgcpConnectionTable=cXgcpConnectionTable, cXgcpMgcConfigAddress=cXgcpMgcConfigAddress, cXgcpMediaGwRequestRetries=cXgcpMediaGwRequestRetries, cXgcpMediaGwLastFailMgcAddrType=cXgcpMediaGwLastFailMgcAddrType, cXgcpStatsTxNotifies=cXgcpStatsTxNotifies, cXgcpStatsTxFailRsips=cXgcpStatsTxFailRsips, cXgcpConnEventResult=cXgcpConnEventResult, cXgcpStatsRxSuccDlcxs=cXgcpStatsRxSuccDlcxs, cXgcpMsgStatsFailMessages=cXgcpMsgStatsFailMessages, cXgcpMsgStatsIndex=cXgcpMsgStatsIndex, cXgcpStatsTxFailNotifies=cXgcpStatsTxFailNotifies, cXgcpStatsMsgParsingErrors=cXgcpStatsMsgParsingErrors, cXgcpStatsUdpRxPkts=cXgcpStatsUdpRxPkts, cXgcpConnRemoteUdpPort=cXgcpConnRemoteUdpPort, cXgcpStatsTxRsips=cXgcpStatsTxRsips, cXgcpMediaGwCaleaEnabled=cXgcpMediaGwCaleaEnabled, cXgcpStatsRxFailAueps=cXgcpStatsRxFailAueps, cXgcpMIBCompliances=cXgcpMIBCompliances, cXgcpNotifications=cXgcpNotifications, cXgcpStatsAckRxMsgs=cXgcpStatsAckRxMsgs, cXgcpConnLastFailedEvent=cXgcpConnLastFailedEvent, cXgcpMsgStatsGroup=cXgcpMsgStatsGroup, cXgcpMediaGwGroupSup1=cXgcpMediaGwGroupSup1, cXgcpMsgStatsMgcIPAddressType=cXgcpMsgStatsMgcIPAddressType, cXgcpMediaGwDtmfRelay=cXgcpMediaGwDtmfRelay, cXgcpMsgStatsTable=cXgcpMsgStatsTable, cXgcpConnectionGroup=cXgcpConnectionGroup, cXgcpMgcConfigEntry=cXgcpMgcConfigEntry, cXgcpObjects=cXgcpObjects, cXgcpMediaGw=cXgcpMediaGw, cXgcpMediaGwRestartMwd=cXgcpMediaGwRestartMwd, cXgcpMediaGwAnnexabSdpEnabled=cXgcpMediaGwAnnexabSdpEnabled, cXgcpMsgStatsEntry=cXgcpMsgStatsEntry, ciscoXgcpMIBComplianceRev3=ciscoXgcpMIBComplianceRev3, cXgcpMediaGwQuarantinePersist=cXgcpMediaGwQuarantinePersist, cXgcpStatsEntry=cXgcpStatsEntry, cXgcpMediaGwMaxExpTimeout=cXgcpMediaGwMaxExpTimeout, cXgcpMediaGwRequestRetryMethod=cXgcpMediaGwRequestRetryMethod, cXgcpStatsTxDlcxs=cXgcpStatsTxDlcxs, cXgcpMgcConfigGatewayUdpPort=cXgcpMgcConfigGatewayUdpPort, PYSNMP_MODULE_ID=ciscoXgcpMIB, cXgcpStatsUdpTxPkts=cXgcpStatsUdpTxPkts, cXgcpMediaGwQuarantineProcess=cXgcpMediaGwQuarantineProcess, cXgcpStatsTxSuccRsips=cXgcpStatsTxSuccRsips, cXgcpStatsNackRxMsgs=cXgcpStatsNackRxMsgs, cXgcpMediaGwLongDurTimer=cXgcpMediaGwLongDurTimer)

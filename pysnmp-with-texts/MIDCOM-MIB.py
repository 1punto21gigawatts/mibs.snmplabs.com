#
# PySNMP MIB module MIDCOM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MIDCOM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:12:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddress, InetPortNumber, InetAddressType, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetPortNumber", "InetAddressType", "InetAddressPrefixLength")
NatBindIdOrZero, = mibBuilder.importSymbols("NAT-MIB", "NatBindIdOrZero")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Gauge32, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, mib_2, IpAddress, ModuleIdentity, TimeTicks, iso, ObjectIdentity, NotificationType, Integer32, Unsigned32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "mib-2", "IpAddress", "ModuleIdentity", "TimeTicks", "iso", "ObjectIdentity", "NotificationType", "Integer32", "Unsigned32", "Counter32")
TruthValue, DisplayString, StorageType, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "StorageType", "TextualConvention", "RowStatus")
midcomMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 171))
midcomMIB.setRevisions(('2007-08-09 10:11',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: midcomMIB.setRevisionsDescriptions(('Initial version, published as RFC 5190.',))
if mibBuilder.loadTexts: midcomMIB.setLastUpdated('200708091011Z')
if mibBuilder.loadTexts: midcomMIB.setOrganization('IETF Middlebox Communication Working Group')
if mibBuilder.loadTexts: midcomMIB.setContactInfo('WG charter: http://www.ietf.org/html.charters/midcom-charter.html Mailing Lists: General Discussion: midcom@ietf.org To Subscribe: midcom-request@ietf.org In Body: subscribe your_email_address Co-editor: Juergen Quittek NEC Europe Ltd. Kurfuersten-Anlage 36 69115 Heidelberg Germany Tel: +49 6221 4342-115 Email: quittek@nw.neclab.eu Co-editor: Martin Stiemerling NEC Europe Ltd. Kurfuersten-Anlage 36 69115 Heidelberg Germany Tel: +49 6221 4342-113 Email: stiemerling@nw.neclab.eu Co-editor: Pyda Srisuresh Kazeon Systems, Inc. 1161 San Antonio Rd. Mountain View, CA 94043 U.S.A. Tel: +1 408 836-4773 Email: srisuresh@yahoo.com')
if mibBuilder.loadTexts: midcomMIB.setDescription('This MIB module defines a set of basic objects for configuring middleboxes, such as firewalls and network address translators, in order to enable communication across these devices. Managed objects defined in this MIB module are structured in three kinds of objects: - transaction objects required according to the MIDCOM protocol requirements defined in RFC 3304 and according to the MIDCOM protocol semantics defined in RFC 3989, - configuration objects that can be used for retrieving or setting parameters of the implementation of transaction objects, - optional monitoring objects that provide information about used resource and statistics The transaction objects are organized in two subtrees: - objects modeling MIDCOM policy rules in the midcomRuleTable - objects modeling MIDCOM policy rule groups in the midcomGroupTable Note that typically, configuration objects are not intended to be written by MIDCOM clients. In general, write access to these objects needs to be restricted more strictly than write access to objects in the transaction subtrees. Copyright (C) The Internet Society (2008). This version of this MIB module is part of RFC 5190; see the RFC itself for full legal notices.')
midcomNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 0))
midcomObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 1))
midcomConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 2))
midcomTransaction = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 1, 1))
midcomConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 1, 2))
midcomMonitoring = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 1, 3))
midcomRuleTable = MibTable((1, 3, 6, 1, 2, 1, 171, 1, 1, 3), )
if mibBuilder.loadTexts: midcomRuleTable.setStatus('current')
if mibBuilder.loadTexts: midcomRuleTable.setDescription('This table lists policy rules. It is indexed by the midcomRuleOwner, the midcomGroupIndex, and the midcomRuleIndex. This implies that a rule is a member of exactly one group and that group membership cannot be changed. Entries can be deleted by writing to midcomGroupLifetime or midcomRuleLifetime and potentially also to midcomRuleStorageTime.')
midcomRuleEntry = MibTableRow((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1), ).setIndexNames((0, "MIDCOM-MIB", "midcomRuleOwner"), (0, "MIDCOM-MIB", "midcomGroupIndex"), (0, "MIDCOM-MIB", "midcomRuleIndex"))
if mibBuilder.loadTexts: midcomRuleEntry.setStatus('current')
if mibBuilder.loadTexts: midcomRuleEntry.setDescription('An entry describing a particular MIDCOM policy rule.')
midcomRuleOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: midcomRuleOwner.setStatus('current')
if mibBuilder.loadTexts: midcomRuleOwner.setDescription('The manager who owns this row in the midcomRuleTable. This object SHOULD uniquely identify an authenticated MIDCOM client. This object is part of the table index to allow for the use of the SNMPv3 View-based Access Control Model (VACM, RFC 3415).')
midcomRuleIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: midcomRuleIndex.setStatus('current')
if mibBuilder.loadTexts: midcomRuleIndex.setDescription('The value of this object must be unique in combination with the values of the objects midcomRuleOwner and midcomGroupIndex in this row.')
midcomRuleAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("reserve", 1), ("enable", 2), ("notSet", 3))).clone('notSet')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleAdminStatus.setStatus('current')
if mibBuilder.loadTexts: midcomRuleAdminStatus.setDescription("The value of this object indicates the desired status of the policy rule. See the definition of midcomRuleOperStatus for a description of the values. When a midcomRuleEntry is created without explicitly setting this object, its value will be notSet(3). However, a SET request can only set this object to either reserve(1) or enable(2). Attempts to set this object to notSet(3) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. When the midcomRuleAdminStatus object is set, then the MIDCOM-MIB implementation will try to read the respective relevant objects of the entry and try to achieve the corresponding midcomRuleOperStatus. Setting midcomRuleAdminStatus to value reserve(1) when object midcomRuleOperStatus has a value of reserved(7) does not have any effect on the policy rule. Setting midcomRuleAdminStatus to value enable(2) when object midcomRuleOperStatus has a value of enabled(8) does not have any effect on the policy rule. Depending on whether the midcomRuleAdminStatus is set to reserve(1) or enable(2), several objects must be set in advance. They serve as parameters of the policy rule to be established. When object midcomRuleAdminStatus is set to reserve(1), then the following objects in the same entry are of relevance: - midcomRuleInterface - midcomRuleTransportProtocol - midcomRulePortRange - midcomRuleInternalIpVersion - midcomRuleExternalIpVersion - midcomRuleInternalIpAddr - midcomRuleInternalIpPrefixLength - midcomRuleInternalPort - midcomRuleLifetime MIDCOM-MIB implementation may also consider the value of object midcomRuleMaxIdleTime when establishing a reserve rule. When object midcomRuleAdminStatus is set to enable(2), then the following objects in the same entry are of relevance: - midcomRuleInterface - midcomRuleFlowDirection - midcomRuleMaxIdleTime - midcomRuleTransportProtocol - midcomRulePortRange - midcomRuleInternalIpVersion - midcomRuleExternalIpVersion - midcomRuleInternalIpAddr - midcomRuleInternalIpPrefixLength - midcomRuleInternalPort - midcomRuleExternalIpAddr - midcomRuleExternalIpPrefixLength - midcomRuleExternalPort - midcomRuleLifetime When retrieved, the object returns the last set value. If no value has been set, it returns the default value notSet(3).")
midcomRuleOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("newEntry", 1), ("setting", 2), ("checkingRequest", 3), ("incorrectRequest", 4), ("processingRequest", 5), ("requestRejected", 6), ("reserved", 7), ("enabled", 8), ("timedOut", 9), ("terminatedOnRequest", 10), ("terminated", 11), ("genericError", 12))).clone('newEntry')).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleOperStatus.setStatus('current')
if mibBuilder.loadTexts: midcomRuleOperStatus.setDescription('The actual status of the policy rule. The midcomRuleOperStatus object may have the following values: - newEntry(1) indicates that the entry in the midcomRuleTable was created, but not modified yet. Such an entry needs to be filled with values specifying a request first. - setting(2) indicates that the entry has been already modified after generating it, but no request was made yet. - checkingRequest(3) indicates that midcomRuleAdminStatus has recently been set and that the MIDCOM-MIB implementation is currently checking the parameters of the request. This is a transient state. The value of this object will change to either incorrectRequest(4) or processingRequest(5) without any external interaction. A MIDCOM-MIB implementation MAY return this value while checking request parameters. - incorrectRequest(4) indicates that checking a request resulted in detecting an incorrect value in one of the objects containing request parameters. The failure reason is indicated by the value of midcomRuleError. - processingRequest(5) indicates that midcomRuleAdminStatus has recently been set and that the MIDCOM-MIB implementation is currently processing the request and trying to configure the middlebox accordingly. This is a transient state. The value of this object will change to either requestRejected(6), reserved(7), or enabled(8) without any external interaction. A MIDCOM-MIB implementation MAY return this value while processing a request. - requestRejected(6) indicates that a request to establish a policy rule specified by the entry was rejected. The reason for rejection is indicated by the value of midcomRuleError. - reserved(7) indicates that the entry describes an established policy reserve rule. These values of MidcomRuleEntry are meaningful for a reserved policy rule: - midcomRuleMaxIdleTime - midcomRuleInterface - midcomRuleTransportProtocol - midcomRulePortRange - midcomRuleInternalIpVersion - midcomRuleExternalIpVersion - midcomRuleInternalIpAddr - midcomRuleInternalIpPrefixLength - midcomRuleInternalPort - midcomRuleOutsideIpAddr - midcomRuleOutsidePort - midcomRuleLifetime - enabled(8) indicates that the entry describes an established policy enable rule. These values of MidcomRuleEntry are meaningful for an enabled policy rule: - midcomRuleFlowDirection - midcomRuleInterface - midcomRuleMaxIdleTime - midcomRuleTransportProtocol - midcomRulePortRange - midcomRuleInternalIpVersion - midcomRuleExternalIpVersion - midcomRuleInternalIpAddr - midcomRuleInternalIpPrefixLength - midcomRuleInternalPort - midcomRuleExternalIpAddr - midcomRuleExternalIpPrefixLength - midcomRuleExternalPort - midcomRuleInsideIpAddr - midcomRuleInsidePort - midcomRuleOutsideIpAddr - midcomRuleOutsidePort - midcomRuleLifetime - timedOut(9) indicates that the lifetime of a previously established policy rule has expired and that the policy rule is terminated for this reason. - terminatedOnRequest(10) indicates that a previously established policy rule was terminated by an SNMP manager setting the midcomRuleLifetime to 0 or setting midcomGroupLifetime to 0. - terminated(11) indicates that a previously established policy rule was terminated by the MIDCOM-MIB implementation for a reason other than lifetime expiration or an explicit request from a MIDCOM client. - genericError(12) indicates that the policy rule specified by the entry is not established due to an error condition not listed above. The states timedOut(9), terminatedOnRequest(10), and terminated(11) are referred to as termination states. The states incorrectRequest(4), requestRejected(6), and genericError(12) are referred to as error states. The checkingRequest(3) and processingRequest(5) states are transient states, which will lead to either one of the error states or the reserved(7) state or the enabled(8) state. MIDCOM-MIB implementations MAY return these values when checking or processing requests.')
midcomRuleStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 6), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleStorageType.setStatus('current')
if mibBuilder.loadTexts: midcomRuleStorageType.setDescription("When retrieved, this object returns the storage type of the policy rule. Writing to this object can change the storage type of the particular row from volatile(2) to nonVolatile(3) or vice versa. Attempts to set this object to permanent will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If midcomRuleStorageType has the value permanent(4), then all objects in this row whose MAX-ACCESS value is read-create must be read-only.")
midcomRuleStorageTime = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 7), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleStorageTime.setStatus('current')
if mibBuilder.loadTexts: midcomRuleStorageTime.setDescription('The value of this object specifies how long this row can exist in the midcomRuleTable after the midcomRuleOperStatus switched to a termination state or to an error state. This object returns the remaining time that the row may exist before it is aged out. After expiration or termination of the context, the value of this object ticks backwards. The entry in the midcomRuleTable is destroyed when the value reaches 0. The value of this object may be set in order to increase or reduce the remaining time that the row may exist. Setting the value to 0 will destroy this entry as soon as the midcomRuleOperStatus switched to a termination state or to an error state. Note that there is no guarantee that the row is stored as long as this object indicates. At any time, the MIDCOM- MIB implementation may decide to remove a row describing a terminated policy rule before the storage time of the corresponding row in the midcomRuleTable reaches the value of 0. In this case, the information stored in this row is not available anymore. If object midcomRuleStorageType indicates that the policy rule has the storage type permanent(4), then this object has a constant value of 4294967295.')
midcomRuleError = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 8), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleError.setReference('RFC 3989, sections 2.3.9 and 2.3.10')
if mibBuilder.loadTexts: midcomRuleError.setStatus('current')
if mibBuilder.loadTexts: midcomRuleError.setDescription("This object contains a descriptive error message if the transition into the operational status reserved(7) or enabled(8) failed. Implementations must reset the error message to a zero-length string when a new attempt to change the policy rule status to reserved(7) or enabled(8) is started. RECOMMENDED values to be returned in particular cases include - 'lack of IP addresses' - 'lack of port numbers' - 'lack of resources' - 'specified NAT interface does not exist' - 'specified NAT interface does not support NAT' - 'conflict with already existing policy rule' - 'no internal IP wildcarding allowed' - 'no external IP wildcarding allowed' The semantics of these error messages and the corresponding behavior of the MIDCOM-MIB implementation are specified in sections 2.3.9 and 2.3.10 of RFC 3989.")
midcomRuleInterface = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleInterface.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInterface.setDescription("This object indicates the IP interface for which enforcement of a policy rule is requested or performed, respectively. The interface is identified by its index in the ifTable (see IF-MIB in RFC 2863). If the object has a value of 0, then no particular interface is indicated. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to request its preference concerning the interface at which it requests NAT service. The default value of 0 indicates that the manager does not have a preferred interface or does not have sufficient topology information for specifying one. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object indicates the interface at which NAT service for this rule is performed. If NAT service is not required for enforcing the policy rule, then the value of this object is 0. Also, if the MIDCOM-MIB implementation cannot indicate an interface, because it does not have this information or because NAT service is not offered at a particular single interface, then the value of the object is 0. Note that the index of a particular interface in the ifTable may change after a re-initialization of the middlebox, for example, after adding another interface to it. In such a case, the value of this object may change, but the interface referred to by the MIDCOM-MIB MUST still be the same. If, after a re-initialization of the middlebox, the interface referred to before re-initialization cannot be uniquely mapped anymore to a particular entry in the ifTable, then the value of object midcomRuleOperStatus of the same entry MUST be changed to terminated(11). If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleFlowDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2), ("biDirectional", 3))).clone('outbound')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleFlowDirection.setStatus('current')
if mibBuilder.loadTexts: midcomRuleFlowDirection.setDescription("This parameter specifies the direction of enabled communication, either inbound(1), outbound(2), or biDirectional(3). The semantics of this object depends on the protocol the rule relates to. If the rule is independent of the transport protocol (midcomRuleTransportProtocol has a value of 0) or if the transport protocol is UDP, then the value of midcomRuleFlowDirection indicates the direction of packets traversing the middlebox. In this case, value inbound(1) indicates that packets are traversing from outside to inside, value outbound(2) indicates that packets are traversing from inside to outside. For both values, inbound(1) and outbound(2) packets can traverse the middlebox only unidirectional. A bidirectional flow is indicated by value biDirectional(3). If the transport protocol is TCP, the packet flow is always bidirectional, but the value of midcomRuleFlowDirection indicates that: - inbound(1): bidirectional TCP packet flow. First packet, with TCP SYN flag set, must arrive at an outside interface of the middlebox. - outbound(2): bidirectional TCP packet flow. First packet, with TCP SYN flag set, must arrive at an inside interface of the middlebox. - biDirectional(3): bidirectional TCP packet flow. First packet, with TCP SYN flag set, may arrive at an inside or an outside interface of the middlebox. This object is used as input to a request for establishing a policy enable rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has a value of either newEntry(1), setting(2), or reserved(7), then this object can be written by a manager in order to specify a requested direction to be enabled by a policy rule. Writing to this object in any state other than newEntry(1), setting(2), or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value enabled(8), then this object indicates the enabled flow direction. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleMaxIdleTime = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 11), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleMaxIdleTime.setStatus('current')
if mibBuilder.loadTexts: midcomRuleMaxIdleTime.setDescription("Maximum idle time of the policy rule in seconds. If no packet to which the policy rule applies passes the middlebox for the specified midcomRuleMaxIdleTime, then the policy rule enters the termination state timedOut(9). A value of 0 indicates that the policy does not require an individual idle time and that instead, a default idle time chosen by the middlebox is used. A value of 4294967295 ( = 2^32 - 1 ) indicates that the policy does not time out if it is idle. This object is used as input to a request for establishing a policy enable rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has a value of either newEntry(1), setting(2), or reserved(7), then this object can be written by a manager in order to specify a maximum idle time for the policy rule to be requested. Writing to this object in any state others than newEntry(1), setting(2), or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value enabled(8), then this object indicates the maximum idle time of the policy rule. Note that even if a maximum idle time greater than zero was requested, the middlebox may not be able to support maximum idle times and set the value of this object to zero when entering state enabled(8). If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleTransportProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleTransportProtocol.setStatus('current')
if mibBuilder.loadTexts: midcomRuleTransportProtocol.setDescription("The transport protocol. Valid values for midcomRuleTransportProtocol other than zero are defined at: http://www.iana.org/assignments/protocol-numbers This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has a value of either newEntry(1) or setting(2), then this object can be written by a manager in order to specify a requested transport protocol. If translation of an IP address only is requested, then this object must have the default value 0. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object indicates which transport protocol is enforced by this policy rule. A value of 0 indicates a rule acting on IP addresses only. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRulePortRange = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("single", 1), ("pair", 2))).clone('single')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRulePortRange.setStatus('current')
if mibBuilder.loadTexts: midcomRulePortRange.setDescription("The range of port numbers. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. It is relevant to the operation of the MIDCOM-MIB implementation only if the value of object midcomTransportProtocol in the same entry has a value other than 0. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the requested size of the port range. With single(1) just a single port number is requested, with pair(2) a consecutive pair of port numbers is requested with the lower number being even. Requesting a consecutive pair of port numbers may be used by RTP [RFC3550] and may even be required to support older RTP applications. Writing to this object in any state other than newEntry(1), setting(2) or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8), then this object will have the value that it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleInternalIpVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 14), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleInternalIpVersion.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInternalIpVersion.setDescription("IP version of the internal address (A0) and the inside address (A1). Allowed values are ipv4(1), ipv6(2), ipv4z(3), and ipv6z(4). This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the IP version required at the inside of the middlebox. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object indicates the internal/inside IP version. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleExternalIpVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 15), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleExternalIpVersion.setStatus('current')
if mibBuilder.loadTexts: midcomRuleExternalIpVersion.setDescription("IP version of the external address (A3) and the outside address (A2). Allowed values are ipv4(1) and ipv6(2). This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the IP version required at the outside of the middlebox. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object indicates the external/outside IP version. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7) or enabled(8), then the value of this object is irrelevant.")
midcomRuleInternalIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 16), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleInternalIpAddr.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInternalIpAddr.setDescription("The internal IP address (A0). This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the internal IP address for which a reserve policy rule or a enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object will have the value which it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7) or enabled(8), then the value of this object is irrelevant.")
midcomRuleInternalIpPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 17), InetAddressPrefixLength().clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleInternalIpPrefixLength.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInternalIpPrefixLength.setDescription("The prefix length of the internal IP address used for wildcarding. A value of 0 indicates a full wildcard; in this case, the value of midcomRuleInternalIpAddr is irrelevant. If midcomRuleInternalIpVersion has a value of ipv4(1), then a value > 31 indicates no wildcarding at all. If midcomRuleInternalIpVersion has a value of ipv4(2), then a value > 127 indicates no wildcarding at all. A MIDCOM-MIB implementation that does not support IP address wildcarding MUST implement this object as read-only with a value of 128. A MIDCOM that does not support wildcarding based on prefix length MAY restrict allowed values for this object to 0 and 128. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the prefix length of the internal IP address for which a reserve policy rule or an enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object will have the value which it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleInternalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 18), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleInternalPort.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInternalPort.setDescription("The internal port number. A value of 0 is a wildcard. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. It is relevant to the operation of the MIDCOM-MIB implementation only if the value of object midcomTransportProtocol in the same entry has a value other than 0. If object midcomRuleOperStatus of the same entry has the value newEntry(1) or setting(2), then this object can be written by a manager in order to specify the internal port number for which a reserve policy rule or an enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1) or setting(2) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value reserved(7) or enabled(8), then this object will have the value that it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleExternalIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 19), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleExternalIpAddr.setStatus('current')
if mibBuilder.loadTexts: midcomRuleExternalIpAddr.setDescription("The external IP address (A3). This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1), setting(2), or reserved(7), then this object can be written by a manager in order to specify the external IP address for which an enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1), setting(2), or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value enabled(8), then this object will have the value that it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleExternalIpPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 20), InetAddressPrefixLength().clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleExternalIpPrefixLength.setStatus('current')
if mibBuilder.loadTexts: midcomRuleExternalIpPrefixLength.setDescription("The prefix length of the external IP address used for wildcarding. A value of 0 indicates a full wildcard; in this case, the value of midcomRuleExternalIpAddr is irrelevant. If midcomRuleExternalIpVersion has a value of ipv4(1), then a value > 31 indicates no wildcarding at all. If midcomRuleExternalIpVersion has a value of ipv4(2), then a value > 127 indicates no wildcarding at all. A MIDCOM-MIB implementation that does not support IP address wildcarding MUST implement this object as read-only with a value of 128. A MIDCOM that does not support wildcarding based on prefix length MAY restrict allowed values for this object to 0 and 128. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has the value newEntry(1), setting(2), or reserved(7), then this object can be written by a manager in order to specify the prefix length of the external IP address for which an enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1), setting(2), or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value enabled(8), then this object will have the value that it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleExternalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 21), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleExternalPort.setStatus('current')
if mibBuilder.loadTexts: midcomRuleExternalPort.setDescription("The external port number. A value of 0 is a wildcard. This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. It is relevant to the operation of the MIDCOM-MIB implementation only if the value of object midcomTransportProtocol in the same entry has a value other than 0. If object midcomRuleOperStatus of the same entry has the value newEntry(1), setting(2) or reserved(7), then this object can be written by a manager in order to specify the external port number for which an enable policy rule is requested to be established. Writing to this object in any state other than newEntry(1), setting(2) or reserved(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has the value enabled(8), then this object will have the value which it had before the transition to this state. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7) or enabled(8), then the value of this object is irrelevant.")
midcomRuleInsideIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 22), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleInsideIpAddr.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInsideIpAddr.setDescription('The inside IP address at the middlebox (A1). The value of this object is relevant only if object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8).')
midcomRuleInsidePort = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 23), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleInsidePort.setStatus('current')
if mibBuilder.loadTexts: midcomRuleInsidePort.setDescription('The inside port number at the middlebox. A value of 0 is a wildcard. The value of this object is relevant only if object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8).')
midcomRuleOutsideIpAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 24), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleOutsideIpAddr.setStatus('current')
if mibBuilder.loadTexts: midcomRuleOutsideIpAddr.setDescription('The outside IP address at the middlebox (A2). The value of this object is relevant only if object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8).')
midcomRuleOutsidePort = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 25), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRuleOutsidePort.setStatus('current')
if mibBuilder.loadTexts: midcomRuleOutsidePort.setDescription('The outside port number at the middlebox. A value of 0 is a wildcard. The value of this object is relevant only if object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8).')
midcomRuleLifetime = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 26), Unsigned32().clone(180)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleLifetime.setStatus('current')
if mibBuilder.loadTexts: midcomRuleLifetime.setDescription("The remaining lifetime in seconds of this policy rule. Lifetime of a policy rule starts when object midcomRuleOperStatus in the same entry enters either state reserved(7) or state enabled(8). This object is used as input to a request for establishing a policy rule as well as for indicating the properties of an established policy rule. If object midcomRuleOperStatus of the same entry has a value of either newEntry(1) or setting(2), then this object can be written by a manager in order to specify the requested lifetime of a policy rule to be established. If object midcomRuleOperStatus of the same entry has a value of either reserved(7) or enabled(8), then this object indicates the (continuously decreasing) remaining lifetime of the established policy rule. Note that when entering state reserved(7) or enabled(8), the MIDCOM-MIB implementation can choose a lifetime shorter than the one requested. Unlike other parameters of the policy rule, this parameter can still be written in state reserved(7) and enabled(8). Writing to this object is processed by the MIDCOM-MIB implementation by choosing a lifetime value that is greater than 0 and less than or equal to the minimum of the requested value and the value specified by object midcomConfigMaxLifetime: 0 <= lt_granted <= MINIMUM(lt_requested, lt_maximum) where: - lt_granted is the actually granted lifetime by the MIDCOM-MIB implementation - lt_requested is the requested lifetime of the MIDCOM client - lt_maximum is the value of object midcomConfigMaxLifetime SNMP SET requests to this object may be rejected or the value of the object after an accepted SET operation may be less than the value that was contained in the SNMP SET request. Successfully writing a value of 0 terminates the policy rule. Note that after a policy rule is terminated, still the entry will exist as long as indicated by the value of midcomRuleStorageTime. Writing to this object in any state other than newEntry(1), setting(2), reserved(7), or enabled(7) will always fail with an 'inconsistentValue' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. If object midcomRuleOperStatus of the same entry has a value other than newEntry(1), setting(2), reserved(7), or enabled(8), then the value of this object is irrelevant.")
midcomRuleRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 3, 1, 27), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: midcomRuleRowStatus.setStatus('current')
if mibBuilder.loadTexts: midcomRuleRowStatus.setDescription("A control that allows entries to be added and removed from this table. Entries can also be removed from this table by setting objects midcomRuleLifetime and midcomRuleStorageTime of an entry to 0. Attempts to set a row notInService(2) where the value of the midcomRuleStorageType object is permanent(4) or readOnly(5) will result in an 'notWritable' error. Note that this error code is SNMP specific. If the MIB module is used with other protocols than SNMP, errors with similar semantics specific to those protocols should be returned. The value of this object has no effect on whether other objects in this conceptual row can be modified.")
midcomGroupTable = MibTable((1, 3, 6, 1, 2, 1, 171, 1, 1, 4), )
if mibBuilder.loadTexts: midcomGroupTable.setStatus('current')
if mibBuilder.loadTexts: midcomGroupTable.setDescription('This table lists all current policy rule groups. Entries in this table are created or removed implicitly when entries in the midcomRuleTable are created or removed, respectively. A group entry in this table only exists as long as there are member rules of this group in the midcomRuleTable. The table serves for listing the existing groups and their remaining lifetimes and for changing lifetimes of groups and implicitly of all group members. Groups and all their member policy rules can only be deleted by deleting all member policies in the midcomRuleTable. Setting midcomGroupLifetime will result in setting the lifetime of all policy members to the same value.')
midcomGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 171, 1, 1, 4, 1), ).setIndexNames((0, "MIDCOM-MIB", "midcomRuleOwner"), (0, "MIDCOM-MIB", "midcomGroupIndex"))
if mibBuilder.loadTexts: midcomGroupEntry.setStatus('current')
if mibBuilder.loadTexts: midcomGroupEntry.setDescription('An entry describing properties of a particular MIDCOM policy rule group.')
midcomGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: midcomGroupIndex.setStatus('current')
if mibBuilder.loadTexts: midcomGroupIndex.setDescription('The index of this group for the midcomRuleOwner. A group is identified by the combination of midcomRuleOwner and midcomGroupIndex. The value of this index must be unique per midcomRuleOwner.')
midcomGroupLifetime = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 1, 4, 1, 3), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomGroupLifetime.setStatus('current')
if mibBuilder.loadTexts: midcomGroupLifetime.setDescription("When retrieved, this object delivers the maximum lifetime in seconds of all member rules of this group, i.e., of all rows in the midcomRuleTable that have the same values for midcomRuleOwner and midcomGroupIndex. Successfully writing to this object modifies the lifetime of all member policies. Successfully writing a value of 0 terminates all member policies and implicitly deletes the group as soon as all member entries are removed from the midcomRuleTable. Note that after a group's lifetime is expired or is set to 0, still the corresponding entry in the midcomGroupTable will exist as long as terminated member policy rules are stored as entries in the midcomRuleTable. Writing to this object is processed by the MIDCOM-MIB implementation by choosing a lifetime value that is greater than 0 and less than or equal to the minimum of the requested value and the value specified by object midcomConfigMaxLifetime: 0 <= lt_granted <= MINIMUM(lt_requested, lt_maximum) where: - lt_granted is the actually granted lifetime by the MIDCOM-MIB implementation - lt_requested is the requested lifetime of the MIDCOM client - lt_maximum is the value of object midcomConfigMaxLifetime SNMP SET requests to this object may be rejected or the value of the object after an accepted SET operation may be less than the value that was contained in the SNMP SET request.")
midcomConfigMaxLifetime = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 2, 1), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomConfigMaxLifetime.setStatus('current')
if mibBuilder.loadTexts: midcomConfigMaxLifetime.setDescription('When retrieved, this object returns the maximum lifetime, in seconds, that this middlebox allows policy rules to have.')
midcomConfigPersistentRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 2, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomConfigPersistentRules.setStatus('current')
if mibBuilder.loadTexts: midcomConfigPersistentRules.setDescription('When retrieved, this object returns true(1) if the MIDCOM-MIB implementation can store policy rules persistently. Otherwise, it returns false(2). A value of true(1) indicates that there may be entries in the midcomRuleTable with object midcomRuleStorageType set to value nonVolatile(3).')
midcomConfigIfTable = MibTable((1, 3, 6, 1, 2, 1, 171, 1, 2, 3), )
if mibBuilder.loadTexts: midcomConfigIfTable.setStatus('current')
if mibBuilder.loadTexts: midcomConfigIfTable.setDescription("This table indicates capabilities of the MIDCOM-MIB implementation per IP interface. The table is indexed by the object midcomConfigIfIndex. For indexing a single interface, this object contains the value of the ifIndex object that is associated with the interface. If an entry with midcomConfigIfIndex = 0 occurs, then bits set in objects of this entry apply to all interfaces for which there is no entry in this table with the interface's index.")
midcomConfigIfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 171, 1, 2, 3, 1), ).setIndexNames((0, "MIDCOM-MIB", "midcomConfigIfIndex"))
if mibBuilder.loadTexts: midcomConfigIfEntry.setStatus('current')
if mibBuilder.loadTexts: midcomConfigIfEntry.setDescription('An entry describing the capabilities of a middlebox with respect to the indexed IP interface.')
midcomConfigIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 3, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: midcomConfigIfIndex.setStatus('current')
if mibBuilder.loadTexts: midcomConfigIfIndex.setDescription('The index of an entry in the midcomConfigIfTable. For values different from zero, this object identifies an IP interface by containing the same value as the ifIndex object associated with the interface. Note that the index of a particular interface in the ifTable may change after a re-initialization of the middlebox, for example, after adding another interface to it. In such a case, the value of this object may change, but the interface referred to by the MIDCOM-MIB MUST still be the same. If, after a re-initialization of the middlebox, the interface referred to before re-initialization cannot be uniquely mapped anymore to a particular entry in the ifTable, then the value of object midcomConfigIfEnabled of the same entry MUST be changed to false(2). If the object has a value of 0, then values specified by further objects of the same entry apply to all interfaces for which there is no explicit entry in the midcomConfigIfTable.')
midcomConfigIfBits = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 3, 1, 2), Bits().clone(namedValues=NamedValues(("ipv4", 0), ("ipv6", 1), ("addressWildcards", 2), ("portWildcards", 3), ("firewall", 4), ("nat", 5), ("portTranslation", 6), ("protocolTranslation", 7), ("twiceNat", 8), ("inside", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomConfigIfBits.setStatus('current')
if mibBuilder.loadTexts: midcomConfigIfBits.setDescription('When retrieved, this object returns a set of bits indicating the capabilities (or configuration) of the middlebox with respect to the referenced IP interface. If the index equals 0, then all set bits apply to all interfaces. If the ipv4(0) bit is set, then the middlebox supports IPv4 at the indexed IP interface. If the ipv6(1) bit is set, then the middlebox supports IPv6 at the indexed IP interface. If the addressWildcards(2) bit is set, then the middlebox supports IP address wildcarding at the indexed IP interface. If the portWildcards(3) bit is set, then the middlebox supports port wildcarding at the indexed IP interface. If the firewall(4) bit is set, then the middlebox offers firewall functionality at the indexed interface. If the nat(5) bit is set, then the middlebox offers network address translation service at the indexed interface. If the portTranslation(6) bit is set, then the middlebox offers port translation service at the indexed interface. This bit is only relevant if nat(5) is set. If the protocolTranslation(7) bit is set, then the middlebox offers protocol translation service between IPv4 and IPv6 at the indexed interface. This bit is only relevant if nat(5) is set. If the twiceNat(8) bit is set, then the middlebox offers twice network address translation service at the indexed interface. This bit is only relevant if nat(5) is set. If the inside(9) bit is set, then the indexed interface is an inside interface with respect to NAT functionality. Otherwise, it is an outside interface. This bit is only relevant if nat(5) is set. An SNMP agent supporting both the MIDCOM-MIB module and the NAT-MIB module SHOULD ensure that the value of this object is consistent with the values of corresponding objects in the NAT-MIB module.')
midcomConfigIfEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 3, 1, 3), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomConfigIfEnabled.setStatus('current')
if mibBuilder.loadTexts: midcomConfigIfEnabled.setDescription('The value of this object indicates the availability of the middlebox service described by midcomConfigIfBits at the indexed IP interface. By writing to this object, the MIDCOM support for the entire IP interface can be switched on or off. Setting this object to false(2) immediately stops middlebox support at the indexed IP interface. This implies that all policy rules that use NAT or firewall resources at the indexed IP interface are terminated immediately. In this case, the MIDCOM agent MUST send midcomUnsolicitedRuleEvent to all MIDCOM clients that have access to one of the terminated rules.')
midcomConfigFirewallTable = MibTable((1, 3, 6, 1, 2, 1, 171, 1, 2, 4), )
if mibBuilder.loadTexts: midcomConfigFirewallTable.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallTable.setDescription("This table lists the firewall configuration per IP interface. It can be used for configuring how policy rules created by MIDCOM clients are realized as firewall rules of a firewall implementation. Particularly, the priority used for MIDCOM policy rules can be configured. For a single firewall implementation at a particular IP interface, all MIDCOM policy rules are realized as firewall rules with the same priority. Also, a firewall rule group name can be configured. The table is indexed by the object midcomConfigFirewallIndex. For indexing a single interface, this object contains the value of the ifIndex object that is associated with the interface. If an entry with midcomConfigFirewallIndex = 0 occurs, then bits set in objects of this entry apply to all interfaces for which there is no entry in this table for the interface's index.")
midcomConfigFirewallEntry = MibTableRow((1, 3, 6, 1, 2, 1, 171, 1, 2, 4, 1), ).setIndexNames((0, "MIDCOM-MIB", "midcomConfigFirewallIndex"))
if mibBuilder.loadTexts: midcomConfigFirewallEntry.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallEntry.setDescription('An entry describing a particular set of firewall resources.')
midcomConfigFirewallIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 4, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: midcomConfigFirewallIndex.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallIndex.setDescription('The index of an entry in the midcomConfigFirewallTable. For values different from 0, this object identifies an IP interface by containing the same value as the ifIndex object associated with the interface. Note that the index of a particular interface in the ifTable may change after a re-initialization of the middlebox, for example, after adding another interface to it. In such a case, the value of this object may change, but the interface referred to by the MIDCOM-MIB MUST still be the same. If, after a re-initialization of the middlebox, the interface referred to before re-initialization cannot be uniquely mapped anymore to a particular entry in the ifTable, then the entry in the midcomConfigFirewallTable MUST be deleted. If the object has a value of 0, then values specified by further objects of the same entry apply to all interfaces for which there is no explicit entry in the midcomConfigFirewallTable.')
midcomConfigFirewallGroupId = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 4, 1, 2), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomConfigFirewallGroupId.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallGroupId.setDescription('The firewall rule group to which all firewall rules are assigned that the MIDCOM server creates for the interface indicated by object midcomConfigFirewallIndex. If the value of object midcomConfigFirewallIndex is 0, then all firewall rules of the MIDCOM server that are created for interfaces with no specific entry in the midcomConfigFirewallTable are assigned to the firewall rule group indicated by the value of this object.')
midcomConfigFirewallPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 2, 4, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: midcomConfigFirewallPriority.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallPriority.setDescription('The priority assigned to all firewall rules that the MIDCOM server creates for the interface indicated by object midcomConfigFirewallIndex. If the value of object midcomConfigFirewallIndex is 0, then this priority is assigned to all firewall rules of the MIDCOM server that are created for interfaces for which there is no specific entry in the midcomConfigFirewallTable.')
class MidcomNatBindMode(TextualConvention, Integer32):
    description = 'An indicator of the kind of NAT resources used by a policy rule. This definition corresponds to the definition of NatBindMode in the NAT-MIB (RFC 4008). Value none(3) can be used to indicate that the policy rule does not use any NAT binding. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("addressBind", 1), ("addressPortBind", 2), ("none", 3))

class MidcomNatSessionIdOrZero(TextualConvention, Unsigned32):
    description = 'A unique ID that is assigned to each NAT session by a NAT implementation. This definition corresponds to the definition of NatSessionId in the NAT-MIB (RFC 4008). Value 0 can be used to indicate that the policy rule does not use any NAT binding.'
    status = 'current'
    displayHint = 'd'

midcomResourceTable = MibTable((1, 3, 6, 1, 2, 1, 171, 1, 3, 1), )
if mibBuilder.loadTexts: midcomResourceTable.setStatus('current')
if mibBuilder.loadTexts: midcomResourceTable.setDescription('This table lists all used middlebox resources per MIDCOM policy rule. The midcomResourceTable augments the midcomRuleTable.')
midcomResourceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1), )
midcomRuleEntry.registerAugmentions(("MIDCOM-MIB", "midcomResourceEntry"))
midcomResourceEntry.setIndexNames(*midcomRuleEntry.getIndexNames())
if mibBuilder.loadTexts: midcomResourceEntry.setStatus('current')
if mibBuilder.loadTexts: midcomResourceEntry.setDescription('An entry describing a particular set of middlebox resources.')
midcomRscNatInternalAddrBindMode = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 4), MidcomNatBindMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatInternalAddrBindMode.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatInternalAddrBindMode.setDescription('An indication of whether this policy rule uses an address NAT bind or an address-port NAT bind for binding the internal address. If the MIDCOM-MIB module is operated together with the NAT-MIB module (RFC 4008) then object midcomRscNatInternalAddrBindMode contains the same value as the corresponding object natSessionPrivateSrcEPBindMode of the NAT-MIB module.')
midcomRscNatInternalAddrBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 5), NatBindIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatInternalAddrBindId.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatInternalAddrBindId.setDescription('This object references to the allocated internal NAT bind that is used by this policy rule. A NAT bind describes the mapping of internal addresses to outside addresses. MIDCOM-MIB implementations can read this object to learn the corresponding NAT bind resource for this particular policy rule. If the MIDCOM-MIB module is operated together with the NAT-MIB module (RFC 4008) then object midcomRscNatInternalAddrBindId contains the same value as the corresponding object natSessionPrivateSrcEPBindId of the NAT-MIB module.')
midcomRscNatInsideAddrBindMode = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 6), MidcomNatBindMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatInsideAddrBindMode.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatInsideAddrBindMode.setDescription('An indication of whether this policy rule uses an address NAT bind or an address-port NAT bind for binding the external address. If the MIDCOM-MIB module is operated together with the NAT-MIB module (RFC 4008), then object midcomRscNatInsideAddrBindMode contains the same value as the corresponding object natSessionPrivateDstEPBindMode of the NAT-MIB module.')
midcomRscNatInsideAddrBindId = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 7), NatBindIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatInsideAddrBindId.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatInsideAddrBindId.setDescription('This object refers to the allocated external NAT bind that is used by this policy rule. A NAT bind describes the mapping of external addresses to inside addresses. MIDCOM-MIB implementations can read this object to learn the corresponding NAT bind resource for this particular policy rule. If the MIDCOM-MIB module is operated together with the NAT-MIB module (RFC 4008), then object midcomRscNatInsideAddrBindId contains the same value as the corresponding object natSessionPrivateDstEPBindId of the NAT-MIB module.')
midcomRscNatSessionId1 = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 8), MidcomNatSessionIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatSessionId1.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatSessionId1.setDescription('This object refers to the first allocated NAT session for this policy rule. MIDCOM-MIB implementations can read this object to learn whether or not a NAT session for a particular policy rule is used. A value of 0 means that no NAT session is allocated for this policy rule. A value other than 0 refers to the NAT session.')
midcomRscNatSessionId2 = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 9), MidcomNatSessionIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscNatSessionId2.setStatus('current')
if mibBuilder.loadTexts: midcomRscNatSessionId2.setDescription('This object refers to the second allocated NAT session for this policy rule. MIDCOM-MIB implementations can read this object to learn whether or not a NAT session for a particular policy rule is used. A value of 0 means that no NAT session is allocated for this policy rule. A value other than 0 refers to the NAT session.')
midcomRscFirewallRuleId = MibTableColumn((1, 3, 6, 1, 2, 1, 171, 1, 3, 1, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomRscFirewallRuleId.setStatus('current')
if mibBuilder.loadTexts: midcomRscFirewallRuleId.setDescription('This object refers to the allocated firewall rule in the firewall engine for this policy rule. MIDCOM-MIB implementations can read this value to learn whether a firewall rule for this particular policy rule is used or not. A value of 0 means that no firewall rule is allocated for this policy rule. A value other than 0 refers to the firewall rule number within the firewall engine.')
midcomStatistics = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 1, 3, 2))
midcomCurrentOwners = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomCurrentOwners.setStatus('current')
if mibBuilder.loadTexts: midcomCurrentOwners.setDescription('The number of different values for midcomRuleOwner for all current entries in the midcomRuleTable.')
midcomTotalRejectedRuleEntries = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalRejectedRuleEntries.setStatus('current')
if mibBuilder.loadTexts: midcomTotalRejectedRuleEntries.setDescription('The total number of failed attempts to create an entry in the midcomRuleTable.')
midcomCurrentRulesIncomplete = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomCurrentRulesIncomplete.setStatus('current')
if mibBuilder.loadTexts: midcomCurrentRulesIncomplete.setDescription('The current number of policy rules that are incomplete. Policy rules are loaded via row entries in the midcomRuleTable. This object counts policy rules that are loaded but not fully specified, i.e., they are in state newEntry(1) or setting(2).')
midcomTotalIncorrectReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalIncorrectReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalIncorrectReserveRules.setDescription('The total number of policy reserve rules that failed parameter check and entered state incorrectRequest(4).')
midcomTotalRejectedReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalRejectedReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalRejectedReserveRules.setDescription('The total number of policy reserve rules that failed while being processed and entered state requestRejected(6).')
midcomCurrentActiveReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomCurrentActiveReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomCurrentActiveReserveRules.setDescription('The number of currently active policy reserve rules.')
midcomTotalExpiredReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalExpiredReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalExpiredReserveRules.setDescription('The total number of expired policy reserve rules (entered termination state timedOut(9)).')
midcomTotalTerminatedOnRqReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalTerminatedOnRqReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalTerminatedOnRqReserveRules.setDescription('The total number of policy reserve rules that were terminated on request (entered termination state terminatedOnRequest(10)).')
midcomTotalTerminatedReserveRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalTerminatedReserveRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalTerminatedReserveRules.setDescription('The total number of policy reserve rules that were terminated, but not on request (entered termination state terminated(11)).')
midcomTotalIncorrectEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalIncorrectEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalIncorrectEnableRules.setDescription('The total number of policy enable rules that failed parameter check and entered state incorrectRequest(4).')
midcomTotalRejectedEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalRejectedEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalRejectedEnableRules.setDescription('The total number of policy enable rules that failed while being processed and entered state requestRejected(6).')
midcomCurrentActiveEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomCurrentActiveEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomCurrentActiveEnableRules.setDescription('The number of currently active policy enable rules.')
midcomTotalExpiredEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalExpiredEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalExpiredEnableRules.setDescription('The total number of expired policy enable rules (entered termination state timedOut(9)).')
midcomTotalTerminatedOnRqEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalTerminatedOnRqEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalTerminatedOnRqEnableRules.setDescription('The total number of policy enable rules that were terminated on request (entered termination state terminatedOnRequest(10)).')
midcomTotalTerminatedEnableRules = MibScalar((1, 3, 6, 1, 2, 1, 171, 1, 3, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: midcomTotalTerminatedEnableRules.setStatus('current')
if mibBuilder.loadTexts: midcomTotalTerminatedEnableRules.setDescription('The total number of policy enable rules that were terminated, but not on request (entered termination state terminated(11)).')
midcomUnsolicitedRuleEvent = NotificationType((1, 3, 6, 1, 2, 1, 171, 0, 1)).setObjects(("MIDCOM-MIB", "midcomRuleOperStatus"), ("MIDCOM-MIB", "midcomRuleLifetime"))
if mibBuilder.loadTexts: midcomUnsolicitedRuleEvent.setStatus('current')
if mibBuilder.loadTexts: midcomUnsolicitedRuleEvent.setDescription('This notification is generated whenever the value of midcomRuleOperStatus enters any error state or any termination state without an explicit trigger by a MIDCOM client.')
midcomSolicitedRuleEvent = NotificationType((1, 3, 6, 1, 2, 1, 171, 0, 2)).setObjects(("MIDCOM-MIB", "midcomRuleOperStatus"), ("MIDCOM-MIB", "midcomRuleLifetime"))
if mibBuilder.loadTexts: midcomSolicitedRuleEvent.setStatus('current')
if mibBuilder.loadTexts: midcomSolicitedRuleEvent.setDescription('This notification is generated whenever the value of midcomRuleOperStatus enters one of the states {reserved, enabled, any error state, any termination state} as a result of a MIDCOM agent writing successfully to object midcomRuleAdminStatus. In addition, it is generated when the lifetime of a rule was changed by successfully writing to object midcomRuleLifetime.')
midcomSolicitedGroupEvent = NotificationType((1, 3, 6, 1, 2, 1, 171, 0, 3)).setObjects(("MIDCOM-MIB", "midcomGroupLifetime"))
if mibBuilder.loadTexts: midcomSolicitedGroupEvent.setStatus('current')
if mibBuilder.loadTexts: midcomSolicitedGroupEvent.setDescription("This notification is generated for indicating that the lifetime of all member rules of the group was changed by successfully writing to object midcomGroupLifetime. Note that this notification is only sent if the lifetime of a group was changed by successfully writing to object midcomGroupLifetime. No notification is sent - if a group's lifetime is changed by writing to object midcomRuleLifetime of any of its member policies, - if a group's lifetime expires (in this case, notifications are sent for all member policies), or - if the group is terminated by terminating the last of its member policies without writing to object midcomGroupLifetime.")
midcomCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 2, 1))
midcomGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 171, 2, 2))
midcomCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 171, 2, 1, 1)).setObjects(("MIDCOM-MIB", "midcomRuleGroup"), ("MIDCOM-MIB", "midcomNotificationsGroup"), ("MIDCOM-MIB", "midcomCapabilitiesGroup"), ("MIDCOM-MIB", "midcomStatisticsGroup"), ("MIDCOM-MIB", "midcomConfigFirewallGroup"), ("MIDCOM-MIB", "midcomResourceGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomCompliance = midcomCompliance.setStatus('current')
if mibBuilder.loadTexts: midcomCompliance.setDescription('The compliance statement for implementations of the MIDCOM-MIB module. Note that compliance with this compliance statement requires compliance with the ifCompliance3 MODULE-COMPLIANCE statement of the IF-MIB [RFC2863].')
midcomRuleGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 1)).setObjects(("MIDCOM-MIB", "midcomRuleAdminStatus"), ("MIDCOM-MIB", "midcomRuleOperStatus"), ("MIDCOM-MIB", "midcomRuleStorageType"), ("MIDCOM-MIB", "midcomRuleStorageTime"), ("MIDCOM-MIB", "midcomRuleError"), ("MIDCOM-MIB", "midcomRuleInterface"), ("MIDCOM-MIB", "midcomRuleFlowDirection"), ("MIDCOM-MIB", "midcomRuleMaxIdleTime"), ("MIDCOM-MIB", "midcomRuleTransportProtocol"), ("MIDCOM-MIB", "midcomRulePortRange"), ("MIDCOM-MIB", "midcomRuleInternalIpVersion"), ("MIDCOM-MIB", "midcomRuleExternalIpVersion"), ("MIDCOM-MIB", "midcomRuleInternalIpAddr"), ("MIDCOM-MIB", "midcomRuleInternalIpPrefixLength"), ("MIDCOM-MIB", "midcomRuleInternalPort"), ("MIDCOM-MIB", "midcomRuleExternalIpAddr"), ("MIDCOM-MIB", "midcomRuleExternalIpPrefixLength"), ("MIDCOM-MIB", "midcomRuleExternalPort"), ("MIDCOM-MIB", "midcomRuleInsideIpAddr"), ("MIDCOM-MIB", "midcomRuleInsidePort"), ("MIDCOM-MIB", "midcomRuleOutsideIpAddr"), ("MIDCOM-MIB", "midcomRuleOutsidePort"), ("MIDCOM-MIB", "midcomRuleLifetime"), ("MIDCOM-MIB", "midcomRuleRowStatus"), ("MIDCOM-MIB", "midcomGroupLifetime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomRuleGroup = midcomRuleGroup.setStatus('current')
if mibBuilder.loadTexts: midcomRuleGroup.setDescription('A collection of objects providing information about policy rules and policy rule groups.')
midcomCapabilitiesGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 2)).setObjects(("MIDCOM-MIB", "midcomConfigMaxLifetime"), ("MIDCOM-MIB", "midcomConfigPersistentRules"), ("MIDCOM-MIB", "midcomConfigIfBits"), ("MIDCOM-MIB", "midcomConfigIfEnabled"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomCapabilitiesGroup = midcomCapabilitiesGroup.setStatus('current')
if mibBuilder.loadTexts: midcomCapabilitiesGroup.setDescription('A collection of objects providing information about the capabilities of a middlebox.')
midcomConfigFirewallGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 3)).setObjects(("MIDCOM-MIB", "midcomConfigFirewallGroupId"), ("MIDCOM-MIB", "midcomConfigFirewallPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomConfigFirewallGroup = midcomConfigFirewallGroup.setStatus('current')
if mibBuilder.loadTexts: midcomConfigFirewallGroup.setDescription('A collection of objects providing information about the firewall rule group and firewall rule priority to be used by firewalls loaded through MIDCOM.')
midcomResourceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 4)).setObjects(("MIDCOM-MIB", "midcomRscNatInternalAddrBindMode"), ("MIDCOM-MIB", "midcomRscNatInternalAddrBindId"), ("MIDCOM-MIB", "midcomRscNatInsideAddrBindMode"), ("MIDCOM-MIB", "midcomRscNatInsideAddrBindId"), ("MIDCOM-MIB", "midcomRscNatSessionId1"), ("MIDCOM-MIB", "midcomRscNatSessionId2"), ("MIDCOM-MIB", "midcomRscFirewallRuleId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomResourceGroup = midcomResourceGroup.setStatus('current')
if mibBuilder.loadTexts: midcomResourceGroup.setDescription('A collection of objects providing information about the used NAT and firewall resources.')
midcomStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 5)).setObjects(("MIDCOM-MIB", "midcomCurrentOwners"), ("MIDCOM-MIB", "midcomTotalRejectedRuleEntries"), ("MIDCOM-MIB", "midcomCurrentRulesIncomplete"), ("MIDCOM-MIB", "midcomTotalIncorrectReserveRules"), ("MIDCOM-MIB", "midcomTotalRejectedReserveRules"), ("MIDCOM-MIB", "midcomCurrentActiveReserveRules"), ("MIDCOM-MIB", "midcomTotalExpiredReserveRules"), ("MIDCOM-MIB", "midcomTotalTerminatedOnRqReserveRules"), ("MIDCOM-MIB", "midcomTotalTerminatedReserveRules"), ("MIDCOM-MIB", "midcomTotalIncorrectEnableRules"), ("MIDCOM-MIB", "midcomTotalRejectedEnableRules"), ("MIDCOM-MIB", "midcomCurrentActiveEnableRules"), ("MIDCOM-MIB", "midcomTotalExpiredEnableRules"), ("MIDCOM-MIB", "midcomTotalTerminatedOnRqEnableRules"), ("MIDCOM-MIB", "midcomTotalTerminatedEnableRules"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomStatisticsGroup = midcomStatisticsGroup.setStatus('current')
if mibBuilder.loadTexts: midcomStatisticsGroup.setDescription('A collection of objects providing statistical information about the MIDCOM server.')
midcomNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 171, 2, 2, 6)).setObjects(("MIDCOM-MIB", "midcomUnsolicitedRuleEvent"), ("MIDCOM-MIB", "midcomSolicitedRuleEvent"), ("MIDCOM-MIB", "midcomSolicitedGroupEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    midcomNotificationsGroup = midcomNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: midcomNotificationsGroup.setDescription('The notifications emitted by the midcomMIB.')
mibBuilder.exportSymbols("MIDCOM-MIB", midcomConfigPersistentRules=midcomConfigPersistentRules, midcomRscNatInsideAddrBindId=midcomRscNatInsideAddrBindId, midcomCompliances=midcomCompliances, midcomRuleMaxIdleTime=midcomRuleMaxIdleTime, midcomRscNatSessionId1=midcomRscNatSessionId1, midcomRuleStorageTime=midcomRuleStorageTime, midcomRuleExternalIpVersion=midcomRuleExternalIpVersion, midcomRuleStorageType=midcomRuleStorageType, midcomCapabilitiesGroup=midcomCapabilitiesGroup, midcomConfigIfEnabled=midcomConfigIfEnabled, midcomTotalRejectedEnableRules=midcomTotalRejectedEnableRules, midcomConfigFirewallGroup=midcomConfigFirewallGroup, midcomCurrentRulesIncomplete=midcomCurrentRulesIncomplete, midcomRuleOwner=midcomRuleOwner, midcomRuleExternalIpPrefixLength=midcomRuleExternalIpPrefixLength, midcomCurrentOwners=midcomCurrentOwners, midcomRuleOutsideIpAddr=midcomRuleOutsideIpAddr, midcomUnsolicitedRuleEvent=midcomUnsolicitedRuleEvent, midcomCurrentActiveReserveRules=midcomCurrentActiveReserveRules, midcomTotalExpiredReserveRules=midcomTotalExpiredReserveRules, midcomRuleInternalPort=midcomRuleInternalPort, midcomRuleRowStatus=midcomRuleRowStatus, midcomStatisticsGroup=midcomStatisticsGroup, midcomTotalIncorrectEnableRules=midcomTotalIncorrectEnableRules, midcomRuleExternalPort=midcomRuleExternalPort, midcomTotalRejectedRuleEntries=midcomTotalRejectedRuleEntries, midcomRuleGroup=midcomRuleGroup, midcomGroupIndex=midcomGroupIndex, midcomConfigIfBits=midcomConfigIfBits, midcomGroupTable=midcomGroupTable, midcomConfigFirewallPriority=midcomConfigFirewallPriority, midcomRscNatInsideAddrBindMode=midcomRscNatInsideAddrBindMode, midcomTotalTerminatedOnRqEnableRules=midcomTotalTerminatedOnRqEnableRules, midcomRuleInternalIpVersion=midcomRuleInternalIpVersion, midcomRuleTable=midcomRuleTable, midcomConfig=midcomConfig, midcomNotificationsGroup=midcomNotificationsGroup, midcomConfigFirewallIndex=midcomConfigFirewallIndex, midcomRuleAdminStatus=midcomRuleAdminStatus, midcomRscNatInternalAddrBindId=midcomRscNatInternalAddrBindId, midcomConfigIfIndex=midcomConfigIfIndex, MidcomNatBindMode=MidcomNatBindMode, midcomRuleOperStatus=midcomRuleOperStatus, midcomCompliance=midcomCompliance, midcomRscNatInternalAddrBindMode=midcomRscNatInternalAddrBindMode, midcomRuleIndex=midcomRuleIndex, midcomRuleTransportProtocol=midcomRuleTransportProtocol, midcomConfigFirewallTable=midcomConfigFirewallTable, midcomObjects=midcomObjects, midcomResourceTable=midcomResourceTable, midcomRulePortRange=midcomRulePortRange, midcomRuleInterface=midcomRuleInterface, midcomRuleInsideIpAddr=midcomRuleInsideIpAddr, midcomResourceEntry=midcomResourceEntry, midcomCurrentActiveEnableRules=midcomCurrentActiveEnableRules, midcomGroupEntry=midcomGroupEntry, midcomResourceGroup=midcomResourceGroup, midcomRuleLifetime=midcomRuleLifetime, midcomConfigIfEntry=midcomConfigIfEntry, midcomRuleInternalIpPrefixLength=midcomRuleInternalIpPrefixLength, midcomStatistics=midcomStatistics, midcomMIB=midcomMIB, midcomGroups=midcomGroups, midcomConfigFirewallGroupId=midcomConfigFirewallGroupId, midcomRscFirewallRuleId=midcomRscFirewallRuleId, midcomConformance=midcomConformance, midcomTotalTerminatedEnableRules=midcomTotalTerminatedEnableRules, midcomMonitoring=midcomMonitoring, midcomTotalTerminatedReserveRules=midcomTotalTerminatedReserveRules, midcomConfigFirewallEntry=midcomConfigFirewallEntry, midcomRuleExternalIpAddr=midcomRuleExternalIpAddr, midcomRuleInternalIpAddr=midcomRuleInternalIpAddr, midcomRuleInsidePort=midcomRuleInsidePort, midcomRuleEntry=midcomRuleEntry, midcomConfigIfTable=midcomConfigIfTable, PYSNMP_MODULE_ID=midcomMIB, MidcomNatSessionIdOrZero=MidcomNatSessionIdOrZero, midcomNotifications=midcomNotifications, midcomSolicitedRuleEvent=midcomSolicitedRuleEvent, midcomSolicitedGroupEvent=midcomSolicitedGroupEvent, midcomTotalIncorrectReserveRules=midcomTotalIncorrectReserveRules, midcomTransaction=midcomTransaction, midcomConfigMaxLifetime=midcomConfigMaxLifetime, midcomRuleError=midcomRuleError, midcomTotalTerminatedOnRqReserveRules=midcomTotalTerminatedOnRqReserveRules, midcomRuleFlowDirection=midcomRuleFlowDirection, midcomRuleOutsidePort=midcomRuleOutsidePort, midcomGroupLifetime=midcomGroupLifetime, midcomTotalExpiredEnableRules=midcomTotalExpiredEnableRules, midcomTotalRejectedReserveRules=midcomTotalRejectedReserveRules, midcomRscNatSessionId2=midcomRscNatSessionId2)

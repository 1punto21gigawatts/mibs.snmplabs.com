#
# PySNMP MIB module HH3C-DHCP-SNOOP2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HH3C-DHCP-SNOOP2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:25:53 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
hh3cCommon, = mibBuilder.importSymbols("HH3C-OID-MIB", "hh3cCommon")
ifIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifIndex", "InterfaceIndexOrZero")
InetAddressIPv4, = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv4")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, IpAddress, NotificationType, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, ObjectIdentity, Gauge32, TimeTicks, iso, MibIdentifier, Bits, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "IpAddress", "NotificationType", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "ObjectIdentity", "Gauge32", "TimeTicks", "iso", "MibIdentifier", "Bits", "ModuleIdentity")
TextualConvention, RowStatus, TruthValue, MacAddress, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "TruthValue", "MacAddress", "DisplayString")
hh3cDhcpSnoop2 = ModuleIdentity((1, 3, 6, 1, 4, 1, 25506, 2, 124))
hh3cDhcpSnoop2.setRevisions(('2013-04-15 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hh3cDhcpSnoop2.setRevisionsDescriptions(('The private MIB file includes the DHCP Snooping profile.',))
if mibBuilder.loadTexts: hh3cDhcpSnoop2.setLastUpdated('201304150000Z')
if mibBuilder.loadTexts: hh3cDhcpSnoop2.setOrganization('Hangzhou H3C Technologies Co., Ltd.')
if mibBuilder.loadTexts: hh3cDhcpSnoop2.setContactInfo('Platform Team Hangzhou H3C Technologies Co., Ltd. Hai-Dian District Beijing P.R. China http://www.h3c.com Zip:100085 ')
if mibBuilder.loadTexts: hh3cDhcpSnoop2.setDescription('DHCP SNOOPING MIB 2')
hh3cDhcpSnoop2ScalarObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1))
hh3cDhcpSnoop2ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 1))
hh3cDhcpSnoop2Enabled = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2Enabled.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2Enabled.setDescription("If the value of this object is set to 'true', DHCP snooping is enabled.")
hh3cDhcpSnoop2BindDbName = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindDbName.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindDbName.setDescription('Name of the file that used to store binding information. If the value of the object is set to a zero-length string, the configuration will be removed.')
hh3cDhcpSnoop2BindRefreshIntvl = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 864000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRefreshIntvl.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRefreshIntvl.setDescription('The refresh interval of the binding information in seconds.')
hh3cDhcpSnoop2BindRefresh = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRefresh.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRefresh.setDescription("If the value of this object is set to 'on', the binding information will be refreshed immediately.")
hh3cDhcpSnoop2StatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 2))
hh3cDhcpSnoop2PktSentNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 2, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktSentNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktSentNum.setDescription('The total number of the packets send by DHCP snooping.')
hh3cDhcpSnoop2PktRcvNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 2, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktRcvNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktRcvNum.setDescription('The total number of the packets received by DHCP snooping.')
hh3cDhcpSnoop2PktDropNum = MibScalar((1, 3, 6, 1, 4, 1, 25506, 2, 124, 1, 2, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktDropNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2PktDropNum.setDescription('The total number of the packets dropped by DHCP snooping.')
hh3cDhcpSnoop2Tables = MibIdentifier((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2))
hh3cDhcpSnoop2BindTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1), )
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindTable.setDescription('The table containing information of DHCP clients listened by DHCP snooping.')
hh3cDhcpSnoop2BindEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1), ).setIndexNames((0, "HH3C-DHCP-SNOOP2-MIB", "hh3cDhcpSnoop2BindIpAddr"), (0, "HH3C-DHCP-SNOOP2-MIB", "hh3cDhcpSnoop2BindVlanId"), (0, "HH3C-DHCP-SNOOP2-MIB", "hh3cDhcpSnoop2BindSecVlanId"))
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindEntry.setDescription('An entry containing information of DHCP clients.')
hh3cDhcpSnoop2BindIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 1), InetAddressIPv4())
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindIpAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindIpAddr.setDescription("DHCP client's IP addresses collected by DHCP snooping.")
hh3cDhcpSnoop2BindVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindVlanId.setDescription("DHCP client's VLAN ID collected by DHCP snooping.")
hh3cDhcpSnoop2BindSecVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 4094), ValueRangeConstraint(65535, 65535), )))
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindSecVlanId.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindSecVlanId.setDescription("DHCP client's second VLAN ID collected by DHCP snooping. 65535 means no second VLAN.")
hh3cDhcpSnoop2BindMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 4), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindMacAddr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindMacAddr.setDescription("DHCP client's MAC address collected by DHCP snooping.")
hh3cDhcpSnoop2BindLease = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindLease.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindLease.setDescription('Left lease time in seconds collected by DHCP snooping. The value of this object cannot be 0.')
hh3cDhcpSnoop2BindPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindPortIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindPortIndex.setDescription("DHCP client's port index collected by DHCP snooping. The value of zero means unknown port.")
hh3cDhcpSnoop2BindRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2BindRowStatus.setDescription('RowStatus. Only destroy action is allow to use.')
hh3cDhcpSnoop2IfConfigTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2), )
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfConfigTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfConfigTable.setDescription('A table is used to configure DHCP snooping functions on ports.')
hh3cDhcpSnoop2IfConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfConfigEntry.setDescription('An entry containing DHCP snooping configurations of ports.')
hh3cDhcpSnoop2IfTrustStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("untrusted", 0), ("trusted", 1))).clone('untrusted')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfTrustStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfTrustStatus.setDescription('Trusted status of the port.')
hh3cDhcpSnoop2IfCheckMac = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfCheckMac.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfCheckMac.setDescription("If the value is 'true', MAC address of DHCP packets received on the port will be checked.")
hh3cDhcpSnoop2IfCheckRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfCheckRequest.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfCheckRequest.setDescription("If the value is 'true', DHCP request packets will be checked.")
hh3cDhcpSnoop2IfRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 4), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfRateLimit.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfRateLimit.setDescription('The rate limit in Kbps. If the value is 0, there is no rate limit on the port.')
hh3cDhcpSnoop2IfRecordBind = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 5), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfRecordBind.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfRecordBind.setDescription("If the value is 'true', information of DHCP packets received on the port will be recorded.")
hh3cDhcpSnoop2IfMaxLearnNum = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfMaxLearnNum.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfMaxLearnNum.setDescription('The maximum number of binding entries that could be learned on the port. If the value is 0, it means that there is no threshold on the port.')
hh3cDhcpSnoop2IfOpt82Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82Enable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82Enable.setDescription("If DHCP snooping supports option 82 functions, the value is 'true'. If DHCP snooping does NOT support option 82 functions, the value is 'false'.")
hh3cDhcpSnoop2IfOpt82Strategy = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("drop", 1), ("keep", 2), ("replace", 3))).clone('replace')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82Strategy.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82Strategy.setDescription("The strategy of DHCP snooping handling option 82. 'drop' indicates DHCP snooping discarding the request packet including option 82. 'keep' indicates DHCP snooping accepting the request packet without any change of the option 82. 'replace' indicates DHCP snooping accepting the request packet on condition that it generates a new option 82 to replace the original one.")
hh3cDhcpSnoop2IfOpt82CIDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("verbose", 2), ("userDefine", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDMode.setDescription("The mode of filling in the circuit ID suboption of DHCP option 82. 'normal' is the standard mode. 'verbose' is the detailed mode. 'userDefine' is the user-defined mode. If the value of this object is set to 'userDefine', hh3cDhcpSnoop2IfOpt82CIDStr must also be set.")
hh3cDhcpSnoop2IfOpt82CIDNodeType = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("invalid", 1), ("mac", 2), ("sysname", 3), ("userDefine", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDNodeType.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDNodeType.setDescription("Type of access node identifier that is used to fill in the circuit ID suboption of option 82 when the value of hh3cDhcpSnoop2IfOption82CIDMode is set to 'verbose'. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82CIDMode. 'invalid' indicates that the node identifier is NOT used to fill in the circuit ID suboption of option 82. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is NOT 'verbose', the value of this object is set to 'invalid' automatically. Otherwise the value of this object cannot be set to 'invalid'. 'mac' indicates that the node identifier is filled in with the bridge MAC of DHCP snooping device. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is set to 'verbose', the default value of this object is 'mac'. 'sysname' indicates that the node identifier is filled in with the sysname of the DHCP snooping. 'userDefine' indicates the node identifier is filled in with the string defined by the object of hh3cDhcpSnoop2IfOpt82CIDNodeStr. If the value is set to 'userDefine', the value of hh3cDhcpSnoop2IfOpt82CIDNodeStr must also be set to a non-zero length string.")
hh3cDhcpSnoop2IfOpt82CIDNodeStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 50))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDNodeStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDNodeStr.setDescription("The string defined by user to fill in the node identifier in the verbose mode. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is NOT 'verbose', or the value of hh3cDhcpSnoop2IfOpt82CIDNodeType is NOT 'userDefine', it is set to a zero-length string automatically. Otherwise it must be set to a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82CIDMode and hh3cDhcpSnoop2IfOpt82CIDNodeType.")
hh3cDhcpSnoop2IfOpt82CIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 12), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(3, 63), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDStr.setDescription("The string defined by user to fill in the circuit ID suboption of option 82 in the user-define mode. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is NOT 'userDefine', it is set to a zero-length string automatically. Otherwise it must be set to a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82CIDMode.")
hh3cDhcpSnoop2IfOpt82CIDFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2), ("undefine", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDFormat.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82CIDFormat.setDescription("The format of the circuit ID suboption of DHCP option 82. 'hex' is the hex format. 'ascii' is the ascii format. 'undefine' is the undefine format. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is 'normal', this object is set with 'hex' automatically and cannot be set with 'undefine'. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is 'verbose', the default value of this object is 'undefine'. If the value of hh3cDhcpSnoop2IfOpt82CIDMode is 'userDefine', this object is set with 'ascii' automatically and cannot be set with other value. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82CIDMode.")
hh3cDhcpSnoop2IfOpt82RIDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("sysname", 2), ("userDefine", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDMode.setDescription("The mode of filling in the remote ID suboption of DHCP option 82. 'normal' is the standard mode. 'userDefine' is the user-defined mode. 'sysname' is the sysname mode. If the value of this object is set to 'userDefine', hh3cDhcpSnoop2IfOpt82RIDStr must also be set.")
hh3cDhcpSnoop2IfOpt82RIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDStr.setDescription("The string defined by user to fill in the remote ID in the user-defined mode. If the value of hh3cDhcpSnoop2IfOpt82RIDMode is NOT 'userDefine', this object is set with a zero-length string automatically. Otherwise it must be set with a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82RIDMode.")
hh3cDhcpSnoop2IfOpt82RIDFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hex", 1), ("ascii", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDFormat.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfOpt82RIDFormat.setDescription("The format of DHCP option 82 remote ID in 'normal' mode. 'hex' is the hex format. 'ascii' is the ascii format. If the value of hh3cDhcpSnoop2IfOpt82RIDMode is 'sysname' or 'userDefine', this object is set with 'ascii' automatically and cannot be set with other value. If the value of hh3cDhcpSnoop2IfOpt82RIDMode is 'normal', the default value of this object is 'hex'. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfOpt82RIDMode.")
hh3cDhcpSnoop2IfVlanCIDTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 3), )
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDTable.setDescription('A table containing the information of the circuit ID suboption of DHCP option 82 in VLAN.')
hh3cDhcpSnoop2IfVlanCIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-DHCP-SNOOP2-MIB", "hh3cDhcpSnoop2IfVlanCIDVlanIndex"))
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDEntry.setDescription('An entry containing the information of the circuit ID suboption of DHCP option 82 in VLAN.')
hh3cDhcpSnoop2IfVlanCIDVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDVlanIndex.setDescription('VLAN ID.')
hh3cDhcpSnoop2IfVlanCIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDStr.setDescription('The string defined by user to fill in the circuit ID suboption of option 82.')
hh3cDhcpSnoop2IfVlanCIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanCIDRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy.')
hh3cDhcpSnoop2IfVlanRIDTable = MibTable((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4), )
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDTable.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDTable.setDescription('A table containing the information of the remote ID suboption of DHCP option 82 in VLAN.')
hh3cDhcpSnoop2IfVlanRIDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "HH3C-DHCP-SNOOP2-MIB", "hh3cDhcpSnoop2IfVlanRIDVlanIndex"))
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDEntry.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDEntry.setDescription('An entry containing the information of the remote ID suboption of DHCP option 82 in VLAN.')
hh3cDhcpSnoop2IfVlanRIDVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094)))
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDVlanIndex.setDescription('VLAN ID.')
hh3cDhcpSnoop2IfVlanRIDMode = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sysname", 1), ("userDefine", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDMode.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDMode.setDescription("The mode of filling in the remote ID suboption of DHCP option 82 in VLAN. 'sysname' indicates using the device sysname to fill in the suboption. 'userDefine' indicates using the string defined by hh3cDhcpSnoop2IfVlanRIDStr to fill in the suboption. If the value of this object is set to 'userDefine', hh3cDhcpSnoop2IfVlanRIDStr must also be set.")
hh3cDhcpSnoop2IfVlanRIDStr = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDStr.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDStr.setDescription("The string used to fill in the remote ID suboption. If the value of hh3cDhcpSnoop2IfVlanRIDMode is NOT 'userDefine', this object is set with a zero-length string automatically. Otherwise it must be set with a non-zero length string. The SET operation of this object must be with the SET operation of hh3cDhcpSnoop2IfVlanRIDMode.")
hh3cDhcpSnoop2IfVlanRIDRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 25506, 2, 124, 2, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDRowStatus.setStatus('current')
if mibBuilder.loadTexts: hh3cDhcpSnoop2IfVlanRIDRowStatus.setDescription('Operation status of this table entry. Three actions are used: active, createAndGo, destroy.')
mibBuilder.exportSymbols("HH3C-DHCP-SNOOP2-MIB", hh3cDhcpSnoop2IfMaxLearnNum=hh3cDhcpSnoop2IfMaxLearnNum, hh3cDhcpSnoop2BindSecVlanId=hh3cDhcpSnoop2BindSecVlanId, hh3cDhcpSnoop2IfCheckMac=hh3cDhcpSnoop2IfCheckMac, hh3cDhcpSnoop2IfOpt82Enable=hh3cDhcpSnoop2IfOpt82Enable, hh3cDhcpSnoop2PktRcvNum=hh3cDhcpSnoop2PktRcvNum, hh3cDhcpSnoop2IfOpt82RIDMode=hh3cDhcpSnoop2IfOpt82RIDMode, hh3cDhcpSnoop2IfOpt82RIDFormat=hh3cDhcpSnoop2IfOpt82RIDFormat, hh3cDhcpSnoop2Enabled=hh3cDhcpSnoop2Enabled, hh3cDhcpSnoop2BindRowStatus=hh3cDhcpSnoop2BindRowStatus, hh3cDhcpSnoop2IfOpt82CIDMode=hh3cDhcpSnoop2IfOpt82CIDMode, PYSNMP_MODULE_ID=hh3cDhcpSnoop2, hh3cDhcpSnoop2PktSentNum=hh3cDhcpSnoop2PktSentNum, hh3cDhcpSnoop2IfConfigTable=hh3cDhcpSnoop2IfConfigTable, hh3cDhcpSnoop2IfVlanCIDVlanIndex=hh3cDhcpSnoop2IfVlanCIDVlanIndex, hh3cDhcpSnoop2BindLease=hh3cDhcpSnoop2BindLease, hh3cDhcpSnoop2BindVlanId=hh3cDhcpSnoop2BindVlanId, hh3cDhcpSnoop2IfRecordBind=hh3cDhcpSnoop2IfRecordBind, hh3cDhcpSnoop2IfVlanRIDEntry=hh3cDhcpSnoop2IfVlanRIDEntry, hh3cDhcpSnoop2BindMacAddr=hh3cDhcpSnoop2BindMacAddr, hh3cDhcpSnoop2IfVlanCIDRowStatus=hh3cDhcpSnoop2IfVlanCIDRowStatus, hh3cDhcpSnoop2PktDropNum=hh3cDhcpSnoop2PktDropNum, hh3cDhcpSnoop2IfVlanRIDStr=hh3cDhcpSnoop2IfVlanRIDStr, hh3cDhcpSnoop2IfVlanRIDMode=hh3cDhcpSnoop2IfVlanRIDMode, hh3cDhcpSnoop2IfOpt82CIDFormat=hh3cDhcpSnoop2IfOpt82CIDFormat, hh3cDhcpSnoop2ScalarObjects=hh3cDhcpSnoop2ScalarObjects, hh3cDhcpSnoop2IfVlanRIDVlanIndex=hh3cDhcpSnoop2IfVlanRIDVlanIndex, hh3cDhcpSnoop2IfRateLimit=hh3cDhcpSnoop2IfRateLimit, hh3cDhcpSnoop2BindTable=hh3cDhcpSnoop2BindTable, hh3cDhcpSnoop2BindIpAddr=hh3cDhcpSnoop2BindIpAddr, hh3cDhcpSnoop2StatisticsGroup=hh3cDhcpSnoop2StatisticsGroup, hh3cDhcpSnoop2IfVlanCIDStr=hh3cDhcpSnoop2IfVlanCIDStr, hh3cDhcpSnoop2IfOpt82RIDStr=hh3cDhcpSnoop2IfOpt82RIDStr, hh3cDhcpSnoop2BindDbName=hh3cDhcpSnoop2BindDbName, hh3cDhcpSnoop2ConfigGroup=hh3cDhcpSnoop2ConfigGroup, hh3cDhcpSnoop2Tables=hh3cDhcpSnoop2Tables, hh3cDhcpSnoop2BindRefresh=hh3cDhcpSnoop2BindRefresh, hh3cDhcpSnoop2IfOpt82Strategy=hh3cDhcpSnoop2IfOpt82Strategy, hh3cDhcpSnoop2IfOpt82CIDNodeType=hh3cDhcpSnoop2IfOpt82CIDNodeType, hh3cDhcpSnoop2IfOpt82CIDStr=hh3cDhcpSnoop2IfOpt82CIDStr, hh3cDhcpSnoop2IfOpt82CIDNodeStr=hh3cDhcpSnoop2IfOpt82CIDNodeStr, hh3cDhcpSnoop2IfVlanRIDTable=hh3cDhcpSnoop2IfVlanRIDTable, hh3cDhcpSnoop2IfVlanCIDEntry=hh3cDhcpSnoop2IfVlanCIDEntry, hh3cDhcpSnoop2BindRefreshIntvl=hh3cDhcpSnoop2BindRefreshIntvl, hh3cDhcpSnoop2IfVlanCIDTable=hh3cDhcpSnoop2IfVlanCIDTable, hh3cDhcpSnoop2=hh3cDhcpSnoop2, hh3cDhcpSnoop2IfConfigEntry=hh3cDhcpSnoop2IfConfigEntry, hh3cDhcpSnoop2IfTrustStatus=hh3cDhcpSnoop2IfTrustStatus, hh3cDhcpSnoop2IfCheckRequest=hh3cDhcpSnoop2IfCheckRequest, hh3cDhcpSnoop2BindEntry=hh3cDhcpSnoop2BindEntry, hh3cDhcpSnoop2IfVlanRIDRowStatus=hh3cDhcpSnoop2IfVlanRIDRowStatus, hh3cDhcpSnoop2BindPortIndex=hh3cDhcpSnoop2BindPortIndex)

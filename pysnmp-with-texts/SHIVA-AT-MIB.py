#
# PySNMP MIB module SHIVA-AT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SHIVA-AT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:02:50 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
tATalk, = mibBuilder.importSymbols("SHIVA-MIB", "tATalk")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Unsigned32, ModuleIdentity, Counter32, ObjectIdentity, IpAddress, NotificationType, Gauge32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, iso, Integer32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Unsigned32", "ModuleIdentity", "Counter32", "ObjectIdentity", "IpAddress", "NotificationType", "Gauge32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "iso", "Integer32", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
tRTMPEntryTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryTimeouts.setDescription('The number of entries which were removed from routing table because the aging algorithm indicated that they were invalid.')
tRTMPEntryDeletes = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryDeletes.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryDeletes.setDescription('The number of entries which were removed from the routing table for any reason other than aging, for instance, due to a command from a Network Management station.')
tRTMPEntryEqualReplaces = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryEqualReplaces.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryEqualReplaces.setDescription('The number of entries whose route was replaced by another route with the same hop count.')
tRTMPEntryBetterReplaces = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryBetterReplaces.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryBetterReplaces.setDescription('The number of entries whose route was replaced by another route with a lower hop count.')
tRTMPEntryAdds = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryAdds.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryAdds.setDescription('The number of new entries which have been added to the table.')
tRTMPZeroCounters = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("zero", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tRTMPZeroCounters.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPZeroCounters.setDescription('Writing this variable causes all the RTMP variables in this group to be set to zero.')
tZIPDeletes = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tZIPDeletes.setStatus('mandatory')
if mibBuilder.loadTexts: tZIPDeletes.setDescription('The number of Zones which have been deleted from the Zone Table.')
tZIPAdds = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tZIPAdds.setStatus('mandatory')
if mibBuilder.loadTexts: tZIPAdds.setDescription('The number of Zones which have been added to the Zone Table.')
tZIPZeroCounters = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("zero", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tZIPZeroCounters.setStatus('mandatory')
if mibBuilder.loadTexts: tZIPZeroCounters.setDescription('Writing this variable causes all the ZIP variables in this group to be set to zero.')
tAARPClearCache = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clear", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tAARPClearCache.setStatus('mandatory')
if mibBuilder.loadTexts: tAARPClearCache.setDescription('Writing this variable clears the AARP Cache.')
tKIPRoutesValid = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tKIPRoutesValid.setStatus('mandatory')
if mibBuilder.loadTexts: tKIPRoutesValid.setDescription('This variable can be used to force KIP to reacquire its configuration information.')
tNBPDeviceObject = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tNBPDeviceObject.setStatus('mandatory')
if mibBuilder.loadTexts: tNBPDeviceObject.setDescription("The NBP name used to advertise this device's primary NVE on the LAN interface.")
tNBPDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tNBPDeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: tNBPDeviceType.setDescription("The NBP type used to advertise this device's primary NVE on the LAN interface.")
tNBPDeviceZone = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tNBPDeviceZone.setStatus('mandatory')
if mibBuilder.loadTexts: tNBPDeviceZone.setDescription('The zone in which this device registers its primary NVE on the LAN interface.')
tNBPDeviceSocket = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tNBPDeviceSocket.setStatus('mandatory')
if mibBuilder.loadTexts: tNBPDeviceSocket.setDescription('The DDP socket number used by the device in NBP Responses for its primary NVE registered on the LAN interface.')
tATDialinNetwork = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tATDialinNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: tATDialinNetwork.setDescription("The AppleTalk network number in which AppleTalk dialin users appear. When tATDialInPacketDeliveryMode is routing(1) this value corresponds to the configured dialin network number. When tATDialInPacketDeliveryMode is endNodeForwarding(2) this value corresponds to the network number of the LAN interface. Note that when endNodeForwarding(2) it is possible that not all dialin clients have addresses on this network because there may not have been enough available node ids to obtain addresses for all of the clients. In this case another network in the extended range of the LAN interface may be used for the remaining clients' addresses. Ideally this should be a table of clients with their dialin addresses.")
tATDialinZone = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: tATDialinZone.setStatus('mandatory')
if mibBuilder.loadTexts: tATDialinZone.setDescription('The zone with which tATDialinNetwork is associated.')
tATRoutingMode = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("conformingRouter", 1), ("seedRouter", 2), ("endNode", 3), ("other", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tATRoutingMode.setStatus('mandatory')
if mibBuilder.loadTexts: tATRoutingMode.setDescription("The routing behavior of this device for AppleTalk. If the device is configured as conformingRouter(1) or seedRouter(2) then it will behave as an AppleTalk router on the LAN interface, and will route packets to all interfaces. If it is a conformingRouter(1) then it will learn its configuration for the LAN interface from other routers on that interface's directly-connected network. If it is a seedRouter(2) then it will use the configured LAN interface parameters. If the device is configured as endNode(3) it will behave as an AppleTalk endnode on the LAN interface. other(4) is provided in the event a value is returned which does not match any of the other enumerated values. It is not expected that this will happen.")
tATDialinPacketDeliveryMode = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("routing", 1), ("endNodeForwarding", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tATDialinPacketDeliveryMode.setStatus('mandatory')
if mibBuilder.loadTexts: tATDialinPacketDeliveryMode.setDescription('The method used to deliver packets to and from Appletalk dialin clients. If the device is configured as routing(1) it will use routing tables to deliver packets to and from dialin clients, which will be homed on an internal virtual interface (port). Technically, the value routing(1) is only valid if the device is acting as a router (the value of tATRoutingMode is conformingRouter(1) or seedRouter(2)). If the device is configured to use endNodeForwarding(2) then it will obtain addresses for dialin users in the LAN network range, and will defend those addresses. Packets to and from dialin clients will be forwarded. Technically the device may be configured as endNodeForwarding(2) when tATRoutingMode is any of: conformingRouter(1), seedRouter(2), or endNode(3). other(3) is provided in the event a value is returned which does not match any of the other enumerated values. It is not expected that this will happen.')
tRTMPEntryTotal = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tRTMPEntryTotal.setStatus('mandatory')
if mibBuilder.loadTexts: tRTMPEntryTotal.setDescription("The number of network (range) entries in the device's RTMP Table. This value is not cleared by the tRTMPZeroCounters switch.")
tZoneTotal = MibScalar((1, 3, 6, 1, 4, 1, 166, 4, 2, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tZoneTotal.setStatus('mandatory')
if mibBuilder.loadTexts: tZoneTotal.setDescription('The number of AppleTalk zones for which the device has learned one or more associated nets or net ranges. This value is not cleared by the tZIPZeroCounters switch.')
mibBuilder.exportSymbols("SHIVA-AT-MIB", tRTMPEntryAdds=tRTMPEntryAdds, tRTMPEntryDeletes=tRTMPEntryDeletes, tRTMPEntryTotal=tRTMPEntryTotal, tATRoutingMode=tATRoutingMode, tZIPDeletes=tZIPDeletes, tNBPDeviceZone=tNBPDeviceZone, tRTMPEntryBetterReplaces=tRTMPEntryBetterReplaces, tNBPDeviceObject=tNBPDeviceObject, tNBPDeviceSocket=tNBPDeviceSocket, tRTMPEntryEqualReplaces=tRTMPEntryEqualReplaces, tATDialinZone=tATDialinZone, tAARPClearCache=tAARPClearCache, tZIPZeroCounters=tZIPZeroCounters, tZoneTotal=tZoneTotal, tNBPDeviceType=tNBPDeviceType, tATDialinPacketDeliveryMode=tATDialinPacketDeliveryMode, tKIPRoutesValid=tKIPRoutesValid, tATDialinNetwork=tATDialinNetwork, tRTMPZeroCounters=tRTMPZeroCounters, tRTMPEntryTimeouts=tRTMPEntryTimeouts, tZIPAdds=tZIPAdds)

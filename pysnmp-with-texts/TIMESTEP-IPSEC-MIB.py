#
# PySNMP MIB module TIMESTEP-IPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TIMESTEP-IPSEC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:16:48 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, iso, Unsigned32, MibIdentifier, Bits, Gauge32, TimeTicks, ObjectIdentity, ModuleIdentity, Counter32, NotificationType, Integer32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "iso", "Unsigned32", "MibIdentifier", "Bits", "Gauge32", "TimeTicks", "ObjectIdentity", "ModuleIdentity", "Counter32", "NotificationType", "Integer32", "IpAddress")
TextualConvention, TruthValue, DateAndTime, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DateAndTime", "DisplayString")
timestep, = mibBuilder.importSymbols("TIMESTEP-MIB", "timestep")
ipsecMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 1022, 10))
ipsecMIB.setRevisions(('1970-01-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipsecMIB.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: ipsecMIB.setLastUpdated('9811091200Z')
if mibBuilder.loadTexts: ipsecMIB.setOrganization('IETF IPSec Working Group')
if mibBuilder.loadTexts: ipsecMIB.setContactInfo(' Newbridge Corporation 362 Terry Fox Drive Kanata, ON K0A 2H0 Canada 1-800-383-8211 tsupport@newbridge.com')
if mibBuilder.loadTexts: ipsecMIB.setDescription('The MIB module to describe generic IPSec objects, transient and permanent virtual tunnels created by IPSec SAs, and entity level IPSec objects and events.')
ipsecMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1))
ipsec = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1))
ipsecIkeSaTable = MibTable((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1), )
if mibBuilder.loadTexts: ipsecIkeSaTable.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTable.setDescription("The (conceptual) table containing information on IPSec's IKE SAs.")
ipsecIkeSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1), ).setIndexNames((0, "TIMESTEP-IPSEC-MIB", "ipsecIkeSaIndex"))
if mibBuilder.loadTexts: ipsecIkeSaEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEntry.setDescription('An entry (conceptual row) containing the information on a particular IKE SA.')
ipsecIkeSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIndex.setDescription("A unique value, greater than zero, for each tunnel interface. It is recommended that values are assigned contiguously starting from 1. The value for each tunnel interface must remain constant at least from one re-initialization of entity's network management system to the next re-initialization. Further, the value for tunnel interfaces that are marked as permanent must remain constant across all re- initializations of the network management system.")
ipsecIkeSaPeerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerIpAddress.setDescription('The IP address of the peer that this SA was negotiated with, or 0 if unknown.')
ipsecIkeSaPeerPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerPortNumber.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerPortNumber.setDescription('The port number of the peer that this SA was negotiated with, or 0 if the default ISAKMP port number (500).')
ipsecIkeSaAuthMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaAuthMethod.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaAuthMethod.setDescription('The authentication method used to authenticate the peers. Note that this does not include the specific method of authentication if extended authenticated is used. Specific values are used as described in the ISAKMP Class Values of Authentication Method from Appendix A of [IKE].')
ipsecIkeSaPeerIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerIdType.setDescription('The type of ID used by the peer. Specific values are used as described in Section 4.6.2.1 of [IPDOI].')
ipsecIkeSaPeerId = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerId.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerId.setDescription('The ID of the peer this SA was negotiated with. The length may require truncation under some conditions.')
ipsecIkeSaPeerCertSerialNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerCertSerialNum.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerCertSerialNum.setDescription('The serial number of the certificate of the peer this SA was negotiated with. This object has no meaning if a certificate was not used in authenticating the peer.')
ipsecIkeSaPeerCertIssuer = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerCertIssuer.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerCertIssuer.setDescription('The serial number of the certificate of the peer this SA was negotiated with. This object has no meaning if a certificate was not used in authenticating the peer.')
ipsecIkeSaType = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transient", 1), ("permanent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaType.setDescription('The type of virtual tunnel represented by this row. A transient link will disappear from the table when the SAs needed for it cannot be established. A permanent link will shows its status in the ipsecIkeSaStatus object.')
ipsecIkeSaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("neverTried", 0), ("linkUp", 1), ("linkDown", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaStatus.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaStatus.setDescription("The status of the virtual tunnel represented by this row, if the tunnel is configured as permanent. 'neverTried' means that no attempt to set-up the link has been done. 'linkUp' means that the link is up and operating normally. 'linkDown' means that the link was up, but has gone down.")
ipsecIkeSaEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic carried by this SA or 0 if there is no encryption applied. Specific values are used as described in the ISAKMP Class Values of Encryption Algorithms from Appendix A of [IKE].')
ipsecIkeSaEncKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEncKeyLength.setDescription('The length of the encryption key in bits used for algorithm specified in the ipsecIkeSaEncAlg object or 0 if the key length is implicit in the specified algorithm or there is no encryption specified.')
ipsecIkeSaHashAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaHashAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaHashAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA or 0 if there is no encryption applied. Specific values are used as described in the ISAKMP Class Values of Hash Algorithms from Appendix A of [IKE].')
ipsecIkeSaDifHelGroupDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupDesc.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupDesc.setDescription('A unique value representing the Diffie-Hellman group description used or 0 if the group is unknown. Specific values are used as described in the ISAKMP Class Values of Group Description from Appendix A of [IKE].')
ipsecIkeSaDifHelGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupType.setDescription('A unique value representing the Diffie-Hellman group type used or 0 if the group is unknown. Specific values are used as described in the ISAKMP Class Values of Group Type from Appendix A of [IKE].')
ipsecIkeSaDifHelFieldSize = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelFieldSize.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelFieldSize.setDescription('The field size, in bits, of a Diffie-Hellman group.')
ipsecIkeSaPRF = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPRF.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPRF.setDescription('The pseudo-random functions used, or 0 if not used or if unknown. Specific values are used as described in the ISAKMP Class Values of PRF from Appendix A of [IKE] (which specifies none at the present time).')
ipsecIkeSaPFS = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPFS.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPFS.setDescription('A value that indicates that perfect forward secrecy is used for all IPSec SAs created by this IKE SA.')
ipsecIkeSaInitiatorCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInitiatorCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInitiatorCookie.setDescription('The value of the cookie used by the initiator for the current phase 1 SA.')
ipsecIkeSaResponderCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaResponderCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaResponderCookie.setDescription('The value of the cookie used by the responder for the current phase 1 SA.')
ipsecIkeSaTimeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 21), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTimeStart.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTimeStart.setDescription('The date and time that the current SA within the link was set up. It is not the date and time that the virtual tunnel was set up.')
ipsecIkeSaTimeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTimeLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTimeLimit.setDescription('The maximum lifetime in seconds of the current SA supporting the virtual tunnel, or 0 if there is no time constraint on its expiration.')
ipsecIkeSaTrafficLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTrafficLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTrafficLimit.setDescription('The maximum traffic in 1024-byte blocks that the current SA supporting the virtual tunnel is allowed to support, or 0 if there is no traffic constraint on its expiration.')
ipsecIkeSaInboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInboundTraffic.setDescription('The amount traffic measured in bytes handled in the current SA in the inbound direction. ')
ipsecIkeSaOutboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOutboundTraffic.setDescription('The amount traffic measured in bytes handled in the current SA in the outbound direction. ')
ipsecIkeSaInboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInboundPackets.setDescription('The number of packets handled in the current SA in the inbound direction. ')
ipsecIkeSaOutboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOutboundPackets.setDescription('The number of packets handled in the current SA in the outbound direction. ')
ipsecIkeSaTotalSaNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTotalSaNum.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTotalSaNum.setDescription('The total number of SAs, including the current SA, that have been set up to support this virtual tunnel.')
ipsecIkeSaFirstTimeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 29), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaFirstTimeStart.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaFirstTimeStart.setDescription("The data and time that this virtual tunnel was originally set up. It is not the time that the current SA was set up. If this is a permanent virtual tunnel, it is reset when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaTotalInboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTotalInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTotalInboundTraffic.setDescription("The total amount of traffic measured in bytes handled in the tunnel in the inbound direction. In other words, it is the aggregate value of all inbound traffic carried by all SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaTotalOutboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTotalOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTotalOutboundTraffic.setDescription("The total amount of traffic measured in bytes handled in the tunnel in the outbound direction. In other words, it is the aggregate value of all inbound traffic carried by all SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaTotalInboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTotalInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTotalInboundPackets.setDescription("The total number of packets handled by the virtual tunnel since it became active in the inbound direction. In other words, it is the aggregate value of the number of inbound packets carried by all SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaTotalOutboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTotalOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTotalOutboundPackets.setDescription("The total number of packets handled by the virtual tunnel since it became active in the outbound direction. In other words, it is the aggregate value of the number of outbound packets carried by all SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDecryptErrors.setDescription("The total number of inbound packets to this SA discarded due to decryption errors. Note that this refers to IKE protocol packets, and not to packets carried by SAs set up by the SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaHashErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaHashErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaHashErrors.setDescription("The total number of inbound packets to this SA discarded due to hash errors. Note that this refers to IKE protocol packets, and not to packets carried by SAs set up by the SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOtherReceiveErrors.setDescription("The total number of inbound packets to this SA discarded for reasons other than bad hashes or decryption errors. This may include packets dropped to a lack of receive buffer space. Note that this refers to IKE protocol packets, and not to packets carried by SAs set up by the SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaSendErrors.setDescription("The total number of outbound packets from this SA discarded for any reason. This may include packets dropped to a lack of transmit buffer space. Note that this refers to IKE protocol packets, and not to packets carried by SAs set up by the SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecInboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecInboundTraffic.setDescription("The total amount of inbound traffic measured in bytes handled by all IPSec SAs set up by phase 1 SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecOutboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecOutboundTraffic.setDescription("The total amount of outbound traffic measured in bytes handled by all IPSec SAs set up by phase 1 SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecInboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecInboundPackets.setDescription("The total number of inbound packets handled by all IPSec SAs set up by phase 1 SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecOutboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecOutboundPackets.setDescription("The total number of outbound packets handled by all IPSec SAs set up by phase 1 SAs supporting this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecDecryptErrors.setDescription("The total number of inbound packets discarded by all IPSec SAs due to decryption errors. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecAuthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecAuthErrors.setDescription("The total number of inbound packets discarded by all IPSec SAs due to authentication errors. This includes hash failures in IPSec SAs using ESP and AH. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecReplayErrors.setDescription("The total number of inbound packets discarded by all IPSec SAs due to replay errors. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecOtherReceiveErrors.setDescription("The total number of inbound packets discarded by all IPSec SAs due to errors other than authentication, decryption or replay errors. This may include packets dropped due to lack of receive buffers. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecIkeSaIpsecSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 1, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIpsecSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIpsecSendErrors.setDescription("The total number of outbound packets discarded by all IPSec SAs due to any error. This may include packets dropped due to lack of receive buffers. If this is a permanent virtual tunnel, it is not reset to zero when the tunnel goes to the 'linkUp' state.")
ipsecTunnelTable = MibTable((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2), )
if mibBuilder.loadTexts: ipsecTunnelTable.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTable.setDescription('The (conceptual) table containing information on IPSec SA-based tunnels.')
ipsecTunnelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1), ).setIndexNames((0, "TIMESTEP-IPSEC-MIB", "ipsecTunnelIndex"))
if mibBuilder.loadTexts: ipsecTunnelEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelEntry.setDescription('An entry (conceptual row) containing the information on a particular configured tunnel.')
ipsecTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelIndex.setDescription("A unique value, greater than zero, for each tunnel interface. It is recommended that values are assigned contiguously starting from 1. The value for each tunnel interface must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. Further, the value for tunnel interfaces that are marked as permanent must remain constant across all re- initializations of the network management system.")
ipsecTunnelIkeSa = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelIkeSa.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelIkeSa.setDescription('The value of the index into the IKE SA tunnel table that created this tunnel (ipsecIkeSaIndex), or 0 if the tunnel is created by a static IPSec SA.')
ipsecTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("static", 0), ("transient", 1), ("permanent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelType.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelType.setDescription("The type of the virtual tunnel represented by this row. 'static' means that the tunnel is supported by a single static IPSec SA that was setup by configuration, and not by using a key exchange protocol. In this case, the value of ipsecTunnelIkeSa must be 0.")
ipsecTunnelLocalAddressOrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelLocalAddressOrStart.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelLocalAddressOrStart.setDescription('The address of or the start address (if an address range) of the local endpoint of the tunnel, or 0.0.0.0 if unknown or if the SA uses transport mode encapsulation.')
ipsecTunnelLocalAddressMaskOrEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelLocalAddressMaskOrEnd.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelLocalAddressMaskOrEnd.setDescription('The mask of or the end address (if an address range) of the local endpoint of the tunnel, or 0.0.0.0 if unknown or if the SA uses transport mode encapsulation.')
ipsecTunnelRemoteAddressOrStart = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelRemoteAddressOrStart.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelRemoteAddressOrStart.setDescription('The address of or the start address (if an address range) of the remote endpoint of the tunnel, or 0.0.0.0 if unknown or if the SA uses transport mode encapsulation.')
ipsecTunnelRemoteAddressMaskOrEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelRemoteAddressMaskOrEnd.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelRemoteAddressMaskOrEnd.setDescription('The mask of or the end address (if an address range) of the remote endpoint of the tunnel, or 0.0.0.0 if unknown or if the SA uses transport mode encapsulation.')
ipsecTunnelProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelProtocol.setDescription('The number of the protocol that this tunnel carries, or 0 if it carries any protocol.')
ipsecTunnelLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelLocalPort.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelLocalPort.setDescription('The number of the local port that this tunnel carries, or 0 if it carries any port number.')
ipsecTunnelRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelRemotePort.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelRemotePort.setDescription('The number of the remote port that this tunnel carries, or 0 if it carries any port number.')
ipsecTunnelMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transport", 1), ("tunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelMode.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelMode.setDescription('The type of encapsulation used by this virtual tunnel.')
ipsecTunnelEspEncAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelEspEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelEspEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic carried by this SA if it uses ESP or 0 if there is no encryption applied by ESP or if ESP is not used. Specific values are taken from section 4.4.4 of [IPDOI].')
ipsecTunnelEspEncKeyLength = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelEspEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelEspEncKeyLength.setDescription('The length of the encryption key in bits used for the algorithm specified in the ipsecTunnelEspEncAlg object, or 0 if the key length is implicit in the specified algorithm or there is no encryption specified.')
ipsecTunnelEspAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelEspAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelEspAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA if it uses ESP or 0 if there is no authentication applied by ESP or if ESP is not used. Specific values are taken from the Authentication Algorithm attribute values of Section 4.5 of [IPDOI].')
ipsecTunnelAhAuthAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelAhAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelAhAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA if it uses AH or 0 if AH is not used. Specific values are taken from Section 4.4.3 of [IPDOI].')
ipsecTunnelCompAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelCompAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelCompAlg.setDescription('A unique value representing the compression algorithm applied to traffic carried by this SA if it uses IPCOMP. Specific values are taken from Section 4.4.5 of [IPDOI].')
ipsecTunnelStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 17), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelStartTime.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelStartTime.setDescription('The date and time that this virtual tunnel was set up. If this is a permanent virtual tunnel, it is reset when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelCurrentSaNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelCurrentSaNum.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelCurrentSaNum.setDescription('The number of current SAs set up to support this virtual tunnel. If this number is 0, the tunnel must be considered down. Also if this number is 0, the tunnel must a permanent tunnel, since transient tunnels that are down do not appear in the table.')
ipsecTunnelTotalSaNum = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelTotalSaNum.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTotalSaNum.setDescription('The total number of SAs, including all current SAs, that have been set up to support this virtual tunnel.')
ipsecTunnelTotalInboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelTotalInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTotalInboundTraffic.setDescription('The total amount of traffic measured in bytes handled in the tunnel in the inbound direction. In other words, it is the aggregate value of all inbound traffic carried by all IPSec SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelTotalOutboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelTotalOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTotalOutboundTraffic.setDescription('The total amount of traffic measured in bytes handled in the tunnel in the outbound direction. In other words, it is the aggregate value of all inbound traffic carried by all IPSec SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelTotalInboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelTotalInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTotalInboundPackets.setDescription('The total number of packets handled in the tunnel in the inbound direction. In other words, it is the aggregate value of all inbound packets carried by all IPSec SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelTotalOutboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelTotalOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelTotalOutboundPackets.setDescription('The total number of packets handled in the tunnel in the outbound direction. In other words, it is the aggregate value of all outbound packets carried by all IPSec SAs ever set up to support the virtual tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelDecryptErrors.setDescription('The total number of inbound packets discarded by this virtual tunnel due to decryption errors in ESP. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelAuthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelAuthErrors.setDescription('The total number of inbound packets discarded by this virtual tunnel due to authentication errors. This includes hash failures in IPSec SA bundles using both ESP and AH. If this is a permanent virtual tunnel, it is not resetto zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelReplayErrors.setDescription('The total number of inbound packets discarded by this virtual tunnel due to replay errors. This includes replay failures in IPSec SA bundles using both ESP and AH. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelPolicyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelPolicyErrors.setDescription('The total number of inbound packets discarded by this virtual tunnel due to policy errors. This includes errors in all transforms if SA bundles are used. Policy errors are due to the detection of a packet that was inappropriately sent into this tunnel. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelOtherReceiveErrors.setDescription('The total number of inbound packets discarded by this virtual tunnel due to errors other than decryption, authentication or replay errors. This may include packets dropped due to a lack of receive buffers. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecTunnelSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTunnelSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecTunnelSendErrors.setDescription('The total number of outbound packets discarded by this virtual tunnel due to any error. This may include packets dropped due to a lack of transmit buffers. If this is a permanent virtual tunnel, it is not reset to zero when the number of current SAs (ipsecTunnelCurrentSaNum) changes from 0 to 1.')
ipsecSaTable = MibTable((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3), )
if mibBuilder.loadTexts: ipsecSaTable.setStatus('current')
if mibBuilder.loadTexts: ipsecSaTable.setDescription('The (conceptual) table containing information on IPSec SAs.')
ipsecSaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1), ).setIndexNames((0, "TIMESTEP-IPSEC-MIB", "ipsecSaIndex"))
if mibBuilder.loadTexts: ipsecSaEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecSaEntry.setDescription('An entry (conceptual row) containing the information on a particular IPSec SA.')
ipsecSaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecSaIndex.setDescription('A unique value, greater than zero, for each IPSec SA. It is recommended that values are assigned contiguously starting from 1.')
ipsecSaTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaTunnel.setStatus('current')
if mibBuilder.loadTexts: ipsecSaTunnel.setDescription('The value of the index into the IPSec SA tunnel table that this SA supports (ipsecTunnelIndex).')
ipsecSaInboundEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInboundEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInboundEspSpi.setDescription('The value of the SPI for the inbound SA that provides the ESP security service, or zero if ESP is not used.')
ipsecSaOutboundEspSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOutboundEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOutboundEspSpi.setDescription('The value of the SPI for the outbound SA that provides the ESP security service, or zero if ESP is not used.')
ipsecSaInboundAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInboundAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInboundAhSpi.setDescription('The value of the SPI for the inbound SA that provides the AH security service, or zero if AH is not used.')
ipsecSaOutboundAhSpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOutboundAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOutboundAhSpi.setDescription('The value of the SPI for the outbound SA that provides the AH security service, or zero if AH is not used.')
ipsecSaInboundCompCpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInboundCompCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInboundCompCpi.setDescription('The value of the CPI for the inbound SA that provides IP compression, or zero if IPCOMP is not used.')
ipsecSaOutboundCompCpi = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOutboundCompCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOutboundCompCpi.setDescription('The value of the CPI for the outbound SA that provides IP compression, or zero if IPCOMP is not used.')
ipsecSaCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 9), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaCreationTime.setStatus('current')
if mibBuilder.loadTexts: ipsecSaCreationTime.setDescription('The date and time that the current SA was set up.')
ipsecSaTimeLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaTimeLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecSaTimeLimit.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration.')
ipsecSaTrafficLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaTrafficLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecSaTrafficLimit.setDescription('The maximum traffic in 1024-byte blocks that the SA is allowed to support, or 0 if there is no traffic constraint on its expiration.')
ipsecSaInboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInboundTraffic.setDescription('The amount traffic measured in bytes handled by the SA in the inbound direction.')
ipsecSaOutboundTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOutboundTraffic.setDescription('The amount traffic measured in bytes handled by the SA in the outbound direction.')
ipsecSaInboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaInboundPackets.setDescription('The number of packets handled by the SA in the inbound direction.')
ipsecSaOutboundPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOutboundPackets.setDescription('The number of packets handled by the SA in the outbound direction.')
ipsecSaDecryptErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaDecryptErrors.setDescription('The number of inbound packets discarded by the SA due to decryption errors.')
ipsecSaAuthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaAuthErrors.setDescription('The number of inbound packets discarded by the SA due to authentication errors. This includes hash failures in both ESP and AH.')
ipsecSaReplayErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaReplayErrors.setDescription('The number of inbound packets discarded by the SA due to replay errors. This includes replay failures both ESP and AH.')
ipsecSaOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaOtherReceiveErrors.setDescription('The number of inbound packets discarded by the SA due to errors other than decryption, authentication or replay errors. This may include decompression errors or errors due to a lack of receive buffers.')
ipsecSaSendErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecSaSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecSaSendErrors.setDescription('The number of outbound packets discarded by the SA due to any error. This may include compression errors or errors due to a lack of transmit buffers.')
ipsecTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4))
ipsecSaCounts = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 5))
ipsecPermTunStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 6))
ipsecTransTunStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7))
ipsecNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8))
ipsecErrorStats = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9))
ipsecTotalIkeSAs = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalIkeSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalIkeSAs.setDescription('The total number of phase 1 SAs established by the entity since boot time. It is not the total number of tunnels established by the entity since boot time. It does include SAs established to support both permanent and transient tunnels.')
ipsecTotalIpsecSAs = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalIpsecSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalIpsecSAs.setDescription('The total number of phase 2 SAs established by the entity since boot time. It is not the total number of IPSec virtual tunnels established by the entity since boot time. It does include SAs established to support permanent and transient tunnels. It is recommended that SA bundles or security suites be considered a single SA for the purposes of this statistic.')
ipsecCnfgPermIkeTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCnfgPermIkeTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecCnfgPermIkeTunnels.setDescription('The total number of phase 1 tunnels in the entity that are configured as permanent.')
ipsecUpPermIkeTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 6, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecUpPermIkeTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecUpPermIkeTunnels.setDescription('The total number of phase 1 tunnels in the entity that are configured as permanent and are up and available for use.')
ipsecCnfgPermIpsecTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 6, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCnfgPermIpsecTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecCnfgPermIpsecTunnels.setDescription('The total number of phase 2 tunnels in the entity that are configured as permanent.')
ipsecUpPermIpsecTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 6, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecUpPermIpsecTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecUpPermIpsecTunnels.setDescription('The total number of phase 2 tunnels in the entity that are configured as permanent and are up and available for use.')
ipsecTotalTransIkeTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransIkeTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransIkeTunnels.setDescription('The total number of transient phase 1 tunnels established by the entity since boot time.')
ipsecCurrentTransIkeTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurrentTransIkeTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecCurrentTransIkeTunnels.setDescription('The number of transient phase 1 tunnels in the entity that are up and available for use at this moment in time.')
ipsecTotalTransIpsecTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransIpsecTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransIpsecTunnels.setDescription('The total number of transient phase 2 tunnels established by the entity since boot time.')
ipsecCurrentTransIpsecTunnels = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecCurrentTransIpsecTunnels.setStatus('current')
if mibBuilder.loadTexts: ipsecCurrentTransIpsecTunnels.setDescription('The number of phase 2 tunnels in the entity that are up and available for use at this moment in time.')
ipsecTotalTransInboundPackets = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransInboundPackets.setDescription('The total number of inbound packets carried on transient IPSec tunnels since boot time.')
ipsecTotalTransOutboundPackets = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransOutboundPackets.setDescription('The total number of outbound packets carried on transient IPSec tunnels since boot time.')
ipsecTotalTransInboundTraffic = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransInboundTraffic.setDescription('The total amount of inbound traffic carried on transient IPSec tunnels since boot time, measured in 1024-octet blocks.')
ipsecTotalTransOutboundTraffic = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransOutboundTraffic.setDescription('The total amount of outbound traffic carried on transient IPSec tunnels since boot time, measured in 1024-octet blocks.')
ipsecTotalTransIkeSetupFailures = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 7, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecTotalTransIkeSetupFailures.setStatus('current')
if mibBuilder.loadTexts: ipsecTotalTransIkeSetupFailures.setDescription('The total number of IKE SA set up attempts that have failed since entity boot time. This includes SAs associated with transient tunnels only.')
ipsecUnknownSpiErrors = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setDescription('The total number of packets received by the entity since boot time with SPIs or CPIs that were not valid.')
ipsecIkeProtocolErrors = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeProtocolErrors.setDescription('The total number of packets received by the entity since boot time with IKE protocol errors. This includes packets with invalid cookies, but does not include errors that could be associated with specific IKE SAs.')
ipsecIpsecAuthenticationErrors = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecAuthenticationErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecAuthenticationErrors.setDescription('The total number of packets received by the entity since boot time with authentication errors in the IPSec SAs. This includes all packets in which the hash value is determined to be invalid.')
ipsecIpsecReplayErrors = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecReplayErrors.setDescription('The total number of packets received by the entity since boot time with replay errors in the IPSec SAs.')
ipsecIpsecPolicyErrors = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 9, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecPolicyErrors.setDescription('The total number of packets received by the entity since boot time and discarded due to policy errors. This includes packets that had selectors that were invalid for the SA that carried them.')
ipsecNotifyMessageTotalCount = MibScalar((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessageTotalCount.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessageTotalCount.setDescription("The total number of all types of notify messages sent or received by the entity since boot time. It is the sum of all occurrences in the 'ipsecNotifyCountTable'.")
ipsecNotifyCountTable = MibTable((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8, 2), )
if mibBuilder.loadTexts: ipsecNotifyCountTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyCountTable.setDescription('The (conceptual) table containing information on IPSec notify message counts. This table MAY be sparsely populated; that is, rows for which the count is 0 may be absent.')
ipsecNotifyCountEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8, 2, 1), ).setIndexNames((0, "TIMESTEP-IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecNotifyCountEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyCountEntry.setDescription('An entry (conceptual row) containing the total number of occurrences of a notify message.')
ipsecNotifyMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessage.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessage.setDescription('The value representing a specific IPSec notify message, or 0 if unknown. Values are assigned from the set of notify message types as defined in Section 3.14.1 of [ISAKMP]. In addition, the value 0 may be used for this object when the object is used as a trap cause, and the cause is unknown.')
ipsecNotifyMessageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 8, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessageCount.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessageCount.setDescription('The total number of times the specific notify message has been received or sent by the entity since system boot.')
ipsecTrapsObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0))
ipsecTrapPermIkeNegFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 1)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecIkeSaIndex"), ("TIMESTEP-IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecTrapPermIkeNegFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapPermIkeNegFailure.setDescription('An attempt to negotiate a phase 1 SA for the specified permanent IKE tunnel failed.')
ipsecTrapTransIkeNegFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 2)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerIpAddress"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerPortNumber"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaAuthMethod"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerIdType"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerId"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerCertSerialNum"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerCertIssuer"), ("TIMESTEP-IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecTrapTransIkeNegFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapTransIkeNegFailure.setDescription("An attempt to negotiate a phase 1 SA for a transient IKE tunnel failed. This trap is different from the 'ipsecTrapPermIkeNegFailure' trap, since this one will likely result in the removal of this entry from the IKE SA tunnel table.")
ipsecTrapInvalidCookie = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 3)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerIpAddress"), ("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerPortNumber"))
if mibBuilder.loadTexts: ipsecTrapInvalidCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapInvalidCookie.setDescription('IKE packets with invalid cookies were detected from the specified peer. Implementations SHOULD send one trap per peer (within a reasonable time period, rather than sending one trap per packet.')
ipsecTrapIpsecNegFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 4)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecIkeSaIndex"), ("TIMESTEP-IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecTrapIpsecNegFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecNegFailure.setDescription('An attempt to negotiate a phase 2 SA within the specified IKE tunnel failed.')
ipsecTrapIpsecAuthFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 5)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecSaIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecAuthFailure.setDescription('IPSec packets with invalid hashes were found in the specified SA. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapIpsecReplayFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 6)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecSaIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecReplayFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecReplayFailure.setDescription('IPSec packets with invalid sequence numbers were found in the specified SA. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapIpsecPolicyFailure = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 7)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecSaIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecPolicyFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecPolicyFailure.setDescription('IPSec packets carrying packets with invalid selectors for the specified SA were found. Implementations SHOULD send one trap per SA (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapInvalidSpi = NotificationType((1, 3, 6, 1, 4, 1, 1022, 10, 1, 1, 4, 0, 8)).setObjects(("TIMESTEP-IPSEC-MIB", "ipsecIkeSaPeerIpAddress"))
if mibBuilder.loadTexts: ipsecTrapInvalidSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapInvalidSpi.setDescription('ESP, AH or IPCOMP packets with unknown SPIs (or CPIs) were detected from the specified peer. Implementations SHOULD send one trap per peer (within a reasonable time period), rather than sending one trap per packet.')
mibBuilder.exportSymbols("TIMESTEP-IPSEC-MIB", ipsecIkeSaEntry=ipsecIkeSaEntry, ipsecIkeSaHashErrors=ipsecIkeSaHashErrors, ipsecTunnelProtocol=ipsecTunnelProtocol, ipsecIkeSaAuthMethod=ipsecIkeSaAuthMethod, ipsecIkeSaPeerId=ipsecIkeSaPeerId, ipsecTunnelLocalAddressOrStart=ipsecTunnelLocalAddressOrStart, ipsecTunnelRemoteAddressOrStart=ipsecTunnelRemoteAddressOrStart, ipsecIkeSaEncAlg=ipsecIkeSaEncAlg, ipsecSaOutboundCompCpi=ipsecSaOutboundCompCpi, ipsecSaCounts=ipsecSaCounts, ipsecIkeSaStatus=ipsecIkeSaStatus, ipsecIkeSaInboundTraffic=ipsecIkeSaInboundTraffic, ipsecTunnelIkeSa=ipsecTunnelIkeSa, ipsecNotifyMessageCount=ipsecNotifyMessageCount, ipsecIkeSaTrafficLimit=ipsecIkeSaTrafficLimit, ipsecSaOutboundEspSpi=ipsecSaOutboundEspSpi, ipsecTrapInvalidCookie=ipsecTrapInvalidCookie, ipsecIkeSaOutboundPackets=ipsecIkeSaOutboundPackets, ipsecIkeSaPeerIdType=ipsecIkeSaPeerIdType, ipsecIkeSaPeerCertIssuer=ipsecIkeSaPeerCertIssuer, ipsecIkeSaIpsecOutboundTraffic=ipsecIkeSaIpsecOutboundTraffic, ipsecTunnelIndex=ipsecTunnelIndex, ipsecIkeSaOutboundTraffic=ipsecIkeSaOutboundTraffic, ipsecIkeSaInboundPackets=ipsecIkeSaInboundPackets, ipsecTrapInvalidSpi=ipsecTrapInvalidSpi, ipsecTunnelSendErrors=ipsecTunnelSendErrors, ipsecSaInboundTraffic=ipsecSaInboundTraffic, ipsecTunnelTotalInboundTraffic=ipsecTunnelTotalInboundTraffic, ipsecIkeSaIpsecReplayErrors=ipsecIkeSaIpsecReplayErrors, ipsecUpPermIkeTunnels=ipsecUpPermIkeTunnels, ipsecTotalTransIkeTunnels=ipsecTotalTransIkeTunnels, ipsecCnfgPermIpsecTunnels=ipsecCnfgPermIpsecTunnels, ipsecTunnelType=ipsecTunnelType, ipsecTunnelOtherReceiveErrors=ipsecTunnelOtherReceiveErrors, ipsecTotalTransIkeSetupFailures=ipsecTotalTransIkeSetupFailures, ipsecTrapIpsecPolicyFailure=ipsecTrapIpsecPolicyFailure, ipsecSaTimeLimit=ipsecSaTimeLimit, ipsecTunnelDecryptErrors=ipsecTunnelDecryptErrors, ipsecTunnelAuthErrors=ipsecTunnelAuthErrors, ipsecTunnelAhAuthAlg=ipsecTunnelAhAuthAlg, ipsecPermTunStats=ipsecPermTunStats, ipsecIkeProtocolErrors=ipsecIkeProtocolErrors, ipsecIpsecReplayErrors=ipsecIpsecReplayErrors, ipsecIkeSaPeerCertSerialNum=ipsecIkeSaPeerCertSerialNum, ipsecIkeSaDifHelGroupDesc=ipsecIkeSaDifHelGroupDesc, ipsecIkeSaIpsecSendErrors=ipsecIkeSaIpsecSendErrors, ipsecSaTable=ipsecSaTable, ipsecTrapIpsecAuthFailure=ipsecTrapIpsecAuthFailure, ipsecTunnelTable=ipsecTunnelTable, ipsecTrapPermIkeNegFailure=ipsecTrapPermIkeNegFailure, ipsecTunnelRemotePort=ipsecTunnelRemotePort, ipsecSaCreationTime=ipsecSaCreationTime, ipsecIkeSaOtherReceiveErrors=ipsecIkeSaOtherReceiveErrors, ipsecTrapTransIkeNegFailure=ipsecTrapTransIkeNegFailure, ipsecIkeSaTable=ipsecIkeSaTable, ipsecCurrentTransIkeTunnels=ipsecCurrentTransIkeTunnels, ipsecTrapIpsecReplayFailure=ipsecTrapIpsecReplayFailure, ipsecTunnelEspEncKeyLength=ipsecTunnelEspEncKeyLength, ipsecSaOutboundAhSpi=ipsecSaOutboundAhSpi, ipsecSaOutboundPackets=ipsecSaOutboundPackets, ipsecSaDecryptErrors=ipsecSaDecryptErrors, ipsecIkeSaPeerPortNumber=ipsecIkeSaPeerPortNumber, ipsec=ipsec, ipsecTunnelTotalSaNum=ipsecTunnelTotalSaNum, PYSNMP_MODULE_ID=ipsecMIB, ipsecSaInboundPackets=ipsecSaInboundPackets, ipsecIkeSaInitiatorCookie=ipsecIkeSaInitiatorCookie, ipsecTunnelLocalPort=ipsecTunnelLocalPort, ipsecIkeSaIpsecInboundTraffic=ipsecIkeSaIpsecInboundTraffic, ipsecSaReplayErrors=ipsecSaReplayErrors, ipsecIkeSaPRF=ipsecIkeSaPRF, ipsecNotifyMessage=ipsecNotifyMessage, ipsecIkeSaDecryptErrors=ipsecIkeSaDecryptErrors, ipsecTunnelPolicyErrors=ipsecTunnelPolicyErrors, ipsecIkeSaIndex=ipsecIkeSaIndex, ipsecNotifications=ipsecNotifications, ipsecSaOtherReceiveErrors=ipsecSaOtherReceiveErrors, ipsecIkeSaHashAlg=ipsecIkeSaHashAlg, ipsecSaAuthErrors=ipsecSaAuthErrors, ipsecIkeSaDifHelGroupType=ipsecIkeSaDifHelGroupType, ipsecMIBObjects=ipsecMIBObjects, ipsecIkeSaEncKeyLength=ipsecIkeSaEncKeyLength, ipsecTunnelCompAlg=ipsecTunnelCompAlg, ipsecIkeSaIpsecInboundPackets=ipsecIkeSaIpsecInboundPackets, ipsecIpsecPolicyErrors=ipsecIpsecPolicyErrors, ipsecIkeSaIpsecDecryptErrors=ipsecIkeSaIpsecDecryptErrors, ipsecUpPermIpsecTunnels=ipsecUpPermIpsecTunnels, ipsecNotifyMessageTotalCount=ipsecNotifyMessageTotalCount, ipsecSaInboundAhSpi=ipsecSaInboundAhSpi, ipsecTunnelStartTime=ipsecTunnelStartTime, ipsecTunnelCurrentSaNum=ipsecTunnelCurrentSaNum, ipsecTunnelTotalOutboundPackets=ipsecTunnelTotalOutboundPackets, ipsecIkeSaTimeStart=ipsecIkeSaTimeStart, ipsecIkeSaTotalInboundPackets=ipsecIkeSaTotalInboundPackets, ipsecTransTunStats=ipsecTransTunStats, ipsecIkeSaResponderCookie=ipsecIkeSaResponderCookie, ipsecTunnelEspEncAlg=ipsecTunnelEspEncAlg, ipsecTrapIpsecNegFailure=ipsecTrapIpsecNegFailure, ipsecMIB=ipsecMIB, ipsecTotalIkeSAs=ipsecTotalIkeSAs, ipsecSaIndex=ipsecSaIndex, ipsecIkeSaTotalOutboundTraffic=ipsecIkeSaTotalOutboundTraffic, ipsecCnfgPermIkeTunnels=ipsecCnfgPermIkeTunnels, ipsecTunnelTotalInboundPackets=ipsecTunnelTotalInboundPackets, ipsecSaInboundEspSpi=ipsecSaInboundEspSpi, ipsecIkeSaTimeLimit=ipsecIkeSaTimeLimit, ipsecIkeSaDifHelFieldSize=ipsecIkeSaDifHelFieldSize, ipsecTunnelTotalOutboundTraffic=ipsecTunnelTotalOutboundTraffic, ipsecIkeSaTotalSaNum=ipsecIkeSaTotalSaNum, ipsecCurrentTransIpsecTunnels=ipsecCurrentTransIpsecTunnels, ipsecTrapsObjects=ipsecTrapsObjects, ipsecIkeSaPFS=ipsecIkeSaPFS, ipsecNotifyCountEntry=ipsecNotifyCountEntry, ipsecTunnelEntry=ipsecTunnelEntry, ipsecIkeSaTotalOutboundPackets=ipsecIkeSaTotalOutboundPackets, ipsecIkeSaIpsecOutboundPackets=ipsecIkeSaIpsecOutboundPackets, ipsecIpsecAuthenticationErrors=ipsecIpsecAuthenticationErrors, ipsecSaSendErrors=ipsecSaSendErrors, ipsecIkeSaIpsecAuthErrors=ipsecIkeSaIpsecAuthErrors, ipsecTotalTransOutboundTraffic=ipsecTotalTransOutboundTraffic, ipsecTunnelMode=ipsecTunnelMode, ipsecTunnelRemoteAddressMaskOrEnd=ipsecTunnelRemoteAddressMaskOrEnd, ipsecSaInboundCompCpi=ipsecSaInboundCompCpi, ipsecTotalTransInboundTraffic=ipsecTotalTransInboundTraffic, ipsecSaOutboundTraffic=ipsecSaOutboundTraffic, ipsecIkeSaPeerIpAddress=ipsecIkeSaPeerIpAddress, ipsecSaTrafficLimit=ipsecSaTrafficLimit, ipsecUnknownSpiErrors=ipsecUnknownSpiErrors, ipsecTotalTransOutboundPackets=ipsecTotalTransOutboundPackets, ipsecIkeSaFirstTimeStart=ipsecIkeSaFirstTimeStart, ipsecNotifyCountTable=ipsecNotifyCountTable, ipsecTraps=ipsecTraps, ipsecTunnelLocalAddressMaskOrEnd=ipsecTunnelLocalAddressMaskOrEnd, ipsecTotalIpsecSAs=ipsecTotalIpsecSAs, ipsecTunnelEspAuthAlg=ipsecTunnelEspAuthAlg, ipsecTotalTransIpsecTunnels=ipsecTotalTransIpsecTunnels, ipsecIkeSaTotalInboundTraffic=ipsecIkeSaTotalInboundTraffic, ipsecErrorStats=ipsecErrorStats, ipsecTotalTransInboundPackets=ipsecTotalTransInboundPackets, ipsecIkeSaType=ipsecIkeSaType, ipsecTunnelReplayErrors=ipsecTunnelReplayErrors, ipsecIkeSaIpsecOtherReceiveErrors=ipsecIkeSaIpsecOtherReceiveErrors, ipsecSaEntry=ipsecSaEntry, ipsecIkeSaSendErrors=ipsecIkeSaSendErrors, ipsecSaTunnel=ipsecSaTunnel)

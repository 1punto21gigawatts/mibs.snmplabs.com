#
# PySNMP MIB module Wellfleet-ATM-LE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-ATM-LE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:39:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Counter64, IpAddress, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Gauge32, ModuleIdentity, NotificationType, TimeTicks, Counter32, MibIdentifier, ObjectIdentity, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "IpAddress", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Gauge32", "ModuleIdentity", "NotificationType", "TimeTicks", "Counter32", "MibIdentifier", "ObjectIdentity", "Unsigned32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfAtmLeGroup, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfAtmLeGroup")
wfAtmLecConfigTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1), )
if mibBuilder.loadTexts: wfAtmLecConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigTable.setDescription('ATM LEC Interface table - One per LEC Client This table deals with configuration and operational status')
wfAtmLecConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecConfigCct"))
if mibBuilder.loadTexts: wfAtmLecConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigEntry.setDescription('per LEC Client objects - wfAtmLecCct corresponds to Wellfleet circuit number ')
wflecConfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfDelete.setDescription('Indication to create or delete an ATM LE Client Config Entry from the MIB ')
wflecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wflecRowStatus.setDescription('Indication to create or delete an ATM LE Client. This will remove the LEC from the Emulated LAN. However, the instance is not removed from the MIB ')
wflecConfigCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigCct.setDescription('This corresponds to the Wellfleet circuit number')
wflecOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecOwner.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
wflecConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("autocfg", 1), ("mancfg", 2))).clone('autocfg')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigMode.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigMode.setDescription('Indicates whether this LAN Emulation Client should auto-configure the next time it is (re)started.')
wflecConfigLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("ieee8023", 2), ("ieee8025", 3))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigLanType.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigLanType.setDescription('C2 - LEC LAN Type The data frame format which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. ')
wflecConfigMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspec", 1), ("size1516", 2), ("size4544", 3), ("size9234", 4), ("size18190", 5))).clone('unspec')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigMaxDataFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigMaxDataFrameSize.setDescription("C3 Maximum Data Frame Size. The maximum data frame size which this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, lecActualMaxDataFrameSize will be.'")
wflecConfigLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigLanName.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigLanName.setDescription("C5 ELAN Name. The ELAN Name this client will use the next time it returns to the Initial State. Auto-configuring clients use this parameter in their Configure requests. Manually-configured clients use it in their Join requests. This MIB object will not be overwritten with the new value from a LE_{JOIN,CONFIGURE}_RESPONSE. Instead, lecActualMaxDataFrameSize will be.' ")
wflecConfigLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server which this client will use the next time it is started in manual configuration mode. When lecConfigMode is 'automatic', there is no need to set this address, and no advantage to doing so. The client will use the LECS to find a LES, putting the auto-configured address in lecActualLesAtmAddress while leaving lecConfigLesAtmAddress alone. ")
wflecControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecControlTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlTimeout.setDescription('C7 Control Time-out. Time out period used for timing out most request/response control frame most request/response control frame interactions.')
wflecMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMaxUnknownFrameCount.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMaxUnknownFrameCount.setDescription('C10 Maximum Unknown Frame Count. This parameter MUST be less than or equal to 10. (See parameter C11) ')
wflecMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMaxUnknownFrameTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMaxUnknownFrameTime.setDescription('C11 Maximum Unknown Frame Time. This parameter MUST be greater than or equal to 1.0 seconds. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to a given MAC address or Route Designator without also initiating the address resolution protocol to resolve that MAC address or Route Designator. This time value is expressed in seconds. ')
wflecVccTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200))).clone(namedValues=NamedValues(("vcctmodef", 1200))).clone('vcctmodef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecVccTimeoutPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wflecVccTimeoutPeriod.setDescription('C12 VCC Timeout Period. A LE Client may release any Data Direct or Multicast Send VCC that it has not used to transmit or receive any data frames for the length of the VCC Timeout Period. This time value is expressed in seconds. ')
wflecMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMaxRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMaxRetryCount.setDescription("C13 Maximum Retry Count. A LE CLient MUST not retry a LE-ARP for a given frame's LAN destination more than Maximum Retry Count times, after which it must discard the frame.")
wflecAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecAgingTime.setDescription('C17 Aging Time. The maximum time that a LE Client will maintain an entry in its LE-ARP cache in the absence of a verification of that relationship.')
wflecForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 30)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecForwardDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecForwardDelayTime.setDescription('C18 Forward Delay Time. The maximum time that a LE Client will maintain an entry in its LE-ARP cache in the absence of a verification of that relationship, so long as the Topology Change flag C19 is true.')
wflecExpectedArpResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecExpectedArpResponseTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecExpectedArpResponseTime.setDescription('C20 Expected LE_ARP Reponse Time. The maximum time (seconds) that the LEC expects an LE_ARP_REQUEST/ LE_ARP_RESPONSE cycle to take. Used for retries and verifies. ')
wflecFlushTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecFlushTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wflecFlushTimeOut.setDescription('C21 Flush Time-out. Time limit (seconds) to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action.')
wflecPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecPathSwitchingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wflecPathSwitchingDelay.setDescription('C22 Path Switching Delay. The time (seconds) since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol.')
wflecLocalSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecLocalSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: wflecLocalSegmentID.setDescription("C23 Local Segment ID. The segment ID of the emulated LAN. This is only required for IEEE 802.5 clients that are Source Routing bridges.'")
wflecMulticastSendType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("abr", 1), ("vbr", 2), ("cbr", 3))).clone('cbr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMulticastSendType.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendType.setDescription('C24 Multicast Send VCC Type. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. This is the method to be used by the LE Client when specifying traffic parameters when it sets up the Multicast Send VCC for this emulated LAN.')
wflecMulticastSendAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMulticastSendAvgRate.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendAvgRate.setDescription('C25 Multicast Send VCC AvgRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Sustained Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. ')
wflecMulticastSendPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 23), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMulticastSendPeakRate.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendPeakRate.setDescription('C26 Multicast Send VCC PeakRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Peak Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. ')
wflecConnectionCompleteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConnectionCompleteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConnectionCompleteTimer.setDescription('C28 Connection Complete Timer. Optional. In Connection Establishment this is the time period in which data or a READY_IND message is expected from a Calling Party.')
wflecFlushEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecFlushEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wflecFlushEnable.setDescription('Flush Protocol enable/disable - ATM_LEC_FLUSH_ENABLED - ATM LE flush protocol is used when switching VCs. If the Flush timeout (wflecFlushTimeOut) expires data for that MAC address will start flowing over the old VC again. ATM_LEC_FLUSH_DISABLED - ATM LE flush protocol is not used. Instead data for that MAC address will automatically start flowing over the new VC once the Path Switching delay timeout (wflecPathSwitchingDelay) has expired.')
wflecConfigRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigRetry.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigRetry.setDescription('This attribute specifies how many retries should be attempted if any part of the config phase fails. The config phase starts with setting up the config direct VC and ends when a JOIN response is received. The default is 0 which means retry forever with a maximum timeout of 30 seconds between each retry. The time between each retry will start at 2 seconds and double from that point (never exceeding 30 seconds).')
wflecMulticastFwdTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5))).clone(namedValues=NamedValues(("mcsfwdtmodef", 5))).clone('mcsfwdtmodef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMulticastFwdTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastFwdTimeout.setDescription('The attribute specifies how many seconds to wait for the Multicast Forward VC to be set up before retrying. The retry will include closing the Multicast Send VC (if it has been opened) and reARPing for the BUS. A successful ARP response will result in the setup of the Multicast Send which in turn should result in the BUS setting up the Multicast Forward VC.')
wflecMulticastFwdRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10))).clone(namedValues=NamedValues(("mcsfwdrtrydef", 10))).clone('mcsfwdrtrydef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecMulticastFwdRetry.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastFwdRetry.setDescription('The attribute specifies how many retries should be made to get the Multicast Forward VC setup. The LEC will retry after wflecMulticastFwdTimeout seconds and will double this timeout for each each retry which follows. The timeout will not exeed 30 seconds however. After wflecMulticastFwdRetry retries, the LEC will restart itself. If wflecMulticastFwdRetry is set to 0 it will retry the BUS phase forever and will never restart itself.')
wflecDebugLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wflecDebugLevel.setDescription("Debug Levels - The level of debug desired from the Portable LEC code LEC_DBG_OFF - 0 LEC_DBG_WARN - 1 LEC_DBG_ERR - 2 LEC_DBG_MSG - 4 LEC_DBG_DBG - 8 LEC_DBG_VERBOSE - 16 This values above can be used separately, or OR'd together for a combination of debug levels. For example, to see both WARN and ERR messages, LEC_DBG_WARN OR LEC_DBG_ERR = 3, so set this object to 3.")
wflecConfigLECSAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 30), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigLECSAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigLECSAtmAddress.setDescription('The LE Config Server Address to be used. If left (or set) to NULL_VAL the well-known LECS ATM address will be used.')
wflecConfigV2Capable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecConfigV2Capable.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigV2Capable.setDescription('Indication to enable or disable LANE V2 support for this ATM LE Client.')
wfAtmLecStatusTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2), )
if mibBuilder.loadTexts: wfAtmLecStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecStatusTable.setDescription('Lan Emulation Status Group Read-only table containing identification, status, and operational information about the LAN Emulation Clients this agent manages ')
wfAtmLecStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecStatusCct"))
if mibBuilder.loadTexts: wfAtmLecStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecStatusEntry.setDescription('per LEC Client objects - wfAtmLecCct corresponds to Wellfleet circuit number ')
wflecStatusCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecStatusCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecStatusCct.setDescription('This corresponds to the Wellfleet circuit number')
wflecPrimaryAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecPrimaryAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecPrimaryAtmAddress.setDescription("C1 - LE Client's ATM Address.")
wflecID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecID.setStatus('mandatory')
if mibBuilder.loadTexts: wflecID.setDescription("C14 LE Client Identifier. Each LE Client requires a LE Client Identifier (LECID) assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client. This value MUST NOT change without terminating the LE Client and returning to the Initial state. A valid LECID MUST be in the range X'0001' through X'FEFF'. The value of this object is only meaningful for a LEC that is connected to a LES. For a LEC which does not belong to an emulated LAN, the value of this object is defined to be 0.'")
wflecInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initial", 1), ("lecsconnect", 2), ("configure", 3), ("join", 4), ("reg", 5), ("busconnect", 6), ("operational", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInterfaceState.setDescription('Indicates the state for the LE Client')
wflecLastFailureRespCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("none", 1), ("tmo", 2), ("undef", 3), ("vrsnotsup", 4), ("invreq", 5), ("dupdst", 6), ("dupatmadr", 7), ("insufres", 8), ("accdenied", 9), ("invreqid", 10), ("invdst", 11), ("invatmadr", 12), ("nocfg", 13), ("lecfgerr", 14), ("insufinfo", 15))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecLastFailureRespCode.setStatus('mandatory')
if mibBuilder.loadTexts: wflecLastFailureRespCode.setDescription("Failure response code. Status code from the last failed Configure response or Join response. Failed responses are those for which the LE_CONFIGURE_RESPONSE / LE_JOIN_RESPONSE frame contains a non-zero code, or fails to arrive within a timeout period. If none of this client's requests have failed, this object has the value 'none'. If the failed response contained a STATUS code that is not defined in the LAN Emulation specification, this object has the value 'undefinedError'. The value 'timeout' is self-explanatory. Other failure codes correspond to those defined in the specification, although they may have different numeric values.")
wflecLastFailureState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecLastFailureState.setStatus('mandatory')
if mibBuilder.loadTexts: wflecLastFailureState.setDescription("Last failure state The state this client was in when it updated the 'lecLastFailureRespCode'. If 'lecLastFailureRespCode' is 'none', this object has the value initialState(1).")
wflecProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("prot1", 1))).clone('prot1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wflecProtocol.setDescription('The LAN Emulation protocol which this client supports, and specifies in its LE_JOIN_REQUESTs. ')
wflecVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wflecVersion.setDescription('The LAN Emulation protocol version which this client supports, and specifies in its LE_JOIN_REQUESTs. ')
wflecTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: wflecTopologyChange.setDescription('C19 Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Ageing Time C17, to age entries in its LE-ARP cache.')
wflecConfigServerAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigServerAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigServerAtmAddress.setDescription('The ATM address of the LECS for this Client')
wflecConfigSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("viailmi", 1), ("knownadr", 2), ("cfgpvc", 3), ("nolecs", 4))).clone('nolecs')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigSource.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigSource.setDescription('Indicates whether this LAN Emulation Client used the LAN Emulation Configuration Server, and, if so, what method it used to establish the Configuration Direct VCC.')
wflecActualLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unspecified", 1), ("ieee8023", 2), ("ieee8025", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecActualLanType.setStatus('mandatory')
if mibBuilder.loadTexts: wflecActualLanType.setDescription('C2 - LEC LAN Type The data frame format that this LAN Emulation Client is using right now. This may come from lecConfigLanType, the LAN Emulation Configuration Server, or the LAN Emulation Server')
wflecActualMaxDataFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspec", 1), ("size1516", 2), ("size4544", 3), ("size9234", 4), ("size18190", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecActualMaxDataFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: wflecActualMaxDataFrameSize.setDescription('C3 Maximum Data Frame Size. The maximum data frame size that this LAN Emulation client is using right now. This may come from lecConfigLanType, the LAN Emulation Configuration Server, or the LAN Emulation Server ')
wflecActualLanName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecActualLanName.setStatus('mandatory')
if mibBuilder.loadTexts: wflecActualLanName.setDescription('C5 ELAN Name. The identity of the emulated LAN which this client last joined, or wishes to join. This may come from lecConfigLanType, the LAN Emulation Configuration Server, or the LAN Emulation Server')
wflecActualLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecActualLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecActualLesAtmAddress.setDescription("C9 LE Server ATM Address. The LAN Emulation Server address currently in use or most recently attempted. If no LAN Emulation Server attachment has been tried, this object's value is the zero-length string.' ")
wflecProxyClient = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecProxyClient.setStatus('mandatory')
if mibBuilder.loadTexts: wflecProxyClient.setDescription("C4 Proxy When a client joins an ATM emulated LAN, it indicates whether it wants to act as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST frames for such addresses.'")
wfAtmLecOperConfigTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3), )
if mibBuilder.loadTexts: wfAtmLecOperConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecOperConfigTable.setDescription('ATM LEC Interface table - One per LEC Client This table deals with configuration and operational status')
wfAtmLecOperConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecOperConfigCct"))
if mibBuilder.loadTexts: wfAtmLecOperConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecOperConfigEntry.setDescription('per LEC Operation Config objects - wfAtmLecOperConfigCct corresponds to Wellfleet circuit number ')
wflecOperConfigCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigCct.setDescription('This corresponds to the Wellfleet circuit number')
wflecOperConfigControlTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigControlTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigControlTimeout.setDescription('C7 Control Time-out. Time out period used for timing out most request/response control frame most request/response control frame interactions.')
wflecOperConfigMaxUnknownFrameCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMaxUnknownFrameCount.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMaxUnknownFrameCount.setDescription('C10 Maximum Unknown Frame Count. This parameter MUST be less than or equal to 10. (See parameter C11) ')
wflecOperConfigMaxUnknownFrameTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMaxUnknownFrameTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMaxUnknownFrameTime.setDescription('C11 Maximum Unknown Frame Time. This parameter MUST be greater than or equal to 1.0 seconds. Within the period of time defined by the Maximum Unknown Frame Time, a LE Client will send no more than Maximum Unknown Frame Count frames to a given MAC address or Route Designator without also initiating the address resolution protocol to resolve that MAC address or Route Designator. This time value is expressed in seconds. ')
wflecOperConfigVccTimeoutPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigVccTimeoutPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigVccTimeoutPeriod.setDescription('C12 VCC Timeout Period. A LE Client may release any Data Direct or Multicast Send VCC that it has not used to transmit or receive any data frames for the length of the VCC Timeout Period. This time value is expressed in seconds. ')
wflecOperConfigMaxRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMaxRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMaxRetryCount.setDescription("C13 Maximum Retry Count. A LE CLient MUST not retry a LE-ARP for a given frame's LAN destination more than Maximum Retry Count times, after which it must discard the frame.")
wflecOperConfigAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigAgingTime.setDescription('C17 Aging Time. The maximum time that a LE Client will maintain an entry in its LE-ARP cache in the absence of a verification of that relationship.')
wflecOperConfigForwardDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigForwardDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigForwardDelayTime.setDescription('C18 Forward Delay Time. The maximum time that a LE Client will maintain an entry in its LE-ARP cache in the absence of a verification of that relationship, so long as the Topology Change flag C19 is true.')
wflecOperConfigTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigTopologyChange.setDescription('C19 Topology Change. Boolean indication that the LE Client is using the Forward Delay Time C18, instead of the Ageing Time C17, to age entries in its LE-ARP cache.')
wflecOperConfigExpectedArpResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigExpectedArpResponseTime.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigExpectedArpResponseTime.setDescription('C20 Expected LE_ARP Reponse Time. The maximum time (seconds) that the LEC expects an LE_ARP_REQUEST/ LE_ARP_RESPONSE cycle to take. Used for retries and verifies. ')
wflecOperConfigFlushTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigFlushTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigFlushTimeOut.setDescription('C21 Flush Time-out. Time limit (seconds) to wait to receive a LE_FLUSH_RESPONSE after the LE_FLUSH_REQUEST has been sent before taking recovery action.')
wflecOperConfigPathSwitchingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigPathSwitchingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigPathSwitchingDelay.setDescription('C22 Path Switching Delay. The time (seconds) since sending a frame to the BUS after which the LE Client may assume that the frame has been either discarded or delivered to the recipient. May be used to bypass the Flush protocol.')
wflecOperConfigLocalSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigLocalSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigLocalSegmentID.setDescription("C23 Local Segment ID. The segment ID of the emulated LAN. This is only required for IEEE 802.5 clients that are Source Routing bridges.'")
wflecOperConfigMulticastSendType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMulticastSendType.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMulticastSendType.setDescription('C24 Multicast Send VCC Type. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. This is the method to be used by the LE Client when specifying traffic parameters when it sets up the Multicast Send VCC for this emulated LAN.')
wflecOperConfigMulticastSendAvgRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMulticastSendAvgRate.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMulticastSendAvgRate.setDescription('C25 Multicast Send VCC AvgRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Sustained Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. ')
wflecOperConfigMulticastSendPeakRate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigMulticastSendPeakRate.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigMulticastSendPeakRate.setDescription('C26 Multicast Send VCC PeakRate. Signalling parameter that SHOULD be used by the LE Client when establishing the Multicast Send VCC. Forward and Backward Peak Cell Rate to be requested by LE Client when setting up Multicast Send VCC, if using Variable bit rate codings. ')
wflecOperConfigConnectionCompleteTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOperConfigConnectionCompleteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOperConfigConnectionCompleteTimer.setDescription('C28 Connection Complete Timer. Optional. In Connection Establishment this is the time period in which data or a READY_IND message is expected from a Calling Party.')
wfAtmLecStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4), )
if mibBuilder.loadTexts: wfAtmLecStatisticsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecStatisticsTable.setDescription('Table of statistics')
wfAtmLecStatisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecStatisticsCct"))
if mibBuilder.loadTexts: wfAtmLecStatisticsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecStatisticsEntry.setDescription('Entry contains statistics for each LEC')
wflecArpRequestsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecArpRequestsOut.setStatus('mandatory')
if mibBuilder.loadTexts: wflecArpRequestsOut.setDescription('The number of MAC-to-ATM ARP requests made by this LAN Emulation client over the LUNI associated with this emulated packet interface.')
wflecArpRequestsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecArpRequestsIn.setStatus('mandatory')
if mibBuilder.loadTexts: wflecArpRequestsIn.setDescription('The number of MAC-to-ATM ARP requests received by this LAN Emulation client over the LUNI associated with this emulated packet interface. Requests may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented and the chances it has had for learning. This counter covers both VCCs.')
wflecArpRepliesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecArpRepliesOut.setStatus('mandatory')
if mibBuilder.loadTexts: wflecArpRepliesOut.setDescription('The number of MAC-to-ATM ARP replies sent by this LAN Emulation client over the LUNI associated with this emulated packet interface.')
wflecArpRepliesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecArpRepliesIn.setStatus('mandatory')
if mibBuilder.loadTexts: wflecArpRepliesIn.setDescription('The number of MAC-to-ATM ARP replies received by this LAN Emulation client over the LUNI associated with this emulated packet interface. This count includes all such replies, whether solicited or not. Replies may arrive on the Control Direct VCC or on the Control Distribute VCC, depending upon how the LES is implemented. This counter covers both VCCs.')
wflecControlFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlFramesOut.setDescription('The total number of control packets sent by this LAN Emulation client over the LUNI associated with this emulated packet interface.')
wflecControlFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlFramesIn.setDescription('The total number of control packets received by this LAN Emulation client over the LUNI associated with this emulated packet interface')
wflecSvcFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecSvcFailures.setStatus('mandatory')
if mibBuilder.loadTexts: wflecSvcFailures.setDescription('The number of SVCs which this client tried to, but failed to, open.')
wflecStatisticsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecStatisticsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecStatisticsCct.setDescription('This corresponds to the Wellfleet circuit number')
wflecUnknownFramesDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecUnknownFramesDropped.setStatus('mandatory')
if mibBuilder.loadTexts: wflecUnknownFramesDropped.setDescription('The number of frames that have been dropped due to unknown frame pacing.')
wflecInDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInDataFrames.setDescription('')
wflecInUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInUnicastFrames.setDescription('')
wflecInUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInUnicastOctets.setDescription('')
wflecInMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInMulticastFrames.setDescription('')
wflecInMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInMulticastOctets.setDescription('')
wflecInBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInBroadcastFrames.setDescription('')
wflecInBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecInBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecInBroadcastOctets.setDescription('')
wflecOutDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutDataFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutDataFrames.setDescription('')
wflecOutUnknownFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutUnknownFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutUnknownFrames.setDescription('')
wflecOutUnknownOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutUnknownOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutUnknownOctets.setDescription('')
wflecOutMulticastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutMulticastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutMulticastFrames.setDescription('')
wflecOutMulticastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutMulticastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutMulticastOctets.setDescription('')
wflecOutBroadcastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutBroadcastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutBroadcastFrames.setDescription('')
wflecOutBroadcastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutBroadcastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutBroadcastOctets.setDescription('')
wflecOutUnicastFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutUnicastFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutUnicastFrames.setDescription('')
wflecOutUnicastOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecOutUnicastOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wflecOutUnicastOctets.setDescription('')
wfAtmLecServerVccTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5), )
if mibBuilder.loadTexts: wfAtmLecServerVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecServerVccTable.setDescription('Lan Emulation Client - Server VCC Table')
wfAtmLecServerVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecServerVccCct"))
if mibBuilder.loadTexts: wfAtmLecServerVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecServerVccEntry.setDescription('Entry contains statistics for each LEC')
wflecConfigDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigDirectInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigDirectInterface.setDescription('The interface associated with the Configuration Direct VCC. If no Configuration Direct VCC exists, this object has the value 0. Otherwise, the objects ( wflecConfigDirectInterface, wflecConfigDirectVPI, wflecConfigDirectVCI ) identify the circuit')
wflecConfigDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigDirectVpi.setDescription('If the Configuration Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecConfigDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecConfigDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: wflecConfigDirectVci.setDescription('If the Configuration Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecControlDirectInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDirectInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDirectInterface.setDescription('The interface associated with the Control Direct VCC. If no Control Direct VCC exists, this object has the value 0. Otherwise, the objects ( wflecControlDirectInterface, wflecControlDirectVPI, wflecControlDirectVCI ) identify the circuit')
wflecControlDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDirectVpi.setDescription('If the Control Direct VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecControlDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDirectVci.setDescription('If the Control Direct VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecControlDistributeInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDistributeInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDistributeInterface.setDescription('The interface associated with the Control Distribute VCC. If no Control Distribute VCC exists, this object has the value 0. Otherwise, the objects ( wflecControlDistributeInterface, wflecControlDistributeVPI, wflecControlDistributeVCI ) identify the circuit')
wflecControlDistributeVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDistributeVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDistributeVpi.setDescription('If the Control Distribute VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecControlDistributeVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecControlDistributeVci.setStatus('mandatory')
if mibBuilder.loadTexts: wflecControlDistributeVci.setDescription('If the Control Distribute VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecMulticastSendInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastSendInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendInterface.setDescription('The interface associated with the Multicast Send VCC. If no Multicast Send VCC exists, this object has the value 0. Otherwise, the objects ( wflecMulticastSendInterface, wflecMulticastSendVPI, wflecMulticastSendVCI ) identify the circuit')
wflecMulticastSendVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastSendVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendVpi.setDescription('If the Multicast Send VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecMulticastSendVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastSendVci.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastSendVci.setDescription('If the Multicast Send VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecMulticastForwardInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastForwardInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastForwardInterface.setDescription('The interface associated with the Multicast Forward VCC. If no Multicast Forward VCC exists, this object has the value 0. Otherwise, the objects ( wflecMulticastForwardInterface, wflecMulticastForwardVPI, wflecMulticastForwardVCI ) identify the circuit')
wflecMulticastForwardVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastForwardVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastForwardVpi.setDescription('If the Multicast Forward VCC exists, this object contains the VPI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecMulticastForwardVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMulticastForwardVci.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMulticastForwardVci.setDescription('If the Multicast Forward VCC exists, this object contains the VCI which identifies that VCC at the point where it connects to this LE client. Otherwise, this object has the value 0.')
wflecServerVccCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 5, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecServerVccCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecServerVccCct.setDescription('This corresponds to the Wellfleet circuit number')
wfAtmLecAtmAddressTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 6), )
if mibBuilder.loadTexts: wfAtmLecAtmAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecAtmAddressTable.setDescription('LAN Emulation Client - ATM Addresses table')
wfAtmLecAtmAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 6, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecAtmAddressCct"), (0, "Wellfleet-ATM-LE-MIB", "wflecAtmAddress"))
if mibBuilder.loadTexts: wfAtmLecAtmAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecAtmAddressEntry.setDescription('Entry contains ATM address for a LE CLient')
wflecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecAtmAddress.setDescription('The ATM address this row describes. This could be either a primary address or a secondary address.')
wflecAtmAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enbl", 1), ("dsbl", 2))).clone('enbl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wflecAtmAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wflecAtmAddressStatus.setDescription('Used to create and delete rows in this table. A management station cannot disable an ATM address while the client is up')
wflecAtmAddressCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecAtmAddressCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecAtmAddressCct.setDescription('This corresponds to the Wellfleet circuit number')
wfAtmLecMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 7), )
if mibBuilder.loadTexts: wfAtmLecMacAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecMacAddressTable.setDescription('LAN Emulation Client - MAC Addresses table')
wfAtmLecMacAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 7, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wflecMacAddressCct"), (0, "Wellfleet-ATM-LE-MIB", "wflecMacAddress"))
if mibBuilder.loadTexts: wfAtmLecMacAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecMacAddressEntry.setDescription('Entry contains MAC address for a LE CLient')
wflecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMacAddress.setDescription('The MAC address this row describes. This could be either a primary address or a secondary address.')
wflecMacAddressAtmBinding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 7, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMacAddressAtmBinding.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMacAddressAtmBinding.setDescription('The ATM Address registered for wflecMacAddress')
wflecMacAddressCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wflecMacAddressCct.setStatus('mandatory')
if mibBuilder.loadTexts: wflecMacAddressCct.setDescription('This corresponds to the Wellfleet circuit number')
wfAtmLeArpTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8), )
if mibBuilder.loadTexts: wfAtmLeArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLeArpTable.setDescription("Lan Emulation Client ARP Cache Group This table provides access to an ATM LAN Emulation Client's MAC-to-ATM ARP cache. It contains entries for unicast addresses and for the broadcast address, but not for multicast MAC addresses.")
wfAtmLeArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wfleArpCct"), (0, "Wellfleet-ATM-LE-MIB", "wfleArpMacAddress"))
if mibBuilder.loadTexts: wfAtmLeArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLeArpEntry.setDescription('entry of MAC address to ATM address')
wfleArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpMacAddress.setDescription('The MAC address for which this cache entry provides a translation. Since ATM LAN Emulation uses an ARP protocol to locate broadcast and multicast servers, the value of this object could be the broadcast MAC address')
wfleArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpAtmAddress.setDescription("The ATM address of the Broadcast & Unknown Server or LAN Emulation Client whose MAC address is stored in 'leArpMacAddress'. ")
wfleArpIsRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpIsRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpIsRemoteAddress.setDescription("Indicates whether the 'leArpMACaddress' belongs to a remote client. true(1) The address is believed to be remote - or its local/remote status is unknown. For an entry created via the LE_ARP mechanism, this corresponds to the 'Remote address' flag being set in the LE_ARP_RESPONSE. false(2) The address is believed to be local - that is to say, registered with the LES by the client whose ATM address is leArpAtmAddress.")
wfleArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("ctrl", 2), ("data", 3), ("vol", 4), ("nonvol", 5))).clone('vol')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpEntryType.setDescription('Indicates how this LE_ARP table entry was created and whether it is aged.')
wfleArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enbl", 1), ("dsbl", 2))).clone('enbl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfleArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpRowStatus.setDescription('Row status of enable or disable')
wfleArpCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpCct.setDescription('This corresponds to the Wellfleet circuit number')
wfleArpVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpVpi.setDescription('This is the Vpi will be used for this MAC address')
wfleArpVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 8, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleArpVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfleArpVci.setDescription('This is the Vci will be used for this MAC address')
wfAtmLeRDArpTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9), )
if mibBuilder.loadTexts: wfAtmLeRDArpTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLeRDArpTable.setDescription("Lan Emulation Client RDArp Cache Group This table provides access to an ATM LAN Emulation Client's Route Descriptor-to-ATM ARP cache. ")
wfAtmLeRDArpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wfleRDArpCct"), (0, "Wellfleet-ATM-LE-MIB", "wfleRDArpSegmentID"), (0, "Wellfleet-ATM-LE-MIB", "wfleRDArpBridgeNumber"))
if mibBuilder.loadTexts: wfAtmLeRDArpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLeRDArpEntry.setDescription('entry of Route Descriptor to ATM address')
wfleRDArpSegmentID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpSegmentID.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpSegmentID.setDescription('The LAN ID portion of the Route Descriptor associated with this ARP cache entry.')
wfleRDArpBridgeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpBridgeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpBridgeNumber.setDescription('The Bridge Number portion of the Route Descriptor associated with this ARP cache entry.')
wfleRDArpAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpAtmAddress.setDescription('The ATM address of the LAN Emulation Client which is associated with the route descriptor.')
wfleRDArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("ctrl", 2), ("data", 3), ("vol", 4), ("nonvol", 5))).clone('vol')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpEntryType.setDescription('Indicates how this RD LE_ARP table entry was created and whether it is aged.')
wfleRDArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enbl", 1), ("dsbl", 2))).clone('enbl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfleRDArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpRowStatus.setDescription('Row status of enable or disable')
wfleRDArpCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpCct.setDescription('This corresponds to the Wellfleet circuit number')
wfleRDArpVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpVpi.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpVpi.setDescription('This is the Vpi will be used for this Route Descriptor')
wfleRDArpVci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 9, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfleRDArpVci.setStatus('mandatory')
if mibBuilder.loadTexts: wfleRDArpVci.setDescription('This is the Vci will be used for this Route Descriptor')
wfAtmLecConfigLesTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10), )
if mibBuilder.loadTexts: wfAtmLecConfigLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesTable.setDescription('Address of Configured LES per LEC ')
wfAtmLecConfigLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1), ).setIndexNames((0, "Wellfleet-ATM-LE-MIB", "wfAtmLecConfigLesCct"), (0, "Wellfleet-ATM-LE-MIB", "wfAtmLecConfigLesIndex"))
if mibBuilder.loadTexts: wfAtmLecConfigLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesEntry.setDescription('An entry in the ATM Le Table')
wfAtmLecConfigLesDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmLecConfigLesDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesDelete.setDescription('Create or Delete this LES Atm Address from the list')
wfAtmLecConfigLesEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmLecConfigLesEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesEnable.setDescription('Enable or disable this LES Atm Address')
wfAtmLecConfigLesCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLecConfigLesCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesCct.setDescription('CCT number for this LEC')
wfAtmLecConfigLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAtmLecConfigLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesIndex.setDescription('a unique one up type number to create a list')
wfAtmLecConfigLesAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmLecConfigLesAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesAddress.setDescription('Atm address of the LES')
wfAtmLecConfigLesName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5, 20, 10, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAtmLecConfigLesName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAtmLecConfigLesName.setDescription('User name for the LES')
mibBuilder.exportSymbols("Wellfleet-ATM-LE-MIB", wfleArpVpi=wfleArpVpi, wfAtmLeArpTable=wfAtmLeArpTable, wflecMulticastSendType=wflecMulticastSendType, wflecMulticastFwdTimeout=wflecMulticastFwdTimeout, wflecOperConfigTopologyChange=wflecOperConfigTopologyChange, wflecControlDistributeVpi=wflecControlDistributeVpi, wflecLastFailureState=wflecLastFailureState, wflecProtocol=wflecProtocol, wfleArpVci=wfleArpVci, wflecMulticastSendVci=wflecMulticastSendVci, wflecConfigSource=wflecConfigSource, wflecMacAddressAtmBinding=wflecMacAddressAtmBinding, wflecOperConfigControlTimeout=wflecOperConfigControlTimeout, wflecConfigCct=wflecConfigCct, wflecMacAddress=wflecMacAddress, wfleArpAtmAddress=wfleArpAtmAddress, wfAtmLecMacAddressEntry=wfAtmLecMacAddressEntry, wfAtmLecAtmAddressEntry=wfAtmLecAtmAddressEntry, wflecOperConfigMaxUnknownFrameTime=wflecOperConfigMaxUnknownFrameTime, wflecOperConfigLocalSegmentID=wflecOperConfigLocalSegmentID, wfleRDArpSegmentID=wfleRDArpSegmentID, wflecOperConfigFlushTimeOut=wflecOperConfigFlushTimeOut, wflecConfigLanName=wflecConfigLanName, wfAtmLecConfigTable=wfAtmLecConfigTable, wflecFlushTimeOut=wflecFlushTimeOut, wfAtmLecStatusTable=wfAtmLecStatusTable, wfleRDArpVpi=wfleRDArpVpi, wflecActualLanName=wflecActualLanName, wfAtmLecOperConfigTable=wfAtmLecOperConfigTable, wflecActualLanType=wflecActualLanType, wflecAtmAddressStatus=wflecAtmAddressStatus, wfAtmLecConfigLesCct=wfAtmLecConfigLesCct, wflecMaxUnknownFrameCount=wflecMaxUnknownFrameCount, wfAtmLecStatisticsEntry=wfAtmLecStatisticsEntry, wfAtmLecConfigLesEntry=wfAtmLecConfigLesEntry, wfAtmLecConfigLesIndex=wfAtmLecConfigLesIndex, wflecSvcFailures=wflecSvcFailures, wflecID=wflecID, wflecProxyClient=wflecProxyClient, wflecInBroadcastFrames=wflecInBroadcastFrames, wflecOutDataFrames=wflecOutDataFrames, wflecConfigLECSAtmAddress=wflecConfigLECSAtmAddress, wflecInUnicastOctets=wflecInUnicastOctets, wflecStatusCct=wflecStatusCct, wflecInMulticastOctets=wflecInMulticastOctets, wflecConfigLesAtmAddress=wflecConfigLesAtmAddress, wflecMaxRetryCount=wflecMaxRetryCount, wflecLastFailureRespCode=wflecLastFailureRespCode, wflecVersion=wflecVersion, wflecOutMulticastOctets=wflecOutMulticastOctets, wflecControlDistributeInterface=wflecControlDistributeInterface, wflecConfigDirectVci=wflecConfigDirectVci, wflecOperConfigExpectedArpResponseTime=wflecOperConfigExpectedArpResponseTime, wflecOutBroadcastFrames=wflecOutBroadcastFrames, wfAtmLecMacAddressTable=wfAtmLecMacAddressTable, wflecInMulticastFrames=wflecInMulticastFrames, wflecConfigLanType=wflecConfigLanType, wfleRDArpRowStatus=wfleRDArpRowStatus, wflecOperConfigMaxRetryCount=wflecOperConfigMaxRetryCount, wflecConfigV2Capable=wflecConfigV2Capable, wflecAgingTime=wflecAgingTime, wflecMacAddressCct=wflecMacAddressCct, wflecControlDirectVci=wflecControlDirectVci, wflecInUnicastFrames=wflecInUnicastFrames, wfAtmLeArpEntry=wfAtmLeArpEntry, wflecOperConfigPathSwitchingDelay=wflecOperConfigPathSwitchingDelay, wflecOperConfigMaxUnknownFrameCount=wflecOperConfigMaxUnknownFrameCount, wflecActualLesAtmAddress=wflecActualLesAtmAddress, wflecOutBroadcastOctets=wflecOutBroadcastOctets, wflecMulticastFwdRetry=wflecMulticastFwdRetry, wfAtmLecConfigEntry=wfAtmLecConfigEntry, wfleRDArpVci=wfleRDArpVci, wflecActualMaxDataFrameSize=wflecActualMaxDataFrameSize, wflecOperConfigMulticastSendAvgRate=wflecOperConfigMulticastSendAvgRate, wfleRDArpAtmAddress=wfleRDArpAtmAddress, wflecMulticastForwardVci=wflecMulticastForwardVci, wflecControlFramesOut=wflecControlFramesOut, wflecUnknownFramesDropped=wflecUnknownFramesDropped, wflecOperConfigForwardDelayTime=wflecOperConfigForwardDelayTime, wflecMulticastSendVpi=wflecMulticastSendVpi, wflecOutMulticastFrames=wflecOutMulticastFrames, wflecOperConfigConnectionCompleteTimer=wflecOperConfigConnectionCompleteTimer, wflecConfigMaxDataFrameSize=wflecConfigMaxDataFrameSize, wfAtmLeRDArpEntry=wfAtmLeRDArpEntry, wflecOperConfigAgingTime=wflecOperConfigAgingTime, wflecOperConfigMulticastSendType=wflecOperConfigMulticastSendType, wflecMulticastSendInterface=wflecMulticastSendInterface, wflecOutUnknownFrames=wflecOutUnknownFrames, wflecServerVccCct=wflecServerVccCct, wfleRDArpEntryType=wfleRDArpEntryType, wflecInBroadcastOctets=wflecInBroadcastOctets, wflecConfigDirectVpi=wflecConfigDirectVpi, wfAtmLecAtmAddressTable=wfAtmLecAtmAddressTable, wflecOperConfigVccTimeoutPeriod=wflecOperConfigVccTimeoutPeriod, wfleArpMacAddress=wfleArpMacAddress, wflecMulticastSendPeakRate=wflecMulticastSendPeakRate, wfAtmLecConfigLesName=wfAtmLecConfigLesName, wfleArpCct=wfleArpCct, wflecTopologyChange=wflecTopologyChange, wflecVccTimeoutPeriod=wflecVccTimeoutPeriod, wfAtmLecServerVccEntry=wfAtmLecServerVccEntry, wflecConfigServerAtmAddress=wflecConfigServerAtmAddress, wflecControlDirectInterface=wflecControlDirectInterface, wflecAtmAddressCct=wflecAtmAddressCct, wflecFlushEnable=wflecFlushEnable, wfleRDArpCct=wfleRDArpCct, wflecOutUnknownOctets=wflecOutUnknownOctets, wfleRDArpBridgeNumber=wfleRDArpBridgeNumber, wfAtmLecConfigLesDelete=wfAtmLecConfigLesDelete, wflecConfigRetry=wflecConfigRetry, wflecOwner=wflecOwner, wflecConfigMode=wflecConfigMode, wflecArpRequestsOut=wflecArpRequestsOut, wfAtmLecOperConfigEntry=wfAtmLecOperConfigEntry, wflecConnectionCompleteTimer=wflecConnectionCompleteTimer, wfAtmLecConfigLesEnable=wfAtmLecConfigLesEnable, wflecControlDirectVpi=wflecControlDirectVpi, wflecLocalSegmentID=wflecLocalSegmentID, wflecExpectedArpResponseTime=wflecExpectedArpResponseTime, wflecControlFramesIn=wflecControlFramesIn, wflecPathSwitchingDelay=wflecPathSwitchingDelay, wflecDebugLevel=wflecDebugLevel, wflecMulticastForwardVpi=wflecMulticastForwardVpi, wflecOperConfigCct=wflecOperConfigCct, wflecMulticastSendAvgRate=wflecMulticastSendAvgRate, wfAtmLeRDArpTable=wfAtmLeRDArpTable, wflecMulticastForwardInterface=wflecMulticastForwardInterface, wfleArpIsRemoteAddress=wfleArpIsRemoteAddress, wfleArpEntryType=wfleArpEntryType, wfAtmLecServerVccTable=wfAtmLecServerVccTable, wflecForwardDelayTime=wflecForwardDelayTime, wflecControlDistributeVci=wflecControlDistributeVci, wflecArpRepliesOut=wflecArpRepliesOut, wflecOutUnicastFrames=wflecOutUnicastFrames, wfAtmLecConfigLesAddress=wfAtmLecConfigLesAddress, wflecInterfaceState=wflecInterfaceState, wfAtmLecConfigLesTable=wfAtmLecConfigLesTable, wflecAtmAddress=wflecAtmAddress, wflecMaxUnknownFrameTime=wflecMaxUnknownFrameTime, wfAtmLecStatisticsTable=wfAtmLecStatisticsTable, wfAtmLecStatusEntry=wfAtmLecStatusEntry, wflecStatisticsCct=wflecStatisticsCct, wflecRowStatus=wflecRowStatus, wflecPrimaryAtmAddress=wflecPrimaryAtmAddress, wflecOperConfigMulticastSendPeakRate=wflecOperConfigMulticastSendPeakRate, wflecInDataFrames=wflecInDataFrames, wflecOutUnicastOctets=wflecOutUnicastOctets, wflecConfDelete=wflecConfDelete, wflecControlTimeout=wflecControlTimeout, wfleArpRowStatus=wfleArpRowStatus, wflecConfigDirectInterface=wflecConfigDirectInterface, wflecArpRepliesIn=wflecArpRepliesIn, wflecArpRequestsIn=wflecArpRequestsIn)

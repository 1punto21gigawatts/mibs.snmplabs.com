#
# PySNMP MIB module SA-CM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SA-CM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:59:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddressType, InetPortNumber, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetPortNumber", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Bits, TimeTicks, Counter32, Integer32, Counter64, ModuleIdentity, iso, IpAddress, ObjectIdentity, Unsigned32, Gauge32, NotificationType, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "TimeTicks", "Counter32", "Integer32", "Counter64", "ModuleIdentity", "iso", "IpAddress", "ObjectIdentity", "Unsigned32", "Gauge32", "NotificationType", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "enterprises")
DisplayString, TAddress, TDomain, DateAndTime, RowStatus, TruthValue, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TAddress", "TDomain", "DateAndTime", "RowStatus", "TruthValue", "MacAddress", "TextualConvention")
sa = MibIdentifier((1, 3, 6, 1, 4, 1, 1429))
saCmMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 1429, 77))
saCmMib.setRevisions(('2016-05-18 00:00', '2015-05-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: saCmMib.setRevisionsDescriptions(('Added saCmSoftwareDownload tree', 'Initial release of reduced-set module for releases based on BFC 5.7.x.',))
if mibBuilder.loadTexts: saCmMib.setLastUpdated('201505260000Z')
if mibBuilder.loadTexts: saCmMib.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: saCmMib.setContactInfo('support.cisco.com')
if mibBuilder.loadTexts: saCmMib.setDescription('Cisco Cable Modem MIB definition')
dpxCmMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1))
cmVendorInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2))
cmAPInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3))
cmInterfaceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4))
vendorDefaultDSfreq = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(93000000, 855000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorDefaultDSfreq.setStatus('current')
if mibBuilder.loadTexts: vendorDefaultDSfreq.setDescription(' DOCSIS: initial downstream frequency, range: 93000000 to 855000000 Hz EuroDOCSIS: initial downstream frequency, range: 88000000 to 859000000 Hz ')
vendorDSLEDTreatment = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("signalNB", 0), ("signalWB", 1), ("signalWBNBG", 2), ("signalWBNBA", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorDSLEDTreatment.setStatus('current')
if mibBuilder.loadTexts: vendorDSLEDTreatment.setDescription(' This MIB is only valid in DOCSIS 3.0 enabled modems with dual LEDs. This MIB determines the DS LED color, green or amber, to be used to indicate DS state. signalNB: DS LED = amber for narrowband; DS LED = green when DS w-online wideband. signalWB: DS LED = amber for wideband; DS LED = green when DS online narrowband. signalWBNBG: Both WB and NB states are indicated using the Green LED. signalWBNBA: Both WB and NB states are indicated using the Amber LED. ')
vendorLINKLEDTreatment = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("default", 0), ("showlinkspeed", 1), ("d3Amberledslowspeed", 2), ("d3Greenledslowspeed", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorLINKLEDTreatment.setStatus('current')
if mibBuilder.loadTexts: vendorLINKLEDTreatment.setDescription(' This MIB will determine Link Speed using blink rate for DOCSIS 2.0 modems or using LED color for DOCSIS 3.0 Modems as seen with the LINK LED. default: LINK LED behavior follows standard behavior as defined per User Guide FOR DOCSIS 2.0 1: showlinkspeed: When connected, LED blinks 1x/2sec for 10/100 operation and blinks 2x/1sec for Gigabit operation. Traffic is still reflected as 2x/1sec. FOR DOCSIS 3.0 On dual LED D3.0 modems the operator can choose to have 10/100 operation indicated by either a green LED or an amber LED. Modems that support 1000 Mb speeds shall indicate using the alternate LED. 2: d3Greenledslowspeed indicates 10/100 operation using the Green LED. 3: d3Amberledslowspeed indicates 10/100 operation using the Amber LED. ')
vendorUSLEDTreatment = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("signalWBNBG", 0), ("signalNB", 1), ("signalWB", 2), ("signalWBNBA", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorUSLEDTreatment.setStatus('current')
if mibBuilder.loadTexts: vendorUSLEDTreatment.setDescription(' This MIB is only valid in DOCSIS 3.0 enabled modems with dual LEDs. This MIB determines the US LED color, green or amber to be used to indicate US state. signalWBNBG: Both WB and NB states are indicated using the Green LED. signalNB: US LED = amber for narrowband; US LED = green when US w-online wideband. signalWB: US LED = amber for wideband; US LED = green when US online narrowband. signalWBNBA: Both WB and NB states are indicated using the Amber LED. ')
vendorONLINELEDTreatment = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("signalWBNBG", 0), ("signalNB", 1), ("signalWB", 2), ("signalWBNBA", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vendorONLINELEDTreatment.setStatus('current')
if mibBuilder.loadTexts: vendorONLINELEDTreatment.setDescription(' This MIB is only valid in DOCSIS 3.0 enabled modems with dual LEDs. This MIB provides a way to select the ONLINE LED color, green or amber to distinguish between wideband online or online(NB). signalWBNBG: Both WB and NB states are indicated using the Green LED. signalNB: ONLINE LED = amber for narrowband; ONLINE LED = green when DS w-online wideband. signalWB: ONLINE LED = amber for wideband; ONLINE LED = green when DS online narrowband. signalWBNBA: Both WB and NB states are indicated using the Amber LED. NOTE: This LED will only provide indication of a Downstream Bonded environment and does not indicate the presence of Upstream bonding. ')
cmAPIgmp = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableIGMP", 0), ("enableIGMP", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmAPIgmp.setStatus('current')
if mibBuilder.loadTexts: cmAPIgmp.setDescription(' 0: disable IGMP proxy, 1: enable IGMP proxy')
cmAPAgingOut = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableAgingOut", 0), ("enableAgingOut", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmAPAgingOut.setStatus('current')
if mibBuilder.loadTexts: cmAPAgingOut.setDescription(' 0: disable ARP aging out 1: enable ARP aging out')
cmAPMulticastPromiscuousMode = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmAPMulticastPromiscuousMode.setStatus('current')
if mibBuilder.loadTexts: cmAPMulticastPromiscuousMode.setDescription('Support for transparent multicast pass-thru using Promiscuous Multicast Mode. The setting will be stored in non-volatile memory and will be retained through a power cycle. It can be forcibly cleared with a fatcory reset.')
cmAPInternalInterface = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmAPInternalInterface.setStatus('current')
if mibBuilder.loadTexts: cmAPInternalInterface.setDescription('Controls the state of local interface. 0: Shut down local interface, 1: Leave local interface as is.')
cmAPFactoryReset = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 18), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmAPFactoryReset.setStatus('current')
if mibBuilder.loadTexts: cmAPFactoryReset.setDescription('Can be set with a sequence of values to activate a remote factory reset. This is the same as a sustained ( 3 seconds or more ) reset switch. Reading this object always returns false(2).')
saCmArpRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setUnits('packets-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmArpRateLimit.setStatus('current')
if mibBuilder.loadTexts: saCmArpRateLimit.setDescription('Setting ARP rate-limit defines the number of ARP packets that can be processed per second. Limitation of this number prevents denial-of-service attacks. A value of 20 pps is a good reference. Setting the value to 0 allows unlimited incoming ARP messages')
saCmInternalDhcpServer = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 3, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmInternalDhcpServer.setStatus('current')
if mibBuilder.loadTexts: saCmInternalDhcpServer.setDescription('Controls the DHCP server that is used when CM is offline. 0: disable internal DHCP server 1: enable internal DHCP server')
cmConsoleMode = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disable", 0), ("readOnly", 1), ("readWrite", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmConsoleMode.setStatus('current')
if mibBuilder.loadTexts: cmConsoleMode.setDescription('To Control console port is disabled, read only, or read write')
cmTimerT4 = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 60)).clone(30)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmTimerT4.setStatus('current')
if mibBuilder.loadTexts: cmTimerT4.setDescription('T4 timeout definition.')
saCmTodRenewal = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 9), Integer32()).setUnits('hours').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmTodRenewal.setStatus('current')
if mibBuilder.loadTexts: saCmTodRenewal.setDescription('Defines how often to update time with ToD protocol. 0: never 1: together with DHCP renewal 2-11: reserved 12+: number of hours')
saCmAutoResetNoActivity = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 43200))).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmAutoResetNoActivity.setStatus('current')
if mibBuilder.loadTexts: saCmAutoResetNoActivity.setDescription('Setting this object to any value N > 0 will cause the CM to reboot autonomously 3/4th of N minutes after the modem has detected that there is no connectivity to the CM gateway after three unsuccessful pings. NOTE: The default value of 0 means the feature is disabled.')
saCmCpeMacAging = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 11), Integer32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmCpeMacAging.setStatus('current')
if mibBuilder.loadTexts: saCmCpeMacAging.setDescription('Setting this object to any value N > 0 will cause the CM to remove a MAC address from its CPE table N seconds after the modem has detected no traffic from it. This feature applies ONLY to devices connected to the CM, not the embedded ones (as MTA or CableHome). NOTE: The default value of 0 means the feature is disabled.')
saCmBpiForward = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("macTable", 1), ("allPackets", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmBpiForward.setStatus('current')
if mibBuilder.loadTexts: saCmBpiForward.setDescription('This object controls whether to forward traffic that is not destined for any CPE (not in CPE table) when running BPI. 1: follow DOCSIS rules. Do not forward traffic when destination MAC not in the CPE table. 2: when BPI is enabled, forward all traffic (if security association matches, otherwise cannot decrypt packets). When BPI is disabled, this object does not have effect.')
saCmForceDualscan = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("useFactorySetting", 0), ("enable", 1), ("docsis1", 2), ("euroDocsis", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmForceDualscan.setStatus('current')
if mibBuilder.loadTexts: saCmForceDualscan.setDescription('The MIB will choose whether to force dualscan operation for the device. Dualscan refers to the CM ability to automatically scan for both 6MHz and 8MHz carriers. 0 : Will not force dualscan. In this case, the factory configuration for dualscan will take effect. *note: Factory Dualscan configuration is typically only enabled for EPC products. 1 : Will force dualscan to be enabled. In this case, dualscan will be enabled regardless of the factory setting. This MIB value will be stored to NonVolatile memory(NVM) and will persist across reboots. If the MIB is set via the config file, the CM will store the new setting and begin using it on next reboot. Removing the setting from the config file will not change the value stored in NVM the CM will continue to operate using the previously stored value. However, if an SNMP SET is used to modify the value, then the CM will not use the new setting until the next reboot occurs or is commanded. A factory reset of the CM will set the stored value back to 0. 2 : *Docsis1 mode will only allow the modem to lock Annex B (6MHz) channels and will ignore all Annex A (8MHz) channels. 3 : *EuroDocsis mode will only allow the modem to lock Annex A (8MHz) channesl and will ignore all Annex B (6 MHz)channels. *Feature available upon request for dualscan capable modems.')
saCmDsBonding = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1), ("enable2DS", 2), ("enable3DS", 3), ("enable4DS", 4), ("enable5DS", 5), ("enable6DS", 6), ("enable7DS", 7), ("enable8DS", 8))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmDsBonding.setStatus('current')
if mibBuilder.loadTexts: saCmDsBonding.setDescription('The MIB will choose whether to enable downstream channel bonding for bonding-capable modems. Non-bonding modems will ignore this MIB object. 0 : Disable downstream channel bonding. 1 : Enable downstream channel bonding with all available RCP-IDs standard and proprietary. 2 : Enable downstream bonding but only advertise standard RCP-IDs with 2 DS channels. 3 : Enable downstream bonding but only advertise standard RCP-IDs with 3 or fewer DS channels. 4 : Enable downstream bonding but only advertise standard RCP-IDs with 4 or fewer DS channels. 5 : Not currently applicable (same as 1) 6 : Not currently applicable (same as 1) 7 : Not currently applicable (same as 1) 8 : Enable downstream bonding but only advertise standard RCP-IDs with 8 or fewer DS channels. This MIB will take effect at the next reboot. This MIB value will be stored to NonVolatile memory(NVM) and will persist across reboots. If the MIB is set via the config file, the CM will store the new setting and reboot if a change is necessary. Removing the setting from the config file will not change the value stored in NVM: the CM will continue to operate using the previously stored value. If an SNMP SET is used to modify the value, then the CM will not use the new setting until the next reboot occurs or is commanded. A factory reset of the CM will set the stored value back to 1.')
saCmDocsisCapableVersion = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 33), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmDocsisCapableVersion.setStatus('current')
if mibBuilder.loadTexts: saCmDocsisCapableVersion.setDescription("Displays the string value for CM DHCP DISCOVER option 60 text. This mib is only readable through SNMP.This MIB object can queried to identify the device's docsis version that it supports.")
saOorDsidOverride = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saOorDsidOverride.setStatus('current')
if mibBuilder.loadTexts: saOorDsidOverride.setDescription(' This MIB is only valid on DOCSIS 3.0 capable modems. This feature is disabled by default. This MIB will modify the handling of OOR (Out of Range) DSID packets. If disabled the modem will follow DOCSIS specifications for handling OOR DSID packets. If enabled the modem will not follow the DOCSIS specifications but will recover much quicker from this error condition. Intead of 1000 OOR packets or 2 minutes the modem will recover with 3 OOR packets or 1 second. disabled(0): Follow DOCSIS specification (default) enabled (1): Resync after 3 OOR DSIDs or 1 second NOTE: The new setting will persist during reboots but a reboot of the modem is performed automatically if the setting is changed. ')
saCmCpeL2VpnMacAging = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmCpeL2VpnMacAging.setStatus('current')
if mibBuilder.loadTexts: saCmCpeL2VpnMacAging.setDescription('This MIB defines same functionality as TLV 65 for L2VPN implementation. When the value is is set to 1 (Enable), Mac aging implementation is as per cablelabs specification. This MIB will only be enable for L2VPN images. This MIB should take precendence over saCmCpeMacAging, If saCmCpeMacAging is set to a (non-zero) timer value and if saCmCpeL2VpnMacAging is set to 1, saCmCpeL2VpnMacAging implementation of CPE MacAging feature will take affect. saCmCpeMacAging MIB set to non-zero value will only take affect if saCmCpeL2VpnMacAging is set to disable (0)')
saCmL2VpnUsForwardingCriteria = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("forwardOnPrimarySF", 0), ("discard", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmL2VpnUsForwardingCriteria.setStatus('current')
if mibBuilder.loadTexts: saCmL2VpnUsForwardingCriteria.setDescription('Applicable to L2VPN enabled CMs only. This MIB defines the policy that the CM should use when forwarding packets that do not match the upstream classifier criteria. forwardOnPrimarySF(0) - Forward packets on the primary service flow discard(1) - Discard packets')
cmEthernetOperTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41), )
if mibBuilder.loadTexts: cmEthernetOperTable.setStatus('current')
if mibBuilder.loadTexts: cmEthernetOperTable.setDescription('Table for Ethernet interface link speed, duplex, mode, and operation.')
cmEthernetOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41, 1), ).setIndexNames((0, "SA-CM-MIB", "cmEthernetOperIndex"))
if mibBuilder.loadTexts: cmEthernetOperEntry.setStatus('current')
if mibBuilder.loadTexts: cmEthernetOperEntry.setDescription('Entries for Ethernet interface link speed, duplex, mode and operation.')
cmEthernetOperIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: cmEthernetOperIndex.setStatus('current')
if mibBuilder.loadTexts: cmEthernetOperIndex.setDescription('Index used for the interfaces.')
cmEthernetOperSetting = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("link-down", 0), ("half-duplex-10Mbps", 1), ("full-duplex-10Mbps", 2), ("half-duplex-100Mbps", 3), ("full-duplex-100Mbps", 4), ("ethernetNotConnected", 5), ("half-duplex-1Gbps", 6), ("full-duplex-1Gbps", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmEthernetOperSetting.setStatus('current')
if mibBuilder.loadTexts: cmEthernetOperSetting.setDescription('Displays the current Ethernet port link speed and duplex. 0: link-down(0), 1: half-duplex-10Mbps(1), 2: full-duplex-10Mbps(2), 3: half-duplex-100Mbps(3), 4: full-duplex-100Mbps(4), 5: ethernetNotConnected(5), 6: half-duplex-1Gbps(6), 7: full-duplex-1Gbps(7)')
cmEthernetOperMode = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("auto-negotiate", 0), ("manual", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cmEthernetOperMode.setStatus('current')
if mibBuilder.loadTexts: cmEthernetOperMode.setDescription('Displays the current Ethernet port speed and duplex link Mode. 1: Auto-negotiate(0) 2: Manual(1)')
cmEthernetIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 41, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmEthernetIfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: cmEthernetIfAdminStatus.setDescription('For RG Mode this MIB provides a way to force the ifAdminStatus.x MIB settings for the individual Ethernet ports to the values stored in cmEthernetAdminStatus.x. This feature is activated by setting cmEthernetIfAdminOverride is set to enable(1). Bridge mode is a special case since there is only one ifindex = .1 for all 4 ports. In Bridge Mode this MIB still allows you control the port status per Ethernet interface. However, the value of ifAdminStatus.1 and ifOperStatus.1 will follow the following logic: If at least 1 port is set to up by cmEthernetIfAdminStatus.x then ifAdminStatus.x will be set to up(1). If all ports are set to down by cmEthernetIfAdminStatus.x then ifAdminStatus.1 will report down(2). ifAdminStatus.x will report testing(3) if all ports set by cmEthernetIfAdminStatus.x are in testing(3) status. The major use case for this MIB is to set specific unused ports on the RG to down(2) status immediately after a reboot and prior to CM registration. This MIB is written to non-vol and survives a reboot. A factory reset sets MIB index values back to up(1). 1: up(1) Force the individual port to up(1). 2: down(2) Force the individual port to down(2) 3: testing(3) Force the port to testing status(3) No packets passed.')
cmEthernetIfAdminOverride = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmEthernetIfAdminOverride.setStatus('current')
if mibBuilder.loadTexts: cmEthernetIfAdminOverride.setDescription('For RG Mode enabling this MIB forces the index values of cmEthernetifAdminStatus.x stored in non-vol into ifAdminStatus.x For Bridge Mode the ports are exclusively controlled by cmEthernetifAdminStatus.x and ifAdminStatus.x has no direct mapping and is overridden. This MIB is written to non-vol and survives a reboot. A factory reset sets MIB index values back to disable(0).')
saCmUsBonding = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disable", 0), ("enable", 1))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmUsBonding.setStatus('current')
if mibBuilder.loadTexts: saCmUsBonding.setDescription('The MIB will choose whether to advertise upstream channel bonding for bonding-capable modems in the modem capabilitiies during registration. Non-DOCSIS 3.0 modems will not have this MIB object. 0 : Disable upstream channel bonding advertisement. 1 : Enable upstream channel bonding advertisement. This MIB must be set in the config file to function. This MIB can be read from SNMP for current value.')
saCmIcmpRateLimit = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setUnits('packets-per-second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmIcmpRateLimit.setStatus('current')
if mibBuilder.loadTexts: saCmIcmpRateLimit.setDescription('Setting ICMP rate-limit defines the number of ICMP packets that can be processed per second. Limitation of this number prevents denial-of-service attacks. Setting the value to 0 allows unlimited incoming ICMP messages. The default value has been changed from 10 to 0 in 5.5.9 and newer releases.')
saCmTftpBlockSizeV4 = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmTftpBlockSizeV4.setStatus('current')
if mibBuilder.loadTexts: saCmTftpBlockSizeV4.setDescription('This MIB controls the TFTP block size in IPv4 operation. Valid values are 0, 8-8192. A value of 0 means to use the default block size of 1448 and do not negotiate block size. Any other value must be comply with block size negotiation in RFC 1350, RFC 1782, and RFC2348. This value is stored in nonvol.')
saCmTftpBlockSizeV6 = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 47), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmTftpBlockSizeV6.setStatus('current')
if mibBuilder.loadTexts: saCmTftpBlockSizeV6.setDescription('This MIB controls the TFTP block size in IPv4 operation. Valid values are 0, 8-8192. A value of 0 means to use the default block size of 1428 and do not negotiate block size. Any other value must be comply with block size negotiation in RFC 1350, RFC 1782, and RFC2348. This value is stored in nonvol.')
saCmUsPowerLimit = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 4, 48), Integer32().clone(51)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmUsPowerLimit.setStatus('current')
if mibBuilder.loadTexts: saCmUsPowerLimit.setDescription('This MIB controls the upstream power limit imposed on the cable modem (in dB).')
saCmSoftwareDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6))
saCmSoftwareTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1), )
if mibBuilder.loadTexts: saCmSoftwareTable.setStatus('current')
if mibBuilder.loadTexts: saCmSoftwareTable.setDescription('Table for hardware specific software download.')
saCmSoftwareEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1), ).setIndexNames((0, "SA-CM-MIB", "saCmSwIndex"))
if mibBuilder.loadTexts: saCmSoftwareEntry.setStatus('current')
if mibBuilder.loadTexts: saCmSoftwareEntry.setDescription('Entries for hardware specific software download.')
saCmSwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)))
if mibBuilder.loadTexts: saCmSwIndex.setStatus('current')
if mibBuilder.loadTexts: saCmSwIndex.setDescription('Index used to order the application of access entries.')
saCmSwModel = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 2), SnmpAdminString())
if mibBuilder.loadTexts: saCmSwModel.setStatus('current')
if mibBuilder.loadTexts: saCmSwModel.setDescription('Model name of the cable modem product. If not set, applies to all models. example: DPC2100')
saCmSwHwVer = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 3), SnmpAdminString().clone('any'))
if mibBuilder.loadTexts: saCmSwHwVer.setStatus('current')
if mibBuilder.loadTexts: saCmSwHwVer.setDescription('Hardware version of the cable modem product. If not set, applies to all versions.')
saCmSwBootLoader = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 4), SnmpAdminString().clone('any'))
if mibBuilder.loadTexts: saCmSwBootLoader.setStatus('current')
if mibBuilder.loadTexts: saCmSwBootLoader.setDescription('Boot loader version of the cable modem product. If not set, applies to all versions.')
saCmSwProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("any", 0), ("ncs", 1), ("sip", 2))))
if mibBuilder.loadTexts: saCmSwProtocol.setStatus('current')
if mibBuilder.loadTexts: saCmSwProtocol.setDescription('Protocol used in cable modem product.')
saCmSwFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64)))
if mibBuilder.loadTexts: saCmSwFilename.setStatus('current')
if mibBuilder.loadTexts: saCmSwFilename.setDescription('Filename of the software image.')
saCmSwServer = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 7), IpAddress())
if mibBuilder.loadTexts: saCmSwServer.setStatus('deprecated')
if mibBuilder.loadTexts: saCmSwServer.setDescription('TFTP server IP address where software image is located.')
saCmSwAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("saCmSwAllowProvisioningUpgrade", 2), ("saCmSwIgnoreProvisioningUpgrade", 3))))
if mibBuilder.loadTexts: saCmSwAdminStatus.setStatus('current')
if mibBuilder.loadTexts: saCmSwAdminStatus.setDescription('See docsDevSwAdminStatus for details.')
saCmSwMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("secure", 1), ("unsecure", 2))).clone(1))
if mibBuilder.loadTexts: saCmSwMethod.setStatus('current')
if mibBuilder.loadTexts: saCmSwMethod.setDescription('Method of software download.')
saCmSwServerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 11), InetAddressType())
if mibBuilder.loadTexts: saCmSwServerAddressType.setStatus('current')
if mibBuilder.loadTexts: saCmSwServerAddressType.setDescription('This MIB defines the type of internet address to be used for the TFTP Server. 0: An unknown address type. This value MUST be used if the value of the corresponding InetAddress object is a zero-length string. It may also be used to indicate an IP address that is not in one of the formats defined below. 1 : IPv4 TFTP Server Address 2 : IPv6 TFTP Server Address (reserved for future support)')
saCmSwServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 1, 1, 12), InetAddress())
if mibBuilder.loadTexts: saCmSwServerAddress.setStatus('current')
if mibBuilder.loadTexts: saCmSwServerAddress.setDescription('TFTP server IP address where software image is located.')
saCmSoftwareDownloadTFTPServer = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 6, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sameAsCM", 1), ("dhcpOption54", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmSoftwareDownloadTFTPServer.setStatus('current')
if mibBuilder.loadTexts: saCmSoftwareDownloadTFTPServer.setDescription('When CM configuration file initiated software upgrade is needed, the TFTP request will be sent to SwUpgradeServer IP address. When the value of SwUpgradeServer is not specified in the CM configuration file then the TFTP request will be sent to the same TFTP server used for CM configuration file download (1) or to the IP address specified in DHCP Option 54 (2).')
saCmWebAccess = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7))
saCmWebAccessUserIfTypeTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 2), )
if mibBuilder.loadTexts: saCmWebAccessUserIfTypeTable.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessUserIfTypeTable.setDescription('Table for various user/if type web access levels.')
saCmWebAccessUserIfTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 2, 1), ).setIndexNames((0, "SA-CM-MIB", "saCmWebAccessUserTypeIndex"), (0, "SA-CM-MIB", "saCmWebAccessIfTypeIndex"))
if mibBuilder.loadTexts: saCmWebAccessUserIfTypeEntry.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessUserIfTypeEntry.setDescription('Entries for various users/if type web access levels.')
saCmWebAccessUserTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 10, 100))).clone(namedValues=NamedValues(("home-user", 1), ("cus-admin", 5), ("adv-user", 10), ("all-users", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmWebAccessUserTypeIndex.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessUserTypeIndex.setDescription("Access level for various user types. home-user(1): This is intended to be used for home users cus-admin(5): This is intended to be used for the CUSADMIN adv-user(10): This type is intended to be used by MSO admin all-users(100): This will be a write-only value and it's a convenience provided to the MSO to specify that the same setting takes effect for all users. This index should not be available in an SNMP Walk/Get but administrator should be able to set this value. Example: Scenario: MSO wants to disable the wan-rg access for home-user and adv-user. MIB Set: saCmWebAccessUserIfLevel.all-users.wan-rg = 0 MIB Walk: saCmWebAccessUserIfLevel.home-user.wan-rg = 0 saCmWebAccessUserIfLevel.adv-user.wan-rg = 0 Basically, MSO has a provision to set this MIB which will internally fill the values for both users (and any other user types in future) and they will be shown individually in an SNMP Walk")
saCmWebAccessIfTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16, 40, 100))).clone(namedValues=NamedValues(("lan", 1), ("rf-cm", 2), ("mta", 16), ("wan-rg", 40), ("all-ifs", 100)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmWebAccessIfTypeIndex.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessIfTypeIndex.setDescription("Web access over various interface types. lan(1): This will control the CPE interface on the lan side. rf-cm(2): This will control the remote access to the web pages through the CM public IP mta(16): This will control the web-access through MTA interface wan-rg(40): This will control the remote access to the web pages through RG public IP all-ifs(100): This will be a write-only value and it's a convenience provided to the MSO to specify that the same setting will take effect for all interfaces. This index should not be available in an SNMP Walk/Get but administrator should be able to set this value. Example: Scenario: MSO wants to disable the access to WEB pages (similar to cmApWebSwitch = 0 now). MIB Set: saCmWebAccessUserIfLevel.all-users.all-ifs = 0 MIB Walk: saCmWebAccessUserIfLevel.home-user.lan = 0 saCmWebAccessUserIfLevel.home-user.rf-cm = 0 saCmWebAccessUserIfLevel.home-user.mta = 0 saCmWebAccessUserIfLevel.home-user.wan-rg = 0 saCmWebAccessUserIfLevel.adv-user.lan = 0 saCmWebAccessUserIfLevel.adv-user.rf-cm = 0 saCmWebAccessUserIfLevel.adv-user.mta = 0 saCmWebAccessUserIfLevel.adv-user.wan-rg = 0 Basically, MSO has a provision to set this MIB which will internally fill the values for all interfaces and they will be shown individually in an SNMP Walk")
saCmWebAccessUserIfLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 3, 100))).clone(namedValues=NamedValues(("not-applicable", -1), ("off", 0), ("system", 1), ("basic", 2), ("readonly", 3), ("advanced", 100)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmWebAccessUserIfLevel.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessUserIfLevel.setDescription('Access levels for web pages. not-applicable(-1) - This will be displayed if access level can not be determined for any interface/user. In the case when the various interfaces have different access levels, all-ifs value will show as not-applicable. Example: Configure the following values in modem config file saCmWebAccessUserIfLevel.home-user.all-ifs = 100 and saCmWebAccessUserIfLevel.adv-user.all-ifs is = 2 An SNMP walk on the saCmWebAccessUserIfLevel will provide the following saCmWebAccessUserIfLevel.home-user.lan = advanced (100) saCmWebAccessUserIfLevel.home-user.rf-cm = advanced (100) saCmWebAccessUserIfLevel.home-user.mta = advanced (100) saCmWebAccessUserIfLevel.home-user.wan-rg = advanced (100) saCmWebAccessUserIfLevel.home-user.all-ifs = not-applicable (-1) saCmWebAccessUserIfLevel.adv-user.lan = basic (2) saCmWebAccessUserIfLevel.adv-user.rf-cm = basic (2) saCmWebAccessUserIfLevel.adv-user.mta = basic (2) saCmWebAccessUserIfLevel.adv-user.wan-rg = basic (2) saCmWebAccessUserIfLevel.adv-user.all-ifs = not-applicable (-1) off(0) - This will shut-down the port and this interface if the same value is used for all users. If any of the user has a non-zero value for this interface, this will be automatically treated as same as a value 1. systemOnly(1) - Login/Landing page will be displayed but user(s) will not authenticate. This will display all the web pages available to the user without login. Please refer to the Access Table section in the Web GUI PRD to find out the details basic(2) - The specified users can access only the basic pages after login. Please refer to Access Table section in Web GUI PRD to find out the details about Basic Access readonly (3) - This will provide read-only access to users specified from the interface selected. The pages displayed in readOnly mode will be same as if the user had the access level set to advanced except that pages are not editable. Please refer to the appropriate columns of Access Table in the Web GUI PRD for understanding what pages need to be displayed to the home-user/adv-user in Online/Offline status. This value if set, will take precedence over saCmWebAccessWritePages Example: Page 1 - saCmWebAccessReadPages = 1, saCmWebAccessWritePages = 1, Page 2 - saCmWebAccessReadPages = 1, saCmWebAccessWritePages = 0, Page 3 - saCmWebAccessReadPages = 0, saCmWebAccessWritePages = 0 Scenario 1: saCmWebAccessUserIfLevel.all-users.all-ifs = 100 Result: Display Page1 and Page 2 with read-write access to Page 1 Scenario 2: saCmWebAccessUserIfLevel.all-users.all-ifs = 3 Result: Display Page 1 and Page 2 but both will be just read-only. So in both cases, only those pages that are enabled in saCmWebAccessReadPages will be displayed but setting the MIB to this value will disable the write access irrespective of whatever value is set in saCmWebAccessWritePages for that particular page. advanced(100) - Full Access to the specified user types on specified interfaces (Full access details for various user types are mentioned in the Access table section of Web GUI PRD). Only the web pages enabled for read-access using saCmWebAccessReadPages will be shown. Default value for this MIB in various conditions will be governed by the following table. Interface Type Home-user Adv-user lan 100 1 or 2* rf-cm 1 2 mta 0 0 wan-rg 0 0 * - This will be 1 when the adv-user credentials are not defined and the modem is online and should be 2 when adv-user credentials are defined or the modem is offline')
saCmWebAccessHomeUsername = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 3), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmWebAccessHomeUsername.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessHomeUsername.setDescription('Defines the username for home-user. This parameter is stored in non-vol and is blank by default. NOTE: This should be a hidden value in SNMPGET/SNMPWALK but user should be able to set this using SNMPSET')
saCmWebAccessHomeUserPassword = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 4), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmWebAccessHomeUserPassword.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessHomeUserPassword.setDescription("Defines the password for home-user. If user's password matches the default password (meaning user has not changed the password), a change password page comes out every time a user connects to the web pages. If user's password does not match the default password (meaning user has changed it) the change password page does not show. This parameter is stored in non-vol and is blank by default. If the default password is blank in non-vol (after factory default for example), it gets populated with this object's value. NOTE: This should be a hidden value in SNMPGET/SNMPWALK but user should be able to set this using SNMPSET")
saCmWebAccessAdvancedType = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("plain", 1), ("potd", 2))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmWebAccessAdvancedType.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessAdvancedType.setDescription('Type of password for advnaced pages.')
saCmWebAccessAdvancedUsername = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)).clone('admin')).setMaxAccess("readonly")
if mibBuilder.loadTexts: saCmWebAccessAdvancedUsername.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessAdvancedUsername.setDescription('Username for advanced web pages. NOTE: This should be a hidden value in SNMPGET/SNMPWALK but user should be able to set this using SNMPSET')
saCmWebAccessAdvancedPassword = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 40)))
if mibBuilder.loadTexts: saCmWebAccessAdvancedPassword.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessAdvancedPassword.setDescription('Password (depends on type) for advanced web pages. If type = 1, the password is the string value. If type = 2, the password is the 16-byte octet (hex) string of MD5 of seed generated by the PoTD tool. NOTE: This should be a hidden value in SNMPGET/SNMPWALK but user should be able to set this using SNMPSET')
saCmWebAccessNoActivityTimeout = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 8), Integer32().clone(900)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmWebAccessNoActivityTimeout.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessNoActivityTimeout.setDescription('Timeout for a web session if no activity is present. If the timer expires, user will be logged out of Advanced webpage. If 0, web session will not timeout. Valid values are 0, 30-86400')
saCmWebAccessHomeUserClearPassword = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 7, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saCmWebAccessHomeUserClearPassword.setStatus('current')
if mibBuilder.loadTexts: saCmWebAccessHomeUserClearPassword.setDescription('Clears home-user passwords if set to true (clear=set to default). Always returns false when read.')
saPUF = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10))
saPUFTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1), )
if mibBuilder.loadTexts: saPUFTable.setStatus('current')
if mibBuilder.loadTexts: saPUFTable.setDescription('A table of PowerUp Frequencies scanned first.')
saPUFEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1), ).setIndexNames((0, "SA-CM-MIB", "saPUFIndex"))
if mibBuilder.loadTexts: saPUFEntry.setStatus('current')
if mibBuilder.loadTexts: saPUFEntry.setDescription('A row in the table that specifies a single frequency.')
saPUFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32)))
if mibBuilder.loadTexts: saPUFIndex.setStatus('current')
if mibBuilder.loadTexts: saPUFIndex.setDescription('Indicates the instance of this table row.')
saPUFRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFRowStatus.setStatus('current')
if mibBuilder.loadTexts: saPUFRowStatus.setDescription('Controls and reflects the status of rows in this table. Rows in this table may be created by either the create-and-go or create-and-wait paradigms. There is no restriction on changing values in a row of this table while the row is active. Setting the value of this object to active (either directly or indirectly via create-and-go) will cause the row to be written to non-volatile storage. Changing the value of saPUFFrequency while the row is active will also cause the row to be written to non-volatile storage.')
saPUFFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(93000000, 999000000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: saPUFFrequency.setStatus('current')
if mibBuilder.loadTexts: saPUFFrequency.setDescription('Frequency in Hz')
saPUFAnnex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("annexA", 0), ("annexB", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFAnnex.setStatus('current')
if mibBuilder.loadTexts: saPUFAnnex.setDescription('Annex mode for the frequency')
saPUFScanNow = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 5), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFScanNow.setStatus('current')
if mibBuilder.loadTexts: saPUFScanNow.setDescription('Setting an index of this object to true(1) causes the modem to immediately go offline and scan for the frequency stored in saPUFFrequency.x. The results and timestamp of the scan are stored to non-vol. After the scan takes place the modem re-inits the CM mac and re-registers. Conditions to run the scan: - saPUFRowStatus.x must be set to active for a scan to take place. - The scan will not take place if a provisioned line is offhook. - If this mib is added to the CM config file, a scan will not take place unless the current time from TOD server is > 360 seconds (6 minutes) from the last scan time stored in saPUFScanTimestamp.x. This mib object returns false(2) when read if no scan was initiated')
saPUFScanOnNextBoot = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("unset", 0), ("set", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFScanOnNextBoot.setStatus('current')
if mibBuilder.loadTexts: saPUFScanOnNextBoot.setDescription('Setting an index of this object to set(1) causes the modem to scan for the frequency stored in saPUFFrequency.x on the next reboot and record the results to non-vol. After the reboot and data is recorded, the index of this object is reset back to unset(0) . Conditions to run a scan on Next boot: - saPUFScanOnNextBoot.x must = set (1). - saPUFRowStatus.x must be set to active in non-vol.')
saPUFScanResults = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notDetected", 0), ("detected", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: saPUFScanResults.setStatus('current')
if mibBuilder.loadTexts: saPUFScanResults.setDescription('Indicates if RF energy was detected on the last scan. This value is stored in non-volatile memory.')
saPUFScanTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readonly")
if mibBuilder.loadTexts: saPUFScanTimestamp.setStatus('current')
if mibBuilder.loadTexts: saPUFScanTimestamp.setDescription('Reports the timestamp (YYYYMMDDHHMM) of the last scan. This value is stored in non-volatile memory.')
saPUFScanResultsType = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notDetected", 0), ("qam", 1), ("docsisQam", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: saPUFScanResultsType.setStatus('current')
if mibBuilder.loadTexts: saPUFScanResultsType.setDescription('Indicates the type of RF energy that was detected on the last scan. This value is stored in non-volatile memory.')
saPUFTrapServer = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFTrapServer.setStatus('current')
if mibBuilder.loadTexts: saPUFTrapServer.setDescription('Defines the IP address of the server to send SNMP traps after running a scan. This value is stored in non-volatile memory.')
saPUFTrapControl = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disable", 0), ("enableOnEnergyDetection", 1), ("enableOnNoEnergyDetected", 2), ("enableOnFrequencyScan", 3), ("enableOnQamDetection", 4), ("enableOnDocsisQamDetection", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFTrapControl.setStatus('current')
if mibBuilder.loadTexts: saPUFTrapControl.setDescription('Send a trap: - If RF energy is detected - enableOnEnergyDetection(1), - If RF energy is not detected - enableOnNoEnergyDetected(2), - When a scan is run - enableOnFrequencyScan(3), - If a QAM is detected - enableOnQamDetection(4), - If a Docsis QAM is detected - enableOnDocsisQamDetection(5) To disable sending traps set the MIB to disable(0),the default. This value is written to non-volatile memory.')
saPUFScanAllNow = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: saPUFScanAllNow.setStatus('current')
if mibBuilder.loadTexts: saPUFScanAllNow.setDescription('Setting this object to true(1) causes the modem to immediately go offline and scan all the frequencies stored in the saPUFFrequency table. Results and timestamp of the scan are stored to non-vol. After the scan takes place the modem re-inits the CM mac and re-registers. Conditions to run the scan: - saPUFRowStatus.x must be set to active for a scan to take place for that frequency. - The scan will not take place if a provisioned line is offhook. - If this mib is added to the CM config file, a scan will not take place unless the current time from TOD server is > 360 seconds (6 minutes) from the last scan time stored in saPUFScanTimestamp.x. This mib object returns false(2)when read if no scan was initiated.')
saPUFEntriesClearOnRFD = MibScalar((1, 3, 6, 1, 4, 1, 1429, 77, 1, 10, 5), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: saPUFEntriesClearOnRFD.setStatus('current')
if mibBuilder.loadTexts: saPUFEntriesClearOnRFD.setDescription('By Default, reset to factory default (RFD) would clear all the PUF entries to factory values. Setting this value to false(2) would mean that the saPUF table frequencies would not be cleared upon a factory reset. This MIB should not be cleared upon factory reset and hence in permanent non-vol. The MIB would take effect only in configuration file, but can be read via SNMPGET or SNMPWALK.')
saLKF = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 11))
saLKFTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 11, 1), )
if mibBuilder.loadTexts: saLKFTable.setStatus('current')
if mibBuilder.loadTexts: saLKFTable.setDescription('A table of Last Known Frequencies.')
saLKFEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 11, 1, 1), ).setIndexNames((0, "SA-CM-MIB", "saLKFIndex"))
if mibBuilder.loadTexts: saLKFEntry.setStatus('current')
if mibBuilder.loadTexts: saLKFEntry.setDescription('A row in the table that specifies a single frequency.')
saLKFIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 11, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)))
if mibBuilder.loadTexts: saLKFIndex.setStatus('current')
if mibBuilder.loadTexts: saLKFIndex.setDescription('Indicates the instance of this table row.')
saLKFFrequency = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 11, 1, 1, 2), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: saLKFFrequency.setStatus('current')
if mibBuilder.loadTexts: saLKFFrequency.setDescription('Frequency in Hz')
saSoftwareIdentity = MibIdentifier((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14))
saSoftwareTable = MibTable((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14, 1), )
if mibBuilder.loadTexts: saSoftwareTable.setStatus('current')
if mibBuilder.loadTexts: saSoftwareTable.setDescription('A Table of SW features support in the running image')
saSoftwareTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14, 1, 1), ).setIndexNames((0, "SA-CM-MIB", "saSoftwareIndex"))
if mibBuilder.loadTexts: saSoftwareTableEntry.setStatus('current')
if mibBuilder.loadTexts: saSoftwareTableEntry.setDescription('A row in the table that specifies a single reset entry.')
saSoftwareIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128)))
if mibBuilder.loadTexts: saSoftwareIndex.setStatus('current')
if mibBuilder.loadTexts: saSoftwareIndex.setDescription('Index for the table.')
saSoftwareBaseVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: saSoftwareBaseVersion.setStatus('current')
if mibBuilder.loadTexts: saSoftwareBaseVersion.setDescription('Defines the SoC vendor base version for the feature, if any')
saSoftwareFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 1429, 77, 1, 14, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: saSoftwareFeatureName.setStatus('current')
if mibBuilder.loadTexts: saSoftwareFeatureName.setDescription('Shows the features present in the software. Also provides Cisco specific compile options used')
mibBuilder.exportSymbols("SA-CM-MIB", saCmWebAccessHomeUsername=saCmWebAccessHomeUsername, saPUFScanOnNextBoot=saPUFScanOnNextBoot, cmAPInternalInterface=cmAPInternalInterface, saCmSoftwareDownloadTFTPServer=saCmSoftwareDownloadTFTPServer, cmEthernetOperTable=cmEthernetOperTable, saCmTftpBlockSizeV4=saCmTftpBlockSizeV4, saCmUsPowerLimit=saCmUsPowerLimit, saCmSwIndex=saCmSwIndex, saCmSwAdminStatus=saCmSwAdminStatus, saCmSoftwareDownload=saCmSoftwareDownload, saPUFEntry=saPUFEntry, saCmWebAccessNoActivityTimeout=saCmWebAccessNoActivityTimeout, saCmIcmpRateLimit=saCmIcmpRateLimit, saCmWebAccessUserIfTypeTable=saCmWebAccessUserIfTypeTable, vendorONLINELEDTreatment=vendorONLINELEDTreatment, saPUFFrequency=saPUFFrequency, saPUFScanTimestamp=saPUFScanTimestamp, saSoftwareFeatureName=saSoftwareFeatureName, saPUFScanResultsType=saPUFScanResultsType, saCmSwProtocol=saCmSwProtocol, saLKFIndex=saLKFIndex, cmAPAgingOut=cmAPAgingOut, saCmSoftwareTable=saCmSoftwareTable, saCmArpRateLimit=saCmArpRateLimit, sa=sa, cmVendorInfo=cmVendorInfo, saCmWebAccessAdvancedUsername=saCmWebAccessAdvancedUsername, cmTimerT4=cmTimerT4, saCmCpeL2VpnMacAging=saCmCpeL2VpnMacAging, saCmWebAccess=saCmWebAccess, saCmTodRenewal=saCmTodRenewal, saPUFTrapServer=saPUFTrapServer, saCmWebAccessUserIfLevel=saCmWebAccessUserIfLevel, cmEthernetIfAdminOverride=cmEthernetIfAdminOverride, vendorLINKLEDTreatment=vendorLINKLEDTreatment, saCmSwModel=saCmSwModel, saCmCpeMacAging=saCmCpeMacAging, saPUFAnnex=saPUFAnnex, saCmForceDualscan=saCmForceDualscan, cmAPInfo=cmAPInfo, saCmSwMethod=saCmSwMethod, saCmBpiForward=saCmBpiForward, saPUFScanResults=saPUFScanResults, vendorUSLEDTreatment=vendorUSLEDTreatment, saCmWebAccessUserTypeIndex=saCmWebAccessUserTypeIndex, saCmWebAccessHomeUserPassword=saCmWebAccessHomeUserPassword, cmConsoleMode=cmConsoleMode, saCmWebAccessIfTypeIndex=saCmWebAccessIfTypeIndex, saPUF=saPUF, cmAPFactoryReset=cmAPFactoryReset, saCmUsBonding=saCmUsBonding, cmEthernetOperSetting=cmEthernetOperSetting, saCmL2VpnUsForwardingCriteria=saCmL2VpnUsForwardingCriteria, saCmSwFilename=saCmSwFilename, saSoftwareTableEntry=saSoftwareTableEntry, saPUFIndex=saPUFIndex, PYSNMP_MODULE_ID=saCmMib, saPUFRowStatus=saPUFRowStatus, saCmWebAccessHomeUserClearPassword=saCmWebAccessHomeUserClearPassword, saCmSwServerAddress=saCmSwServerAddress, saCmAutoResetNoActivity=saCmAutoResetNoActivity, saCmDocsisCapableVersion=saCmDocsisCapableVersion, saSoftwareBaseVersion=saSoftwareBaseVersion, saPUFScanAllNow=saPUFScanAllNow, cmAPMulticastPromiscuousMode=cmAPMulticastPromiscuousMode, cmEthernetIfAdminStatus=cmEthernetIfAdminStatus, vendorDefaultDSfreq=vendorDefaultDSfreq, cmAPIgmp=cmAPIgmp, saSoftwareTable=saSoftwareTable, saLKFFrequency=saLKFFrequency, saLKF=saLKF, saCmSoftwareEntry=saCmSoftwareEntry, saCmTftpBlockSizeV6=saCmTftpBlockSizeV6, cmEthernetOperMode=cmEthernetOperMode, saCmWebAccessAdvancedPassword=saCmWebAccessAdvancedPassword, saLKFTable=saLKFTable, saLKFEntry=saLKFEntry, dpxCmMibObjects=dpxCmMibObjects, saOorDsidOverride=saOorDsidOverride, saPUFEntriesClearOnRFD=saPUFEntriesClearOnRFD, saCmInternalDhcpServer=saCmInternalDhcpServer, saPUFScanNow=saPUFScanNow, saCmWebAccessAdvancedType=saCmWebAccessAdvancedType, vendorDSLEDTreatment=vendorDSLEDTreatment, cmEthernetOperEntry=cmEthernetOperEntry, saCmSwServerAddressType=saCmSwServerAddressType, saCmSwHwVer=saCmSwHwVer, saPUFTable=saPUFTable, cmInterfaceInfo=cmInterfaceInfo, saCmDsBonding=saCmDsBonding, saCmSwServer=saCmSwServer, saSoftwareIndex=saSoftwareIndex, saCmWebAccessUserIfTypeEntry=saCmWebAccessUserIfTypeEntry, saCmMib=saCmMib, saPUFTrapControl=saPUFTrapControl, saCmSwBootLoader=saCmSwBootLoader, saSoftwareIdentity=saSoftwareIdentity, cmEthernetOperIndex=cmEthernetOperIndex)

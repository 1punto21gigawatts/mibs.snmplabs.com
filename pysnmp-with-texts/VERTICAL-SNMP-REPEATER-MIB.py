#
# PySNMP MIB module VERTICAL-SNMP-REPEATER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/VERTICAL-SNMP-REPEATER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:34:09 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
OwnerString, = mibBuilder.importSymbols("RFC1271-MIB", "OwnerString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
IpAddress, Unsigned32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Gauge32, iso, NotificationType, Bits, Integer32, Counter64, ModuleIdentity, MibIdentifier, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Unsigned32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Gauge32", "iso", "NotificationType", "Bits", "Integer32", "Counter64", "ModuleIdentity", "MibIdentifier", "NotificationType", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vertical, = mibBuilder.importSymbols("VERTICALT1-E1-MIB", "vertical")
vsnmpDot3RptrMgt = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4))
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

vrptrBasicPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 1))
vrptrGroupInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2))
vrptrPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3))
vrptrAllRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4))
vrptrMonitorPackage = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 2))
vrptrMonitorPortInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3))
vrptrMonitorAllRptrInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4))
vrptrGroupTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1), )
if mibBuilder.loadTexts: vrptrGroupTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupTable.setDescription('Table of descriptive and status information about the groups of ports.')
vrptrGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrGroupIndex"))
if mibBuilder.loadTexts: vrptrGroupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupEntry.setDescription('An entry in the table, containing information about a single group of ports.')
vrptrGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupIndex.setReference('[IEEE 802.3 Mgt], 30.4.2.1.1, aGroupID.')
if mibBuilder.loadTexts: vrptrGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupIndex.setDescription('This object identifies the group within the system for which this entry contains information.')
vrptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupObjectID.setDescription("The vendor's authoritative identification of the group. This value may be allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of group is being managed. For example, this object could take the value 1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones, Inc.' was assigned the subtree 1.3.6.1.4.1.4242, and had assigned the identifier 1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone 6-Port FOIRL Plug-in Module.'")
vrptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupOperStatus.setDescription('An object that indicates the operational status of the group. A status of notPresent(4) indicates that the group is temporarily or permanently physically and/or logically not a part of the repeater. It is an implementation-specific matter as to whether the agent effectively removes notPresent entries from the table. A status of operational(2) indicates that the group is functioning, and a status of malfunctioning(3) indicates that the group is malfunctioning in some way.')
vrptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupPortCapacity.setReference('IEEE 802.3 Mgt, 30.4.2.1.2, aGroupPortCapacity.')
if mibBuilder.loadTexts: vrptrGroupPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupPortCapacity.setDescription('The rptrGroupPortCapacity is the number of ports that can be contained within the group. Valid range is 1-2147483647. Within each group, the ports are uniquely numbered in the range from 1 to vrptrGroupPortCapacity. Some ports may not be present in the system, in which case the actual number of ports present will be less than the value of rptrGroupPortCapacity. The number of ports present in the group will never be greater than the value of rptrGroupPortCapacity. Note: In practice, this will generally be the number of ports on a module, card, or board, and the port numbers will correspond to numbers marked on the physical embodiment.')
vrptrGroupSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupSlotNumber.setDescription("The physical slot number in the Vertical's InstantOffice box that this repeater group resides.")
vrptrGroupBroadcastDomainNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupBroadcastDomainNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupBroadcastDomainNumber.setDescription("This object indicates the repeater's broadcast domain. A broadcast domain is an Ethernet segment or set of segments throughout which a broadcast frame will be transmitted. The segments may be separated by repeaters or switches, but not routers. This value will be 0 if the broadcast domain number is unknown.")
vrptrGroupNetworkAdapterNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupNetworkAdapterNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupNetworkAdapterNumber.setDescription('This object indicates the identification number of the InstantOffice network adapter associated with the repeater, if any. This value will be 0 if the repeated domain number is unassociated or unknown.')
vrptrGroupLedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("none", 2), ("green", 3), ("red", 4), ("greenRed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupLedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupLedStatus.setDescription("This object indicates the status of the card LEDs. The LED status is shown for any card that has an Ethernet interface. Valid values are unknown (1), none(2), green(3), red(4) and greenRed(5). A status of unknown(1) indicates that the LED status is not available from the hardware and could not be determined from the card's state. A status of greenRed(5) indicates that both the green and red LEDs are ON. A status of none(2) indicates neither the green nor the red LED is ON. However, note that the green LED on the Resource Switch Card blinks every second to indicate an active Fault Monitor, and therefore, if this value is requested during the short period when the green LED is off, it will indicate that it is off.")
vrptrGroupExternalPortCapacity = MibScalar((1, 3, 6, 1, 4, 1, 2338, 4, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrGroupExternalPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrGroupExternalPortCapacity.setDescription('The rptrGroupExternalPortCapacity is similar to, and typical equal to, rptrGroupPortCapacity. External ports are those which extrude from the front faceplate. Non-external ports may be used for internal subsystems or testing, but which are useful for statistic purposes. External ports will always be listed first in the group, and thus non-external ports are listed with higher port numbers.')
vrptrPortTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1), )
if mibBuilder.loadTexts: vrptrPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortTable.setDescription('Table of descriptive and status information about the repeater ports in the system. The number of entries is independent of the number of repeaters in the managed system.')
vrptrPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrPortGroupIndex"), (0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrPortIndex"))
if mibBuilder.loadTexts: vrptrPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortEntry.setDescription('An entry in the table, containing information about a single port.')
vrptrPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
vrptrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortIndex.setReference('[IEEE 802.3 Mgt], 30.4.3.1.1, aPortID.')
if mibBuilder.loadTexts: vrptrPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortIndex.setDescription('This object identifies the port within the group for which this entry contains information. This identifies the port independently from the repeater it may be attached to. The numbering scheme for ports is implementation specific; however, this value can never be greater than rptrGroupPortCapacity for the associated group.')
vrptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrptrPortAdminStatus.setReference('[IEEE 802.3 Mgt], 30.4.3.1.2, aPortAdminState and 30.4.3.2.1, acPortAdminControl.')
if mibBuilder.loadTexts: vrptrPortAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortAdminStatus.setDescription("Setting this object to disabled(2) disables the port. A disabled port neither transmits nor receives. Once disabled, a port must be explicitly enabled to restore operation. A port which is disabled when power is lost or when a reset is exerted shall remain disabled when normal operation resumes. The admin status takes precedence over auto- partition and functionally operates between the auto-partition mechanism and the AUI/PMA. Setting this object to enabled(1) enables the port and exerts a BEGIN on the port's auto-partition state machine. (In effect, when a port is disabled, the value of rptrPortAutoPartitionState for that port is frozen until the port is next enabled. When the port becomes enabled, the rptrPortAutoPartitionState becomes notAutoPartitioned(1), regardless of its pre-disabling state.)")
vrptrPortAutoPartitionState = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notAutoPartitioned", 1), ("autoPartitioned", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortAutoPartitionState.setReference('[IEEE 802.3 Mgt], 30.4.3.1.3, aAutoPartitionState.')
if mibBuilder.loadTexts: vrptrPortAutoPartitionState.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortAutoPartitionState.setDescription("The autoPartitionState flag indicates whether the port is currently partitioned by the repeater's auto-partition protection. The conditions that cause port partitioning are specified in partition state machine in Sections 9 and 27 of [IEEE 802.3 Std]. They are not differentiated here.")
vrptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("notOperational", 2), ("notPresent", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortOperStatus.setDescription("This object indicates the port's operational status. The notPresent(3) status indicates the port is physically removed (note this may or may not be possible depending on the type of port.) The operational(1) status indicates that the port is enabled (see rptrPortAdminStatus) and working, even though it might be auto-partitioned (see rptrPortAutoPartitionState). If this object has the value operational(1) and rptrPortAdminStatus is set to disabled(2), it is expected that this object's value will soon change to notOperational(2).")
vrptrPortRptrId = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortRptrId.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortRptrId.setDescription('This object identifies the repeater to which this port belongs. The repeater identified by a particular value of this object is the same as that identified by the same value of rptrInfoId. A value of zero indicates that this port currently is not a member of any repeater.')
vrptrPortLinkState = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("link", 1), ("noLink", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortLinkState.setDescription('Describes whether there is link on this port or not: link = 1 noLink = 2')
vrptrPortSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("mbps-10", 2), ("mbps-100", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortSpeed.setDescription('Specifies the ethernet speed of this particular port. Valid values are : unknown = 1, 10-MBPS =2 (10MB per second), 100-MBPS = 3 (100 MB per second)')
vrptrPortSpeedSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("speed-select-auto", 1), ("speed-select-10", 2), ("speed-select-100", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortSpeedSelect.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortSpeedSelect.setDescription('This object indicates the selection used by the port for negotiating the Ethernet speed. If automatic is selected, the highest supported speed will be negotiated. Currently, this variable is read-only. Valid values are : speed-select-auto = 1, speed-select-10 = 2 (10MB per second), speed-select-100 = 3 (100 MB per second)')
vrptrPortDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("half", 2), ("full", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortDuplex.setDescription('This object indicates the duplex of the Ethernet port. Valid values are : unknown = 1, half = 2, full = 3')
vrptrPortDuplexSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("duplex-select-auto", 1), ("duplex-select-half", 2), ("duplex-select-full", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortDuplexSelect.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortDuplexSelect.setDescription('This object indicates the selection used by the port for negotiating the Ethernet duplex. If automatic is selected, the best supported duplex will be negotiated. This is currently a read-only variable. Valid values are : duplex-select-auto = 1, duplex-select-half = 2, duplex-select-full = 3')
vrptrPortPolarity = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("straight", 2), ("crossed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrPortPolarity.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrPortPolarity.setDescription('This object indicates the polarity of the Ethernet cable. If the polarity is crossed, the repeater may compensate for it, but it indicates a wiring problem with the attached Ethernet device. Valid values are : unknown = 1, straight = 2, crossed = 3')
vrptrInfoTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1), )
if mibBuilder.loadTexts: vrptrInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoTable.setDescription('A table of information about each non-trivial repeater. The number of entries depends on the physical configuration of the managed system.')
vrptrInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrInfoId"))
if mibBuilder.loadTexts: vrptrInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoEntry.setDescription('An entry in the table, containing information about a single non-trivial repeater.')
vrptrInfoId = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrInfoId.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoId.setDescription('This object identifies the repeater for which this entry contains information.')
vrptrInfoRptrType = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("tenMb", 2), ("onehundredMbClassI", 3), ("onehundredMbClassII", 4), ("tenMbOrOnehundredMb", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrInfoRptrType.setReference('[IEEE 802.3 Mgt], 30.4.1.1.2, aRepeaterType.')
if mibBuilder.loadTexts: vrptrInfoRptrType.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoRptrType.setDescription('The rptrInfoRptrType returns a value that identifies the CSMA/CD repeater type. The value 5 (tenMbOrOnehundredMb) is a Vertical Network extension specifying 10/100 MB repeater which contains mixed 10Mb and 100 Mb ports.')
vrptrInfoOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("failure", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrInfoOperStatus.setReference('[IEEE 802.3 Mgt], 30.4.1.1.5, aRepeaterHealthState.')
if mibBuilder.loadTexts: vrptrInfoOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoOperStatus.setDescription('The rptrInfoOperStatus object indicates the operational state of the repeater.')
vrptrInfoReset = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrptrInfoReset.setReference('[IEEE 802.3 Mgt], 30.4.1.2.1, acResetRepeater.')
if mibBuilder.loadTexts: vrptrInfoReset.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoReset.setDescription('Setting this object to reset(2) causes a transition to the START state of Fig 9-2 in section 9 [IEEE 802.3 Std] for a 10Mb/s repeater, and to the START state of Fig 27-2 in section 27 of that standard for a 100Mb/s repeater. Setting this object to noReset(1) has no effect. The agent will always return the value noReset(1) when this object is read. After receiving a request to set this variable to reset(2), the agent is allowed to delay the reset for a short period. For example, the implementor may choose to delay the reset long enough to allow the SNMP response to be transmitted. In any event, the SNMP response must be transmitted. This action does not reset the management counters defined in this document nor does it affect the portAdminStatus parameters. Included in this action is the execution of a disruptive Self-Test with the following characteristics: a) The nature of the tests is not specified. b) The test resets the repeater but without affecting management information about the repeater. c) The test does not inject packets onto any segment. d) Packets received during the test may or may not be transferred. e) The test does not interfere with management functions. After performing this self-test, the agent will update the repeater health information (including rptrInfoOperStatus), and send a rptrInfoResetEvent notification.')
vrptrInfoPartitionedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrInfoPartitionedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoPartitionedPorts.setDescription('This object returns the total number of ports in the repeater whose current state meets all three of the following criteria: rptrPortOperStatus does not have the value notPresent(3), rptrPortAdminStatus is enabled(1), and rptrPortAutoPartitionState is autoPartitioned(2).')
vrptrInfoLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 1, 4, 1, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrInfoLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrInfoLastChange.setDescription('The value of sysUpTime when any of the following conditions occurred: 1) agent cold- or warm-started; 2) this instance of repeater was created (such as when a device or module was added to the system); 3) a change in the value of rptrInfoOperStatus; 4) ports were added or removed as members of the repeater; or 5) any of the counters associated with this repeater had a discontinuity.')
vrptrMonitorPortTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1), )
if mibBuilder.loadTexts: vrptrMonitorPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortTable.setDescription('Table of performance and error statistics for the ports. The number of entries is the same as that in the rptrPortTable. The columnar object rptrMonitorPortLastChange is used to indicate possible discontinuities of counter type columnar objects in the table.')
vrptrMonitorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrMonitorPortGroupIndex"), (0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrMonitorPortIndex"))
if mibBuilder.loadTexts: vrptrMonitorPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortEntry.setDescription('An entry in the table, containing performance and error statistics for a single port.')
vrptrMonitorPortGroupIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortGroupIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortGroupIndex.setDescription('This object identifies the group containing the port for which this entry contains information.')
vrptrMonitorPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortIndex.setReference('[IEEE 802.3 Mgt], 30.4.3.1.1, aPortID.')
if mibBuilder.loadTexts: vrptrMonitorPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortIndex.setDescription('This object identifies the port within the group for which this entry contains information.')
vrptrMonitorPortReadableFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortReadableFrames.setReference('[IEEE 802.3 Mgt], 30.4.3.1.4, aReadableFrames.')
if mibBuilder.loadTexts: vrptrMonitorPortReadableFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortReadableFrames.setDescription('This object is the number of frames of valid frame length that have been received on this port. This counter is incremented by one for each frame received on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours at 10Mb/s.')
vrptrMonitorPortReadableOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortReadableOctets.setReference('[IEEE 802.3 Mgt], 30.4.3.1.5, aReadableOctets.')
if mibBuilder.loadTexts: vrptrMonitorPortReadableOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortReadableOctets.setDescription("This object is the number of octets contained in valid frames that have been received on this port. This counter is incremented by OctetCount for each frame received on this port which has been determined to be a readable frame (i.e., including FCS octets but excluding framing bits and dribble bits). A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter in a 10Mb/s repeater is 58 minutes. For ports receiving traffic at a maximum rate in a 100Mb/s repeater, this counter can roll over in less than 6 minutes. Since that amount of time could be less than a management station's poll cycle time, in order to avoid a loss of information a management station is advised to also poll the rptrMonitorPortUpper32Octets object, or to use the 64-bit counter defined by rptrMonitorPortHCReadableOctets instead of the two 32-bit counters.")
vrptrMonitorPortFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortFCSErrors.setReference('[IEEE 802.3 Mgt], 30.4.3.1.6, aFrameCheckSequenceErrors.')
if mibBuilder.loadTexts: vrptrMonitorPortFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortFCSErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError signal asserted and the FramingError and CollisionEvent signals deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 80 hours at 10Mb/s.')
vrptrMonitorPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortAlignmentErrors.setReference('[IEEE 802.3 Mgt], 30.4.3.1.7, aAlignmentErrors.')
if mibBuilder.loadTexts: vrptrMonitorPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortAlignmentErrors.setDescription('This counter is incremented by one for each frame received on this port with the FCSError and FramingError signals asserted and CollisionEvent signal deasserted and whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1). If rptrMonitorPortAlignmentErrors is incremented then the rptrMonitorPortFCSErrors Counter shall not be incremented for the same frame. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 80 hours at 10Mb/s.')
vrptrMonitorPortFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortFrameTooLongs.setReference('[IEEE 802.3 Mgt], 30.4.3.1.8, aFramesTooLong.')
if mibBuilder.loadTexts: vrptrMonitorPortFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortFrameTooLongs.setDescription('This counter is incremented by one for each frame received on this port whose OctetCount is greater than maxFrameSize (Ref: 4.4.2.1, IEEE 802.3 Std). If rptrMonitorPortFrameTooLongs is incremented then neither the rptrMonitorPortAlignmentErrors nor the rptrMonitorPortFCSErrors counter shall be incremented for the frame. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 61 days in a 10Mb/s repeater.')
vrptrMonitorPortShortEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortShortEvents.setReference('[IEEE 802.3 Mgt], 30.4.3.1.9, aShortEvents.')
if mibBuilder.loadTexts: vrptrMonitorPortShortEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortShortEvents.setDescription('This counter is incremented by one for each CarrierEvent on this port with ActivityDuration less than ShortEventMaxTime. ShortEventMaxTime is greater than 74 bit times and less than 82 bit times. ShortEventMaxTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Notes: ShortEvents may indicate externally generated noise hits which will cause the repeater to transmit Runts to its other ports, or propagate a collision (which may be late) back to the transmitting DTE and damaged frames to the rest of the network. Implementors may wish to consider selecting the ShortEventMaxTime towards the lower end of the allowed tolerance range to accommodate bit losses suffered through physical channel devices not budgeted for within this standard. The significance of this attribute is different in 10 and 100 Mb/s collision domains. Clause 9 repeaters perform fragment extension of short events which would be counted as runts on the interconnect ports of other repeaters. Clause 27 repeaters do not perform fragment extension. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 16 hours in a 10Mb/s repeater.')
vrptrMonitorPortRunts = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortRunts.setReference('[IEEE 802.3 Mgt], 30.4.3.1.10, aRunts.')
if mibBuilder.loadTexts: vrptrMonitorPortRunts.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortRunts.setDescription('This counter is incremented by one for each CarrierEvent on this port that meets one of the following two conditions. Only one test need be made. a) The ActivityDuration is greater than ShortEventMaxTime and less than ValidPacketMinTime and the CollisionEvent signal is deasserted. b) The OctetCount is less than 64, the ActivityDuration is greater than ShortEventMaxTime and the CollisionEvent signal is deasserted. ValidPacketMinTime is greater than or equal to 552 bit times and less than 565 bit times. An event whose length is greater than 74 bit times but less than 82 bit times shall increment either the shortEvents counter or the runts counter but not both. A CarrierEvent greater than or equal to 552 bit times but less than 565 bit times may or may not be counted as a runt. ValidPacketMinTime has tolerances included to provide for circuit losses between a conformance test point at the AUI and the measurement point within the state machine. Runts usually indicate collision fragments, a normal network event. In certain situations associated with large diameter networks a percentage of collision fragments may exceed ValidPacketMinTime. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 16 hours in a 10Mb/s repeater.')
vrptrMonitorPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortCollisions.setReference('[IEEE 802.3 Mgt], 30.4.3.1.11, aCollisions.')
if mibBuilder.loadTexts: vrptrMonitorPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortCollisions.setDescription('For a clause 9 repeater, this counter is incremented by one for any CarrierEvent signal on any port for which the CollisionEvent signal on this port is asserted. For a clause 27 repeater port the counter increments on entering the Collision Count Increment state of the partition state diagram (fig 27-8 of [IEEE 802.3 Std]). A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 16 hours in a 10Mb/s repeater.')
vrptrMonitorPortLateEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortLateEvents.setReference('[IEEE 802.3 Mgt], 30.4.3.1.12, aLateEvents.')
if mibBuilder.loadTexts: vrptrMonitorPortLateEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortLateEvents.setDescription('For a clause 9 repeater port, this counter is incremented by one for each CarrierEvent on this port in which the CollIn(X) variable transitions to the value SQE (Ref: 9.6.6.2, IEEE 802.3 Std) while the ActivityDuration is greater than the LateEventThreshold. For a clause 27 repeater port, this counter is incremented by one on entering the Collision Count Increment state of the partition state diagram (fig 27-8) while the ActivityDuration is greater than the LateEvent- Threshold. Such a CarrierEvent is counted twice, as both a collision and as a lateEvent. The LateEventThreshold is greater than 480 bit times and less than 565 bit times. LateEventThreshold has tolerances included to permit an implementation to build a single threshold to serve as both the LateEventThreshold and ValidPacketMinTime threshold. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 81 hours in a 10Mb/s repeater.')
vrptrMonitorPortVeryLongEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortVeryLongEvents.setReference('[IEEE 802.3 Mgt], 30.4.3.1.13, aVeryLongEvents.')
if mibBuilder.loadTexts: vrptrMonitorPortVeryLongEvents.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortVeryLongEvents.setDescription('For a clause 9 repeater port, this counter is incremented by one for each CarrierEvent whose ActivityDuration is greater than the MAU Jabber Lockup Protection timer TW3 (Ref: 9.6.1 & 9.6.5, IEEE 802.3 Std). For a clause 27 repeater port, this counter is incremented by one on entry to the Rx Jabber state of the receiver timer state diagram (fig 27-7). Other counters may be incremented as appropriate. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes.')
vrptrMonitorPortDataRateMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortDataRateMismatches.setReference('[IEEE 802.3 Mgt], 30.4.3.1.14, aDataRateMismatches.')
if mibBuilder.loadTexts: vrptrMonitorPortDataRateMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortDataRateMismatches.setDescription("This counter is incremented by one for each frame received by this port that meets all of the conditions required by only one of the following two measurement methods: Measurement method A: 1) The CollisionEvent signal is not asserted (10Mb/s operation) or the Collision Count Increment state of the partition state diagram (fig 27-8 of [IEEE 802.3 Std]) has not been entered (100Mb/s operation). 2) The ActivityDuration is greater than ValidPacketMinTime. 3) The frequency (data rate) is detectably mismatched from the local transmit frequency. Measurement method B: 1) The CollisionEvent signal is not asserted (10Mb/s operation) or the Collision Count Increment state of the partition state diagram (fig 27-8 of [IEEE 802.3 Std]) has not been entered (100Mb/s operation). 2) The OctetCount is greater than 63. 3) The frequency (data rate) is detectably mismatched from the local transmit frequency. The exact degree of mismatch is vendor specific and is to be defined by the vendor for conformance testing. When this event occurs, other counters whose increment conditions were satisfied may or may not also be incremented, at the implementor's discretion. Whether or not the repeater was able to maintain data integrity is beyond the scope of this standard. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes.")
vrptrMonitorPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortAutoPartitions.setReference('[IEEE 802.3 Mgt], 30.4.3.1.15, aAutoPartitions.')
if mibBuilder.loadTexts: vrptrMonitorPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortAutoPartitions.setDescription('This counter is incremented by one for each time the repeater has automatically partitioned this port. The conditions that cause a clause 9 repeater port to partition are specified in the partition state diagram in clause 9 of [IEEE 802.3 Std]. They are not differentiated here. A clause 27 repeater port partitions on entry to the Partition Wait state of the partition state diagram (fig 27-8 in [IEEE 802.3 Std]). A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes.')
vrptrMonitorPortTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortTotalErrors.setDescription('The total number of errors which have occurred on this port. This counter is the summation of the values of other error counters (for the same port), namely: vrptrMonitorPortFCSErrors, vrptrMonitorPortAlignmentErrors, vrptrMonitorPortFrameTooLongs, vrptrMonitorPortShortEvents, vrptrMonitorPortLateEvents, vrptrMonitorPortVeryLongEvents, vrptrMonitorPortDataRateMismatches, and vrptrMonitorPortSymbolErrors. This counter is redundant in the sense that it is the summation of information already available through other objects. However, it is included specifically because the regular retrieval of this object as a means of tracking the health of a port provides a considerable optimization of network management traffic over the otherwise necessary retrieval of the summed counters. Note that rptrMonitorPortRunts is not included in this total; this is because runts usually indicate collision fragments, a normal network event. A discontinuity may occur in the value when the value of object vrptrMonitorPortLastChange changes.')
vrptrMonitorPortLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortLastChange.setDescription('The value of sysUpTime when the last of the following occurred: 1) the agent cold- or warm-started; 2) the row for the port was created (such as when a device or module was added to the system); or 3) any condition that would cause one of the counters for the row to experience a discontinuity.')
vrptrMonitorPortSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortSentFrames.setDescription('This object is the number of frames of valid frame length that have been sent on this port. This counter is incremented by one for each frame sent on this port whose OctetCount is greater than or equal to minFrameSize and less than or equal to maxFrameSize (Ref: IEEE 802.3 Std, 4.4.2.1) and for which the FCSError and CollisionEvent signals are not asserted. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours at 10Mb/s.')
vrptrMonitorPortSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortSentOctets.setDescription("This object is the number of octets contained in valid frames that have been sent on this port. This counter is incremented by OctetCount for each frame sent on this port which has been determined to be a readable frame (i.e., including FCS octets but excluding framing bits and dribble bits). A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter in a 10Mb/s repeater is 58 minutes. For ports receiving traffic at a maximum rate in a 100Mb/s repeater, this counter can roll over in less than 6 minutes. Since that amount of time could be less than a management station's poll cycle time, in order to avoid a loss of information a management station is advised to also poll the rptrMonitorPortUpper32SentOctets object, or to use the 64-bit counter defined by rptrMonitorPortHCReadableOctets instead of the two 32-bit counters.")
vrptrMonitorPortDroppedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortDroppedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortDroppedFrames.setDescription('This counter is incremented by one for each time the switch had dropped a frame due a buffer full event. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes.')
vrptrMonitorPortOtherErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortOtherErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortOtherErrors.setDescription('This counter is incremented by one for each time the repeater has detected an error which is not reported in any other error counter. The frame may or may not be lost due to the error. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes.')
vrptrMonitor100PortTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2), )
if mibBuilder.loadTexts: vrptrMonitor100PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitor100PortTable.setDescription('Table of additional performance and error statistics for 100Mb/s ports, above and beyond those parameters that apply to both 10 and 100Mbps ports. Entries exist only for ports attached to 100Mbps repeaters. The columnar object rptrMonitorPortLastChange is used to indicate possible discontinuities of counter type columnar objects in this table.')
vrptrMonitor100PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrMonitorPortGroupIndex"), (0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrMonitorPortIndex"))
if mibBuilder.loadTexts: vrptrMonitor100PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitor100PortEntry.setDescription('An entry in the table, containing performance and error statistics for a single 100Mb/s port.')
vrptrMonitorPortIsolates = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortIsolates.setReference('[IEEE 802.3 Mgt], 30.4.3.1.16, aIsolates.')
if mibBuilder.loadTexts: vrptrMonitorPortIsolates.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortIsolates.setDescription('This counter is incremented by one each time that the repeater port automatically isolates as a consequence of false carrier events. The conditions which cause a port to automatically isolate are defined by the transition from the False Carrier state to the Link Unstable state of the carrier integrity state diagram (figure 27-9) [IEEE 802.3 Standard]. Note: Isolates do not affect the value of the PortOperStatus object. A discontinuity may occur in the value when the value of object vrptrMonitorPortLastChange changes.')
vrptrMonitorPortSymbolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortSymbolErrors.setReference('[IEEE 802.3 Mgt], 30.4.3.1.17, aSymbolErrorDuringPacket.')
if mibBuilder.loadTexts: vrptrMonitorPortSymbolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortSymbolErrors.setDescription('This counter is incremented by one each time when valid length packet was received at the port and there was at least one occurrence of an invalid data symbol. This can increment only once per valid carrier event. A collision presence at any port of the repeater containing port N, will not cause this attribute to increment. A discontinuity may occur in the value when the value of object rptrMonitorPortLastChange changes. The approximate minimum time for rollover of this counter is 7.4 hours at 100Mb/s.')
vrptrMonitorPortUpper32Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortUpper32Octets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortUpper32Octets.setDescription('This object is the number of octets contained in valid frames that have been received on this port, modulo 2**32. That is, it contains the upper 32 bits of a 64-bit octets counter, of which the lower 32 bits are contained in the rptrMonitorPortReadableOctets object. This two-counter mechanism is provided for those network management protocols that do not support 64-bit counters (e.g. SNMP V1) and are used to manage a repeater type of 100Mb/s. Conformance clauses for this MIB are defined such that implementation of this object is not required in a system which does not support 100Mb/s. However, systems with mixed 10 and 100Mb/s ports may implement this object across all ports, including 10Mb/s. If this object is implemented, it must be according to the definition in the first paragraph of this description; that is, the value of this object MUST be a valid count. A discontinuity may occur in the value when the value of object vrptrMonitorPortLastChange changes.')
vrptrMonitorPortUpper32SentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonitorPortUpper32SentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonitorPortUpper32SentOctets.setDescription('This object is the number of octets contained in valid frames that have been sent on this port, modulo 2**32. That is, it contains the upper 32 bits of a 64-bit octets counter, of which the lower 32 bits are contained in the rptrMonitorPortSentOctets object. This two-counter mechanism is provided for those network management protocols that do not support 64-bit counters (e.g. SNMP V1) and are used to manage a repeater type of 100Mb/s. Conformance clauses for this MIB are defined such that implementation of this object is not required in a system which does not support 100Mb/s. However, systems with mixed 10 and 100Mb/s ports may implement this object across all ports, including 10Mb/s. If this object is implemented, it must be according to the definition in the first paragraph of this description; that is, the value of this object MUST be a valid count. A discontinuity may occur in the value when the value of object vrptrMonitorPortLastChange changes.')
vrptrMonTable = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1), )
if mibBuilder.loadTexts: vrptrMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonTable.setDescription('A table of information about each non-trivial repeater. The number of entries in this table is the same as the number of entries in the rptrInfoTable. The columnar object rptrInfoLastChange is used to indicate possible discontinuities of counter type columnar objects in this table.')
vrptrMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrInfoId"))
if mibBuilder.loadTexts: vrptrMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonEntry.setDescription('An entry in the table, containing information about a single non-trivial repeater.')
vrptrMonTxCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonTxCollisions.setReference('[IEEE 802.3 Mgt], 30.4.1.1.8, aTransmitCollisions')
if mibBuilder.loadTexts: vrptrMonTxCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonTxCollisions.setDescription('For a clause 9 (10Mb/s) repeater, this counter is incremented every time the repeater state machine enters the TRANSMIT COLLISION state from any state other than ONE PORT LEFT (Ref: Fig 9-2 [IEEE 802.3 Std]). For a clause 27 repeater, this counter is incremented every time the repeater core state diagram enters the Jam state as a result of Activity(ALL) > 1 (fig 27-2 [IEEE 802.3 Std]). The approximate minimum time for rollover of this counter is 16 hours in a 10Mb/s repeater and 1.6 hours in a 100Mb/s repeater.')
vrptrMonTotalFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonTotalFrames.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonTotalFrames.setDescription('The number of frames of valid frame length that have been received on the ports in this repeater and for which the FCSError and CollisionEvent signals were not asserted. If an implementation can not obtain a count of frames as seen by the repeater itself, this counter may be implemented as the summation of the values of the rptrMonitorPortReadableFrames counters for all of the ports in the repeater. This statistic provides one of the parameters necessary for obtaining the packet error rate. The approximate minimum time for rollover of this counter is 80 hours in a 10Mb/s repeater.')
vrptrMonTotalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonTotalErrors.setDescription('The total number of errors which have occurred on all of the ports in this repeater. The errors included in this count are the same as those listed for the rptrMonitorPortTotalErrors counter. If an implementation can not obtain a count of these errors as seen by the repeater itself, this counter may be implemented as the summation of the values of the rptrMonitorPortTotalErrors counters for all of the ports in the repeater.')
vrptrMonTotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0))).clone(namedValues=NamedValues(("notSupported", -1), ("supported", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonTotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonTotalOctets.setDescription("The total number of octets contained in the valid frames that have been received on the ports in this group. If an implementation can not obtain a count of octets as seen by the repeater itself, this counter may be the summation of the values of the rptrMonitorPortReadableOctets counters for all of the ports in the group. This statistic provides an indicator of the total data transferred. The approximate minimum time for rollover of this counter in a 10Mb/s repeater is 58 minutes divided by the number of ports in the repeater. For 100Mb/s repeaters processing traffic at a maximum rate, this counter can roll over in less than 6 minutes divided by the number of ports in the repeater. Since that amount of time could be less than a management station's poll cycle time, in order to avoid a loss of information a management station is advised to also poll the rptrMonUpper32TotalOctets object, or to use the 64-bit counter defined by rptrMonHCTotalOctets instead of the two 32-bit counters.")
vrptrMon100Table = MibTable((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 2), )
if mibBuilder.loadTexts: vrptrMon100Table.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMon100Table.setDescription('A table of additional information about each 100Mb/s repeater, augmenting the entries in the rptrMonTable. Entries exist in this table only for 100Mb/s repeaters. The columnar object rptrInfoLastChange is used to indicate possible discontinuities of counter type columnar objects in this table.')
vrptrMon100Entry = MibTableRow((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 2, 1), ).setIndexNames((0, "VERTICAL-SNMP-REPEATER-MIB", "vrptrInfoId"))
if mibBuilder.loadTexts: vrptrMon100Entry.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMon100Entry.setDescription('An entry in the table, containing information about a single 100Mbps repeater.')
vrptrMonUpper32TotalOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 2338, 4, 2, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrptrMonUpper32TotalOctets.setStatus('mandatory')
if mibBuilder.loadTexts: vrptrMonUpper32TotalOctets.setDescription('The total number of octets contained in the valid frames that have been received on the ports in this repeater, modulo 2**32. That is, it contains the upper 32 bits of a 64-bit counter, of which the lower 32 bits are contained in the rptrMonTotalOctets object. If an implementation can not obtain a count of octets as seen by the repeater itself, the 64-bit value may be the summation of the values of the rptrMonitorPortReadableOctets counters combined with the corresponding rptrMonitorPortUpper32Octets counters for all of the ports in the repeater. This statistic provides an indicator of the total data transferred within the repeater. This two-counter mechanism is provided for those network management protocols that do not support 64-bit counters (e.g. SNMP V1) and are used to manage a repeater type of 100Mb/s. Conformance clauses for this MIB are defined such that implementation of this object is not required in a system which does not support 100Mb/s. However, systems with mixed 10 and 100Mb/s ports may implement this object across all ports, including 10Mb/s. If this object is implemented, it must be according to the definition in the first paragraph of this description; that is, the value of this object MUST be a valid count.')
mibBuilder.exportSymbols("VERTICAL-SNMP-REPEATER-MIB", vrptrPortTable=vrptrPortTable, vrptrInfoRptrType=vrptrInfoRptrType, vrptrGroupExternalPortCapacity=vrptrGroupExternalPortCapacity, vrptrMonitorPortEntry=vrptrMonitorPortEntry, vrptrMonitorPortLateEvents=vrptrMonitorPortLateEvents, vrptrPortAutoPartitionState=vrptrPortAutoPartitionState, vrptrMonitorPortOtherErrors=vrptrMonitorPortOtherErrors, vrptrMonTxCollisions=vrptrMonTxCollisions, vrptrMonitorPortDataRateMismatches=vrptrMonitorPortDataRateMismatches, vrptrGroupOperStatus=vrptrGroupOperStatus, vrptrMonitorPortInfo=vrptrMonitorPortInfo, vrptrInfoId=vrptrInfoId, vrptrInfoLastChange=vrptrInfoLastChange, vrptrMonitorAllRptrInfo=vrptrMonitorAllRptrInfo, vrptrAllRptrInfo=vrptrAllRptrInfo, vrptrGroupPortCapacity=vrptrGroupPortCapacity, vrptrMonitorPortFrameTooLongs=vrptrMonitorPortFrameTooLongs, vrptrMonitorPortShortEvents=vrptrMonitorPortShortEvents, vrptrGroupLedStatus=vrptrGroupLedStatus, vrptrMonitorPortUpper32SentOctets=vrptrMonitorPortUpper32SentOctets, vrptrInfoPartitionedPorts=vrptrInfoPartitionedPorts, vrptrMonTotalErrors=vrptrMonTotalErrors, vrptrPortAdminStatus=vrptrPortAdminStatus, vrptrPortRptrId=vrptrPortRptrId, vrptrInfoTable=vrptrInfoTable, vrptrMonitorPortVeryLongEvents=vrptrMonitorPortVeryLongEvents, vrptrBasicPackage=vrptrBasicPackage, vrptrGroupObjectID=vrptrGroupObjectID, vsnmpDot3RptrMgt=vsnmpDot3RptrMgt, vrptrPortLinkState=vrptrPortLinkState, vrptrPortIndex=vrptrPortIndex, vrptrGroupBroadcastDomainNumber=vrptrGroupBroadcastDomainNumber, vrptrMonitor100PortEntry=vrptrMonitor100PortEntry, vrptrPortDuplexSelect=vrptrPortDuplexSelect, vrptrMonTotalFrames=vrptrMonTotalFrames, vrptrMonUpper32TotalOctets=vrptrMonUpper32TotalOctets, vrptrMonitorPortDroppedFrames=vrptrMonitorPortDroppedFrames, vrptrGroupSlotNumber=vrptrGroupSlotNumber, vrptrPortPolarity=vrptrPortPolarity, vrptrMonitorPortFCSErrors=vrptrMonitorPortFCSErrors, vrptrMon100Entry=vrptrMon100Entry, vrptrMonitorPortAlignmentErrors=vrptrMonitorPortAlignmentErrors, vrptrPortSpeedSelect=vrptrPortSpeedSelect, vrptrPortInfo=vrptrPortInfo, vrptrPortOperStatus=vrptrPortOperStatus, vrptrMonitorPortSymbolErrors=vrptrMonitorPortSymbolErrors, vrptrMonitorPortReadableOctets=vrptrMonitorPortReadableOctets, vrptrMonitorPortRunts=vrptrMonitorPortRunts, vrptrGroupInfo=vrptrGroupInfo, vrptrPortEntry=vrptrPortEntry, vrptrMonitorPortReadableFrames=vrptrMonitorPortReadableFrames, vrptrMonitorPortLastChange=vrptrMonitorPortLastChange, vrptrPortDuplex=vrptrPortDuplex, vrptrMonitorPortTotalErrors=vrptrMonitorPortTotalErrors, vrptrMonitorPortIsolates=vrptrMonitorPortIsolates, vrptrGroupIndex=vrptrGroupIndex, vrptrMonTable=vrptrMonTable, vrptrMonitorPortGroupIndex=vrptrMonitorPortGroupIndex, vrptrGroupEntry=vrptrGroupEntry, MacAddress=MacAddress, vrptrMonitorPackage=vrptrMonitorPackage, vrptrMonitorPortTable=vrptrMonitorPortTable, vrptrPortSpeed=vrptrPortSpeed, vrptrMon100Table=vrptrMon100Table, vrptrMonitorPortSentFrames=vrptrMonitorPortSentFrames, vrptrGroupNetworkAdapterNumber=vrptrGroupNetworkAdapterNumber, vrptrMonitorPortSentOctets=vrptrMonitorPortSentOctets, vrptrGroupTable=vrptrGroupTable, vrptrInfoEntry=vrptrInfoEntry, vrptrMonitorPortUpper32Octets=vrptrMonitorPortUpper32Octets, vrptrInfoReset=vrptrInfoReset, vrptrInfoOperStatus=vrptrInfoOperStatus, vrptrMonitorPortIndex=vrptrMonitorPortIndex, vrptrMonTotalOctets=vrptrMonTotalOctets, vrptrMonitor100PortTable=vrptrMonitor100PortTable, vrptrMonitorPortAutoPartitions=vrptrMonitorPortAutoPartitions, vrptrMonitorPortCollisions=vrptrMonitorPortCollisions, vrptrPortGroupIndex=vrptrPortGroupIndex, vrptrMonEntry=vrptrMonEntry)

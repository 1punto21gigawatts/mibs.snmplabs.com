#
# PySNMP MIB module DEC-LECS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DEC-LECS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:37:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
decMIBextension, = mibBuilder.importSymbols("DECATM-MIB", "decMIBextension")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, ObjectIdentity, Gauge32, Unsigned32, NotificationType, IpAddress, TimeTicks, MibIdentifier, iso, Counter32, Bits, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "ObjectIdentity", "Gauge32", "Unsigned32", "NotificationType", "IpAddress", "TimeTicks", "MibIdentifier", "iso", "Counter32", "Bits", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
decLecsMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31))
decElanAdminGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1))
decElanConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2))
decElanLecsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3))
decElanLecsConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1))
decElanLecsFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2))
decElanLecsStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3))
decElanAdminPolicyVal = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1))
assignByAtmAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1, 1))
assignByMacAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1, 2))
assignByRouteDescriptor = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1, 3))
assignByElanName = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1, 4))
assignByCompatibility = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 1, 1, 5))
decLecsMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4))
decLecsMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1))
decLecsMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 2))
decElanConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfNextId.setDescription('The next available ELAN index provided by the agent. The value of this object can be used as the index to the decElanConfTable during row creation.')
decElanConfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2), )
if mibBuilder.loadTexts: decElanConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfTable.setDescription('This table describes all of the Emulated LANs (ELANs) that this agent manages. An emulated LAN is defined by the ELAN name, a set of TLVs, and other parameters. After an ELAN is created, members of the ELAN such as a LAN Emulation Server (LES) or Client (LEC) can be added to the ELAN, using their respective tables.')
decElanConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanConfIndex"))
if mibBuilder.loadTexts: decElanConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfEntry.setDescription('Each entry in this table represents an Emulated LAN. Objects elanConfIndex and elanConfRowStatus are required during row creation and deletion.')
decElanConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfIndex.setDescription('A value which uniquely identifies a conceptual row in the decElanConfTable. If the conceptual row identified by this value of decElanConfIndex is recreated following an agent restart, the same value of elanConfIndex must be used to identify the recreated row.')
decElanConfName = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfName.setReference('LAN Emulation Over ATM Specification - version 1.0. C5.')
if mibBuilder.loadTexts: decElanConfName.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfName.setDescription("The name of this Emulated LAN entry. When this object's length is zero, the ELAN name is not specified, and clients that are assigned to the ELAN will also have zero-length strings for their ELAN names.")
decElanConfTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfTlvIndex.setDescription('The value of this object identifies the rows in the decLecsTlvTable which apply to this ELAN.')
decElanConfLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("s8023", 2), ("s8025", 3))).clone('other')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfLanType.setReference('LAN Emulation Over ATM Specification - version 1.0. S2.')
if mibBuilder.loadTexts: decElanConfLanType.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfLanType.setDescription('The LAN type of this ELAN entry.')
decElanConfMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("max1516", 2), ("max4544", 3), ("max9234", 4), ("max18190", 5))).clone('unspecified')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfMaxFrameSize.setReference('LAN Emulation Over ATM Specification - version 1.0. S3.')
if mibBuilder.loadTexts: decElanConfMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfMaxFrameSize.setDescription('The maximum data frame size of this ELAN entry.')
decElanConfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfAdminStatus.setDescription("This object is used to enable and disable ELANs. When an ELAN is 'disabled(2)', the LECS will not tell clients about the ELAN. Note that this object has no effect on the operation of the LES and the BUS -- or the behavior of manually-configured clients.")
decElanConfDefaultElan = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfDefaultElan.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfDefaultElan.setDescription("This object is used to choose which ELANs are considered to be default ELANs for the purposes of 'assignByCompatibility' policy matching. Clients are matched against default ELANs on the basis of LAN Type and Maximum Data Frame Size.")
decElanConfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanConfRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanConfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanConfRowStatus.setDescription('This object is used to create or delete entries in the decElanConfTable.')
decElanLesTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 3), )
if mibBuilder.loadTexts: decElanLesTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLesTable.setDescription('This table describes the LESes for the ELANs specified in the decElanConfTable. Each ELAN can have more than one LES providing LAN Emulation services. Each LES can only service one ELAN. The table is indexed by decElanConfIndex, which points to the ELAN that this LES is providing service to, and decElanLesIndex, which uniquely identifies a LES. This table is only used for configuration of ELANs; that is, to say, creating a LES in this table does not instantiate a LES in the network. (That is done in the LES MIB.)')
decElanLesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 3, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanConfIndex"), (0, "DEC-LECS-MIB", "decElanLesIndex"))
if mibBuilder.loadTexts: decElanLesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLesEntry.setDescription('Each entry in this table represents a LES/Emulated LAN pair. Objects decElanLesAtmAddress and decElanLesRowStatus are required during row creation.')
decElanLesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLesIndex.setDescription('An arbitrary number which uniquely identifies the LES this entry pertains to.')
decElanLesAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanLesAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLesAtmAddress.setDescription('The ATM address of the LES entry. If a LECS is supported, the value of this object is the LES ATM address that the LECS returns to a LEC in the CONFIGURE response. If a LECS is not supported, this is more or less a place where the manager can note which LES ATM address must be manually provided to each LEC.')
decElanLesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanLesRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanLesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLesRowStatus.setDescription('This object is used to create or delete entries in this table.')
decElanPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4), )
if mibBuilder.loadTexts: decElanPolicyTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyTable.setDescription('This table describes all of the policies which the system uses for assigning LECs to ELANs. When a LECS receives a Configure request, it checks the policies in this table to determine which ELAN and LES the LEC will join. Policies with the highest priority (i.e., the smallest decElanPolicyPriority) are evaluated first. Policies which have the same priority are evaluated at the same time with the AND operation. This table is indexed by a selector index and a policy index. The policy index uniquely identifies a policy, while the selector index allows different LECSes to use different sets of policies.')
decElanPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanPolicySelectorIndex"), (0, "DEC-LECS-MIB", "decElanPolicyIndex"))
if mibBuilder.loadTexts: decElanPolicyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyEntry.setDescription('Each entry in this table represents a policy supported by the entity which provides LAN Emulation configuration services. Each policy can be used to evaluate the CONFIGURE request from the LEC in determining which ELAN it belongs to.')
decElanPolicySelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanPolicySelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicySelectorIndex.setDescription('The value of this object indicates a group of policies that can be selected by an ELAN configuration service provider (such as the LECS).')
decElanPolicyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanPolicyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyIndex.setDescription('The value of this object uniquely identifies a single policy entry in this table. ')
decElanPolicyPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanPolicyPriority.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyPriority.setDescription('The priority of this policy entry. Policies are evaluated by the entity which provides ELAN configuration service (i.e., LECS) in order of their priorities. Policies with the same priority values should be evaluated at the same time with an AND operation. That is, to say, if one of the policies with the same priority is not met, the evaluation should fail. The value 1 has the highest priority.')
decElanPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1, 4), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanPolicyType.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyType.setDescription('The type of this policy.')
decElanPolicyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanPolicyRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanPolicyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanPolicyRowStatus.setDescription('This object is used to create or delete entries in the decElanPolicyTable.')
decElanLecAtmAddrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 5), )
if mibBuilder.loadTexts: decElanLecAtmAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecAtmAddrTable.setDescription("This table is used to assign a LEC to an ELAN by ATM address. When the 'assign by ATM address' policy is used, this table is used to specify the LEC's ATM address or portion of an ATM address. The ATM address is used by the LECS or other entity which serves the LANE configuration function to determine the ELAN membership. This table is indexed by the decElanConfIndex which points to the ELAN this LEC belongs, the decElanLesIndex which points to the LES this LEC should join, the LEC's ATM address and an ATM address mask. Portions of an ATM address can be used in determining ELAN membership by using both the ATM address and the mask.")
decElanLecAtmAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 5, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanConfIndex"), (0, "DEC-LECS-MIB", "decElanLesIndex"), (0, "DEC-LECS-MIB", "decElanLecAtmAddress"), (0, "DEC-LECS-MIB", "decElanLecAtmMask"))
if mibBuilder.loadTexts: decElanLecAtmAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecAtmAddrEntry.setDescription('Each entry represents a LEC to ELAN binding.')
decElanLecAtmAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 5, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLecAtmAddress.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecAtmAddress.setDescription('The value of this object is the ATM address of a LAN Emulation client. This object and the object decElanLecAtmMask are used to form an ATM address or portion of an ATM address to be used by the LECS in determining the ELAN membership when the policy of this LECS is by ATM address.')
decElanLecAtmMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLecAtmMask.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecAtmMask.setDescription("The ATM address mask associated with the object decElanLecAtmAddress. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
decElanLecAtmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanLecAtmRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanLecAtmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecAtmRowStatus.setDescription('This object is used to create or delete entries in this table.')
decElanLecMacAddrTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 6), )
if mibBuilder.loadTexts: decElanLecMacAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecMacAddrTable.setDescription("This table is used to assign a LEC to an ELAN by MAC address. When the 'assign by MAC address' policy is used, this table is used to specify the LEC's ELAN membership by MAC address. This table is indexed by the decElanConfIndex which points to the ELAN this LEC belongs, the decElanLesIndex which points to the LES this LEC should join, and the LEC's MAC address.")
decElanLecMacAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 6, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanConfIndex"), (0, "DEC-LECS-MIB", "decElanLesIndex"), (0, "DEC-LECS-MIB", "decElanLecMacAddress"))
if mibBuilder.loadTexts: decElanLecMacAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecMacAddrEntry.setDescription('Each entry represents a LEC to ELAN binding. Object elanLecMacRowStatus is required during row creation or deletion.')
decElanLecMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 6, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLecMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecMacAddress.setDescription('The value of this object is the MAC address of a LAN Emulation client. When a CONFIGURE request is received with this ATM address, it will be assigned to the ELAN which elanConfIndex is pointing to.')
decElanLecMacRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanLecMacRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanLecMacRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecMacRowStatus.setDescription('This object is used to create or delete entries in this table.')
decElanLecRdTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 7), )
if mibBuilder.loadTexts: decElanLecRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecRdTable.setDescription("This table is used to assign a LEC to an ELAN by Route Descriptor. When the 'by Route Descriptor' policy is used, this table is used to specify the LEC's ELAN membership by Route Descriptor. This table is indexed by the decElanConfIndex which points to the ELAN this LEC belongs, the decElanLesIndex which points to the LES this LEC should join, and the LEC's Route Descriptors.")
decElanLecRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 7, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decElanConfIndex"), (0, "DEC-LECS-MIB", "decElanLesIndex"), (0, "DEC-LECS-MIB", "decElanLecRdSegId"), (0, "DEC-LECS-MIB", "decElanLecRdBridgeNum"))
if mibBuilder.loadTexts: decElanLecRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecRdEntry.setDescription('Each entry represents a LEC to ELAN binding.')
decElanLecRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLecRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecRdSegId.setDescription('The LAN ID portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
decElanLecRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decElanLecRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecRdBridgeNum.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this conceptual row.')
decElanLecRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 2, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decElanLecRdRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decElanLecRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decElanLecRdRowStatus.setDescription('This object is used to create or destroy entries in this table.')
decLecsConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsConfNextId.setDescription('The next available LECS index. The value of this object can be used as the index to the decLecsConfTable during creation.')
decLecsConfTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2), )
if mibBuilder.loadTexts: decLecsConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsConfTable.setDescription('This table contains the configuration information of all the LECSes this agent manages. This table can also be used to create, delete or configure a LECS.')
decLecsConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decLecsConfIndex"))
if mibBuilder.loadTexts: decLecsConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsConfEntry.setDescription('Each entry represents a LECS this agent maintains. Objects decLecsAtmIfIndex, decLecsAtmAddrSpec, and decLecsAtmAddrMask cannot be modified unless the decLecsAdminStatus is set to down(2). Changes to this object do not take effect until the decLecsAdminStatus is set to up(1).')
decLecsConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsConfIndex.setDescription('An arbitrary integer which represents a LECS this agent manages. If the conceptual row identified by this value of decLecsConfIndex is recreated following an agent restart, the same value of decLecsConfIndex must be used to identify the recreated row.')
decLecsAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 2), Integer32().clone(0)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsAtmIfIndex.setDescription('The ATM interface on which the LECS receives CONFIGURE requests. This value must match an existing value in the ifTable. This object is set to zero when the ATM interface is not specified or the LECS uses more than one ATM interface.')
decLecsAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20)).clone(hexValue="4700790000000000000000000000A03E00000100")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsAtmAddrSpec.setDescription('An ATM address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the LECS on the designated ATM interface will use to derive the actual ATM address from the network or ILMI. The derived ATM address is specified in the object decLecsAtmAddrActual, which is used to receive CONFIGURE requests. The value of this object, if not specified, is defaulted to the well-known LECS ATM address specified in the LAN Emulation Spec. 1.0.')
decLecsAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20).clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsAtmAddrMask.setDescription("The ATM address mask associated with the object decLecsAtmAddrSpec. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
decLecsAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsAtmAddrActual.setDescription("The resulting ATM address at which the LECS is accepting CONFIGURE requests on the interface indicated by the object decLecsAtmIfIndex. This address is the result of the specified ATM address, its mask and interaction through the ILMI with the switch. Note that this object is only valid when the corresponding decLecsOperStatus is 'up'.")
decLecsPolicySelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsPolicySelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsPolicySelIndex.setDescription('The set of policies used by this LECS in determining requesters ELAN membership. The policies are defined in the decElanPolicyTable. The value of this object must exist in the decElanPolicyTable.')
decLecsLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsLastInitialized.setDescription('The time (in hundredths of a second) since the LECS was last re-initialized.')
decLecsOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsOperStatus.setDescription(" This object reflects the actual state of the LECS which may differ from that of the decLecsAdminStatus object. This can occur when the interface ifOperStatus is 'down' but the corresponding decLecsAdminStatus is 'up'.")
decLecsAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsAdminStatus.setDescription('The desired state of the LECS on this interface as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the decLecsOperStatus.')
decLecsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsRowStatus.setReference('RFC 1443, Textual Conventions for Version 2 of the Simple Network Management Protocol.')
if mibBuilder.loadTexts: decLecsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsRowStatus.setDescription('This object is used to create or delete entries in this table.')
decLecsTlvTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4), )
if mibBuilder.loadTexts: decLecsTlvTable.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvTable.setDescription('This table contains all TLVs this agent supports. This includes not only the standard TLVs specified in the LAN Emulation Spec. 1.0 but also the additional parameters exchanged between the LECS and LEC. This table is indexed by a selector index, which allows more than one TLV to be selected by an ELAN; and the TLV tag, which specifies the type of the TLV; and a TLV index which is used to distinguish between different entries with the same TLV tag.')
decLecsTlvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decLecsTlvSelectorIndex"), (0, "DEC-LECS-MIB", "decLecsTlvTag"), (0, "DEC-LECS-MIB", "decLecsTlvIndex"))
if mibBuilder.loadTexts: decLecsTlvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvEntry.setDescription("Each entry represents a TLV encoding for use with those ELANs whose 'decElanConfTlvIndex' equals the 'decLecsTlvSelectorIndex'. Objects decLecsTlvVal and decLecsTlvRowStatus are required during row creation.")
decLecsTlvSelectorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsTlvSelectorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvSelectorIndex.setDescription('The value of this object indicates a group of TLVs that can be selected.')
decLecsTlvTag = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsTlvTag.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvTag.setDescription('The value of this object represents the type of the contents of the decLecsTlvVal field in the entry. The OUI field in this object occupies the first ( or most significant )3 octets. The OUI value 00-A0-3E is used for the standard values defined by the ATM Forum specification.')
decLecsTlvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsTlvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvIndex.setDescription('The index of this TLV encoding entry. The value of this object can be used to distinguish between different entries with the same decLecsTlvTag value.')
decLecsTlvVal = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsTlvVal.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvVal.setDescription('The value of this TLV entry.')
decLecsTlvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsTlvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsTlvRowStatus.setDescription('This object is used to create or destroy entries in this table')
decLecsStatsTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1), )
if mibBuilder.loadTexts: decLecsStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatsTable.setDescription(' A (conceptual) table of statistics associated with all LECS instances on the device.')
decLecsStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decLecsConfIndex"))
if mibBuilder.loadTexts: decLecsStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatsEntry.setDescription(' A (conceptual) row in the decLecsStatsTable which corresponds to the statistics kept by a particular instance of a LES.')
decLecsStatSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatSuccessful.setDescription('The number of CONFIGURE requests successfully granted since the agent was last initialized.')
decLecsStatInBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInBadFrames.setDescription('The number of malformed CONFIGURE requests dropped by the LECS.')
decLecsStatInvalidParam = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInvalidParam.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInvalidParam.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInvalidParam.setDescription('The number of CONFIGURE requests rejected due to the invalid request parameters error.')
decLecsStatInsufRes = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInsufRes.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInsufRes.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInsufRes.setDescription('The number of CONFIGURE requests rejected due to the insufficent resources to grant request error.')
decLecsStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatAccDenied.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatAccDenied.setDescription('The number of CONFIGURE requests rejected due to the access denied error.')
decLecsStatInvalidReq = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInvalidReq.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInvalidReq.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInvalidReq.setDescription('The number of CONFIGURE requests rejected due to the invalid requester-id error.')
decLecsStatInvalidDest = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInvalidDest.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInvalidDest.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInvalidDest.setDescription('The number of CONFIGURE requests rejected due to the invalid destination error.')
decLecsStatInvalidAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInvalidAddr.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInvalidAddr.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInvalidAddr.setDescription('The number of CONFIGURE requests rejected due to the invalid ATM address error.')
decLecsStatNoConf = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatNoConf.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatNoConf.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatNoConf.setDescription('The number of CONFIGURE requests rejected due to the LE Client is not recognized error.')
decLecsStatConfError = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatConfError.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatConfError.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatConfError.setDescription('The number of CONFIGURE requests rejected due to the LE_CONFIGURE error.')
decLecsStatInsufInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsStatInsufInfo.setReference('LAN Emulation Over ATM Spec. v1.0. Table 13')
if mibBuilder.loadTexts: decLecsStatInsufInfo.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsStatInsufInfo.setDescription('The number of CONFIGURE requests rejected due to the insufficient information error.')
decLecsErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1), )
if mibBuilder.loadTexts: decLecsErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlTable.setDescription('This table contains error log control information of all LECS instances. This table is an extension to the lecsConfTable. It is used to enable or disable error logs for a particular LECS entry.')
decLecsErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decLecsConfIndex"))
if mibBuilder.loadTexts: decLecsErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlEntry.setDescription('Each entry represents a LECS entry in the decLecsConfTable.')
decLecsErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlAdminStatus.setDescription('This object is used to enable/disable error logging for the LECS.')
decLecsErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlOperStatus.setDescription('This object is used to indicate the result of a set operation to the object decLecsErrCtlAdminStatus. If the error log was successfully started, it is in active(2) mode. Otherwise, it is set to either outOfRes(3) or failed(4) for the respective reasons.')
decLecsErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlClearLog.setDescription('This object is used to clear the error log entries associated with this LECS.')
decLecsErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlMaxEntries.setDescription('The maximum entries of the error log a LECS can support.')
decLecsErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: decLecsErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrCtlLastEntry.setDescription('The index to the last entry in the error log table associated with this LECS.')
decLecsErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2), )
if mibBuilder.loadTexts: decLecsErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogTable.setDescription('This table contains error logs of the LECS instances enabled in the decLecsErrCtlTable. This table is indexed by the LECS instance index and an arbitrary integer which uniquely identifies an error log.')
decLecsErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2, 1), ).setIndexNames((0, "DEC-LECS-MIB", "decLecsConfIndex"), (0, "DEC-LECS-MIB", "decLecsErrLogIndex"))
if mibBuilder.loadTexts: decLecsErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogEntry.setDescription('Each entry represents a LEC that was rejected due to a violation against the policies or an error.')
decLecsErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogIndex.setDescription('An arbitrary integer which uniquely identifies an error log entry. This number ranges from 1 to the value of the object decLecsErrCtlMaxEntries times number of LECS error log capability enabled. The enabling/disabling of the error log capability is done in the decLecsErrCtlTable.')
decLecsErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogAtmAddr.setDescription('The ATM address of the requester which sends the CONFIGURE request and causes the error to occur. The corresponding error code is specified in the object decLecsErrLogErrCode.')
decLecsErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogErrCode.setDescription('The Error code which indicates the cause of the error triggered by the CONFIGURE request sent by the requester indicated by the value of the object decLecsErrLogAtmAddr.')
decLecsErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 3, 2, 2, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: decLecsErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: decLecsErrLogTime.setDescription('The sysUpTime when this entry was logged by the LECS.')
decElanCConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 1))
decElanLecAssignByAtmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 2))
decElanLecAssignByMacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 3))
decElanLecAssignByRdGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 4))
decLecsCStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 5))
decLecsCGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 6))
decLecsCFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 1, 7))
decLecsMIBCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 36, 2, 18, 31, 4, 2, 1))
mibBuilder.exportSymbols("DEC-LECS-MIB", decLecsConfIndex=decLecsConfIndex, decLecsMIB=decLecsMIB, assignByRouteDescriptor=assignByRouteDescriptor, decElanLecRdRowStatus=decElanLecRdRowStatus, decElanConfRowStatus=decElanConfRowStatus, decLecsErrCtlClearLog=decLecsErrCtlClearLog, assignByCompatibility=assignByCompatibility, decElanPolicySelectorIndex=decElanPolicySelectorIndex, decLecsAtmAddrMask=decLecsAtmAddrMask, decLecsCFaultGroup=decLecsCFaultGroup, decElanConfNextId=decElanConfNextId, decElanLecAtmAddrTable=decElanLecAtmAddrTable, decLecsStatsTable=decLecsStatsTable, decElanLesIndex=decElanLesIndex, decElanLecAtmAddrEntry=decElanLecAtmAddrEntry, decLecsMIBCompliances=decLecsMIBCompliances, decElanLecsStatGroup=decElanLecsStatGroup, decElanLecRdBridgeNum=decElanLecRdBridgeNum, decElanPolicyRowStatus=decElanPolicyRowStatus, decLecsStatInsufInfo=decLecsStatInsufInfo, decLecsTlvVal=decLecsTlvVal, decElanConfEntry=decElanConfEntry, decLecsOperStatus=decLecsOperStatus, decElanConfMaxFrameSize=decElanConfMaxFrameSize, decElanLecAtmMask=decElanLecAtmMask, decLecsMIBCompliance=decLecsMIBCompliance, decElanPolicyPriority=decElanPolicyPriority, decElanLecMacAddress=decElanLecMacAddress, decElanConfName=decElanConfName, decElanLecsFaultGroup=decElanLecsFaultGroup, decLecsTlvEntry=decLecsTlvEntry, decElanLecRdSegId=decElanLecRdSegId, decLecsErrCtlMaxEntries=decLecsErrCtlMaxEntries, decElanPolicyType=decElanPolicyType, assignByMacAddr=assignByMacAddr, decElanLecAtmRowStatus=decElanLecAtmRowStatus, decElanLesTable=decElanLesTable, decElanAdminPolicyVal=decElanAdminPolicyVal, decLecsAtmAddrActual=decLecsAtmAddrActual, decElanLecMacAddrTable=decElanLecMacAddrTable, decLecsConfTable=decLecsConfTable, decLecsMIBGroups=decLecsMIBGroups, decElanLecsConfGroup=decElanLecsConfGroup, decElanConfDefaultElan=decElanConfDefaultElan, decElanLecRdEntry=decElanLecRdEntry, decLecsStatsEntry=decLecsStatsEntry, decElanPolicyIndex=decElanPolicyIndex, decLecsErrCtlTable=decLecsErrCtlTable, decLecsErrCtlAdminStatus=decLecsErrCtlAdminStatus, assignByAtmAddr=assignByAtmAddr, decElanPolicyTable=decElanPolicyTable, decLecsCStatGroup=decLecsCStatGroup, assignByElanName=assignByElanName, decLecsErrLogErrCode=decLecsErrLogErrCode, decElanConfIndex=decElanConfIndex, decElanLecAtmAddress=decElanLecAtmAddress, decLecsAdminStatus=decLecsAdminStatus, decLecsErrCtlOperStatus=decLecsErrCtlOperStatus, decLecsStatInvalidReq=decLecsStatInvalidReq, decLecsLastInitialized=decLecsLastInitialized, decLecsStatInBadFrames=decLecsStatInBadFrames, decElanCConfGroup=decElanCConfGroup, decLecsStatInvalidAddr=decLecsStatInvalidAddr, decLecsTlvIndex=decLecsTlvIndex, decLecsStatConfError=decLecsStatConfError, decLecsStatSuccessful=decLecsStatSuccessful, decLecsStatInvalidDest=decLecsStatInvalidDest, decLecsTlvTag=decLecsTlvTag, decLecsErrCtlEntry=decLecsErrCtlEntry, decElanLecMacRowStatus=decElanLecMacRowStatus, decLecsStatAccDenied=decLecsStatAccDenied, decLecsMIBConformance=decLecsMIBConformance, decLecsStatInsufRes=decLecsStatInsufRes, decLecsAtmAddrSpec=decLecsAtmAddrSpec, decLecsErrCtlLastEntry=decLecsErrCtlLastEntry, decElanPolicyEntry=decElanPolicyEntry, decLecsAtmIfIndex=decLecsAtmIfIndex, decLecsConfNextId=decLecsConfNextId, decElanConfGroup=decElanConfGroup, decLecsStatNoConf=decLecsStatNoConf, decLecsErrLogIndex=decLecsErrLogIndex, decLecsCGroup=decLecsCGroup, decElanConfAdminStatus=decElanConfAdminStatus, decElanLecsGroup=decElanLecsGroup, decLecsErrLogTable=decLecsErrLogTable, decElanAdminGroup=decElanAdminGroup, decLecsErrLogAtmAddr=decLecsErrLogAtmAddr, decElanLesAtmAddress=decElanLesAtmAddress, decLecsConfEntry=decLecsConfEntry, decLecsTlvRowStatus=decLecsTlvRowStatus, decElanConfLanType=decElanConfLanType, decElanLecAssignByAtmGroup=decElanLecAssignByAtmGroup, decLecsTlvSelectorIndex=decLecsTlvSelectorIndex, decLecsRowStatus=decLecsRowStatus, decLecsPolicySelIndex=decLecsPolicySelIndex, decLecsErrLogEntry=decLecsErrLogEntry, decLecsErrLogTime=decLecsErrLogTime, decElanConfTable=decElanConfTable, decElanLecRdTable=decElanLecRdTable, decLecsStatInvalidParam=decLecsStatInvalidParam, decElanLesEntry=decElanLesEntry, decElanConfTlvIndex=decElanConfTlvIndex, decElanLecMacAddrEntry=decElanLecMacAddrEntry, decElanLesRowStatus=decElanLesRowStatus, decElanLecAssignByMacGroup=decElanLecAssignByMacGroup, decElanLecAssignByRdGroup=decElanLecAssignByRdGroup, decLecsTlvTable=decLecsTlvTable)

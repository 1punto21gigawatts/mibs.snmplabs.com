#
# PySNMP MIB module INXNMM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INXNMM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:55:27 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, MibIdentifier, NotificationType, Counter32, iso, Counter64, ModuleIdentity, Gauge32, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "MibIdentifier", "NotificationType", "Counter32", "iso", "Counter64", "ModuleIdentity", "Gauge32", "TimeTicks", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
internet = MibIdentifier((1, 3, 6, 1))
experimental = MibIdentifier((1, 3, 6, 1, 3))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
interlan = MibIdentifier((1, 3, 6, 1, 4, 1, 28))
dot3 = MibIdentifier((1, 3, 6, 1, 3, 3))
riTelnet = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 3))
riBoot = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 16))
riThresh = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 17))
riSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 18))
riTsRates = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 22))
riLdcNmm = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 10))
riPort = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 13))
riHotFail = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 10, 14))
riProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1))
riProdLdc = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1, 3))
riPLdcNMM = MibIdentifier((1, 3, 6, 1, 4, 1, 28, 1, 3, 1))
dot3Table = MibTable((1, 3, 6, 1, 3, 3, 1), )
if mibBuilder.loadTexts: dot3Table.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Table.setDescription("A list of the INX-NMM Ethernet interface's operational attributes, such as whether it is configured for multicast receive and the status of the MAC sublayer . You cannot access this variable; it is only a table marker in the MIB.")
dot3Entry = MibTableRow((1, 3, 6, 1, 3, 3, 1, 1), ).setIndexNames((0, "INXNMM-MIB", "dot3Index"))
if mibBuilder.loadTexts: dot3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Entry.setDescription('An entry in the INX-NMM Interface table. (See the previous variable, INX-NMM Interface Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Table Index MAC Initialization Status MAC Operational Status Multicast Receive Status Nonaligned Frames Recd FCS Errored Frames Received')
dot3Index = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3Index.setStatus('mandatory')
if mibBuilder.loadTexts: dot3Index.setDescription('The value assigned to the INX-NMM Ethernet interface. Because the INX-NMM has only one interface, this variable always returns 1.')
dot3InitializeMAC = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("initialize", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3InitializeMAC.setStatus('mandatory')
if mibBuilder.loadTexts: dot3InitializeMAC.setDescription('The initialization status of the MAC and PLS subsystems of the interface. Because the MAC and PLS subsystems on the INX-NMM are initialized at power-up and remain so, this variable always returns initialized(1).')
dot3MACSubLayerStatus = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("enabled", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3MACSubLayerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot3MACSubLayerStatus.setDescription('The operational status of the MAC sublayer, i.e., whether it is ready to transmit and receive frames. Because this sublayer is always active in the INX-NMM, this variable always returns enabled(1).')
dot3MulticastReceiveEnabled = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3MulticastReceiveEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: dot3MulticastReceiveEnabled.setDescription('The Multicast Receive status, i.e., whether the INX-NMM is configured to receive frames with a multicast address. Because Multicast Receive is always enabled on the INX-NMM, this variable always returns true(1).')
dot3AlignmentErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3AlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3AlignmentErrors.setDescription('The number of frames received on the interface that are not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight) and do not pass the FCS check. This condition indicates that the frames were corrupted during transmission.')
dot3FCSErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3FCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3FCSErrors.setDescription('The number of frames received on the interface that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) that do not pass the FCS check, indicating that the frames were corrupted during transmission.')
dot3TxTable = MibTable((1, 3, 6, 1, 3, 3, 2), )
if mibBuilder.loadTexts: dot3TxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxTable.setDescription('A list of transmit errors and statistics for the INX-NMM Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3TxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 2, 1), ).setIndexNames((0, "INXNMM-MIB", "dot3TxIndex"))
if mibBuilder.loadTexts: dot3TxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxEntry.setDescription('An entry in the Interface Transmit table. (See the previous variable, Interface Transmit Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Transmit Index Single Collisions Transmitted Multiple Collisions Xmitted Total SQE Test Errors')
dot3TxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxIndex.setDescription('The value assigned to the INX-NMM Ethernet interface. Because the INX-NMM has only one interface, this variable always returns 1.')
dot3TxSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxSingleCollisionFrames.setDescription('The number of frames that were successfully transmitted after experiencing one and only one collision.')
dot3TxMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxMultipleCollisionFrames.setDescription('The number of frames that were successfully transmitted after experiencing more than one collision.')
dot3TxSQETestErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3TxSQETestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3TxSQETestErrors.setDescription("The number of times that the SQE TEST ERROR message has been generated by this interface's PLS sublayer. The PLS sublayer generates an SQE test error message when the Signal-Quality-Error test fails. The Signal-Quality-Error test verifies good data transmission. The INX-NMM does not generate SQE test error messages, so this variable always returns 0.")
dot3XRxTable = MibTable((1, 3, 6, 1, 3, 3, 3), )
if mibBuilder.loadTexts: dot3XRxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxTable.setDescription('A list of receive errors and statistics for the INX-NMM Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3XRxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 3, 1), ).setIndexNames((0, "INXNMM-MIB", "dot3XRxIndex"))
if mibBuilder.loadTexts: dot3XRxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxEntry.setDescription('An entry in the Interface Receive table. (See the previous variable, Interface Receive Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Receive Index Too Long Frames Recd In-Range Length Errors Recd Out-Range Length Errors Recd MAC Errors Received Autopartition Status Autopartition Disconnects Last Good Source Address Recd Source Address Changes Count')
dot3XRxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxIndex.setDescription('The value assigned to the INX-NMM Ethernet interface. Because the INX-NMM has only one interface, this variable always returns 1.')
dot3XRxFrameTooLongs = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxFrameTooLongs.setDescription('The number of frames received on the interface that exceed the maximum permitted frame size, i.e., 1012 octets.')
dot3XRxInRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxInRangeLengthErrors.setDescription('The number of in-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error. The INX-NMM receives Ethernet frames that do not have a length in the length field. It therefore cannot detect this error, and this variable always returns 0.')
dot3XRxOutOfRangeLengthFields = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxOutOfRangeLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxOutOfRangeLengthFields.setDescription('The number of out-of-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside 802.3 parameters, the receiving device returns an out-of-range error. The INX-NMM receives Ethernet frames that do not have a length in the length field. It therefore cannot detect this error, and this variable always returns 0.')
dot3XRxInternalMACReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxInternalMACReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxInternalMACReceiveErrors.setDescription('The number of frames the interface could not receive because of an internal MAC sublayer receive error. This variable returns frames not counted by the Too Long Frames Received, Nonaligned Frames Received, FCS Errored Frames Received, In-Range Length Errors Recd, and Out-Range Length Errors Recd variables.')
dot3XRxAutoPartitionStatus = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3XRxAutoPartitionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxAutoPartitionStatus.setDescription('The autopartition status of the INX-NMM. Devices that support autopartitioning have the ability to autonomously disconnect from the network when they sense trouble, e.g., a device with a jabber condition. Because the INX-NMM interface does not support autopartitioning, this variable always returns 2, and may only be set to 2.')
dot3XRxAutoPartitionLog = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxAutoPartitionLog.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxAutoPartitionLog.setDescription('The number of autopartitions the INX-NMM has performed. Devices that support autopartitioning maintain a log of the number of times they disconnected from the network. Because the INX-NMM interface does not support auto-partitioning, this variable always returns 0.')
dot3XRxLastSourceAddress = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxLastSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxLastSourceAddress.setDescription('The source address of the last frame successfully received. Because this value changes too often to be useful, the INX-NMM interface does not record the last source address of received frames; therefore, this variable always returns a string of 0s.')
dot3XRxSourceAddressLog = MibTableColumn((1, 3, 6, 1, 3, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XRxSourceAddressLog.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XRxSourceAddressLog.setDescription('The number of times that the value of Last Good Source Address has changed. The INX-NMM interface does not log source address changes; therefore, this variable always returns 0.')
dot3XTxTable = MibTable((1, 3, 6, 1, 3, 3, 4), )
if mibBuilder.loadTexts: dot3XTxTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxTable.setDescription('A list of transmit errors and statistics for the INX-NMM Ethernet interface. You cannot access this variable; it is only a table marker in the MIB.')
dot3XTxEntry = MibTableRow((1, 3, 6, 1, 3, 3, 4, 1), ).setIndexNames((0, "INXNMM-MIB", "dot3XTxIndex"))
if mibBuilder.loadTexts: dot3XTxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxEntry.setDescription('An entry in the Interface Xmit Error/Stat table. (See the previous variable, Interface Xmit Error/Stat Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Interface Xmit Error/Stat Index Interface Transmit Status Transmissions Deferred Late Collisions Detected Excessive Collisions Detected MAC Transmit Errors Carrier Sense Errors Deferred Frames TDR Status')
dot3XTxIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxIndex.setDescription('The value assigned to the INX-NMM Ethernet interface. Because the INX-NMM has only one interface, this variable always returns 1.')
dot3XTxEnabled = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot3XTxEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxEnabled.setDescription('The transmit status of the interface, i.e., whether it is able to transmit frames. Because transmit is always enabled on the INX-NMM, this variable always returns true(1).')
dot3XTxDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxDeferredTransmissions.setDescription('The number of times the INX-NMM deferred transmission of data because it sensed traffic on the network. Because the INX-NMM does not record deferrals, this variable always returns 0.')
dot3XTxLateCollisions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxLateCollisions.setDescription('The number of times that a collision has been detected on this bus later than 512 bit times from frame start. This count is not maintained by the INX-NMM, so this variable always returns 0.')
dot3XTxExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxExcessiveCollisions.setDescription('The number of frames the interface could not transmit because of excessive collisions.')
dot3XTxInternalMACTransmitErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxInternalMACTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxInternalMACTransmitErrors.setDescription('The number of frames the interface could not transmit because of an internal MAC sublayer transmit error. This variable counts frames not counted by the Late Collisions Detected, Excessive Collisions Detected, Carrier Sense Errors, and Deferred Frames variables.')
dot3XTxCarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxCarrierSenseErrors.setDescription('The number of times that the carrier-sense condition was lost or never asserted when the INX-NMM attempted to transmit a frame on the interface. This count is incrememted at most once per transmission attempt, even if the carrier-sense condition fluctuates during the transmit attempt.')
dot3XTxExcessiveDeferrals = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxExcessiveDeferrals.setDescription('The number of frames the INX-NMM deferred transmitting for an excessive period of time. Because the INX-NMM interface does not record deferrals, this variable always returns 0.')
dot3XTxTDR = MibTableColumn((1, 3, 6, 1, 3, 3, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3XTxTDR.setStatus('mandatory')
if mibBuilder.loadTexts: dot3XTxTDR.setDescription('The status of Time Domain Reflectometry (TDR) on the INX-NMM. TDR is the ability of a device to check the viability of a cable by sending a signal to the end of the cable. The INX-NMM interface does not support Time Domain Reflectometry, so this variable always returns 0.')
dot3CollTable = MibTable((1, 3, 6, 1, 3, 3, 5), )
if mibBuilder.loadTexts: dot3CollTable.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollTable.setDescription('A histogram representing the frequency of collisions on the interface. In the Collision Frequency histogram, one dimension of each cell represents Collisions per Frame, and the other dimension represents Collision Frequency. You cannot access this variable; it is only a table marker in the MIB.')
dot3CollEntry = MibTableRow((1, 3, 6, 1, 3, 3, 5, 1), ).setIndexNames((0, "INXNMM-MIB", "dot3CollIndex"), (0, "INXNMM-MIB", "dot3CollCount"))
if mibBuilder.loadTexts: dot3CollEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollEntry.setDescription('An entry in the Collision Frequency table. (See the previous variable, Collision Frequency Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Collision Frequency Index Collisions per Frame Collision Frequency')
dot3CollIndex = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollIndex.setDescription('The value assigned to the INX-NMM Ethernet interface. Because the INX-NMM has only one interface, this variable always returns 1.')
dot3CollCount = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollCount.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollCount.setDescription('The number of media collisions per frame indicated by one cell in the collision histogram. The INX-NMM tracks the number of collisions up to 15.')
dot3CollFrequency = MibTableColumn((1, 3, 6, 1, 3, 3, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot3CollFrequency.setStatus('mandatory')
if mibBuilder.loadTexts: dot3CollFrequency.setDescription('The number of frames that were transmitted after experiencing exactly Collisions per Frame collisions on the INX-NMM Ethernet interface (see the previous variable).')
riNumBoots = MibScalar((1, 3, 6, 1, 4, 1, 28, 16, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riNumBoots.setStatus('mandatory')
if mibBuilder.loadTexts: riNumBoots.setDescription("The number of entries in the Boot table. There is one entry for the INX-NMM's operating software image file, and one entry for the Chassis Management Protocol (CMP) image file, so this variable always returns 2, and can only be set to 2.")
riBootServiceOffered = MibScalar((1, 3, 6, 1, 4, 1, 28, 16, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("false", 1), ("true", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootServiceOffered.setStatus('mandatory')
if mibBuilder.loadTexts: riBootServiceOffered.setDescription(' The setting of this variable determines whether this INX-NMM can provide boot operating system images to other INX-NMM, returning true(2) if it can and false(1) if it cannot.')
riBootTable = MibTable((1, 3, 6, 1, 4, 1, 28, 16, 3), )
if mibBuilder.loadTexts: riBootTable.setStatus('mandatory')
if mibBuilder.loadTexts: riBootTable.setDescription('The Boot table contains boot information. You cannot access this variable; it is only a table marker in the MIB.')
riBootEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 16, 3, 1), ).setIndexNames((0, "INXNMM-MIB", "riBootIndex"))
if mibBuilder.loadTexts: riBootEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riBootEntry.setDescription('This variable returns a particular boot specification, i.e., an entry in the Boot table. (See the previous variable, Boot Table, for an explanation of this table). You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Boot Table Index Boot File Name Boot Server IP Address Boot File Version Gateway IP Address')
riBootIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riBootIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riBootIndex.setDescription('This variable returns a unique value for each entry in the Boot table. It returns 1 for the Chassis Management Protocol file and 2 for the operating software image file.')
riBootFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootFileName.setStatus('mandatory')
if mibBuilder.loadTexts: riBootFileName.setDescription('The name of the operating software image file on the Featurecard or TFTP boot server from which you want to load the image.')
riBootIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: riBootIPAddress.setDescription('The Internet address of the boot server from which you want to load the software to the INX-NMM. Note: There is only one boot server IP address for all entries in the Boot table. If you change the address for one entry, all other entries will reflect the change as well.')
riBootVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootVersion.setStatus('mandatory')
if mibBuilder.loadTexts: riBootVersion.setDescription('The revision level of the operating software image file on the Featurecard or TFTP boot server from which you want to load the image.')
riBootGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 16, 3, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riBootGateway.setStatus('mandatory')
if mibBuilder.loadTexts: riBootGateway.setDescription('The Internet address of the gateway the INX-NMM must use to get to the boot server, if applicable. Note: There is only one gateway address for all entries in the Boot table. If you change the address for one entry, all other entries will reflect the change as well.')
riSystemHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemHardwareRev.setDescription('The hardware revision level of the INX-NMM.')
riSystemFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemFirmwareRev.setDescription('The firmware revision level of the INX-NMM.')
riSystemSoftwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemSoftwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemSoftwareRev.setDescription('The software revision level of the INX-NMM.')
riSystemSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemSerialNumber.setDescription('The serial number of the INX-NMM.')
riSystemReset = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("notreset", 1), ("resetupdate", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riSystemReset.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemReset.setDescription('The reset status of the INX-NMM. The reset types are o resetupdate(3) saves the current configuration in NVRAM and then resets the INX-NMM. This value is returned while a reset is in progress. o notreset(1) is returned when the INX-NMM is not being reset. Setting this variable to notreset(1) will not abort an outstanding resetupdate(3).')
riSystemTicksPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemTicksPerSecond.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemTicksPerSecond.setDescription('The number of internal clock ticks that occur each second on the INX-NMM, which is 100.')
riSystemRateInterval = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riSystemRateInterval.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemRateInterval.setDescription('How often, in seconds, any rate statistic maintained by the INX-NMM is checked. The default is 20 seconds.')
riSystemNVRamWriteCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 18, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riSystemNVRamWriteCount.setStatus('mandatory')
if mibBuilder.loadTexts: riSystemNVRamWriteCount.setDescription('The number of times that the NVRAM has been changed.')
tnCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnCount.setStatus('mandatory')
if mibBuilder.loadTexts: tnCount.setDescription("The number of telnet sessions that have been initiated from the INX-NMM. Because the INX-NMM doesn't initiate sessions, this variable always returns 0.")
tnTable = MibTable((1, 3, 6, 1, 4, 1, 28, 3, 2), )
if mibBuilder.loadTexts: tnTable.setStatus('mandatory')
if mibBuilder.loadTexts: tnTable.setDescription('Contains telnet session-specific information that is appropriate to either the server or client side of a session. You cannot access this variable; it is only a table marker in the MIB.')
tnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 3, 2, 1), ).setIndexNames((0, "INXNMM-MIB", "tnLocalIpAddress"), (0, "INXNMM-MIB", "tnLocalPort"), (0, "INXNMM-MIB", "tnRemoteIpAddress"), (0, "INXNMM-MIB", "tnRemotePort"))
if mibBuilder.loadTexts: tnEntry.setStatus('mandatory')
if mibBuilder.loadTexts: tnEntry.setDescription('An entry in the Telnet Session table. (See the previous variable, Telnet Session Table, for an explanation of this table.) There is one entry in the table for each active telnet session. You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Telnet Port Identifier Local IP Addr of TCP Cxn Remote IP Addr of TCP Cxn Local Port of TCP Connection Remote Port of TCP Connection Up Time at Session Start Session Options On Telnet Session State Telnet User ID')
tnPort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnPort.setStatus('mandatory')
if mibBuilder.loadTexts: tnPort.setDescription('An internal index in the INX-NMM.')
tnLocalIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnLocalIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tnLocalIpAddress.setDescription('The local IP address of the TCP connection that this telnet session is using. The value of this variable is the same as the value of the Connection Local Address variable for the TCP connection this telnet session is using.')
tnRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: tnRemoteIpAddress.setDescription('The remote IP address of the TCP connection that this telnet session is using. The value of this variable is the same as the value of the Connection Remote Address variable for the TCP connection this telnet session is using.')
tnLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnLocalPort.setStatus('mandatory')
if mibBuilder.loadTexts: tnLocalPort.setDescription('The local port of the TCP connection that this telnet session is using. The value of this variable is the same as the value of the Connection Local Port Number variable for the TCP connection this telnet session is using.')
tnRemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnRemotePort.setStatus('mandatory')
if mibBuilder.loadTexts: tnRemotePort.setDescription('The remote port of the TCP connection that this telnet session is using. The value of this variable is the same as the value of the Connection Remote Port Number variable for the TCP connection this telnet session is using.')
tnUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 6), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: tnUpTime.setDescription('The value of INX-NMM Up Time at the time the telnet session was established.')
tnOptionsOn = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnOptionsOn.setStatus('mandatory')
if mibBuilder.loadTexts: tnOptionsOn.setDescription('Indicates which options are on/enabled in the will/do state. Each octet in the string contains the numerical value of an option that is on. For example, if a session had options 1, 4, 10, 15, and 20 on, then this variable would be 5 octets long, and the octets would contain the values 1, 4, 10, 15, and 20. The option values in the octet string can be in any order.')
tnState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("serverActive", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnState.setStatus('mandatory')
if mibBuilder.loadTexts: tnState.setDescription('Shows the state of the session. This variable always returns serverActive(1), which indicates that the INX-NMM is the telnet server and that a session is active, i.e., the user has logged in to this end of the connection.')
tnUserId = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 3, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tnUserId.setStatus('mandatory')
if mibBuilder.loadTexts: tnUserId.setDescription('The identification of the actual user at that end of the telnet session. The INX-NMM always returns a null string for this variable, because the concept of a user ID is not relevant to the INX-NMM.')
riLdcHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHardwareRev.setDescription('The hardware revision level of the INX-CMM, which this variable returns as a hexadecimal display string. Note: This is NOT the hardware revision level of the INX-NMM module.')
riLdcFirmwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcFirmwareRev.setDescription('The firmware revision level of the INX-CMM, i.e., the revision level of the INX-CMM PROMs. Note: This is NOT the firmware revision level of the INX-NMM module.')
riLdcChassisSoftwareRev = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcChassisSoftwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcChassisSoftwareRev.setDescription('The software revision level of higher-level INX-CMM software. Currently, there is no higher-level software on the INX-CMM; all its software is contained in the INX-CMM PROMS, whose revision level is returned by the previous variable, riLdcFirmwareRev. Because there is no higher-level software on the INX-CMM, this variable returns 0. Note: This is NOT the software revision level of the INX-NMM module.')
riLdcChassisSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcChassisSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcChassisSerialNumber.setDescription('The logic module serial number of the INX-CMM.')
riLdcChassisStatus = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 7, 200))).clone(namedValues=NamedValues(("reset", 1), ("enabled", 6), ("disabled", 7), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcChassisStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcChassisStatus.setDescription('The state of the modules in the chassis. This variable returns enabled(6) if any module in the chassis is set to enabled(6). It returns disabled(7) when all modules, excluding the INX-NMM, are set to disabled(7). To reboot all modules in the chassis, including the INX-NMM, set this variable to reset(1). Wait two minutes after changing boot parameters for any module in the chassis before setting this variable to reset(1). This ensures that your configuration updates have been stored in NVRAM. You cannot set this variable to other(200).')
riLdcChassisSlotCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcChassisSlotCount.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcChassisSlotCount.setDescription('The total number of slots available in the chassis for INTERNExT modules. The INX5000-3 contains 3 slots, and the INX5000-12 contains 13 slots.')
riLdcNumPowerSupplies = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcNumPowerSupplies.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcNumPowerSupplies.setDescription('The number of power supplies that are installed in the INTERNExT chassis. This variable returns either 1 or 2, because the INX5000-3 requires one power supply module, and the INX5000-12 can operate with either one or two power supply modules installed.')
riLdcNumBusMons = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcNumBusMons.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcNumBusMons.setDescription('The number of entries in the Bus Monitor table, which contains statistics for the internal INTERNExT chassis buses. This variable always returns 2, because the chassis contains two internal Ethernet buses, Bus A and Bus B.')
riLdcNumFans = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcNumFans.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcNumFans.setDescription('The number of entries in the Fan Status table, which contains information about the chassis fans. This variable returns either 1 or 4, because the INX5000-3 requires one fan to operate, and the INX5000-12 requires four.')
riLdcChassisSlotTable = MibTable((1, 3, 6, 1, 4, 1, 28, 10, 10), )
if mibBuilder.loadTexts: riLdcChassisSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcChassisSlotTable.setDescription('The Slot table contains information on the contents of each INTERNExT chassis slot. You cannot access this variable; it is only a table marker in the MIB.')
riLdcSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 10, 10, 1), ).setIndexNames((0, "INXNMM-MIB", "riLdcSlotIndex"))
if mibBuilder.loadTexts: riLdcSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotEntry.setDescription('An entry in the Slot table. (See the previous variable, Chassis Slot Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Chassis Slot Index Logic Module Object ID Desired Logic Module State Current Logic Module State Logic Module Bus Logic Module Hardware Rev Logic Module Firmware Rev Logic Module Software Rev Logic Module Serial Number Slot Diagnostic Results Slot Diagnostic Code Logic Module Detection Time Slot Temperature Status Connectivity Module Type Connectivity Module Rev Connectivity Module Serial Number Connectivity Module State Connectivity Module Bus Media Type Setting Sonic Bus Slot Module Type Set INX-NMM to Standby')
riLdcSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotIndex.setDescription('A unique value for each slot in the chassis. The value ranges from 1 to n, where n is the number of slots in the chassis. This variable returns 14 for the CMM slot in the INX5000-12, and 4 for the CMM slot in the INX5000-3.')
riLdcSlotContents = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotContents.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotContents.setDescription('The type of logic module that is in the slot, as specified below. If the slot is empty, this variable returns 0.0. 1.3.6.1.4.1.28.1.3.1.1 INX-NMM 1.3.6.1.4.1.28.1.3.2.1 INX-10BT 1.3.6.1.4.1.28.1.3.3.1 INX-FOIRL 1.3.6.1.4.1.28.1.3.4.1 INX-NTS 1.3.6.1.4.1.28.1.3.6.1 INX-CMM 1.3.6.1.4.1.28.1.3.5.1 INX-LBR 1.3.6.1.4.1.28.1.3.5.2 INX-RBR 0.0 No module in slot.')
riLdcSlotAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 7, 31, 34, 200))).clone(namedValues=NamedValues(("reboot", 1), ("enabled", 6), ("disabled", 7), ("empty", 31), ("booting", 34), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotAdminStatus.setDescription('The state of the logic module in the slot. To enable or disable a logic module, first set this variable to enabled(6) or disabled(7), then reboot the module by setting the variable to reboot(1). Only reboot(1), enabled(6), and disabled(7) are settable values. If you try to set the state of the INX-CMM with this variable, the value is accepted but has no effect. To set the state of the INX-CMM, use the Chassis Module State variable. If you try to set this variable for an empty slot, a badValue error is returned. When read, the variable returns the same status as Current Logic Module State.')
riLdcSlotOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 7, 31, 34, 200))).clone(namedValues=NamedValues(("enabled", 6), ("disabled", 7), ("empty", 31), ("booting", 34), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotOperStatus.setDescription('The current state of the logic module in the slot. empty(31) indicates that there is nothing in the slot; other(200) indicates that the module in the slot has an undefined status.')
riLdcSlotBus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 200))).clone(namedValues=NamedValues(("bus-a", 2), ("bus-b", 3), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotBus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotBus.setDescription("The internal Ethernet bus connected to the NIC of the logic module. The values have the following meanings: o bus-a(2) indicates that the NIC is connected to Bus A. o bus-b(3) indicates that the NIC is connected to Bus B. o other(200) indicates that the slot is empty. After you set this variable, you must reboot the module with the Desired Logic Module State variable for the new setting to take effect. If you set this variable and then read it without rebooting, the old setting is returned. If you set one of these values for the INX-CMM or INX-LBR, it is accepted but has no effect on the INX-CMM's or INX-LBR's operation, because it has no bus connection and the INX-LBR is not currently configurable from the INX-NMM")
riLdcSlotHwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotHwRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotHwRev.setDescription('The hardware revision level of the logic module in the slot, returned as a hexadecimal string. If the slot is empty, the variable returns 0.')
riLdcSlotFwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotFwRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotFwRev.setDescription('The firmware revision level of the logic module in the slot. If the slot contains no module, or if the module contains no firmware, the variable returns 0.')
riLdcSlotSwRev = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotSwRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotSwRev.setDescription('The revision level of the operating software image of the logic module in the slot. If the slot contains no module, or the module has no software, the variable returns 0.')
riLdcSlotSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotSerialNumber.setDescription('The serial number of the logic module in the slot. If the slot is empty, the variable returns 0.')
riLdcSlotDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(92, 93, 200))).clone(namedValues=NamedValues(("pass", 92), ("fail", 93), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotDiagnostic.setDescription('The results of the internal startup (i.e., nondestructive) diagnostics for the logic and connectivity modules in a slot. This variable returns either pass(92) or fail(93), indicating the general results of the diagnostic tests. If the variable returns fail(93), see the next variable, Slot Diagnostic Code, for information about which test failed.')
riLdcSlotDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotDiagnosticCode.setDescription('Diagnostic results, returned as an octet string.')
riLdcSlotResetTime = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotResetTime.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotResetTime.setDescription('The value of INX-NMM Up Time (i.e., the length of time since the INX-NMM was last initialized) when the INX-NMM detected the presence of a logic module in this slot. This variable returns 0 in two cases: if the slot is empty, and if the slot contains an INX-NMM, because the INX-NMM detects its own presence immediately.')
riLdcSlotTempCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(60, 61, 62))).clone(namedValues=NamedValues(("unknown", 60), ("ok", 61), ("too-hot", 62)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotTempCondition.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotTempCondition.setDescription('The temperature status of the slot. When the slot is empty or when the module in the slot is in some other failure or error state, this variable returns unknown(60).')
riLdcSlotConnectivityType = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotConnectivityType.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivityType.setDescription('The type of connectivity module that is in the slot, as specified below. If there is no connectivity module in this slot, or the type cannot be determined, then this variable returns 0.0. 1.3.6.1.4.1.28.1.3.2.1.1.1 10BT-RJ45 1.3.6.1.4.1.28.1.3.2.1.2.1 10BT-TELCO 1.3.6.1.4.1.28.1.3.3.1.1.1 FOIRL-FST 1.3.6.1.4.1.28.1.3.4.1.1.1 NTS-RJ45 1.3.6.1.4.1.28.1.3.4.1.2.1 NTS-TELCO 1.3.6.1.4.1.28.1.3.5.2.1.1 INX-V35 1.3.6.1.4.1.28.1.3.5.2.1.2 INX-X21 1.3.6.1.4.1.28.1.3.6.1.1.1 INX-AUI 1.3.6.1.4.1.28.1.3.6.1.2.1 INX-FST 0.0 No module in slot.')
riLdcSlotConnectivityRev = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotConnectivityRev.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivityRev.setDescription('The hardware revision of the connectivity module in the slot, returned as a hexadecimal string. If the slot is empty, then this variable returns 0.')
riLdcSlotConnectivitySerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotConnectivitySerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivitySerialNumber.setDescription('The serial number of the connectivity module in the slot. This variable returns a null string for INX-10BT RJ45 and INX-10BT Telco connectivity modules, because these modules are not equipped with identification ROM. If the slot is empty, then this variable returns 0.')
riLdcSlotConnectivityState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 19, 200))).clone(namedValues=NamedValues(("disabled", 10), ("enabled", 19), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotConnectivityState.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivityState.setDescription('The state of the connectivity module in the slot. You can enable or disable only INX-AUI and INX-FST connectivity modules with this variable. INX-10BT, INX-NTS and FOIRL-FST connectivity modules always return enabled(19), and cannot be set to disabled(10). other(200) is returned for empty slots; you cannot set this value.')
riLdcSlotConnectivityBus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 9, 200))).clone(namedValues=NamedValues(("bus-a", 8), ("bus-b", 9), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotConnectivityBus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivityBus.setDescription('The bus connected to an INX-AUI or INX-FST connectivity module. o bus-a(8) indicates that the INX-AUI or INX-FST is connected to Bus A. o bus-b(9) indicates that INX-AUI or INX-FST is connected to Bus B. o other(200) indicates that the connectivity module is not an INX-AUI or INX-FST; you cannot set this value.')
riLdcSlotConnectivityMedia = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12, 13, 17, 18, 33, 34, 49, 81, 82, 200))).clone(namedValues=NamedValues(("backbone-thick", 11), ("backbone-thin", 12), ("backbone-fiber", 13), ("nts-telco", 17), ("nts-rj45", 18), ("bt-10-telco", 33), ("bt-10-rj45", 34), ("foirl-fiber", 49), ("bridge-v35", 81), ("bridge-x21", 82), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotConnectivityMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotConnectivityMedia.setDescription('The INX media type for the connectivity module located in this slot. o backbone thick(11) indicates that the media type of the INX-AUI or INX-FST is set for connection to an external transceiver. o backbone-thin(12) indicates that the media type of the INX-AUI is set for connection to Thin Ethernet. o backbone-fiber(13) indicates that the media type of the INX-FST is set for connection to fiber-optic cable. o NTS-TELCO(17) and NTS-RJ45(18) are the connectivity modules for the INX-NTS logic module. The NTS-RJ45 has 16 RJ-45 ports, numbered 1 through 16, top to bottom. The NTS-TELCO has two 50-pin telco connectors. o 10BT-TELCO(33) and 10BT-RJ45(34) are the connectivity modules for the INX-10BT logic module. The 10BT-RJ45 has 12 RJ-45 twisted pair transceiver ports. The 10BT-TELCO has one 50-pin telco connector. o FOIRL-FST(49) is the connectivity module for the INX-FOIRL, containing 6 pairs of ST fiber-optic connectors for connection to six ports. o BRIDGE-V35(81) and BRIDGE-X21U(82) are the connectivity modules for the INX-RBR. o other(200) indicates that the connectivity module is not an INX-AUI or INX-FST; you cannot set this value.')
riLdcSlotSonicBus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15, 16, 200))).clone(namedValues=NamedValues(("bus-a", 15), ("bus-b", 16), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotSonicBus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotSonicBus.setDescription('The internal Ethernet bus that the INX-NMM SONIC is monitoring. o bus-a(15) indicates that the SONIC is monitoring Bus A. o bus-b(16) indicates that the SONIC is monitoring Bus B. o other(200) indicates that the logic module is not an INX-NMM; you cannot set this value. After you set this variable, you must reboot the module with the Desired Logic Module State variable for the new setting to take effect. If you set this variable and then read it without rebooting, the old setting is returned.')
riLdcSlotModuleType = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 31, 200))).clone(namedValues=NamedValues(("inx-nmm", 1), ("inx-nts", 2), ("inx-10bt", 3), ("inx-cmm", 4), ("inx-rbr", 5), ("inx-foirl", 6), ("inx-lbr", 7), ("empty", 31), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcSlotModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotModuleType.setDescription('The type of logic module in the specified slot. This variable returns the same information as Logic Module Object ID, but in integer form, rather than as object identifiers.')
riLdcSlotStandbyNMM = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 10, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 200))).clone(namedValues=NamedValues(("standby-NMM", 3), ("non-standby-NMM", 4), ("other", 200)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcSlotStandbyNMM.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcSlotStandbyNMM.setDescription('Whether this INX-NMM is in standby mode. For this INX-NMM to be the master, this variable must be set to non-standby-NMM(4) and the Desired Logic Module State variable must be set to enabled(6). For this INX-NMM to be the slave, this variable must be set to non-standby-NMM(4) and the MDSU, Desired Logic Module State variable must be set to disabled(7). If this variable is set to standby-NMM(3), this INX-NMM is in standby mode; the setting of this variable overrides the setting of the Desired Logic Module State variable. This variable returns other(200) when read if the module in this slot is not an INX-NMM.')
riLdcPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 28, 10, 11), )
if mibBuilder.loadTexts: riLdcPowerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcPowerSupplyTable.setDescription('The Power Supply table contains information on the INTERNExT chassis power supplies. You cannot access this variable; it is only a table marker in the MIB.')
riLdcPSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 10, 11, 1), ).setIndexNames((0, "INXNMM-MIB", "riLdcPSIndex"))
if mibBuilder.loadTexts: riLdcPSEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcPSEntry.setDescription('An entry in the Power Supply table. (See the previous variable, Power Supply Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Power Supply Table Index Power Supply State')
riLdcPSIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcPSIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcPSIndex.setDescription('A unique value for each power supply in the chassis. Values range from 1 to n, where n is the number of available positions for power supplies in the chassis. There is one position for a power supply module in the INX5000-3, and two positions for power supply modules in the INX5000-12.')
riLdcPSActualStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(71, 72, 200))).clone(namedValues=NamedValues(("off", 71), ("active", 72), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcPSActualStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcPSActualStatus.setDescription('The current operational state of the power supply. The values and their meanings are as follows: o off(71) indicates that the power supply in this position is not supplying power. Warning: Do not remove the power entry module until you have another one to replace it. All modules, except the INX-NMM and INX-CMM, power down automatically within five minutes after the top power entry module is removed. o active(72) indicates that the power supply in this position is active and supplying power to the chassis, and all conditions in the power supply are optimal (i.e., no fault has been detected in the power supply). o other(200) indicates that this position is empty.')
riLdcBusMonTable = MibTable((1, 3, 6, 1, 4, 1, 28, 10, 12), )
if mibBuilder.loadTexts: riLdcBusMonTable.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonTable.setDescription('The Bus Monitor table maintains traffic statistics on the internal buses of the INTERNExT chassis. You cannot access this variable; it is only a table marker in the MIB.')
riLdcBusMonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 10, 12, 1), ).setIndexNames((0, "INXNMM-MIB", "riLdcBusMonIndex"))
if mibBuilder.loadTexts: riLdcBusMonEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonEntry.setDescription('Entries in the Bus Monitor table provide statistical information on the activities of the internal Ethernet buses. (See the previous variable, Bus Monitor Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Bus Monitor Table Index Monitored Bus Frames Received Frames Received Rate Octets Recd Octets Received Rate Multicast Frames Received Multicast Frames Received Rate Broadcast Frames Received Broadcast Frames Received Rate Normal Collisions Normal Collisions Rate Late Collisions Late Collisions Rate CRC Errored Frames Received CRC Errored Frames Recd Rate Collision Fragments Received Collision Fragments Received Rate Short Frames Received Short Frames Received Rate In-Range Errors Received In-Range Errors Received Rate Out-Range Errors Received Out-Range Errors Received Rate Too Long Frames Received Too Long Frames Received Rate Nonaligned Frames Received Nonaligned Frames Recd Rate Missed Frames Received Missed Frames Received Rate Bad Frames Received Bad Frames Received Rate Peak Bus Utilization Peak Bus Utilization Time Current Bus Utilization')
riLdcBusMonIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonIndex.setDescription('A unique value for each table entry. The value ranges from 1 to the value of Bus Monitor Entries. 1 for Bus A, 2 for Bus B')
riLdcBusMonBus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15, 16))).clone(namedValues=NamedValues(("bus-a", 15), ("bus-b", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonBus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonBus.setDescription('The internal Ethernet bus associated with this entry. The INTERNExT chassis contains two internal Ethernet buses, Bus A and Bus B.')
riLdcBusMonFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonFramesReceivedOK.setDescription('The number of frames received successfully off the bus by the SONIC. This value does not include frames received with FCS, length, or alignment errors, or frames lost due to internal errors.')
riLdcBusMonFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonFramesReceivedOKRate.setDescription('The rate of frames received successfully off the bus by the SONIC. This value does not include frames received with FCS, length, or alignment errors, or frames lost due to internal errors.')
riLdcBusMonOctetsReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonOctetsReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonOctetsReceivedOK.setDescription('The number of octets associated with the frames included in Frames Received.')
riLdcBusMonOctetsReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonOctetsReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonOctetsReceivedOKRate.setDescription('The rate of octets associated with the frames included in Frames Received.')
riLdcBusMonMCastFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonMCastFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonMCastFramesReceivedOK.setDescription('The number of frames received successfully off this bus that have an Ethernet multicast destination address.')
riLdcBusMonMCastFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonMCastFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonMCastFramesReceivedOKRate.setDescription('The rate of frames received successfully off this bus that have an Ethernet multicast destination address.')
riLdcBusMonBCastFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonBCastFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonBCastFramesReceivedOK.setDescription('The number of frames received successfully off this bus that have a broadcast destination address.')
riLdcBusMonBCastFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonBCastFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonBCastFramesReceivedOKRate.setDescription('The rate of frames received successfully off of this bus that have a broadcast destination address.')
riLdcBusMonCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonCollisions.setDescription('The number of collisions detected on this bus that occurred within 512 bit times from frame start. (Collisions are normal for networks with high utilization.)')
riLdcBusMonCollisionsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonCollisionsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonCollisionsRate.setDescription('The rate of collisions detected on this bus that occurred within 512 bit times from frame start.')
riLdcBusMonLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonLateCollisions.setDescription('The number of times that a collision has been detected on this bus later than 512 bit times from frame start. A late collision is counted twice, both as a collision and as a late collision.')
riLdcBusMonLateCollisionsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonLateCollisionsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonLateCollisionsRate.setDescription('The rate of times that a collision has been detected on this bus later than 512 bit times from frame start. A late collision is counted twice, both as a collision and as a late collision.')
riLdcBusMonCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonCRCErrors.setDescription('The number of frames received off this bus that are an integral number of octets in length (the number of bits they contain is a multiple of eight) and that do not pass the FCS check.')
riLdcBusMonCRCErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonCRCErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonCRCErrorsRate.setDescription('The rate of frames received off this bus that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) and that do not pass the FCS check.')
riLdcBusMonPygmies = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonPygmies.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonPygmies.setDescription('The number of collision fragments (frames less than 96 bits long) received on this bus.')
riLdcBusMonPygmiesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonPygmiesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonPygmiesRate.setDescription('The rate of collision fragments (frames less than 96 bits long) received on this bus.')
riLdcBusMonShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonShortFrames.setDescription('The number of frames received on this bus that are between 8 and 63 octets long.')
riLdcBusMonShortFramesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonShortFramesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonShortFramesRate.setDescription('The rate of frames received on this bus that are between 8 and 63 octets long.')
riLdcBusMonInRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonInRangeLengthErrors.setDescription('Number of in-range errors received on this bus. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error.')
riLdcBusMonInRangeLengthErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonInRangeLengthErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonInRangeLengthErrorsRate.setDescription('Rate of in-range errors received on this bus. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error.')
riLdcBusMonOutOfRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonOutOfRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonOutOfRangeLengthErrors.setDescription('Number of out-of-range errors received on this bus. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside of 802.3 parameters, the receiving device returns an out-of-range error. Because the INX-NMM receives frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riLdcBusMonOutOfRangeLengthErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonOutOfRangeLengthErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonOutOfRangeLengthErrorsRate.setDescription('Rate of out-of-range errors received on this bus. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside of 802.3 parameters, the receiving device returns an out-of-range error. Because the INX-NMM receives frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riLdcBusMonFramesTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonFramesTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonFramesTooLong.setDescription('The number of frames received on this bus that are greater than 1520 octets long, but not greater than 5msec in duration (which would indicate a jabber condition).')
riLdcBusMonFramesTooLongRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 26), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonFramesTooLongRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonFramesTooLongRate.setDescription('The rate of frames received on this bus that are greater than 1520 octets long, but not greater than 5 msec in duration (which would indicate a jabber condition).')
riLdcBusMonAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonAlignmentErrors.setDescription('The number of frames received on this bus that are not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight). These frames will not pass the FCS check but are counted as FCS errors.')
riLdcBusMonAlignmentErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonAlignmentErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonAlignmentErrorsRate.setDescription('The rate of frames received on this bus that are not an integral number of octets in length. (These frames will not pass the FCS check but are not counted as FCS errors.)')
riLdcBusMonMissedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonMissedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonMissedPackets.setDescription('The number of frames received while the INX-NMM receive state is disabled. The receive state usually becomes disabled because a network error condition has created a situation where resources are limited.')
riLdcBusMonMissedPacketsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonMissedPacketsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonMissedPacketsRate.setDescription('The rate of frames received while the INX-NMM receive state is disabled. The receive state usually becomes disabled because a network error condition has created a situation where resources are limited.')
riLdcBusMonErrorFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonErrorFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonErrorFrames.setDescription('The total number of frames received with CRC, alignment, or length errors.')
riLdcBusMonErrorFramesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonErrorFramesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonErrorFramesRate.setDescription('The rate of frames received with CRC, alignment, or length errors.')
riLdcBusMonUtilPeak = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 33), Gauge32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcBusMonUtilPeak.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonUtilPeak.setDescription('The highest utilization of the 10MBit/sec Ethernet network detected since NMM boot (eg. 27% Peak Utilization = 2.7Mbits/sec). To clear this value and the UtilPeakTime, set this object to 0')
riLdcBusMonUtilPeakTime = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 34), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonUtilPeakTime.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonUtilPeakTime.setDescription('The NMM Uptime when the UtilPeak was detected.')
riLdcBusMonUtilCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 12, 1, 35), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcBusMonUtilCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcBusMonUtilCurrent.setDescription('The current utilization of the 10MBit/sec Ethernet network. (eg. 15% Current Utilization = 1.5Mbits/sec).')
riLdcFanTable = MibTable((1, 3, 6, 1, 4, 1, 28, 10, 13), )
if mibBuilder.loadTexts: riLdcFanTable.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcFanTable.setDescription('The Fan Status table lists the status of all fans in the chassis. You cannot access this variable; it is only a table marker in the MIB.')
riLdcFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 10, 13, 1), ).setIndexNames((0, "INXNMM-MIB", "riLdcFanIndex"))
if mibBuilder.loadTexts: riLdcFanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcFanEntry.setDescription('Status information on a single fan, i.e., an entry in the Fan Status table. (See the previous variable, Fan Status Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Fan Status Table Index Fan Status')
riLdcFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcFanIndex.setDescription('A unique value for each Fan Status Table entry. The value ranges from 1 to the value of Fan Status Entries. The fans are numbered from left to right as you are facing the chassis.')
riLdcFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(81, 82, 200))).clone(namedValues=NamedValues(("off", 81), ("on", 82), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcFanStatus.setDescription('The status of the fan. This variable returns on(82) if the fan is operating, and off(81) if it is not operating.')
riLdcHfAPrimaryAui = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfAPrimaryAui.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfAPrimaryAui.setDescription('The number of the slot in which the primary Bus A backbone connectivity module for the chassis is installed.(CMM Slot is recommended)')
riLdcHfAPrimaryMedia = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12, 13))).clone(namedValues=NamedValues(("backbone-thick", 11), ("backbone-thin", 12), ("backbone-fiber", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfAPrimaryMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfAPrimaryMedia.setDescription('The media type of the primary Bus A backbone connectivity module for the chassis. This variable returns backbone-thick(11) if the module is configured to be connected to the backbone network via a transceiver cable; backbone-thin(12) if the module is configured to be connected to the backbone via a Thin Ethernet coaxial cable; and backbone-fiber(13) if it is configured for connection to the backbone via fiber-optic cabling.')
riLdcHfBPrimaryAui = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfBPrimaryAui.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBPrimaryAui.setDescription('The number of the slot in which the primary Bus B backbone connectivity module for the chassis is installed. You can set this variable to not configured(200) if you do not want a backup configuration for Bus B. You cannot set this variable to the slot number of the INX-CMM.')
riLdcHfBPrimaryMedia = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12, 13))).clone(namedValues=NamedValues(("backbone-thick", 11), ("backbone-thin", 12), ("backbone-fiber", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfBPrimaryMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBPrimaryMedia.setDescription('The media type of the primary Bus B backbone connectivity module for the chassis. This variable returns backbone-thick(11) if the module is configured to be connected to the backbone netswork via a transceiver cable; backbone-thin(12) if the module is configured to be connected to the backbone via a Thin Ethernet coaxial cable; and backbone-fiber(13) if it is configured for connection to the backbone via fiber-optic cabling.')
riLdcHfABackupAui = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfABackupAui.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfABackupAui.setDescription('The number of the slot in which the backup Bus A backbone connectivity module for the chassis is installed. Note: If you do not want to enable hot failover, but want to know when an event that would have caused it occurs, you can set this variable and Bus A Primary Backbone Slot # to the same value, and Bus A Primary Backbone Media and Bus A Backup Backbone Media to the same value. Hot failover will not occur, but if there is a failure of a network component, the Hot Failover trap is generated (if it can be transmitted on the network).')
riLdcHfABackupMedia = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12, 13))).clone(namedValues=NamedValues(("backbone-thick", 11), ("backbone-thin", 12), ("backbone-fiber", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfABackupMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfABackupMedia.setDescription('The media type of the backup Bus A backbone connectivity module for the chassis. This variable returns backbone-thick(11) if the module is configured to be connected to the backbone netswork via a transceiver cable; backbone-thin(12) if the module is configured to be connected to the backbone via a Thin Ethernet coaxial cable; and backbone-fiber(13) if it is configured for connection to the backbone via fiber-optic cabling.')
riLdcHfBBackupAui = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfBBackupAui.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBBackupAui.setDescription('The number of the slot in which the backup Bus B backbone connectivity module for the chassis is installed. You can set this variable to not-configured(200) if you do not want a backup configuration slot number for Bus B. You cannot set this variable to the slot number of the INX-CMM.')
riLdcHfBBackupMedia = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(11, 12, 13))).clone(namedValues=NamedValues(("backbone-thick", 11), ("backbone-thin", 12), ("backbone-fiber", 13)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfBBackupMedia.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBBackupMedia.setDescription('The media type of the backup Bus B backbone connectivity module for the chassis. This variable returns backbone-thick(11) if the module is configured to be connected to the backbone netswork via a transceiver cable; backbone-thin(12) if the module is configured to be connected to the backbone via a Thin Ethernet coaxial cable; and backbone-fiber(13) if it is configured for connection to the backbone via fiber-optic cabling.')
riLdcHfIntState = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("dis-no-A-config", 3), ("dis-no-B-config", 4), ("dis-A-B-conflict", 5), ("dis-zero-frequency", 6), ("dis-no-backbone", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfIntState.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntState.setDescription('The current state of internal hot failover detection for both Bus A and Bus B. Setting this variable to enabled(1) invokes internal hot failover detection/monitoring and enables the chassis to the primary hot failover configuration. To modify the internal polling frequency or the internal retry limit, you must first set this variable to disabled(2), make the modification (with the Internal Polling Frequency or Maximum Polling Retries variable), and then set this variable to enabled(1). Under certain conditions, enabling can fail; when this happens, a General Error status is returned. (Refer to the ASN file, Racal-INXNMM for detailed error definitions)')
riLdcHfIntPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfIntPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntPollFreq.setDescription('The frequency, in seconds, with which the INX-NMM master and slave modules attempt to transmit a self-addressed packet onto the bus for which their NIC is configured (i.e., the communication bus). The range of valid values is 1-255 seconds, and the default is 60 seconds.')
riLdcHfIntRetries = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfIntRetries.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntRetries.setDescription('The number of polling transmits (see the previous variable, Internal Polling Frequency) that must fail before internal failover is invoked. The range of valid values is 1 - 255, and the default is 3.')
riLdcHfExtState = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("dis-no-A-config", 3), ("dis-no-B-config", 4), ("dis-A-B-conflict", 5), ("dis-zero-frequency", 6), ("dis-no-backbone", 7), ("dis-zero-p1-addr", 8), ("dis-wrong-ext-bus", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtState.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtState.setDescription("The current state of external hot failover detection. External hot failover detection is only available for the bus on which the master INX-NMM's NIC is configured. Setting this variable to enabled(1) invokes external hot failover detection/monitoring. In addition to the status returned by the riLdcHfIntState object, the following two failures descriptions are returned if an enable(1) fails with a General Error. dis-zero-p1-addr(8) is returned when the Ping 1 address is set to 0.0.0.0. See the Ext Failover Detection/Ping 1 variable. dis-wrong-ext-bus(9) is returned when the master NIC is on Bus B and the primary or backup configuration for Bus B is invalid. See the Bus B Primary Backbone Slot #, Bus B Backup Backbone Slot #, Bus B Primary Backbone Media, and Bus B Backup Backbone Media variables.")
riLdcHfExtPing1 = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtPing1.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing1.setDescription('The IP adress of the node to which the master INX-NMM will ping to detect external cable failures. The master INX-NMM wil send the pings on the bus for which its NIC is configured. Only that bus can have external hot failure detection in use. Setting this value to 0.0.0.0 disables external hot failover detection by making it impossible to set External Failover Detection to enabled.')
riLdcHfExtPing2 = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 14), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtPing2.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing2.setDescription(' The IP address of a second node to ping should the first host not respond (see the previous variable, Ext Failover Detection/Ping 1). This eliminates the false hot failover detections that occur when the ping1 host is rebooting at the time the ping is made. The INX-NMM only tries to ping this address once the ping address reverts to the one specified by Ext Failover Detection/Ping 1. As with Ext Failover Detection/Ping1, set this variable to the address of the node to which the master INX-NMM will ping to detect external cable failures. The master INX-NMM sends the pings on the bus for which its NIC is configured (i.e., the value of Logic Module Bus). If you set this variable to 0.0.0.0, external hot failover detection is enabled, but only Ext Failover Detection/Ping1 is used.')
riLdcHfExtPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPollFreq.setDescription(' The frequency, in seconds, with which the master INX-NMM pings the address specified by Ext Failover Detection/Ping 1 or Ext Failover Detection/Ping 2. The range of valid values is 1 - 255 seconds, and the default is 15 seconds.')
riLdcHfExtResponseTmo = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtResponseTmo.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtResponseTmo.setDescription(' The number of seconds the INX-NMM waits for a response to the ping before the ping is considered failed. The range of valid values is 1 - 60 seconds, and the default is three seconds.')
riLdcHfExtRetries = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfExtRetries.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtRetries.setDescription(' The number of pings to the host specified by Ext Failover Detection/Ping 1 that must fail before external failover is invoked. The range is 1 - 255, and the default is 3.')
riLdcHfHysteresis = MibScalar((1, 3, 6, 1, 4, 1, 28, 10, 14, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riLdcHfHysteresis.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfHysteresis.setDescription(' The number of seconds required between failovers from the backup configuration to the primary configuration. This hysteresis time eliminates the continuous hot failing from one network to another that can occur if there is an intermittent failure on one of the networks. There is no hysteresis time when failing the primary configuration to the backup configuration.')
riLdcHfTable = MibTable((1, 3, 6, 1, 4, 1, 28, 10, 14, 19), )
if mibBuilder.loadTexts: riLdcHfTable.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfTable.setDescription(' The Hot Failover Status table contains information on the hot failover status of each internal bus.')
riLdcHfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1), ).setIndexNames((0, "INXNMM-MIB", "riLdcHfIndex"))
if mibBuilder.loadTexts: riLdcHfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfEntry.setDescription('Statistical information for the Hot Failover functions. (See the previous variable, Hot Fail Table, for an explanation of this table.) Hot Failover Status Index Current Configuration Time of Last Failover Internal Failover Count External Failover Count Primary Config Failover Cause Backup Config Failover Cause Internal Transmit Status Internal Transmit Failures AUI Autopartition Status Bus Autopartitions Bus Clock Status Bus Clock Failures Configuration Status Configuration Changes Ping 1 Host Status Ping 1 Host Failures Ping 2 Host Status Ping 2 Host Failures')
riLdcHfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIndex.setDescription(' A unique value for each bus entry in the Hot Failover Status table, i.e., Bus A or Bus B. This variable returns 1 for Bus A and 2 for Bus B.')
riLdcHfPrimBkupState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 200))).clone(namedValues=NamedValues(("using-prim-config", 1), ("using-bkup-config", 2), ("not-in-use", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfPrimBkupState.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfPrimBkupState.setDescription(' Whether this bus is currently operating with its primary configuration or its backup configuration. The returned value of this variable depends on the settings of the first eight variables in the Hot Failover group: Bus A Primary Backbone Slot #, Bus A Primary Backbone Media, Bus B Primary Backbone Slot #, Bus B Primary Backbone Media, Bus A Backup Backbone Slot #, Bus A Backup Backbone Media, Bus B Backup Backbone Slot #, and Bus B Backup Backbone Media. This variable returns not-in-use(200) if both internal and external hot failover detection are disabled for this bus, or if there is a problem in the configuration for the bus, which might be due to contradictory settings of some of the variables in the Hot Failover group.')
riLdcHfLastFailover = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfLastFailover.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfLastFailover.setDescription(' The value of INX-NMM Up Time (the sysUpTime variable in the System group for the INX-NMM) at the time the last failover for this bus occurred. By subtracting this value from the current INX-NMM UP Time value, you can tell how long ago the failover occurred.')
riLdcHfIntFailovers = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfIntFailovers.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntFailovers.setDescription(' The number of internal hot failovers invoked for this bus since the last boot of the INX-NMM.')
riLdcHfExtFailovers = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfExtFailovers.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtFailovers.setDescription('The number of external hot failovers invoked for this bus since the last boot of the INX-NMM.')
riLdcHfPrimReason = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("nofailover", 1), ("autopartitioned", 3), ("bus-clock-failure", 4), ("internal-tx-failure", 5), ("external-ping-failure", 6), ("config-change", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfPrimReason.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfPrimReason.setDescription(' The reason that an initial failover or automatic configuration change was invoked following a fault detected in the primary configuration. This variable returns nofailover(1) if no failover has occurred or if the bus is not configured. It returns autopartitioned(3) if the reason for the failure is that the bus backbone module has autopartitioned, bus-clock-failure(4) if the cause is an internal chassis bus clock failure, internal-tx-failure(5) if the cause is an internal transmit failure, external-ping-failure(6) if the cause is the failure of a ping attempt, and config-change(7) if the backbone modules had to be reset during the current configuration if another backbone was enabled by a means other than hot failover (for example, with the Connectivity Module Bus variable).')
riLdcHfBkupReason = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("nofailover", 1), ("autopartitioned", 3), ("bus-clock-failure", 4), ("internal-tx-failure", 5), ("external-ping-failure", 6), ("config-change", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBkupReason.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBkupReason.setDescription(' The reason that an initial failover or automatic Bacbone re-configuration was invoked following a fault detected in the backup configuration. This variable returns nofailover(1) if no failover has occurred or if the bus is not configured. It returns autopartitioned(3) if the reason for the failure is that the bus backbone module has autopartitioned, bus-clock-failure(4) if the cause is an internal chassis bus clock failure, internal-tx-failure(5) if the cause is an internal transmit failure, external-ping-failure(6) if the cause is the failure of a ping attempt, and config-change(7) if the backbone modules had to be reset during the current configuration if another backbone was enabled by a means other than hot failover (for example, with the Connectivity Module Bus variable).')
riLdcHfIntTxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 200))).clone(namedValues=NamedValues(("internal-bus-OK", 1), ("lost-crs", 2), ("excess-collisions", 3), ("other-tx-error", 4), ("not-in-use", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfIntTxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntTxStatus.setDescription(' This variable returns the transmit status of the internal detection scheme for this bus. It returns internal-bus-OK(1) if internal transmits are succeeding and no other bus errors are evident. If internal transmits are not succeeding or there is another bus error, it returns a value that tells you what the problem is, i.e., lost-crs(2), excess-collisions(3), or other-tx-error(4). If internal detection is not enabled, this variable returns not-in-use(200).')
riLdcHfIntTxFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfIntTxFailures.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfIntTxFailures.setDescription(' The number of internal transmit failures that have occurred on this bus since the last boot of the INX-NMM.')
riLdcHfAutopartState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 200))).clone(namedValues=NamedValues(("aui-OK", 1), ("aui-autopartitioned", 2), ("not-configured", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfAutopartState.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfAutopartState.setDescription(' The state of the backbone connectivity module for this bus, i.e., whether it is currently autopartitioned. This variable returns aui-OK(1) if the module is not autopartitioned, and aui-autopartitioned(2) if it is. It returns other(200) if either Bus B Primary Backbone Slot # or Bus B Backup Backbone Slot # is set to not configured(200).')
riLdcHfBusAutopartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBusAutopartitions.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBusAutopartitions.setDescription(' The number of times this bus has autopartitioned since the last boot of the INX-NMM. This count is the number of autopartitions of the backbone connectivity module. Note: This count does not include any port that is connected to this bus through a concentrator module.')
riLdcHfBusClockStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bus-clock-ok", 1), ("bus-clock-failed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBusClockStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBusClockStatus.setDescription(" The status of this bus's master clock, which is provided by the backbone connectivity module. This variable returns busclockok(1) if the clock is functioning normally, and busclockfailed(2) if it is not.")
riLdcHfBusClockFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBusClockFailures.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBusClockFailures.setDescription(" The number times this bus's clock has failed since the last reboot of the INX-NMM.")
riLdcHfBusConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("config-ok", 1), ("two-backbones-enabled", 2), ("no-backbones-enabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBusConfigStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBusConfigStatus.setDescription(" The current status of the backbone connectivity module's configuration.")
riLdcHfBusConfigChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfBusConfigChanges.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfBusConfigChanges.setDescription(' The number of times the backbone modules were reconfigured to the primary configuration because a mismatch of that configuration with the actual physical backbone configuration or an illegal configuration was detected. Hot Failover detects this change and fails to the primary configuration.')
riLdcHfExtPing1Status = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 200))).clone(namedValues=NamedValues(("external-bus-OK", 1), ("host-unreachable", 2), ("not-configured", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfExtPing1Status.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing1Status.setDescription(" The ping 1 host (i.e., the value of Ext Failover Det'n/Ping 1 Addr) status for the external detection scheme. This variable returns external-bus-OK(1) if the INX-NMM is able to ping the external host, and host-unreachable(2) if it cannot. If external failover detection is not enabled, this variable returns not-in-use(200).")
riLdcHfExtPing1Failures = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfExtPing1Failures.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing1Failures.setDescription(" The number of ping 1 host (i.e.,the value of Ext Failover Det'n/Ping 1 Addr) status failures for the external detection scheme since the last boot of the INX-NMM.")
riLdcHfExtPing2Status = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 200))).clone(namedValues=NamedValues(("external-bus-OK", 1), ("host-unreachable", 2), ("not-configured", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfExtPing2Status.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing2Status.setDescription(" The ping 2 host (i.e., the value of Ext Failover Det'n/Ping 2 Addr) status for the external detection scheme. This variable returns external-bus-OK(1) if the INX-NMM is able to ping the external host, and host-unreachable(2) if it cannot. If external failover detection is not enabled, or if Ext Failover Detection/Ping 2 is set to 0.0.0.0, this variable returns not-in-use(200).")
riLdcHfExtPing2Failures = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 10, 14, 19, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riLdcHfExtPing2Failures.setStatus('mandatory')
if mibBuilder.loadTexts: riLdcHfExtPing2Failures.setDescription(" The number of ping 2 (i.e., the value of Ext Failover Det'n/Ping 2 Addr) host status failures for the external detection scheme since the last boot of the INX-NMM.")
riPortTable = MibTable((1, 3, 6, 1, 4, 1, 28, 13, 1), )
if mibBuilder.loadTexts: riPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: riPortTable.setDescription('Statistical information about the INX-10BT and INX-FOIRL module ports. You cannot access this variable; it is only a table marker in the MIB. Note: If there is no INX-10BT or INX-FOIRL module in the slot for which you are trying to get information, that slot is not accessible and the variable returns ;MIB Object Not Found.')
riPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 13, 1, 1), ).setIndexNames((0, "INXNMM-MIB", "riPortSlotNumber"), (0, "INXNMM-MIB", "riPortPortNumber"))
if mibBuilder.loadTexts: riPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riPortEntry.setDescription("Statistical information for a single Ethernet port, i.e., an entry in the Port table. (See the previous variable, Port Table, for an explanation of this table.) You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Slot Number Port Number Port State Frames Rec'd Frames Rec'd Rate Octets Rec'd Octets Rec'd Rate Multicast Frames Rec'd Multicast Frames Rec'd Rate Broadcast Frames Rec'd Broadcast Frames Rec'd Rate Collisions Collisions Rate CRC Errored Frames Rec'd CRC Errored Frames Rec'd Rate Short Frames Rec'd Short Frames Rec'd Rate In-Range Errors Rec'd In-Range Errors Rec'd Rate Out-Range Errors Rec'd Out-Range Errors Rec'd Rate Too Long Frames Rec'd Too Long Frames Rec'd Rate Nonaligned Frames Rec'd Nonaligned Frames Rec'd Rate Autopartitions Autopartitions Rate Transmit Clock Violations Transmit Clock Violations Rate Last Good Source Address Source Address Changes Source Address Changes Rate Link Disconnects Link Disconnects Rate Late Collision Count Late Collision Rate Jabber Lockups Jabber Lockups Rate Port Link Status")
riPortSlotNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortSlotNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riPortSlotNumber.setDescription('A unique value for each slot in the chassis that contains an INX-10BT or INX-FOIRL module. Values range from 1 to n, where n is the maximum number of INX-10BT and INX-FOIRL modules that can be contained in a single chassis. This variable identifies the slot in the chassis that contains the media module that contains the port. Values are only returned for slots containing INX-10BT and INX-FOIRL modules.')
riPortPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: riPortPortNumber.setDescription('A unique value for each port on the INX-10BT or INX-FOIRL module that contains this port. The value ranges from 1 to n, where n is the total number of ports on the module.')
riPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 200, 41))).clone(namedValues=NamedValues(("auto-partitioned", 3), ("enabled", 4), ("disabled", 5), ("other", 200), ("empty", 41)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riPortState.setStatus('mandatory')
if mibBuilder.loadTexts: riPortState.setDescription('The state of the port. o empty(41) indicates that there is nothing in the slot. You cannot set the variable to this value o auto-partitioned(3) indicates that the port has auto-partitioned. o enabled(4) indicates that frames can pass through the port. o disabled(5) indicates that the port is turned off - no frames are allowed to pass through the port. o other(200) indicates that the port is not in any of the other three states. You cannot set the variable to this value. You can only set this variable to enabled(4) or disabled(5). If you try to access a slot not containing an INX-10BT or INX-FOIRL module, you receive an object not found error message.')
riPortFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riPortFramesReceivedOK.setDescription('The number of frames successfully received through this port. This count does not include frames received with FCS, length, or alignment errors, or frames lost due to internal errors.')
riPortFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortFramesReceivedOKRate.setDescription('The rate of frames/sec that have been successfully received through this port. This count does not include frames received with FCS, length, or alignment errors, or frames lost due to internal errors.')
riPortOctetsReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortOctetsReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riPortOctetsReceivedOK.setDescription('The number of octets associated with the frames included in Frames Received.')
riPortOctetsReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortOctetsReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortOctetsReceivedOKRate.setDescription('The rate of octets/sec associated with the frames included in Frames Received.')
riPortMulticastFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortMulticastFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riPortMulticastFramesReceivedOK.setDescription('The number of frames that had a multicast destination address sent by the device attached to this port.')
riPortMulticastFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortMulticastFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortMulticastFramesReceivedOKRate.setDescription('The rate of frames/sec sent by the device attached to this port that had a multicast destination address.')
riPortBroadcastFramesReceivedOK = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortBroadcastFramesReceivedOK.setStatus('mandatory')
if mibBuilder.loadTexts: riPortBroadcastFramesReceivedOK.setDescription('The number of frames that had a broadcast destination address sent by the device attached to this port.')
riPortBroadcastFramesReceivedOKRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortBroadcastFramesReceivedOKRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortBroadcastFramesReceivedOKRate.setDescription('The rate of frames/sec sent by the device attached to this port that had a broadcast destination address.')
riPortCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riPortCollisions.setDescription('The number of collisions within 512 bit times from frame start detected when the device attached to this port attempted to transmit. (Collisions are normal for networks with high utilization.)')
riPortCollisionsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortCollisionsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortCollisionsRate.setDescription('The rate of collisions/sec within 512 bit times from frame start detected when the device attached to this port attempted to transmit.')
riPortCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riPortCRCErrors.setDescription('The number of frames sent by the device attached to this port that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) and do not pass the FCS check.')
riPortCRCErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortCRCErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortCRCErrorsRate.setDescription('The rate of frames/sec sent by the device attached to this port that are an integral number of octets in length and do not pass the FCS check.')
riPortShortFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortShortFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riPortShortFrames.setDescription('The number of frames sent by the device attached to this port that are 8-63 octets long.')
riPortShortFramesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortShortFramesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortShortFramesRate.setDescription('The rate of frames/sec sent by the device attached to this port that are 8-63 octets long.')
riPortInRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riPortInRangeLengthErrors.setDescription('The number of in-range errors sent by the device attached to this port. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error. Because the INX-NMM receives Ethernet frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riPortInRangeLengthErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortInRangeLengthErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortInRangeLengthErrorsRate.setDescription('The rate of in-range errors sent by the device attached to this port. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error.Because the INX-NMM receives Ethernet frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riPortOutOfRangeLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortOutOfRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riPortOutOfRangeLengthErrors.setDescription('The number of out-of-range errors sent by the device attached to this port. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside of 802.3 parameters, the receiving device returns an out-of-range error. Because the INX-NMM receives Ethernet frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riPortOutOfRangeLengthErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortOutOfRangeLengthErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortOutOfRangeLengthErrorsRate.setDescription('The rate of out-of-range errors sent by the device attached to this port. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside of 802.3 parameters, the receiving device returns an out-of-range error.Because the INX-NMM receives Ethernet frames that do not have a length field, it cannot detect this error, and this variable always returns 0.')
riPortFramesTooLong = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortFramesTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: riPortFramesTooLong.setDescription('The number of frames sent by the device attached to this port that were greater than 1520 octets long, but not greater than 5 msec in duration (which would indicate a jabber condition).')
riPortFramesTooLongRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortFramesTooLongRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortFramesTooLongRate.setDescription('The rate of frames/sec sent by the device attached to this port that were greater than 1520 octets long, but not greater than 5 msec in duration (which would indicate a jabber condition).')
riPortAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riPortAlignmentErrors.setDescription('The number of frames sent by the device attached to this port that were not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight). These frames will not pass the FCS check but are not counted as FCS errors.')
riPortAlignmentErrorsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 25), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortAlignmentErrorsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortAlignmentErrorsRate.setDescription('The rate of frames/sec sent by the device attached to this port that were not an integral number of octets in length. (These frames will not pass the FCS check but are not counted as FCS errors.) of the INX-NMM, this variable always returns 0.')
riPortAutoPartitions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortAutoPartitions.setStatus('mandatory')
if mibBuilder.loadTexts: riPortAutoPartitions.setDescription('The number of times that the port was automatically partitioned from the network because of an error detected by the INX-10BT or INX-FOIRL module. Autopartitions can be caused by a long collision (between 100 microseconds and 3 milliseconds), or by 31 consecutive collisions (collisions shorter than 100 microseconds that occurred less than 512 bit times after frame start).')
riPortAutoPartitionsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortAutoPartitionsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortAutoPartitionsRate.setDescription('The rate of times/sec that the port was automatically partitioned from the network because of an error detected by the INX-10BT or INX-FOIRL module.')
riPortTransmitClockViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortTransmitClockViolations.setStatus('mandatory')
if mibBuilder.loadTexts: riPortTransmitClockViolations.setDescription("The number of times that the device attached to the port transmits, but its frame cannot be decoded by the module because of a timing error. The timing error is usually caused by an error in the device's transmit logic.")
riPortTransmitClockViolationsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortTransmitClockViolationsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortTransmitClockViolationsRate.setDescription("The rate of times/sec that the device attached to the port transmits, but its frame cannot be decoded by the module because of a timing error. The timing error is usually caused by an error in the device's transmit logic.")
riPortLastSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLastSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLastSourceAddress.setDescription('The Ethernet source address of the last uncorrupted frame sent by the device attached to this port.')
riPortSourceAddressChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortSourceAddressChanges.setStatus('mandatory')
if mibBuilder.loadTexts: riPortSourceAddressChanges.setDescription('The number of times the Ethernet source address of a frame transmitted by the device attached to the port has changed from one frame to the next frame. If the port is attached to a bridge, this count will be very high.')
riPortSourceAddressChangesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 32), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortSourceAddressChangesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortSourceAddressChangesRate.setDescription('The rate of times/sec the Ethernet source address of a frame transmitted by the device attached to the port has changed from one frame to the next frame.')
riPortLinkIntegrityChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLinkIntegrityChanges.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLinkIntegrityChanges.setDescription('The total number of times the device attached to the port has been disconnected or reconnected. When an INX-10BT or INX-FOIRL module is booted, it has a link integrity of 0 for all ports.')
riPortLinkIntegrityChangesRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLinkIntegrityChangesRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLinkIntegrityChangesRate.setDescription('The rate of times the device attached to the port has been disconnected or reconnected. When an INX-10BT or INX-FOIRL module is booted, it has a link integrity of 0 for all ports.')
riPortLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLateCollisions.setDescription('The number of times that a collision has been detected on this port later than 512 bit times from frame start. A late collision is counted twice, as both a collision and as a late collision.')
riPortLateCollisionsRate = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLateCollisionsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLateCollisionsRate.setDescription('The rate of the times/sec that a collision has been detected on this port later than 512 bit times from frame start. A late collision is counted twice, as both a collision and as a late collision.')
riPortMauJabberLockups = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortMauJabberLockups.setStatus('mandatory')
if mibBuilder.loadTexts: riPortMauJabberLockups.setDescription('The number of times the port detects that the attached device is transmitting continuously for more than six ms.')
riPortMauJabberpLockupsRate = MibScalar((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 38), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortMauJabberpLockupsRate.setStatus('mandatory')
if mibBuilder.loadTexts: riPortMauJabberpLockupsRate.setDescription('The rate of times/sec the port detects that the attached device is transmitting for more than 6 ms.')
riPortLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 13, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 200))).clone(namedValues=NamedValues(("link-status-led-on", 1), ("link-status-led-off", 2), ("other", 200)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: riPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riPortLinkStatus.setDescription(" Whether an active device is attached to this port. The device's MAU should generate a 100-ns pulse every 8 to 16 msec. This pulse is detected by the INX-10BT or INX-FOIRL when it polls the port. If the pulse is detected, this variable returns link-status-led-on(1). If the pulse is not detected, this variable returns link-status-led-off(2).")
riThCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThCount.setDescription('the number of active entries in the threshold table.')
riThMaxCount = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThMaxCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThMaxCount.setDescription('The maximum number of active thresholds allowed.')
riThUniqueIndex = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThUniqueIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riThUniqueIndex.setDescription('Setting this variable creates a new entry in the Threshold table. You must type a number for the entry when you set this variable, but the INX-NMM assigns the actual entry number; that number is the one returned in the response to the set command. If you read this variable, it returns the number of the most recently generated threshold entry.')
riThInterval = MibScalar((1, 3, 6, 1, 4, 1, 28, 17, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThInterval.setStatus('mandatory')
if mibBuilder.loadTexts: riThInterval.setDescription('How often, in seconds, thresholds exceeded are checked. To disable threshold checking, set this variable to 0.')
riThTable = MibTable((1, 3, 6, 1, 4, 1, 28, 17, 5), )
if mibBuilder.loadTexts: riThTable.setStatus('mandatory')
if mibBuilder.loadTexts: riThTable.setDescription('A table containing information about the thresholds that have been set. You cannot access this variable; it is only a table marker in the MIB.')
riThEntry = MibTableRow((1, 3, 6, 1, 4, 1, 28, 17, 5, 1), ).setIndexNames((0, "INXNMM-MIB", "riThIndex"))
if mibBuilder.loadTexts: riThEntry.setStatus('mandatory')
if mibBuilder.loadTexts: riThEntry.setDescription('An entry in the Threshold table. (See the previous variable, Threshold Table, for an explanation of this table). You cannot access this variable; it is only a table marker in the MIB. The following variables are entries in the table: Threshold Table Index Threshold Status Threshold Object ID Threshold Value Threshold Hysteresis Direction of Approach to Thresh Threshold Trigger Count Threshold Community Name Threshold Eth Addr Destination Threshold IP Addr Destination')
riThIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThIndex.setStatus('mandatory')
if mibBuilder.loadTexts: riThIndex.setDescription('A unique value for each threshold.')
riThStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delete", 1), ("unset", 2), ("armed", 3), ("safety", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThStatus.setStatus('mandatory')
if mibBuilder.loadTexts: riThStatus.setDescription('The current status of the threshold. o delete(1) deletes the threshold entry specified. o unset(2) means that the threshold is newly created, currently being configured, or disabled. o armed(3) means that the threshold is active and generates a trap PDU when it is triggered. o safety(4) means that the threshold is active, but does not generate trap PDUs.')
riThObject = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThObject.setStatus('mandatory')
if mibBuilder.loadTexts: riThObject.setDescription('The complete object identifier of the variable on which this threshold is set. Threshold Object ID can be set only for Counter or Gauge variables. If you attempt to set a threshold for a variable of any other type, you receive a badValue error.')
riThThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: riThThreshold.setDescription('The threshold value for the variable identified by Threshold Object ID. If this particular variable is a gauge, then whenever its value rises above or drops below (depending on the setting of the Direction of Approach to Thresh variable) the value of Threshold Value, the threshold is considered to have been triggered. If this particular variable is a counter, then whenever its value increments by the value of Threshold Value, the threshold is considered to have been triggered.')
riThHysteresis = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThHysteresis.setStatus('mandatory')
if mibBuilder.loadTexts: riThHysteresis.setDescription("The hysteresis value for the threshold. After a variable's threshold is triggered, the value of the variable must either drop below or rise above a certain value (depending on the setting of the Direction of Approach to Thresh variable), the hysteresis, before another trigger can be recognized. For example, if you set the threshold for module temperature to 80, the threshold is triggered the first time the temperature rises above 80. If you also set the hysteresis for this threshold to 60, the threshold will only be triggered again if the temperature drops below 60, and then rises past 80. If the temperature drops from 80 to 70, and then goes back to 80, the threshold is not triggered. If the hysteresis value is less than the threshold value, the variable's value must drop below the hysteresis before another trigger is recognized. If the hysteresis value is greater than the threshold value, the variable's value must rise above the hysteresis before another trigger is recognized. The value of the hysteresis depends on the value of the threshold and whether the value of the variable is rising or falling; therefore, set this variable in conjunction with both the Threshold Value and Direction of Approach to Thresh variables. This variable is relevant only to thresholds set on Gauge variables.")
riThDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThDirection.setStatus('mandatory')
if mibBuilder.loadTexts: riThDirection.setDescription("The direction in which a change in a Gauge variable's value causes a threshold to trigger. If its direction is up, a trigger occurs when the variable's value rises above the threshold value. In this case, the hysteresis must be less than or equal to the threshold value. If its direction is down, a trigger occurs when the variable's value falls below the threshold value. In this case, the hysteresis must be greater than or equal to the threshold value. This variable is relevant only to thresholds set on Gauge variables.")
riThTriggeredCount = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riThTriggeredCount.setStatus('mandatory')
if mibBuilder.loadTexts: riThTriggeredCount.setDescription('The number of times that this threshold has been triggered.')
riThCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: riThCommunity.setDescription('The community name to place in the authentication header of the trap PDU. This variable specifies the community to which the trap is to be sent when a threshold is triggered.')
riThPhysDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThPhysDestination.setStatus('mandatory')
if mibBuilder.loadTexts: riThPhysDestination.setDescription('The Ethernet address of the node to which the trap is to be sent when the threshold is triggered.')
riThIPDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 28, 17, 5, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: riThIPDestination.setStatus('mandatory')
if mibBuilder.loadTexts: riThIPDestination.setDescription('The IP address of the node to which the trap is to be sent when the threshold is triggered.')
riRateTxSingleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxSingleCollisionFrames.setDescription('The rate of frames that were successfully transmitted after experiencing one and only one collision. This variable corresponds to the Single Collisions Transmitted variable in the dot3 group.')
riRateTxMultipleCollisionFrames = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxMultipleCollisionFrames.setDescription('The rate of frames that were successfully transmitted after experiencing more than one collision. This variable corresponds to the Multiple Collisions Xmitted variable in the dot3 group.')
riRateTxDeferredTransmissions = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxDeferredTransmissions.setDescription('The rate of times the INX-NMM deferred transmission of data because it sensed traffic on the network. Because the INX-NMM does not record deferrals, this variable always returns 0. This variable corresponds to the Transmissions Deferred variable in the dot3 group.')
riRateTxLateCollisions = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxLateCollisions.setDescription('The rate of times that a collision has been detected on this bus later than 512 bit times from frame start. This count is not maintained by the INX-NMM, so this variable always returns 0. This variable corresponds to the Late Collisions Detected variable in the dot3 group.')
riRateTxInternalMACTransmitErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxInternalMACTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxInternalMACTransmitErrors.setDescription('The rate of frames the interface could not transmit because of an internal MAC sublayer transmit error. This variable corresponds to the MAC Transmit Errors variable in the dot3 group.')
riRateTxCarrierSenseErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxCarrierSenseErrors.setDescription('The rate of times that the carrier-sense condition was lost or never asserted when the INX-NMM attempted to transmit a frame on the interface. This variable corresponds to the Carrier Sense Errors variable in the dot3 group.')
riRateTxExcessiveDeferrals = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateTxExcessiveDeferrals.setStatus('mandatory')
if mibBuilder.loadTexts: riRateTxExcessiveDeferrals.setDescription('The rate of frames the INX-NMM deferred transmitting for an excessive period of time. Because the INX-NMM interface does not record deferrals, this variable always returns 0. This variable corresponds to the Deferred Frames variable in the dot3 group.')
riRateRxInternalMACReceiveErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxInternalMACReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxInternalMACReceiveErrors.setDescription('The rate of frames the interface could not receive because of an internal MAC sublayer receive error. This variable corresponds to the MAC Errors Received variable in the dot3 group.')
riRateRxFCSErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxFCSErrors.setDescription('The rate of frames received on the interface that are an integral number of octets in length (i.e., the number of bits they contain is a multiple of eight) that do not pass the FCS check, indicating that the frames were corrupted during transmission. This variable corresponds to the FCS Errored Frames Received variable in the dot3 group.')
riRateRxAlignmentErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxAlignmentErrors.setDescription('The rate of frames received on the interface that are not an integral number of octets in length (i.e., the number of bits they contain is not a multiple of eight) and do not pass the FCS check. This indicates that the frames were corrupted during transmission. This variable corresponds to the Nonaligned Frames Recd variable in the dot3 group.')
riRateRxInRangeLengthErrors = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxInRangeLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxInRangeLengthErrors.setDescription('The rate of in-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the value in the length field and the actual length of the frame do not match, even if the length of the frame is within 802.3 parameters, the receiving device returns an in-range error. The INX-NMM receives Ethernet fr This variable corresponds to the In-Range Length Errors Recd variable in the dot3 group.')
riRateRxOutofRangeLengthFields = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxOutofRangeLengthFields.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxOutofRangeLengthFields.setDescription('The rate of out-of-range length errors received. IEEE 802.3 frames contain a length field, indicating the length of the frame. If the length of the frame is outside 802.3 parameters, the receiving device returns an out-of-range error. The INX-NMM receives Ethernet frames that do not have a length field. It therefore cannot detect this error, This variable corresponds to the Out-Range Length Errors Recd variable in the dot3 group.')
riRateRxFrameTooLongs = MibScalar((1, 3, 6, 1, 4, 1, 28, 22, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: riRateRxFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: riRateRxFrameTooLongs.setDescription('The rate of frames received on the interface that exceed the maximum permitted frame size, i.e., 1012 octets. This variable corresponds to the Too Long Frames Recd variable in the dot3 group.')
mibBuilder.exportSymbols("INXNMM-MIB", riPortOutOfRangeLengthErrors=riPortOutOfRangeLengthErrors, tnLocalPort=tnLocalPort, riRateTxLateCollisions=riRateTxLateCollisions, dot3XRxLastSourceAddress=dot3XRxLastSourceAddress, dot3Index=dot3Index, riLdcPSIndex=riLdcPSIndex, riLdcBusMonFramesTooLongRate=riLdcBusMonFramesTooLongRate, riLdcBusMonPygmiesRate=riLdcBusMonPygmiesRate, riLdcHfIntFailovers=riLdcHfIntFailovers, riLdcHfExtPing2Failures=riLdcHfExtPing2Failures, riLdcNumPowerSupplies=riLdcNumPowerSupplies, riPortTransmitClockViolationsRate=riPortTransmitClockViolationsRate, dot3Entry=dot3Entry, riLdcPSEntry=riLdcPSEntry, dot3XRxFrameTooLongs=dot3XRxFrameTooLongs, riLdcHfPrimBkupState=riLdcHfPrimBkupState, riPortMauJabberLockups=riPortMauJabberLockups, riLdcSlotSonicBus=riLdcSlotSonicBus, riLdcHfBusAutopartitions=riLdcHfBusAutopartitions, riLdcBusMonLateCollisions=riLdcBusMonLateCollisions, riThTriggeredCount=riThTriggeredCount, riPortOutOfRangeLengthErrorsRate=riPortOutOfRangeLengthErrorsRate, dot3XTxExcessiveCollisions=dot3XTxExcessiveCollisions, riPortAlignmentErrorsRate=riPortAlignmentErrorsRate, riLdcFanIndex=riLdcFanIndex, riLdcBusMonOutOfRangeLengthErrors=riLdcBusMonOutOfRangeLengthErrors, riLdcChassisSlotTable=riLdcChassisSlotTable, riLdcSlotConnectivityRev=riLdcSlotConnectivityRev, riLdcSlotContents=riLdcSlotContents, riLdcBusMonOctetsReceivedOKRate=riLdcBusMonOctetsReceivedOKRate, riThHysteresis=riThHysteresis, interlan=interlan, dot3XRxInRangeLengthErrors=dot3XRxInRangeLengthErrors, riSystemFirmwareRev=riSystemFirmwareRev, riLdcHfBusConfigChanges=riLdcHfBusConfigChanges, riThCommunity=riThCommunity, riPortFramesTooLong=riPortFramesTooLong, tnRemotePort=tnRemotePort, riBootServiceOffered=riBootServiceOffered, riRateTxCarrierSenseErrors=riRateTxCarrierSenseErrors, riThTable=riThTable, riPortBroadcastFramesReceivedOKRate=riPortBroadcastFramesReceivedOKRate, riLdcHfExtPing1Failures=riLdcHfExtPing1Failures, riSystemNVRamWriteCount=riSystemNVRamWriteCount, riLdcHfExtPing2=riLdcHfExtPing2, riLdcBusMonUtilPeak=riLdcBusMonUtilPeak, riBootFileName=riBootFileName, riLdcBusMonTable=riLdcBusMonTable, riRateTxDeferredTransmissions=riRateTxDeferredTransmissions, riPortPortNumber=riPortPortNumber, dot3Table=dot3Table, riPortCRCErrors=riPortCRCErrors, riBootTable=riBootTable, riLdcSlotDiagnosticCode=riLdcSlotDiagnosticCode, riLdcFanStatus=riLdcFanStatus, riPortCollisions=riPortCollisions, riLdcSlotModuleType=riLdcSlotModuleType, tnOptionsOn=tnOptionsOn, tnTable=tnTable, riLdcBusMonOutOfRangeLengthErrorsRate=riLdcBusMonOutOfRangeLengthErrorsRate, riLdcHfAutopartState=riLdcHfAutopartState, riPortLinkIntegrityChanges=riPortLinkIntegrityChanges, riLdcBusMonIndex=riLdcBusMonIndex, riPortLinkIntegrityChangesRate=riPortLinkIntegrityChangesRate, riThUniqueIndex=riThUniqueIndex, experimental=experimental, riLdcHfExtPing2Status=riLdcHfExtPing2Status, dot3XTxIndex=dot3XTxIndex, riLdcSlotStandbyNMM=riLdcSlotStandbyNMM, riPortFramesReceivedOKRate=riPortFramesReceivedOKRate, riPortInRangeLengthErrors=riPortInRangeLengthErrors, riBootEntry=riBootEntry, riThInterval=riThInterval, riLdcSlotConnectivityBus=riLdcSlotConnectivityBus, tnRemoteIpAddress=tnRemoteIpAddress, riLdcHfExtPing1=riLdcHfExtPing1, riLdcChassisSoftwareRev=riLdcChassisSoftwareRev, riLdcHfBusClockStatus=riLdcHfBusClockStatus, riLdcHfExtPing1Status=riLdcHfExtPing1Status, riLdcBusMonEntry=riLdcBusMonEntry, riLdcPSActualStatus=riLdcPSActualStatus, riBootGateway=riBootGateway, riPortLinkStatus=riPortLinkStatus, riLdcBusMonUtilPeakTime=riLdcBusMonUtilPeakTime, tnUpTime=tnUpTime, riBootIPAddress=riBootIPAddress, riLdcHfIntPollFreq=riLdcHfIntPollFreq, riLdcSlotEntry=riLdcSlotEntry, riRateRxFCSErrors=riRateRxFCSErrors, dot3MACSubLayerStatus=dot3MACSubLayerStatus, dot3InitializeMAC=dot3InitializeMAC, dot3XRxSourceAddressLog=dot3XRxSourceAddressLog, riSystemTicksPerSecond=riSystemTicksPerSecond, riLdcSlotSerialNumber=riLdcSlotSerialNumber, dot3XRxAutoPartitionStatus=dot3XRxAutoPartitionStatus, riPort=riPort, dot3CollCount=dot3CollCount, riLdcBusMonBCastFramesReceivedOK=riLdcBusMonBCastFramesReceivedOK, riLdcBusMonLateCollisionsRate=riLdcBusMonLateCollisionsRate, riLdcHfIntTxStatus=riLdcHfIntTxStatus, riThMaxCount=riThMaxCount, riHotFail=riHotFail, dot3XRxAutoPartitionLog=dot3XRxAutoPartitionLog, riLdcFirmwareRev=riLdcFirmwareRev, dot3CollEntry=dot3CollEntry, riPortSourceAddressChanges=riPortSourceAddressChanges, riLdcBusMonErrorFramesRate=riLdcBusMonErrorFramesRate, riLdcHfBBackupAui=riLdcHfBBackupAui, riBootIndex=riBootIndex, riPortMauJabberpLockupsRate=riPortMauJabberpLockupsRate, riThEntry=riThEntry, riLdcSlotOperStatus=riLdcSlotOperStatus, dot3TxSingleCollisionFrames=dot3TxSingleCollisionFrames, dot3CollIndex=dot3CollIndex, riLdcNumFans=riLdcNumFans, riLdcBusMonShortFrames=riLdcBusMonShortFrames, riSystemSerialNumber=riSystemSerialNumber, riPortTransmitClockViolations=riPortTransmitClockViolations, riLdcHfPrimReason=riLdcHfPrimReason, riPortLastSourceAddress=riPortLastSourceAddress, riRateRxAlignmentErrors=riRateRxAlignmentErrors, riLdcBusMonAlignmentErrorsRate=riLdcBusMonAlignmentErrorsRate, riLdcHfIndex=riLdcHfIndex, riPortTable=riPortTable, riLdcSlotSwRev=riLdcSlotSwRev, riBoot=riBoot, riLdcHfLastFailover=riLdcHfLastFailover, riLdcSlotDiagnostic=riLdcSlotDiagnostic, riLdcSlotResetTime=riLdcSlotResetTime, riLdcSlotBus=riLdcSlotBus, tnLocalIpAddress=tnLocalIpAddress, riRateRxInRangeLengthErrors=riRateRxInRangeLengthErrors, riLdcNmm=riLdcNmm, riLdcBusMonAlignmentErrors=riLdcBusMonAlignmentErrors, riLdcBusMonFramesTooLong=riLdcBusMonFramesTooLong, dot3XTxCarrierSenseErrors=dot3XTxCarrierSenseErrors, riLdcSlotConnectivityType=riLdcSlotConnectivityType, dot3XRxEntry=dot3XRxEntry, dot3MulticastReceiveEnabled=dot3MulticastReceiveEnabled, riSystemRateInterval=riSystemRateInterval, riTelnet=riTelnet, riLdcSlotIndex=riLdcSlotIndex, dot3CollTable=dot3CollTable, riLdcHfABackupAui=riLdcHfABackupAui, riPortAutoPartitions=riPortAutoPartitions, riLdcHfBkupReason=riLdcHfBkupReason, riLdcHfBPrimaryAui=riLdcHfBPrimaryAui, riLdcHfAPrimaryAui=riLdcHfAPrimaryAui, dot3XTxLateCollisions=dot3XTxLateCollisions, riLdcNumBusMons=riLdcNumBusMons, riLdcHfExtPollFreq=riLdcHfExtPollFreq, dot3XRxInternalMACReceiveErrors=dot3XRxInternalMACReceiveErrors, riLdcBusMonCRCErrors=riLdcBusMonCRCErrors, dot3XTxDeferredTransmissions=dot3XTxDeferredTransmissions, tnEntry=tnEntry, dot3XTxEnabled=dot3XTxEnabled, riLdcFanTable=riLdcFanTable, riLdcHfABackupMedia=riLdcHfABackupMedia, dot3TxEntry=dot3TxEntry, riSystemHardwareRev=riSystemHardwareRev, riProdLdc=riProdLdc, riLdcHfExtRetries=riLdcHfExtRetries, riLdcHfExtResponseTmo=riLdcHfExtResponseTmo, dot3FCSErrors=dot3FCSErrors, riLdcSlotTempCondition=riLdcSlotTempCondition, riLdcBusMonCollisions=riLdcBusMonCollisions, riLdcHfBusClockFailures=riLdcHfBusClockFailures, riPortSourceAddressChangesRate=riPortSourceAddressChangesRate, riTsRates=riTsRates, riThPhysDestination=riThPhysDestination, riLdcBusMonBCastFramesReceivedOKRate=riLdcBusMonBCastFramesReceivedOKRate, riLdcHfTable=riLdcHfTable, riLdcHfBusConfigStatus=riLdcHfBusConfigStatus, dot3XRxOutOfRangeLengthFields=dot3XRxOutOfRangeLengthFields, riNumBoots=riNumBoots, riLdcChassisSlotCount=riLdcChassisSlotCount, private=private, riLdcBusMonMissedPacketsRate=riLdcBusMonMissedPacketsRate, riPLdcNMM=riPLdcNMM, riLdcBusMonPygmies=riLdcBusMonPygmies, tnUserId=tnUserId, riLdcHardwareRev=riLdcHardwareRev, riThThreshold=riThThreshold, riLdcFanEntry=riLdcFanEntry, riLdcHfExtFailovers=riLdcHfExtFailovers, riRateRxFrameTooLongs=riRateRxFrameTooLongs, riPortSlotNumber=riPortSlotNumber, riLdcHfExtState=riLdcHfExtState, dot3TxIndex=dot3TxIndex, riLdcBusMonMissedPackets=riLdcBusMonMissedPackets, riLdcBusMonOctetsReceivedOK=riLdcBusMonOctetsReceivedOK, dot3TxSQETestErrors=dot3TxSQETestErrors, dot3XTxTDR=dot3XTxTDR, riPortCRCErrorsRate=riPortCRCErrorsRate, riPortLateCollisions=riPortLateCollisions, dot3TxMultipleCollisionFrames=dot3TxMultipleCollisionFrames, riLdcBusMonCRCErrorsRate=riLdcBusMonCRCErrorsRate, riSystemSoftwareRev=riSystemSoftwareRev, riLdcSlotConnectivityMedia=riLdcSlotConnectivityMedia, riPortInRangeLengthErrorsRate=riPortInRangeLengthErrorsRate, riLdcBusMonUtilCurrent=riLdcBusMonUtilCurrent, dot3XTxTable=dot3XTxTable, riLdcBusMonBus=riLdcBusMonBus, riPortOctetsReceivedOKRate=riPortOctetsReceivedOKRate, riPortLateCollisionsRate=riPortLateCollisionsRate, riLdcSlotConnectivitySerialNumber=riLdcSlotConnectivitySerialNumber, riLdcBusMonErrorFrames=riLdcBusMonErrorFrames, riThresh=riThresh, tnCount=tnCount, riLdcHfAPrimaryMedia=riLdcHfAPrimaryMedia, riLdcHfHysteresis=riLdcHfHysteresis, riLdcBusMonMCastFramesReceivedOKRate=riLdcBusMonMCastFramesReceivedOKRate, riThCount=riThCount, riRateTxExcessiveDeferrals=riRateTxExcessiveDeferrals, riPortMulticastFramesReceivedOK=riPortMulticastFramesReceivedOK, riLdcHfIntRetries=riLdcHfIntRetries, tnPort=tnPort, tnState=tnState, riLdcHfEntry=riLdcHfEntry, riPortCollisionsRate=riPortCollisionsRate, riLdcHfBPrimaryMedia=riLdcHfBPrimaryMedia, enterprises=enterprises, riSystem=riSystem, riPortOctetsReceivedOK=riPortOctetsReceivedOK, riThStatus=riThStatus, riRateTxMultipleCollisionFrames=riRateTxMultipleCollisionFrames, dot3TxTable=dot3TxTable, riPortFramesTooLongRate=riPortFramesTooLongRate, riLdcHfIntState=riLdcHfIntState, riLdcChassisStatus=riLdcChassisStatus, riLdcBusMonFramesReceivedOKRate=riLdcBusMonFramesReceivedOKRate, riPortEntry=riPortEntry, dot3CollFrequency=dot3CollFrequency, riPortFramesReceivedOK=riPortFramesReceivedOK, riThIndex=riThIndex, riThObject=riThObject, riLdcBusMonInRangeLengthErrorsRate=riLdcBusMonInRangeLengthErrorsRate, riThIPDestination=riThIPDestination, riThDirection=riThDirection, riRateRxInternalMACReceiveErrors=riRateRxInternalMACReceiveErrors, riLdcHfBBackupMedia=riLdcHfBBackupMedia, dot3XTxExcessiveDeferrals=dot3XTxExcessiveDeferrals, riLdcChassisSerialNumber=riLdcChassisSerialNumber, riSystemReset=riSystemReset, riPortAlignmentErrors=riPortAlignmentErrors, riPortShortFramesRate=riPortShortFramesRate, dot3XTxInternalMACTransmitErrors=dot3XTxInternalMACTransmitErrors, riLdcSlotFwRev=riLdcSlotFwRev, dot3=dot3, riLdcSlotConnectivityState=riLdcSlotConnectivityState, riLdcBusMonShortFramesRate=riLdcBusMonShortFramesRate, riRateTxInternalMACTransmitErrors=riRateTxInternalMACTransmitErrors, riLdcBusMonFramesReceivedOK=riLdcBusMonFramesReceivedOK, riPortShortFrames=riPortShortFrames)
mibBuilder.exportSymbols("INXNMM-MIB", riLdcSlotHwRev=riLdcSlotHwRev, riLdcHfIntTxFailures=riLdcHfIntTxFailures, riLdcPowerSupplyTable=riLdcPowerSupplyTable, dot3XTxEntry=dot3XTxEntry, internet=internet, riLdcBusMonMCastFramesReceivedOK=riLdcBusMonMCastFramesReceivedOK, riPortAutoPartitionsRate=riPortAutoPartitionsRate, riLdcBusMonCollisionsRate=riLdcBusMonCollisionsRate, dot3AlignmentErrors=dot3AlignmentErrors, riPortMulticastFramesReceivedOKRate=riPortMulticastFramesReceivedOKRate, riPortState=riPortState, riRateTxSingleCollisionFrames=riRateTxSingleCollisionFrames, dot3XRxIndex=dot3XRxIndex, dot3XRxTable=dot3XRxTable, riBootVersion=riBootVersion, riProducts=riProducts, riLdcBusMonInRangeLengthErrors=riLdcBusMonInRangeLengthErrors, riPortBroadcastFramesReceivedOK=riPortBroadcastFramesReceivedOK, riLdcSlotAdminStatus=riLdcSlotAdminStatus, riRateRxOutofRangeLengthFields=riRateRxOutofRangeLengthFields)

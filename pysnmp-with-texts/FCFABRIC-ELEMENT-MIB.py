#
# PySNMP MIB module FCFABRIC-ELEMENT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/FCFABRIC-ELEMENT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:12:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, experimental, Counter32, NotificationType, MibIdentifier, Unsigned32, Bits, ObjectIdentity, Integer32, ModuleIdentity, iso, Gauge32, IpAddress, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "experimental", "Counter32", "NotificationType", "MibIdentifier", "Unsigned32", "Bits", "ObjectIdentity", "Integer32", "ModuleIdentity", "iso", "Gauge32", "IpAddress", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
fibreChannel = MibIdentifier((1, 3, 6, 1, 3, 42))
fcFabric = MibIdentifier((1, 3, 6, 1, 3, 42, 2))
fcFe = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1))
fcFeConfig = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1, 1))
fcFeOp = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1, 2))
fcFeError = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1, 3))
fcFeAcct = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1, 4))
fcFeCap = MibIdentifier((1, 3, 6, 1, 3, 42, 2, 1, 5))
class DisplayString(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class MilliSeconds(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147383647)

class MicroSeconds(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147383647)

class FcNameId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class FabricName(FcNameId):
    pass

class FcPortName(FcNameId):
    pass

class FcAddressId(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(3, 3)
    fixedLength = 3

class FcRxDataFieldSize(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(128, 2112)

class FcBbCredit(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 32767)

class FcphVersion(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class FcStackedConnMode(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("none", 1), ("transparent", 2), ("lockedDown", 3))

class FcCosCap(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 127)

class Fc0BaudRate(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))
    namedValues = NamedValues(("other", 1), ("oneEighth", 2), ("quarter", 4), ("half", 8), ("full", 16), ("double", 32), ("quadruple", 64))

class Fc0BaudRateCap(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 127)

class Fc0MediaCap(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class Fc0Medium(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128, 256))
    namedValues = NamedValues(("unknown", 1), ("sm", 2), ("m5", 4), ("m6", 8), ("tv", 16), ("mi", 32), ("stp", 64), ("tw", 128), ("lv", 256))

class Fc0TxType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("unknown", 1), ("longWaveLaser", 2), ("shortWaveLaser", 3), ("longWaveLED", 4), ("electrical", 5), ("shortWaveLaser-noOFC", 6))

class Fc0Distance(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("unknown", 1), ("long", 2), ("intermediate", 3), ("short", 4))

class FcFeModuleCapacity(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 256)

class FcFeFxPortCapacity(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 256)

class FcFeModuleIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 256)

class FcFeFxPortIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 256)

class FcFeNxPortIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 126)

class FcFxPortMode(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("fPort", 2), ("flPort", 3))

class FcBbCreditModel(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("regular", 1), ("alternate", 2))

fcFabricName = MibScalar((1, 3, 6, 1, 3, 42, 2, 1, 1, 1), FabricName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFabricName.setStatus('mandatory')
if mibBuilder.loadTexts: fcFabricName.setDescription('The Name_Identifier of the Fabric to which this Fabric Element belongs.')
fcElementName = MibScalar((1, 3, 6, 1, 3, 42, 2, 1, 1, 2), FcNameId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcElementName.setStatus('mandatory')
if mibBuilder.loadTexts: fcElementName.setDescription('The Name_Identifier of the Fabric Element.')
fcFeModuleCapacity = MibScalar((1, 3, 6, 1, 3, 42, 2, 1, 1, 3), FcFeModuleCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleCapacity.setDescription('The maximum number of modules in the Fabric Element, regardless of their current state.')
fcFeModuleTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 1, 4), )
if mibBuilder.loadTexts: fcFeModuleTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleTable.setDescription('A table that contains, one entry for each module in the Fabric Element, information of the modules.')
fcFeModuleEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFeModuleIndex"))
if mibBuilder.loadTexts: fcFeModuleEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleEntry.setDescription('An entry containing the configuration parameters of a module.')
fcFeModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleIndex.setDescription('This object identifies the module within the Fabric Element for which this entry contains information. This value is never greater than fcFeModuleCapacity.')
fcFeModuleDescr = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleDescr.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleDescr.setDescription('A textual description of the module. This value should include the full name and version identification of the module. It should contain printable ASCII characters.')
fcFeModuleObjectID = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleObjectID.setDescription("The vendor's authoritative identification of the module. This value may be allocated within the SMI enterprises subtree (1.3.6.1.4.1) and provides a straight-forward and unambiguous means for determining what kind of module is being managed. For example, this object could take the value 1.3.6.1.4.1.99649.3.9 if vendor 'Neufe Inc.' was assigned the subtree 1.3.6.1.4.1.99649, and had assigned the identifier 1.3.6.1.4.1.99649.3.9 to its 'FeFiFo-16 PlugInCard.'")
fcFeModuleOperStatus = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("testing", 3), ("faulty", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleOperStatus.setDescription('This object indicates the operational status of the module: online(1) the module is functioning properly; offline(2) the module is not available; testing(3) the module is under testing; and faulty(4) the module is defective in some way.')
fcFeModuleLastChange = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleLastChange.setDescription('This object contains the value of sysUpTime when the module entered its current operational status. A value of zero indicates that the operational status of the module has not changed since the agent last restarted.')
fcFeModuleFxPortCapacity = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 6), FcFeFxPortCapacity()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleFxPortCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleFxPortCapacity.setDescription('The number of FxPort that can be contained within the module. Within each module, the ports are uniquely numbered in the range from 1 to fcFeModuleFxPortCapacity inclusive. However, the numbers are not required to be contiguous.')
fcFeModuleName = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 4, 1, 7), FcNameId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFeModuleName.setStatus('mandatory')
if mibBuilder.loadTexts: fcFeModuleName.setDescription('The Name_Identifier of the module.')
fcFxConfTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 1, 5), )
if mibBuilder.loadTexts: fcFxConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxConfTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, configuration and service parameters of the FxPorts.')
fcFxConfEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxConfModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxConfFxPortIndex"))
if mibBuilder.loadTexts: fcFxConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxConfEntry.setDescription('An entry containing the configuration and service parameters of a FxPort.')
fcFxConfModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxConfModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxConfModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxConfFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxConfFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxConfFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortName = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 3), FcPortName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortName.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortName.setDescription('The name identifier of this FxPort. Each FxPort has a unique port name within the address space of the Fabric.')
fcFxPortFcphVersionHigh = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 4), FcphVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortFcphVersionHigh.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortFcphVersionHigh.setDescription('The highest or most recent version of FC-PH that the FxPort is configured to support.')
fcFxPortFcphVersionLow = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 5), FcphVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortFcphVersionLow.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortFcphVersionLow.setDescription('The lowest or earliest version of FC-PH that the FxPort is configured to support.')
fcFxPortBbCredit = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 6), FcBbCredit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortBbCredit.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortBbCredit.setDescription('The total number of receive buffers available for holding Class 1 connect-request, Class 2 or 3 frames from the attached NxPort. It is for buffer-to-buffer flow control in the direction from the attached NxPort (if applicable) to FxPort.')
fcFxPortRxBufSize = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 7), FcRxDataFieldSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortRxBufSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortRxBufSize.setDescription('The largest Data_Field Size (in octets) for an FT_1 frame that can be received by the FxPort.')
fcFxPortRatov = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 8), MilliSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortRatov.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortRatov.setDescription('The Resource_Allocation_Timeout Value configured for the FxPort. This is used as the timeout value for determining when to reuse an NxPort resource such as a Recovery_Qualifier. It represents E_D_TOV (see next object) plus twice the maximum time that a frame may be delayed within the Fabric and still be delivered.')
fcFxPortEdtov = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 9), MilliSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortEdtov.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortEdtov.setDescription('The E_D_TOV value configured for the FxPort. The Error_Detect_Timeout Value is used as the timeout value for detecting an error condition.')
fcFxPortCosSupported = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 10), FcCosCap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCosSupported.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCosSupported.setDescription('A value indicating the set of Classes of Service supported by the FxPort.')
fcFxPortIntermixSupported = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortIntermixSupported.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortIntermixSupported.setDescription('A flag indicating whether or not the FxPort supports an Intermixed Dedicated Connection.')
fcFxPortStackedConnMode = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 12), FcStackedConnMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortStackedConnMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortStackedConnMode.setDescription('A value indicating the mode of Stacked Connect supported by the FxPort.')
fcFxPortClass2SeqDeliv = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortClass2SeqDeliv.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortClass2SeqDeliv.setDescription('A flag indicating whether or not Class 2 Sequential Delivery is supported by the FxPort.')
fcFxPortClass3SeqDeliv = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortClass3SeqDeliv.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortClass3SeqDeliv.setDescription('A flag indicating whether or not Class 3 Sequential Delivery is supported by the FxPort.')
fcFxPortHoldTime = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 15), MicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortHoldTime.setDescription('The maximum time (in microseconds) that the FxPort shall hold a frame before discarding the frame if it is unable to deliver the frame. The value 0 means that the FxPort does not support this parameter.')
fcFxPortBaudRate = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 16), Fc0BaudRate()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortBaudRate.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortBaudRate.setDescription('The FC-0 baud rate of the FxPort.')
fcFxPortMedium = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 17), Fc0Medium()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortMedium.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortMedium.setDescription('The FC-0 medium of the FxPort.')
fcFxPortTxType = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 18), Fc0TxType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortTxType.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortTxType.setDescription('The FC-0 transmitter type of the FxPort.')
fcFxPortDistance = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 1, 5, 1, 19), Fc0Distance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortDistance.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortDistance.setDescription('The FC-0 distance range of the FxPort transmitter.')
fcFxPortOperTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 2, 1), )
if mibBuilder.loadTexts: fcFxPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOperTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, operational status and parameters of the FxPorts.')
fcFxPortOperEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortOperModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortOperFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOperEntry.setDescription('An entry containing operational status and parameters of a FxPort.')
fcFxPortOperModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortOperModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOperModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortOperFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortOperFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOperFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortID = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 3), FcAddressId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortID.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortID.setDescription('The address identifier by which this FxPort is identified within the Fabric. The FxPort may assign its address identifier to its attached NxPort(s) during Fabric Login.')
fcFPortAttachedPortName = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 4), FcPortName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFPortAttachedPortName.setStatus('deprecated')
if mibBuilder.loadTexts: fcFPortAttachedPortName.setDescription("The port name of the attached N_Port, if applicable. If the value of this object is '0000000000000000'H, this FxPort has no NxPort attached to it. This variable has been deprecated and may be implemented for backward compability.")
fcFPortConnectedPort = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 5), FcAddressId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFPortConnectedPort.setStatus('deprecated')
if mibBuilder.loadTexts: fcFPortConnectedPort.setDescription("The address identifier of the destination FxPort with which this FxPort is currently engaged in a either a Class 1 or loop connection. If the value of this object is '000000'H, this FxPort is not engaged in a connection. This variable has been deprecated and may be implemented for backward compability.")
fcFxPortBbCreditAvailable = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortBbCreditAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortBbCreditAvailable.setDescription('The number of buffers currently available for receiving frames from the attached port in the buffer-to-buffer flow control. The value should be less than or equal to fcFxPortBbCredit.')
fcFxPortOperMode = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 7), FcFxPortMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortOperMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOperMode.setDescription('The current operational mode of the FxPort.')
fcFxPortAdminMode = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 1, 1, 8), FcFxPortMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortAdminMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortAdminMode.setDescription('The desired operational mode of the FxPort.')
fcFxPortPhysTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 2, 3), )
if mibBuilder.loadTexts: fcFxPortPhysTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, physical level status and parameters of the FxPorts.')
fcFxPortPhysEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortPhysModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortPhysFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortPhysEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysEntry.setDescription('An entry containing physical level status and parameters of a FxPort.')
fcFxPortPhysModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPhysModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortPhysFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPhysFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortPhysAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("testing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fcFxPortPhysAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysAdminStatus.setDescription('The desired state of the FxPort. A management station may place the FxPort in a desired state by setting this object accordingly. The testing(3) state indicates that no operational frames can be passed. When a Fabric Element initializes, all FxPorts start with fcFxPortPhysAdminStatus in the offline(2) state. As the result of either explicit management action or per configuration information accessible by the Fabric Element, fcFxPortPhysAdminStatus is then changed to either the online(1) or testing(3) states, or remains in the offline state.')
fcFxPortPhysOperStatus = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("online", 1), ("offline", 2), ("testing", 3), ("link-failure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPhysOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysOperStatus.setDescription('The current operational status of the FxPort. The testing(3) indicates that no operational frames can be passed. If fcFxPortPhysAdminStatus is offline(2) then fcFxPortPhysOperStatus should be offline(2). If fcFxPortPhysAdminStatus is changed to online(1) then fcFxPortPhysOperStatus should change to online(1) if the FxPort is ready to accept Fabric Login request from the attached NxPort; it should proceed and remain in the link-failure(4) state if and only if there is a fault that prevents it from going to the online(1) state.')
fcFxPortPhysLastChange = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPhysLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysLastChange.setDescription("The value of sysUpTime at the time the FxPort entered its current operational status. A value of zero indicates that the FxPort's operational status has not changed since the agent last restarted.")
fcFxPortPhysRttov = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 3, 1, 6), MilliSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPhysRttov.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPhysRttov.setDescription('The Receiver_Transmitter_Timeout value of the FxPort. This is used by the receiver logic to detect Loss of Synchronization.')
fcFxlogiTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 2, 4), )
if mibBuilder.loadTexts: fcFxlogiTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxlogiTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, services parameters established from the most recent Fabric Login, explicit or implicit.')
fcFxlogiEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxlogiModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxlogiFxPortIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxlogiNxPortIndex"))
if mibBuilder.loadTexts: fcFxlogiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxlogiEntry.setDescription('An entry containing service parameters established from a successful Fabric Login.')
fcFxlogiModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxlogiModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxlogiModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxlogiFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxlogiFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxlogiFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxlogiNxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 3), FcFeNxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxlogiNxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxlogiNxPortIndex.setDescription('The object identifies the associated NxPort in the attachment for which the entry contains information.')
fcFxPortFcphVersionAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 4), FcphVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortFcphVersionAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortFcphVersionAgreed.setDescription('The version of FC-PH that the FxPort has agreed to support from the Fabric Login')
fcFxPortNxPortBbCredit = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 5), FcBbCredit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortNxPortBbCredit.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortNxPortBbCredit.setDescription('The total number of buffers available for holding Class 1 connect-request, Class 2 or Class 3 frames to be transmitted to the attached NxPort. It is for buffer- to-buffer flow control in the direction from FxPort to NxPort. The buffer-to-buffer flow control mechanism is indicated in the respective fcFxPortBbCreditModel. [1](23.6.2.2)')
fcFxPortNxPortRxDataFieldSize = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 6), FcRxDataFieldSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortNxPortRxDataFieldSize.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortNxPortRxDataFieldSize.setDescription('The Receive Data Field Size of the attached NxPort. This is a binary value that specifies the largest Data Field Size for an FT_1 frame that can be received by the NxPort. The value is in number of bytes and ranges from 128 to 2112 inclusive.')
fcFxPortCosSuppAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 7), FcCosCap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCosSuppAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCosSuppAgreed.setDescription('A variable indicating that the attached NxPort has requested the FxPort for the support of classes of services and the FxPort has granted the request.')
fcFxPortIntermixSuppAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortIntermixSuppAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortIntermixSuppAgreed.setDescription('A variable indicating that the attached NxPort has requested the FxPort for the support of Intermix and the FxPort has granted the request. This flag is only valid if Class 1 service is supported.')
fcFxPortStackedConnModeAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 9), FcStackedConnMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortStackedConnModeAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortStackedConnModeAgreed.setDescription('A variable indicating whether the FxPort has agreed to support stacked connect from the Fabric Login. This is only meaningful if Class 1 service has been agreed.')
fcFxPortClass2SeqDelivAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortClass2SeqDelivAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortClass2SeqDelivAgreed.setDescription('A variable indicating whether the FxPort has agreed to support Class 2 sequential delivery from the Fabric Login. This is only meaningful if Class 2 service has been agreed.')
fcFxPortClass3SeqDelivAgreed = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortClass3SeqDelivAgreed.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortClass3SeqDelivAgreed.setDescription('A flag indicating whether the FxPort has agreed to support Class 3 sequential delivery from the Fabric Login. This is only meaningful if Class 3 service has been agreed.')
fcFxPortNxPortName = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 12), FcPortName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortNxPortName.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortNxPortName.setDescription("The port name of the attached NxPort, if applicable. If the value of this object is '0000000000000000'H, this FxPort has no NxPort attached to it.")
fcFxPortConnectedNxPort = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 13), FcAddressId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortConnectedNxPort.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortConnectedNxPort.setDescription("The address identifier of the destination FxPort with which this FxPort is currently engaged in a either a Class 1 or loop connection. If the value of this object is '000000'H, this FxPort is not engaged in a connection.")
fcFxPortBbCreditModel = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 2, 4, 1, 14), FcBbCreditModel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortBbCreditModel.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortBbCreditModel.setDescription('This object identifies the BB_Credit model used by the FxPort. The regular model refers to the Buffer-to-Buffer flow control mechanism defined in FC-PH [1] is used between the F_Port and the N_Port. For FL_Ports, the Alternate Buffer-to-Buffer flow control mechanism as defined in FC-AL [4] is used between the FL_Port and any attached NL_Ports.')
fcFxPortErrorTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 3, 1), )
if mibBuilder.loadTexts: fcFxPortErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortErrorTable.setDescription('A table that contains, one entry for each FxPort, counters that record the numbers of errors detected.')
fcFxPortErrorEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortErrorModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortErrorFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortErrorEntry.setDescription('An entry containing error counters of a FxPort.')
fcFxPortErrorModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortErrorModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortErrorModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortErrorFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortErrorFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortErrorFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortLinkFailures = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortLinkFailures.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortLinkFailures.setDescription('The number of link failures detected by this FxPort.')
fcFxPortSyncLosses = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortSyncLosses.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortSyncLosses.setDescription('The number of loss of synchronization detected by the FxPort.')
fcFxPortSigLosses = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortSigLosses.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortSigLosses.setDescription('The number of loss of signal detected by the FxPort.')
fcFxPortPrimSeqProtoErrors = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortPrimSeqProtoErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortPrimSeqProtoErrors.setDescription('The number of primitive sequence protocol errors detected by the FxPort.')
fcFxPortInvalidTxWords = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortInvalidTxWords.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortInvalidTxWords.setDescription('The number of invalid transmission word detected by the FxPort.')
fcFxPortInvalidCrcs = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortInvalidCrcs.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortInvalidCrcs.setDescription('The number of invalid CRC detected by this FxPort.')
fcFxPortDelimiterErrors = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortDelimiterErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortDelimiterErrors.setDescription('The number of Delimiter Errors detected by this FxPort.')
fcFxPortAddressIdErrors = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortAddressIdErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortAddressIdErrors.setDescription('The number of address identifier errors detected by this FxPort.')
fcFxPortLinkResetIns = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortLinkResetIns.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortLinkResetIns.setDescription('The number of Link Reset Protocol received by this FxPort from the attached NxPort.')
fcFxPortLinkResetOuts = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortLinkResetOuts.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortLinkResetOuts.setDescription('The number of Link Reset Protocol issued by this FxPort to the attached NxPort.')
fcFxPortOlsIns = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortOlsIns.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOlsIns.setDescription('The number of Offline Sequence received by this FxPort.')
fcFxPortOlsOuts = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortOlsOuts.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortOlsOuts.setDescription('The number of Offline Sequence issued by this FxPort.')
fcFxPortC1AcctTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 4, 1), )
if mibBuilder.loadTexts: fcFxPortC1AcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1AcctTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, Class 1 accounting information recorded since the management agent has re-initialized.')
fcFxPortC1AcctEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC1AcctModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC1AcctFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortC1AcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1AcctEntry.setDescription('An entry containing Class 1 accounting information for each FxPort.')
fcFxPortC1AcctModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1AcctModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1AcctModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortC1AcctFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1AcctFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1AcctFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortC1InConnections = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1InConnections.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1InConnections.setDescription('The number of Class 1 connections successfully established in which the attached NxPort is the source of the connect-request.')
fcFxPortC1OutConnections = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1OutConnections.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1OutConnections.setDescription('The number of Class 1 connections successfully established in which the attached NxPort is the destination of the connect-request.')
fcFxPortC1FbsyFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1FbsyFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1FbsyFrames.setDescription('The number of F_BSY frames generated by this FxPort against Class 1 connect-request.')
fcFxPortC1FrjtFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1FrjtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1FrjtFrames.setDescription('The number of F_RJT frames generated by this FxPort against Class 1 connect-request.')
fcFxPortC1ConnTime = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1ConnTime.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1ConnTime.setDescription('The cumulative time that this FxPort has been engaged in Class 1 connection. The amount of time of each connection is counted in octets from after a connect- request has been accepted until the connection is disengaged, either by an EOFdt or Link Reset.')
fcFxPortC1InFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1InFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1InFrames.setDescription('The number of Class 1 frames (other than Class 1 connect-request) received by this FxPort from its attached NxPort.')
fcFxPortC1OutFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1OutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1OutFrames.setDescription('The number of Class 1 frames (other than Class 1 connect-request) delivered through this FxPort to its attached NxPort.')
fcFxPortC1InOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1InOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1InOctets.setDescription('The number of Class 1 frame octets, including the frame delimiters, received by this FxPort from its attached NxPort.')
fcFxPortC1OutOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1OutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1OutOctets.setDescription('The number of Class 1 frame octets, including the frame delimiters, delivered through this FxPort its attached NxPort.')
fcFxPortC1Discards = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC1Discards.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC1Discards.setDescription('The number of Class 1 frames discarded by this FxPort.')
fcFxPortC2AcctTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 4, 2), )
if mibBuilder.loadTexts: fcFxPortC2AcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2AcctTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, Class 2 accounting information recorded since the management agent has re-initialized.')
fcFxPortC2AcctEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC2AcctModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC2AcctFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortC2AcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2AcctEntry.setDescription('An entry containing Class 2 accounting information for each FxPort.')
fcFxPortC2AcctModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2AcctModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2AcctModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortC2AcctFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2AcctFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2AcctFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortC2InFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2InFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2InFrames.setDescription('The number of Class 2 frames received by this FxPort from its attached NxPort.')
fcFxPortC2OutFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2OutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2OutFrames.setDescription('The number of Class 2 frames delivered through this FxPort to its attached NxPort.')
fcFxPortC2InOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2InOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2InOctets.setDescription('The number of Class 2 frame octets, including the frame delimiters, received by this FxPort from its attached NxPort.')
fcFxPortC2OutOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2OutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2OutOctets.setDescription('The number of Class 2 frame octets, including the frame delimiters, delivered through this FxPort to its attached NxPort.')
fcFxPortC2Discards = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2Discards.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2Discards.setDescription('The number of Class 2 frames discarded by this FxPort.')
fcFxPortC2FbsyFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2FbsyFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2FbsyFrames.setDescription('The number of F_BSY frames generated by this FxPort against Class 2 frames.')
fcFxPortC2FrjtFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC2FrjtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC2FrjtFrames.setDescription('The number of F_RJT frames generated by this FxPort against Class 2 frames.')
fcFxPortC3AcctTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 4, 3), )
if mibBuilder.loadTexts: fcFxPortC3AcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3AcctTable.setDescription('A table that contains, one entry for each FxPort in the Fabric Element, Class 3 accounting information recorded since the management agent has re-initialized.')
fcFxPortC3AcctEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC3AcctModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortC3AcctFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortC3AcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3AcctEntry.setDescription('An entry containing Class 3 accounting information for each FxPort.')
fcFxPortC3AcctModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3AcctModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3AcctModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortC3AcctFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3AcctFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3AcctFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortC3InFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3InFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3InFrames.setDescription('The number of Class 3 frames received by this FxPort from its attached NxPort.')
fcFxPortC3OutFrames = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3OutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3OutFrames.setDescription('The number of Class 3 frames delivered through this FxPort to its attached NxPort.')
fcFxPortC3InOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3InOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3InOctets.setDescription('The number of Class 3 frame octets, including the frame delimiters, received by this FxPort from its attached NxPort.')
fcFxPortC3OutOctets = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3OutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3OutOctets.setDescription('The number of Class 3 frame octets, including the frame delimiters, delivered through this FxPort to its attached NxPort.')
fcFxPortC3Discards = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortC3Discards.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortC3Discards.setDescription('The number of Class 3 frames discarded by this FxPort.')
fcFxPortCapTable = MibTable((1, 3, 6, 1, 3, 42, 2, 1, 5, 1), )
if mibBuilder.loadTexts: fcFxPortCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapTable.setDescription('A table that contains, one entry for each FxPort, the capabilities of the port within the Fabric Element.')
fcFxPortCapEntry = MibTableRow((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1), ).setIndexNames((0, "FCFABRIC-ELEMENT-MIB", "fcFxPortCapModuleIndex"), (0, "FCFABRIC-ELEMENT-MIB", "fcFxPortCapFxPortIndex"))
if mibBuilder.loadTexts: fcFxPortCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapEntry.setDescription('An entry containing the capabilities of a FxPort.')
fcFxPortCapModuleIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 1), FcFeModuleIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapModuleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapModuleIndex.setDescription('This object identifies the module containing the FxPort for which this entry contains information.')
fcFxPortCapFxPortIndex = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 2), FcFeFxPortIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapFxPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapFxPortIndex.setDescription('This object identifies the FxPort within the module. This number ranges from 1 to the value of fcFeModulePortCapacity for the associated module. The value remains constant for the identified FxPort until the module is re-initialized.')
fcFxPortCapFcphVersionHigh = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 3), FcphVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapFcphVersionHigh.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapFcphVersionHigh.setDescription('The highest or most recent version of FC-PH that the FxPort is capable of supporting.')
fcFxPortCapFcphVersionLow = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 4), FcphVersion()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapFcphVersionLow.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapFcphVersionLow.setDescription('The lowest or earliest version of FC-PH that the FxPort is capable of supporting.')
fcFxPortCapBbCreditMax = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 5), FcBbCredit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapBbCreditMax.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapBbCreditMax.setDescription('The maximum number of receive buffers available for holding Class 1 connect-request, Class 2 or Class 3 frames from the attached NxPort.')
fcFxPortCapBbCreditMin = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 6), FcBbCredit()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapBbCreditMin.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapBbCreditMin.setDescription('The minimum number of receive buffers available for holding Class 1 connect-request, Class 2 or Class 3 frames from the attached NxPort.')
fcFxPortCapRxDataFieldSizeMax = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 7), FcRxDataFieldSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapRxDataFieldSizeMax.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapRxDataFieldSizeMax.setDescription('The maximum size in bytes of the Data Field in a frame that the FxPort is capable of receiving from its attached NxPort.')
fcFxPortCapRxDataFieldSizeMin = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 8), FcRxDataFieldSize()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapRxDataFieldSizeMin.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapRxDataFieldSizeMin.setDescription('The minimum size in bytes of the Data Field in a frame that the FxPort is capable of receiving from its attached NxPort.')
fcFxPortCapCos = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 9), FcCosCap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapCos.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapCos.setDescription('A value indicating the set of Classes of Service that the FxPort is capable of supporting.')
fcFxPortCapIntermix = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapIntermix.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapIntermix.setDescription('A flag indicating whether or not the FxPort is capable of supporting the intermixing of Class 2 and Class 3 frames during a Class 1 connection. This flag is only valid if the port is capable of supporting Class 1 service.')
fcFxPortCapStackedConnMode = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 11), FcStackedConnMode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapStackedConnMode.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapStackedConnMode.setDescription('A value indicating the mode of Stacked Connect request that the FxPort is capable of supporting.')
fcFxPortCapClass2SeqDeliv = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapClass2SeqDeliv.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapClass2SeqDeliv.setDescription('A flag indicating whether or not the FxPort is capable of supporting Class 2 Sequential Delivery.')
fcFxPortCapClass3SeqDeliv = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapClass3SeqDeliv.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapClass3SeqDeliv.setDescription('A flag indicating whether or not the FxPort is capable of supporting Class 3 Sequential Delivery.')
fcFxPortCapHoldTimeMax = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 14), MicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapHoldTimeMax.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapHoldTimeMax.setDescription('The maximum holding time (in microseconds) that the FxPort is capable of supporting.')
fcFxPortCapHoldTimeMin = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 15), MicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapHoldTimeMin.setStatus('mandatory')
if mibBuilder.loadTexts: fcFxPortCapHoldTimeMin.setDescription('The minimum holding time (in microseconds) that the FxPort is capable of supporting.')
fcFxPortCapBaudRates = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 16), Fc0BaudRateCap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapBaudRates.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortCapBaudRates.setDescription('A value indicating the set of baud rates that the FxPort is capable of supporting. This variable has been deprecated and may be implemented for backward compability.')
fcFxPortCapMedia = MibTableColumn((1, 3, 6, 1, 3, 42, 2, 1, 5, 1, 1, 17), Fc0MediaCap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fcFxPortCapMedia.setStatus('deprecated')
if mibBuilder.loadTexts: fcFxPortCapMedia.setDescription('A value indicating the set of media that the FxPort is capable of supporting. This variable has been deprecated and may be implemented for backward compability.')
mibBuilder.exportSymbols("FCFABRIC-ELEMENT-MIB", fcFxPortPhysFxPortIndex=fcFxPortPhysFxPortIndex, FcPortName=FcPortName, fcFeModuleObjectID=fcFeModuleObjectID, fcFxPortC2AcctFxPortIndex=fcFxPortC2AcctFxPortIndex, fcFxPortPrimSeqProtoErrors=fcFxPortPrimSeqProtoErrors, fcFxPortDistance=fcFxPortDistance, fcFxPortOperTable=fcFxPortOperTable, fcFxPortName=fcFxPortName, fcFxPortOlsOuts=fcFxPortOlsOuts, fcFxPortBbCreditAvailable=fcFxPortBbCreditAvailable, fcFxPortCapRxDataFieldSizeMin=fcFxPortCapRxDataFieldSizeMin, fcFxConfFxPortIndex=fcFxConfFxPortIndex, fcFxPortDelimiterErrors=fcFxPortDelimiterErrors, fcElementName=fcElementName, fcFxPortC1Discards=fcFxPortC1Discards, fcFxPortRxBufSize=fcFxPortRxBufSize, fcFxPortCapClass2SeqDeliv=fcFxPortCapClass2SeqDeliv, fcFxPortCapBbCreditMin=fcFxPortCapBbCreditMin, FcFeFxPortIndex=FcFeFxPortIndex, fcFxPortOperFxPortIndex=fcFxPortOperFxPortIndex, fcFxConfModuleIndex=fcFxConfModuleIndex, fcFxPortCapTable=fcFxPortCapTable, FcBbCredit=FcBbCredit, Fc0Medium=Fc0Medium, fcFxPortOperEntry=fcFxPortOperEntry, fcFxPortAdminMode=fcFxPortAdminMode, fcFxPortPhysOperStatus=fcFxPortPhysOperStatus, fcFxPortC3InOctets=fcFxPortC3InOctets, fcFxConfEntry=fcFxConfEntry, fcFxPortCapBaudRates=fcFxPortCapBaudRates, fcFxPortC1ConnTime=fcFxPortC1ConnTime, fcFxPortCapEntry=fcFxPortCapEntry, fcFxPortCapHoldTimeMin=fcFxPortCapHoldTimeMin, fcFxPortInvalidTxWords=fcFxPortInvalidTxWords, fcFxlogiEntry=fcFxlogiEntry, Fc0TxType=Fc0TxType, fcFxPortC2AcctTable=fcFxPortC2AcctTable, fcFxPortC2Discards=fcFxPortC2Discards, fcFxPortC2InOctets=fcFxPortC2InOctets, fcFxlogiNxPortIndex=fcFxlogiNxPortIndex, fcFxPortFcphVersionAgreed=fcFxPortFcphVersionAgreed, DisplayString=DisplayString, fcFxPortPhysRttov=fcFxPortPhysRttov, fcFPortConnectedPort=fcFPortConnectedPort, fcFeModuleName=fcFeModuleName, Fc0BaudRateCap=Fc0BaudRateCap, fcFxPortC1AcctEntry=fcFxPortC1AcctEntry, fcFxPortPhysLastChange=fcFxPortPhysLastChange, fcFPortAttachedPortName=fcFPortAttachedPortName, fcFxPortC3AcctEntry=fcFxPortC3AcctEntry, fcFxPortLinkResetOuts=fcFxPortLinkResetOuts, FcRxDataFieldSize=FcRxDataFieldSize, fcFxPortLinkResetIns=fcFxPortLinkResetIns, fcFxPortC1FrjtFrames=fcFxPortC1FrjtFrames, fcFxPortC1FbsyFrames=fcFxPortC1FbsyFrames, fcFxlogiTable=fcFxlogiTable, fcFxPortErrorModuleIndex=fcFxPortErrorModuleIndex, fcFxPortErrorTable=fcFxPortErrorTable, FcFeModuleIndex=FcFeModuleIndex, fcFeConfig=fcFeConfig, fcFxPortAddressIdErrors=fcFxPortAddressIdErrors, fcFxPortCapCos=fcFxPortCapCos, fcFxPortCapFcphVersionLow=fcFxPortCapFcphVersionLow, fcFxPortCosSuppAgreed=fcFxPortCosSuppAgreed, FabricName=FabricName, fcFxPortC2AcctModuleIndex=fcFxPortC2AcctModuleIndex, MicroSeconds=MicroSeconds, fcFeOp=fcFeOp, fcFxPortLinkFailures=fcFxPortLinkFailures, fcFeModuleOperStatus=fcFeModuleOperStatus, fcFxPortC3AcctModuleIndex=fcFxPortC3AcctModuleIndex, fcFxPortCapHoldTimeMax=fcFxPortCapHoldTimeMax, fcFeError=fcFeError, fcFxPortC1AcctModuleIndex=fcFxPortC1AcctModuleIndex, FcFeModuleCapacity=FcFeModuleCapacity, fcFe=fcFe, fcFxPortPhysEntry=fcFxPortPhysEntry, fcFxConfTable=fcFxConfTable, fcFxPortC1OutFrames=fcFxPortC1OutFrames, fcFxPortStackedConnMode=fcFxPortStackedConnMode, FcCosCap=FcCosCap, fcFxPortConnectedNxPort=fcFxPortConnectedNxPort, Fc0Distance=Fc0Distance, fcFxPortOperMode=fcFxPortOperMode, fcFxPortTxType=fcFxPortTxType, Fc0MediaCap=Fc0MediaCap, fcFxPortErrorEntry=fcFxPortErrorEntry, fcFxPortSigLosses=fcFxPortSigLosses, fcFxPortC2OutOctets=fcFxPortC2OutOctets, fcFxPortNxPortBbCredit=fcFxPortNxPortBbCredit, fcFabricName=fcFabricName, fcFxPortCapIntermix=fcFxPortCapIntermix, fcFxPortFcphVersionHigh=fcFxPortFcphVersionHigh, fcFxPortC3InFrames=fcFxPortC3InFrames, fcFxPortCapRxDataFieldSizeMax=fcFxPortCapRxDataFieldSizeMax, FcNameId=FcNameId, fcFxPortC2AcctEntry=fcFxPortC2AcctEntry, fcFxPortEdtov=fcFxPortEdtov, fcFxPortFcphVersionLow=fcFxPortFcphVersionLow, fcFeModuleTable=fcFeModuleTable, fcFxPortBbCredit=fcFxPortBbCredit, fcFxPortOperModuleIndex=fcFxPortOperModuleIndex, fcFxPortStackedConnModeAgreed=fcFxPortStackedConnModeAgreed, fcFxPortMedium=fcFxPortMedium, fcFxPortC1OutOctets=fcFxPortC1OutOctets, fcFxPortCosSupported=fcFxPortCosSupported, fcFxPortPhysModuleIndex=fcFxPortPhysModuleIndex, fcFxPortNxPortRxDataFieldSize=fcFxPortNxPortRxDataFieldSize, fcFabric=fcFabric, fcFxPortID=fcFxPortID, fcFxPortInvalidCrcs=fcFxPortInvalidCrcs, fcFxPortC3AcctTable=fcFxPortC3AcctTable, fcFeModuleFxPortCapacity=fcFeModuleFxPortCapacity, fcFxPortOlsIns=fcFxPortOlsIns, fcFxPortC1OutConnections=fcFxPortC1OutConnections, fcFxPortIntermixSuppAgreed=fcFxPortIntermixSuppAgreed, fcFeModuleIndex=fcFeModuleIndex, fcFxPortCapClass3SeqDeliv=fcFxPortCapClass3SeqDeliv, fcFxPortNxPortName=fcFxPortNxPortName, fcFxPortClass2SeqDeliv=fcFxPortClass2SeqDeliv, fcFxPortClass3SeqDelivAgreed=fcFxPortClass3SeqDelivAgreed, fcFxPortHoldTime=fcFxPortHoldTime, fcFxPortErrorFxPortIndex=fcFxPortErrorFxPortIndex, fcFxPortC1InOctets=fcFxPortC1InOctets, fcFxPortCapBbCreditMax=fcFxPortCapBbCreditMax, FcFxPortMode=FcFxPortMode, fcFxPortC2FrjtFrames=fcFxPortC2FrjtFrames, fcFxPortIntermixSupported=fcFxPortIntermixSupported, fcFxPortC3OutOctets=fcFxPortC3OutOctets, fcFxlogiFxPortIndex=fcFxlogiFxPortIndex, FcFeFxPortCapacity=FcFeFxPortCapacity, fcFxPortC1AcctFxPortIndex=fcFxPortC1AcctFxPortIndex, fcFxlogiModuleIndex=fcFxlogiModuleIndex, FcBbCreditModel=FcBbCreditModel, fcFxPortC3AcctFxPortIndex=fcFxPortC3AcctFxPortIndex, fcFxPortC2InFrames=fcFxPortC2InFrames, fcFxPortCapMedia=fcFxPortCapMedia, FcAddressId=FcAddressId, fcFxPortBaudRate=fcFxPortBaudRate, fcFxPortBbCreditModel=fcFxPortBbCreditModel, FcStackedConnMode=FcStackedConnMode, fcFxPortCapModuleIndex=fcFxPortCapModuleIndex, fcFxPortClass3SeqDeliv=fcFxPortClass3SeqDeliv, fcFeCap=fcFeCap, fcFxPortRatov=fcFxPortRatov, fcFxPortC2FbsyFrames=fcFxPortC2FbsyFrames, fcFxPortPhysTable=fcFxPortPhysTable, fcFxPortPhysAdminStatus=fcFxPortPhysAdminStatus, fcFxPortCapStackedConnMode=fcFxPortCapStackedConnMode, FcphVersion=FcphVersion, fcFxPortSyncLosses=fcFxPortSyncLosses, fcFxPortC3Discards=fcFxPortC3Discards, fcFeModuleDescr=fcFeModuleDescr, MilliSeconds=MilliSeconds, Fc0BaudRate=Fc0BaudRate, fcFxPortC1AcctTable=fcFxPortC1AcctTable, fcFxPortC1InConnections=fcFxPortC1InConnections, fcFeAcct=fcFeAcct, fcFxPortClass2SeqDelivAgreed=fcFxPortClass2SeqDelivAgreed, fibreChannel=fibreChannel, FcFeNxPortIndex=FcFeNxPortIndex, fcFxPortC2OutFrames=fcFxPortC2OutFrames, fcFeModuleLastChange=fcFeModuleLastChange, fcFeModuleEntry=fcFeModuleEntry, fcFxPortCapFxPortIndex=fcFxPortCapFxPortIndex, fcFeModuleCapacity=fcFeModuleCapacity, fcFxPortC3OutFrames=fcFxPortC3OutFrames, fcFxPortC1InFrames=fcFxPortC1InFrames, fcFxPortCapFcphVersionHigh=fcFxPortCapFcphVersionHigh)

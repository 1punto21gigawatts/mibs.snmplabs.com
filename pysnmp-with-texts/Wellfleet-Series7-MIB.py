#
# PySNMP MIB module Wellfleet-Series7-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-Series7-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:41:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Integer32, Counter64, Counter32, iso, Bits, NotificationType, IpAddress, enterprises, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ObjectIdentity, ModuleIdentity, Opaque, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Integer32", "Counter64", "Counter32", "iso", "Bits", "NotificationType", "IpAddress", "enterprises", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ObjectIdentity", "ModuleIdentity", "Opaque", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
wellfleet = MibIdentifier((1, 3, 6, 1, 4, 1, 18))
wfSwSeries7 = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3))
wfHardwareConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 1))
wfSoftwareConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 2))
wfSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3))
wfServices = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3, 2))
wfGameGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5))
wfLine = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4))
wfHwFGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 6))
wfDs1Group = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 12))
wfDs3Group = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 13))
wfSipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 14))
wfSipPlcpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2))
wfFddiGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15))
wfFddiSmtGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1))
wfFddiMacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2))
wfFddiPathGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 3))
wfFddiPortGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4))
wfApplication = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5))
wfDataLink = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1))
wfBridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1))
wfBrLearning = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1))
wfBrSourceRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2))
wfSpanningTree = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2))
wfIfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3))
wfCircuitOptsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4))
wfDecGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 2))
wfInternet = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3))
wfArpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1))
wfIpRouting = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2))
wfIpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1))
wfRipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2))
wfOspfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3))
wfEgpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 4))
wfBgpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 5))
wfTcpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 3))
wfUdpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 4))
wfSnmpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5))
wfTelnetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 7))
wfBootpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 8))
wfAppletalkGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 4))
wfIpxGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 5))
wfOsiGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 6))
wfVinesGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8))
wfWanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9))
wfFrameRelayGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1))
wfPppGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 2))
wfX25Group = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4))
wfAtmGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 5))
wfXnsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 10))
wfTestGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 11))
wfAppleBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1))
wfAppleBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseDelete.setDescription(' Create/Delete parameter for determining whether or not AppleTalk is configured on this slot. ')
wfAppleBaseDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleBaseDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseDisable.setDescription(' Enable/Disable parameter for determining whether or not to startup AppleTalk. ')
wfAppleBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpres", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseState.setDescription(' This parameter relfects the current state of AppleTalk. ')
wfAppleBaseDebugLevel = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleBaseDebugLevel.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseDebugLevel.setDescription(' Appletalk has control of what debug and info messages are printed. ')
wfAppleBaseDdpQueLen = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("default", 20))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleBaseDdpQueLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseDdpQueLen.setDescription(' Queue clipping is done on all packets destined for the port. This is the length of the queue. ')
wfAppleBaseHomedPort = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleBaseHomedPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseHomedPort.setDescription(' The circuit number of the port on which NBP will register this router. ')
wfAppleBaseTotalNets = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleBaseTotalNets.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseTotalNets.setDescription(' The circuit number of the port on which NBP will register this router. ')
wfAppleBaseTotalZones = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleBaseTotalZones.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleBaseTotalZones.setDescription(' The circuit number of the port on which NBP will register this router. ')
wfAppleRtmpTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2), )
if mibBuilder.loadTexts: wfAppleRtmpTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpTable.setDescription(" The table of elements of AppleTalk's routing RTMP table ")
wfAppleRtmpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfAppleRtmpNetStart"), (0, "Wellfleet-Series7-MIB", "wfAppleRtmpNetEnd"))
if mibBuilder.loadTexts: wfAppleRtmpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpEntry.setDescription(' An entry in the Routing table ')
wfAppleRtmpNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpNetStart.setDescription(' The destinatination network range of this route to which this entry pertains. The route is considered the best route to that network. There wil only be one route to a single destination. The address will be in the form of [network min - network max]. ')
wfAppleRtmpNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpNetEnd.setDescription(' The network max in the destination network range to which the routing entry pertains. ')
wfAppleRtmpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpPort.setDescription(' The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex. ')
wfAppleRtmpHops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpHops.setDescription(' The routing metric to get to this destination network. The measurement is in terms of hops. ')
wfAppleRtmpNextHopNet = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpNextHopNet.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpNextHopNet.setDescription(' The AppleTalk net of the next hop router for this route. ')
wfAppleRtmpNextHopNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleRtmpNextHopNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpNextHopNode.setDescription(' The AppleTalk node of the next hop router for this route. ')
wfAppleRtmpState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("good", 1), ("suspect", 2), ("goingbad", 3), ("bad", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleRtmpState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleRtmpState.setDescription(' The state of this routing entry: (G)ood, (S)uspect, (GB) GoingBad, or (B)ad. Setting this object to the value bad(4) has the effect of invalidating the corresponding entry in the RTMP table. ')
wfApplePortTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3), )
if mibBuilder.loadTexts: wfApplePortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortTable.setDescription(' The port descriptor table that describes the configuration parameters for this port of the AppleTalk Router. ')
wfApplePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfApplePortCircuit"))
if mibBuilder.loadTexts: wfApplePortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortEntry.setDescription(' An entry in the Port Descriptor table ')
wfApplePortDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDelete.setDescription(' Create/Delete parameter. Users perform an SNMP SET operation on this object to create/delete an AppleTalk interface. The default is create. ')
wfApplePortDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDisable.setDescription(' Enable/Disable parameter. Users perforn an SNMP SET operation on this object to enable/disable an AppleTalk interface. Default is enabled. ')
wfApplePortCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCircuit.setDescription(' The circuit number for this interface ')
wfApplePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortState.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortState.setDescription(' The current state of the AppleTalk port. ')
wfApplePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortType.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortType.setDescription(' The type for the port ')
wfApplePortCksumDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortCksumDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCksumDisable.setDescription(' Flag to enable/disable the calculation of the DDP checksum for packets sourced by the router over this interface. This value has no effect on incoming packets. ')
wfApplePortTrEndStation = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortTrEndStation.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortTrEndStation.setDescription(' When an interface is running token ring this attribute allows for end station source routing. If the interface is not running token ring the attribute has no meaning. ')
wfApplePortGniForever = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortGniForever.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortGniForever.setDescription(' During initialization default behavior is to send 3 GetNetInfos and then shut down the port. This will send GetNetInfos forever. ')
wfApplePortAarpFlush = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpFlush.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpFlush.setDescription(' Setting this to a non-null value causes the aarp table to be emptied of all entries. ')
wfApplePortMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortMacAddress.setDescription(' Configured mac address ')
wfApplePortNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNodeId.setDescription(' The AppleTalk node id configured for this port/interface. ')
wfApplePortNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNetwork.setDescription(' The Network NUMBER for this interface/port. ')
wfApplePortNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNetStart.setDescription(' The Network start value in the network range for this interface/port. ')
wfApplePortNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNetEnd.setDescription(' The Network end value in the network range for this interface/port. ')
wfApplePortDfltZone = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfApplePortDfltZone.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDfltZone.setDescription(' The default zone name for this network range/ interface. ')
wfApplePortCurMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurMacAddress.setDescription(' Mac Address used ')
wfApplePortCurNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurNodeId.setDescription(' The AppleTalk node id of this port ')
wfApplePortCurNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurNetwork.setDescription(' The network number for this port. ')
wfApplePortCurNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurNetStart.setDescription(' The Network start value in the network range for this port. ')
wfApplePortCurNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurNetEnd.setDescription(' The Network end value in the network range for this port. ')
wfApplePortCurDfltZone = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortCurDfltZone.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortCurDfltZone.setDescription(' The default zone name for this port ')
wfApplePortAarpProbeRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpProbeRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpProbeRxs.setDescription(' The number of AARP Probe packets received on this interface. ')
wfApplePortAarpProbeTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpProbeTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpProbeTxs.setDescription(' The number of AARP Probe packets transmitted on this interface. ')
wfApplePortAarpReqRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpReqRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpReqRxs.setDescription(' The number of AARP Request packets received on this interface. ')
wfApplePortAarpReqTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpReqTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpReqTxs.setDescription(' The number of AARP Request packets transmitted on this interface. ')
wfApplePortAarpRspRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpRspRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpRspRxs.setDescription(' The number of AARP Response packets received on this interface. ')
wfApplePortAarpRspTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortAarpRspTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortAarpRspTxs.setDescription(' The number of AARP Response packets transmitted on this interface. ')
wfApplePortDdpOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpOutRequests.setDescription(' The total number of DDP datagrams which were supplied to DDP by local DDP clients in requests for transmission. Note that this counter does not include any datagrams counted in ddpForwRequests. ')
wfApplePortDdpInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpInReceives.setDescription(' The total number of input datagrams received by DDP, including those received in error. ')
wfApplePortDdpInLocalDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpInLocalDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpInLocalDatagrams.setDescription(' The total number of input DDP datagrams for which this entity was their final DDP destination. ')
wfApplePortDdpNoProtocolHandlers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpNoProtocolHandlers.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpNoProtocolHandlers.setDescription(' The total number of DDP datagrams addressed to this entity that were addressed to an upper layer protocol for which no protocol handler existed. ')
wfApplePortDdpTooShortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpTooShortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpTooShortErrors.setDescription(' The total number of input DDP datagrams dropped because the received data length was less than the data length specified in the DDP header or the received data length was less than the length of the expected DDP header. ')
wfApplePortDdpTooLongErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpTooLongErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpTooLongErrors.setDescription(' The total number of input DDP datagrams dropped because the received data length was greater than the data length specified in the DDP header or because they exceeded the maximum DDP datagram size. ')
wfApplePortDdpChecksumErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpChecksumErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpChecksumErrors.setDescription(' The total number of input DDP datagrams for which this DDP entity was their final destination, and which were dropped because of a checksum error. ')
wfApplePortDdpForwRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpForwRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpForwRequests.setDescription(' The number of input datagrams for which this entity was not their final DDP destination, as a result of which an attempt was made to find a route to forward them to that final destination. ')
wfApplePortDdpOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpOutNoRoutes.setDescription(' The total number of DDP datagrams dropped because a route could not be found to their final destination. ')
wfApplePortDdpBroadcastErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpBroadcastErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpBroadcastErrors.setDescription(' The total number of input DDP datagrams dropped because this entity was not their final destination and they were addressed to the link level broadcast. ')
wfApplePortDdpHopCountErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortDdpHopCountErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortDdpHopCountErrors.setDescription(' The total number of input DDP datagrams dropped because this entity was not their final destination and their hop count would exceed 15. ')
wfApplePortRtmpInDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpInDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpInDataPkts.setDescription(' A count of the number of good RTMP data packets received by this entity. ')
wfApplePortRtmpOutDataPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpOutDataPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpOutDataPkts.setDescription(' A count of the number of RTMP packets sent by this entity. ')
wfApplePortRtmpInRequestPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpInRequestPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpInRequestPkts.setDescription(' A count of the number of good RTMP Request packets received by this entity. ')
wfApplePortRtmpNextIREqualChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpNextIREqualChanges.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpNextIREqualChanges.setDescription(' A count of the number of times RTMP changes the Next Internet Router in a routing entry because the hop count advertised in a routing tuple was equal to the current hop count for a particular network. ')
wfApplePortRtmpNextIRLessChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpNextIRLessChanges.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpNextIRLessChanges.setDescription(' A count of the number of times RTMP changes the Next Internet Router in a routing entry because the hop count advertised in a routing tuple was less than the current hop count for a particular network. ')
wfApplePortRtmpRouteDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpRouteDeletes.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpRouteDeletes.setDescription(' A count of the number of times RTMP deletes a route because it was aged out of the table. This can help to detect routing problems. ')
wfApplePortRtmpNetworkMismatchErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpNetworkMismatchErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpNetworkMismatchErrors.setDescription(' The number of times RTMP receives a Data packet from a router who claims to be on a different network than that configured for the receiving port. This can help to detect configuration errors. ')
wfApplePortRtmpRoutingTableOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortRtmpRoutingTableOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortRtmpRoutingTableOverflows.setDescription(' The number of times RTMP attempted to add a route to the RTMP table but failed due to overflow. ')
wfApplePortZipInZipQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInZipQueries.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInZipQueries.setDescription(' The number of ZIP Queries received by this entity. ')
wfApplePortZipInZipReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInZipReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInZipReplies.setDescription(' The number of ZIP Replies received by this entity. ')
wfApplePortZipOutZipReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutZipReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutZipReplies.setDescription(' The number of ZIP Replies sent by this entity. ')
wfApplePortZipInZipExtendedReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInZipExtendedReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInZipExtendedReplies.setDescription(' The number of ZIP Extended Replies received by this entity. ')
wfApplePortZipOutZipExtendedReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutZipExtendedReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutZipExtendedReplies.setDescription(' The number of ZIP Extended Replies sent by this entity. ')
wfApplePortZipInGetZoneLists = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInGetZoneLists.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInGetZoneLists.setDescription(' The number of ZIP GetZoneList transactions received by this entity. ')
wfApplePortZipOutGetZoneListReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutGetZoneListReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutGetZoneListReplies.setDescription(' The number of ZIP GetZoneListReply transactions sent by this entity. ')
wfApplePortZipInGetLocalZones = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInGetLocalZones.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInGetLocalZones.setDescription(' The number of ZIP GetLocalZone transactions received by this entity. ')
wfApplePortZipOutGetLocalZoneReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutGetLocalZoneReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutGetLocalZoneReplies.setDescription(' The number of ZIP GetLocalZoneReply transactions sent by this entity. ')
wfApplePortZipInGetMyZones = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInGetMyZones.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInGetMyZones.setDescription(' The number of ZIP GetMyZone transactions received by this entity. ')
wfApplePortZipOutGetMyZoneReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutGetMyZoneReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutGetMyZoneReplies.setDescription(' The number of ZIP GetMyZoneReply transactions sent by this entity. ')
wfApplePortZipZoneConflictErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipZoneConflictErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipZoneConflictErrors.setDescription(" The number of times a conflict has been detected between this entity's zone information and another entity's zone information. ")
wfApplePortZipInGetNetInfos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInGetNetInfos.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInGetNetInfos.setDescription(' The number of ZIP GetNetInfo packets received on this port by this entity. ')
wfApplePortZipOutGetNetInfoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutGetNetInfoReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutGetNetInfoReplies.setDescription(' The number of ZIP GetNetInfoReply packets sent out this port by this entity. ')
wfApplePortZipZoneOutInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipZoneOutInvalids.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipZoneOutInvalids.setDescription(' The number of times this entity has sent a ZIP GetNetInfo Reply with the zone invalid bit set in response to a GetNetInfo Request with an invalid zone name. ')
wfApplePortZipAddressInvalids = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipAddressInvalids.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipAddressInvalids.setDescription(' The number of times this entity had to broadcast a ZIP GetNetInfo Reply because the GetNetInfo Request had an invalid address. ')
wfApplePortZipOutGetNetInfos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutGetNetInfos.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutGetNetInfos.setDescription(' The number of ZIP GetNetInfo packets sent out this port by this entity. ')
wfApplePortZipInGetNetInfoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInGetNetInfoReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInGetNetInfoReplies.setDescription(' The number of ZIP GetNetInfoReply packets received on this port by this entity. ')
wfApplePortZipOutZipQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipOutZipQueries.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipOutZipQueries.setDescription(' The number of ZIP Queries sent by this entity. ')
wfApplePortZipInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortZipInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortZipInErrors.setDescription(' The number of ZIP packets received by this entity that were rejected for any error. ')
wfApplePortNbpInLookUpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpInLookUpRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpInLookUpRequests.setDescription(' The number of NBP LookUp Requests received. ')
wfApplePortNbpInLookUpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpInLookUpReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpInLookUpReplies.setDescription(' The number of NBP LookUp Replies received. ')
wfApplePortNbpInBroadcastRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpInBroadcastRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpInBroadcastRequests.setDescription(' The number of NBP Broadcast Requests received. ')
wfApplePortNbpInForwardRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 70), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpInForwardRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpInForwardRequests.setDescription(' The number of NBP Forward Requests received. ')
wfApplePortNbpOutLookUpRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 71), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpOutLookUpRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpOutLookUpRequests.setDescription(' The number of NBP LookUp Requests sent. ')
wfApplePortNbpOutLookUpReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 72), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpOutLookUpReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpOutLookUpReplies.setDescription(' The number of NBP LookUp Replies sent. ')
wfApplePortNbpOutBroadcastRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 73), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpOutBroadcastRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpOutBroadcastRequests.setDescription(' The number of NBP Broadcast Requests sent. ')
wfApplePortNbpOutForwardRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 74), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpOutForwardRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpOutForwardRequests.setDescription(' The number of NBP Forward Requests sent. ')
wfApplePortNbpRegistrationFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 75), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpRegistrationFailures.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpRegistrationFailures.setDescription(' The number of times this node experienced a failure in attempting to register an NBP entity. ')
wfApplePortNbpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 76), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortNbpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortNbpInErrors.setDescription(' The number of NBP packets received by this entity that were rejected for any error. ')
wfApplePortEchoRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 77), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortEchoRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortEchoRequests.setDescription(' The number of AppleTalk Echo requests received. ')
wfApplePortEchoReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 3, 1, 78), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfApplePortEchoReplies.setStatus('mandatory')
if mibBuilder.loadTexts: wfApplePortEchoReplies.setDescription(' The number of AppleTalk Echo replies sent. ')
wfAppleLclZoneTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4), )
if mibBuilder.loadTexts: wfAppleLclZoneTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZoneTable.setDescription(' The Local Zone table describes a list of zone names s serviced by a particular AppleTalk port/interface. In other words, the list of zone names that are associated with a particular network range. ')
wfAppleLclZoneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfAppleLclZonePortCircuit"), (0, "Wellfleet-Series7-MIB", "wfAppleLclZoneIndex"))
if mibBuilder.loadTexts: wfAppleLclZoneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZoneEntry.setDescription(' An entry in the Local Zone table ')
wfAppleLclZoneDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleLclZoneDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZoneDelete.setDescription(' Create/Delete parameter for adding/deleting a zone name to the Local Zone List for a particular AppleTalk network interface. ')
wfAppleLclZonePortCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleLclZonePortCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZonePortCircuit.setDescription(' The circuit number for the corresponding AppleTalk interface /port for this zone list. ')
wfAppleLclZoneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleLclZoneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZoneIndex.setDescription(' A unique value for this zone name. ')
wfAppleLclZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAppleLclZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleLclZoneName.setDescription(' One of the local zone names defined for this/ interface. ')
wfAppleAarpTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5), )
if mibBuilder.loadTexts: wfAppleAarpTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpTable.setDescription(' The AppleTalk Address Translation table contains a mapping of AppleTalk Network addresses to its corresponding physical address. ')
wfAppleAarpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfAppleAarpNet"), (0, "Wellfleet-Series7-MIB", "wfAppleAarpNode"), (0, "Wellfleet-Series7-MIB", "wfAppleAarpIfIndex"))
if mibBuilder.loadTexts: wfAppleAarpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpEntry.setDescription(' An entry in the Address Mapping table ')
wfAppleAarpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleAarpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpIfIndex.setDescription(' The unique value for this interface/cct. This value is the same interface as identified by the value of ifIndex. ')
wfAppleAarpNet = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleAarpNet.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpNet.setDescription(" The host's AppleTalk address (Net.Nodeid). This address corresponds to the media-dependent 'physical' address for this host. ")
wfAppleAarpNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleAarpNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpNode.setDescription(" The host's AppleTalk address (Net.Nodeid). This address corresponds to the media-dependent 'physical' address for this host. ")
wfAppleAarpPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleAarpPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleAarpPhysAddress.setDescription(" The media-dependent 'physical' address. ")
wfAppleZipTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6), )
if mibBuilder.loadTexts: wfAppleZipTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipTable.setDescription(' The Zone Information table for reachable AppleTalk Networks. ')
wfAppleZipEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfAppleZipZoneNetStart"), (0, "Wellfleet-Series7-MIB", "wfAppleZipIndex"))
if mibBuilder.loadTexts: wfAppleZipEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipEntry.setDescription(' An entry in the Zone Information table ')
wfAppleZipZoneNetStart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleZipZoneNetStart.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipZoneNetStart.setDescription(' The network that starts the range for this entry. ')
wfAppleZipZoneNetEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleZipZoneNetEnd.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipZoneNetEnd.setDescription(' The network that ends the range for this entry. ')
wfAppleZipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleZipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipIndex.setDescription(' The unique value for this zone name. ')
wfAppleZipZoneName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleZipZoneName.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipZoneName.setDescription(' The ASCII xone name of this entry. ')
wfAppleZipZoneState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 4, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfAppleZipZoneState.setStatus('mandatory')
if mibBuilder.loadTexts: wfAppleZipZoneState.setDescription(' The state of the ZIP entry. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ZipTable. It effectively, disassociates the mapping identified with this entry. ')
wfBrTp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 1))
wfBrTpBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTpBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the bridge. ')
wfBrTpBaseEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTpBaseEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseEnable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable the bridge. ')
wfBrTpBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("pres", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseState.setDescription(' The current state of the entire Bridge. ')
wfBrTpFdbTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 2), )
if mibBuilder.loadTexts: wfBrTpFdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpFdbTable.setDescription(' A table that contains information about unicast entries for which the bridge has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame. inst = wfBrTpBaseFdbAddress ')
wfBrTpFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrTpBaseFdbAddress"))
if mibBuilder.loadTexts: wfBrTpFdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpFdbEntry.setDescription(' An entry in the wfBrTpFdbTable. ')
wfBrTpBaseFdbAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpBaseFdbAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseFdbAddress.setDescription(' A unicast MAC address for which the bridge has forwarding and/or filtering information. ')
wfBrTpBaseFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpBaseFdbPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseFdbPort.setDescription(' The port number on which the wfBrTpBaseFdbAddress was learned. ')
wfBrTpBaseFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpBaseFdbStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpBaseFdbStatus.setDescription(' The status of this entry. The meanings of the values are: learned(3) : the value of the corresponding instance of wfBrTpFdbPort was learned, and is being used. ')
wfBrTpInterface = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3), )
if mibBuilder.loadTexts: wfBrTpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterface.setDescription(' A table that contains information about every interface that is associated with this transparent bridge. inst_id[1] = wfBrTpInterfaceCircuit ')
wfBrTpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrTpInterfaceCircuit"))
if mibBuilder.loadTexts: wfBrTpInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceEntry.setDescription(' An entry in wfBrTpInterface. ')
wfBrTpInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTpInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an interface. ')
wfBrTpInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTpInterfaceEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceEnable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an interface. ')
wfBrTpInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("pres", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceState.setDescription(' The current state of the interface. ')
wfBrTpInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceCircuit.setDescription(' The circuit that this interface runs over. ')
wfBrTpInterfaceMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceMaxInfo.setDescription(' The maximum size of the INFO (non-MAC) field that this port will receive or transmit. ')
wfBrTpInterfaceInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceInFrames.setDescription(' The number of frames that have been received by this interface from its circuit. ')
wfBrTpInterfaceOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceOutFrames.setDescription(' The number of frames that have been transmitted by this interface to its circuit. ')
wfBrTpInterfaceInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTpInterfaceInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTpInterfaceInDiscards.setDescription(' Count of valid frames received which were received on this interface but then discarded. ')
wfBrTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4), )
if mibBuilder.loadTexts: wfBrTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterTable.setDescription(' Bridge Traffic Filters ')
wfBrTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfBrTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfBrTrafficFilterFragment"))
if mibBuilder.loadTexts: wfBrTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterEntry.setDescription(' An entry in WfBrTrafficFilterTable. ')
wfBrTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfBrTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfBrTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfBrTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfBrTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 5), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfBrTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 6), Integer32())
if mibBuilder.loadTexts: wfBrTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterReserved.setDescription(' Reserved field. ')
wfBrTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterCircuit.setDescription(' The ID of the Bridge Circuit to which the filter is applied. ')
wfBrTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfBrTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 4, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfCctOptsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1), )
if mibBuilder.loadTexts: wfCctOptsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsTable.setDescription(' The table of circuit names ')
wfCctOptsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCctOptsCct"))
if mibBuilder.loadTexts: wfCctOptsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsEntry.setDescription(' Entry format for the table of circuit options ')
wfCctOptsDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsDelete.setDescription(' Creation and deletion flag for this record ')
wfCctOptsPriorityQueueingDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsPriorityQueueingDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsPriorityQueueingDisable.setDescription(' Priority Queuing option ')
wfCctOptsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsCct.setDescription(' circuit number ')
wfCctOptsHighPriorityQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("default", 20))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsHighPriorityQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsHighPriorityQueueLimit.setDescription(' High Priority Queue limit The minimum valid value is zero. The maximum valid value is 63 (HW xmit ring size) minus the sum of the Normal and Low queue limits. ')
wfCctOptsNormalPriorityQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("default", 20))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsNormalPriorityQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsNormalPriorityQueueLimit.setDescription(' Normal Priority Queue limit The minimum valid value is zero. The maximum valid value is 63 (HW xmit ring size) minus the sum of the High and Low queue limits. ')
wfCctOptsLowPriorityQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(20))).clone(namedValues=NamedValues(("default", 20))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLowPriorityQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLowPriorityQueueLimit.setDescription(' Low Priority Queue limit The minimum valid value is zero. The maximum valid value is 63 (HW xmit ring size) minus the sum of the High and Normal queue limits. ')
wfCctOptsMaxInterruptQueueLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 2500, 5000))).clone(namedValues=NamedValues(("minimum", 100), ("default", 2500), ("maximum", 5000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsMaxInterruptQueueLatency.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsMaxInterruptQueueLatency.setDescription(' Interrupt Queue Latency ')
wfCctOptsMaxHighPriorityQueueLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 250, 5000))).clone(namedValues=NamedValues(("minimum", 100), ("default", 250), ("maximum", 5000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsMaxHighPriorityQueueLatency.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsMaxHighPriorityQueueLatency.setDescription(' High Priority Queue Latency ')
wfCctOptsHiXmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsHiXmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsHiXmits.setDescription(' High Priority Transmit count ')
wfCctOptsNormalXmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsNormalXmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsNormalXmits.setDescription(' Normal Priority Transmit count ')
wfCctOptsLoXmits = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLoXmits.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLoXmits.setDescription(' Low Priority Transmit count ')
wfCctOptsHiClippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsHiClippedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsHiClippedPkts.setDescription(' High Prio Transmit Clip Count ')
wfCctOptsNormalClippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsNormalClippedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsNormalClippedPkts.setDescription(' Normal Prio Transmit Clip Count ')
wfCctOptsLoClippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLoClippedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLoClippedPkts.setDescription(' Low Prio Transmit Clip Count ')
wfCctOptsIntrQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIntrQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIntrQHighWaterPkts.setDescription(' Interrupt Queue high-water mark ')
wfCctOptsHiQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsHiQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsHiQHighWaterPkts.setDescription(' High-priority Queue high-water mark ')
wfCctOptsNormalQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsNormalQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsNormalQHighWaterPkts.setDescription(' Normal Queue high-water mark ')
wfCctOptsLoQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLoQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLoQHighWaterPkts.setDescription(' Low-priority Queue high-water mark ')
wfCctOptsHighWaterPktsClear = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsHighWaterPktsClear.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsHighWaterPktsClear.setDescription(' Attribute to clear the high-water marks. When the MIB changes, Priority Queueing (if ENABLED) checks to see if HighWaterPktsClear is different than the last time the MIB was modified in any way. If it is different, all the high water marks (see above) are set to zero. ')
wfCctOptsDroppedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsDroppedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsDroppedPkts.setDescription(' Packets which were filtered in Priority Queueing ')
wfCctOptsLargePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLargePkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLargePkts.setDescription(' Large Packets which became an exception to latency rules ')
wfCctOptsRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsRxPkts.setDescription(' Packets received ')
wfCctOptsBrFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2), )
if mibBuilder.loadTexts: wfCctOptsBrFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterTable.setDescription(' Bridge Filters ')
wfCctOptsBrFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCctOptsBrFilterCct"), (0, "Wellfleet-Series7-MIB", "wfCctOptsBrFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfCctOptsBrFilterFragment"))
if mibBuilder.loadTexts: wfCctOptsBrFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterEntry.setDescription(' An entry in WfCctOptsBrFilterTable. ')
wfCctOptsBrFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsBrFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfCctOptsBrFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsBrFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfCctOptsBrFilterState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsBrFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterState.setDescription(' Defines the current State of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfCctOptsBrFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsBrFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfCctOptsBrFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsBrFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterDefinition.setDescription(' The filter rule definition. ')
wfCctOptsBrFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 6), Integer32())
if mibBuilder.loadTexts: wfCctOptsBrFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterReserved.setDescription(' Reserved field. ')
wfCctOptsBrFilterCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsBrFilterCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterCct.setDescription(' The ID of the CctBridge Cct to which the filter is applied. ')
wfCctOptsBrFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsBrFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterRuleNumber.setDescription(' ID for the rule. ')
wfCctOptsBrFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsBrFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsBrFilterFragment.setDescription(' Fragment number - for large rules. ')
wfCctOptsIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3), )
if mibBuilder.loadTexts: wfCctOptsIpFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterTable.setDescription(' Ip Filters ')
wfCctOptsIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCctOptsIpFilterCct"), (0, "Wellfleet-Series7-MIB", "wfCctOptsIpFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfCctOptsIpFilterFragment"))
if mibBuilder.loadTexts: wfCctOptsIpFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterEntry.setDescription(' An entry in WfCctOptsIpFilterTable. ')
wfCctOptsIpFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsIpFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfCctOptsIpFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsIpFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfCctOptsIpFilterState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIpFilterState.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterState.setDescription(' Defines the current State of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfCctOptsIpFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIpFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfCctOptsIpFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsIpFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterDefinition.setDescription(' The filter rule definition. ')
wfCctOptsIpFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 6), Integer32())
if mibBuilder.loadTexts: wfCctOptsIpFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterReserved.setDescription(' Reserved field. ')
wfCctOptsIpFilterCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIpFilterCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterCct.setDescription(' The ID of the CctIp Cct to which the filter is applied. ')
wfCctOptsIpFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIpFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterRuleNumber.setDescription(' ID for the rule. ')
wfCctOptsIpFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsIpFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsIpFilterFragment.setDescription(' Fragment number - for large rules. ')
wfCctOptsLengthBasedTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4), )
if mibBuilder.loadTexts: wfCctOptsLengthBasedTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedTable.setDescription(' Length Based Priority Table ')
wfCctOptsLengthBasedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCctOptsLengthBasedCct"), (0, "Wellfleet-Series7-MIB", "wfCctOptsLengthBasedMux"), (0, "Wellfleet-Series7-MIB", "wfCctOptsLengthBasedData"))
if mibBuilder.loadTexts: wfCctOptsLengthBasedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedEntry.setDescription(' An entry in WfCctOptsLengthBasedTable. ')
wfCctOptsLengthBasedDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLengthBasedDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedDelete.setDescription(' Defines the existence of the length based priority filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfCctOptsLengthBasedDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLengthBasedDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedDisable.setDescription(' Defines whether or not the length based priority filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfCctOptsLengthBasedState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLengthBasedState.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedState.setDescription(' Defines the current State of the length based priority filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfCctOptsLengthBasedCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLengthBasedCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedCct.setDescription(' The ID of the Cct to which the filter is applied ')
wfCctOptsLengthBasedMux = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("etype", 1), ("lsap", 2), ("snap", 3))).clone('etype')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLengthBasedMux.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedMux.setDescription(' packet mux type ')
wfCctOptsLengthBasedData = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCctOptsLengthBasedData.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedData.setDescription(' a five byte quantity of the form ethernet - 0x6003000000 (e.g. DECnet) lsap - 0xfefe030000 (e.g. OSI) snap - 0x0000000800 (e.g. IP) - 0x0800070800 (e.g. Appletalk DDP) ')
wfCctOptsLengthBasedLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLengthBasedLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedLength.setDescription(' Maximum length of a packet to be considered high priority ')
wfCctOptsLengthBasedLessThanQ = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 1))).clone(namedValues=NamedValues(("hi", 3), ("normal", 2), ("lo", 1))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLengthBasedLessThanQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedLessThanQ.setDescription(' queue into which packets of length less than or equal wfCctOptsLengthBasedLength are placed ')
wfCctOptsLengthBasedGreaterThanQ = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 2, 1))).clone(namedValues=NamedValues(("hi", 3), ("normal", 2), ("lo", 1))).clone('lo')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCctOptsLengthBasedGreaterThanQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfCctOptsLengthBasedGreaterThanQ.setDescription(' queue into which packets of length greater than wfCctOptsLengthBasedLength are placed ')
wfCircuitNameTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3), )
if mibBuilder.loadTexts: wfCircuitNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitNameTable.setDescription(' The table of circuit names ')
wfCircuitNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCircuitNumber"))
if mibBuilder.loadTexts: wfCircuitNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitNameEntry.setDescription(' Entry format for the table of circuit names ')
wfCircuitNameDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCircuitNameDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitNameDelete.setDescription(' Creation and deletion flag for this record ')
wfCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitNumber.setDescription(' circuit number ')
wfCircuitName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCircuitName.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitName.setDescription(' circuit name ')
wfCircuitIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(10, 20, 30, 40, 50, 60, 70))).clone(namedValues=NamedValues(("csmacd", 10), ("sync", 20), ("t1", 30), ("e1", 40), ("token", 50), ("fddi", 60), ("hssi", 70)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCircuitIfType.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitIfType.setDescription(' circuit interface type ')
wfCircuitProtoMap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCircuitProtoMap.setStatus('mandatory')
if mibBuilder.loadTexts: wfCircuitProtoMap.setDescription(' The Circuit-Protocol mask ')
wfConsole = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1))
wfBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 1), Integer32().clone(9600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: wfBaudRate.setDescription(' Baud rate configured on the Technician Interface console ')
wfDataBits = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 2), Integer32().clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDataBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfDataBits.setDescription(' Number of data bits configured on the Technician Interface console ')
wfParity = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("odd", 2), ("even", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfParity.setStatus('mandatory')
if mibBuilder.loadTexts: wfParity.setDescription(' Type of parity configured on the Technician Interface console ')
wfStopBits = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s1bit", 1), ("s15bit", 2), ("s2bit", 3))).clone('s1bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfStopBits.setStatus('mandatory')
if mibBuilder.loadTexts: wfStopBits.setDescription(' Number of stop bits configured on the Technician Interface console ')
wfModemEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfModemEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfModemEnable.setDescription(' Enable the Technician Interface console to run over a modem ')
wfLinesPerScreen = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 6), Integer32().clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLinesPerScreen.setStatus('mandatory')
if mibBuilder.loadTexts: wfLinesPerScreen.setDescription(' Number of lines which can be displayed in one screen on the Technician Interface console ')
wfMoreEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMoreEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfMoreEnable.setDescription(" Enable the 'more' feature on the Technician Interface console ")
wfPrompt = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfPrompt.setStatus('mandatory')
if mibBuilder.loadTexts: wfPrompt.setDescription(' Character string which will be used as the system prompt on the Technician Interface console ')
wfLoginTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 99), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLoginTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfLoginTimeOut.setDescription(' IF MODEM_ENABLED then time out in minutes to HUP when at the login prompt ')
wfPasswordTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 99), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfPasswordTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfPasswordTimeOut.setDescription(' Timout on Password entry ')
wfCommandTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99, 15))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 99), ("default", 15))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCommandTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfCommandTimeOut.setDescription(' IF MODEM_ENABLED then time out in minutes to HUP when at the command prompt ')
wfLoginRetries = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 99, 3))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 99), ("default", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLoginRetries.setStatus('mandatory')
if mibBuilder.loadTexts: wfLoginRetries.setDescription(' IF MODEM_ENABLED then limit # of login attempts then HUP ')
wfTotalLogins = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTotalLogins.setStatus('mandatory')
if mibBuilder.loadTexts: wfTotalLogins.setDescription(' Total number of TI login attempts ')
wfUserLoginErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfUserLoginErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfUserLoginErrors.setDescription(' Total number of FAILED User login attempts ')
wfManagerLoginErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfManagerLoginErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfManagerLoginErrors.setDescription(' Total number of FAILED Manager login attempts ')
wfOtherLoginErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOtherLoginErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfOtherLoginErrors.setDescription(' Total number of FAILED Other login attempts ')
wfTtyFrameErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTtyFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTtyFrameErrors.setDescription(' Count of TTY Frame errors ')
wfTtyOverrunErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTtyOverrunErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTtyOverrunErrors.setDescription(' Count of TTY Overrun errors ')
wfTtyParityErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTtyParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTtyParityErrors.setDescription(' Count of TTY Parity errors ')
wfTtyInfifoErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTtyInfifoErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTtyInfifoErrors.setDescription(' Count of TTY Input Fifo errors ')
wfCSMACDTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 1), )
if mibBuilder.loadTexts: wfCSMACDTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDTable.setDescription(' CSMA/CD line record ')
wfCSMACDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfCSMACDSlot"), (0, "Wellfleet-Series7-MIB", "wfCSMACDConnector"))
if mibBuilder.loadTexts: wfCSMACDEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDEntry.setDescription(' An entry in the csmacd table ')
wfCSMACDDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDDelete.setDescription(' create/delete parameter, dflt = created ')
wfCSMACDEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDEnable.setDescription(' enable/disable parameter, dflt = enabled ')
wfCSMACDState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDState.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDState.setDescription(' line driver state variable, Not Present, Init, Down, Up ')
wfCSMACDSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDSlot.setDescription(' instance ID Slot, filled in by driver ')
wfCSMACDConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDConnector.setDescription(' instance ID Connector, filled in by driver ')
wfCSMACDCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDCct.setDescription(' cct number for this line instance ')
wfCSMACDBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDBofl.setDescription(' bofl parameter, dflt = enabled ')
wfCSMACDBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 60, 5))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 60), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDBoflTmo.setDescription(' bofl parameter, dflt = 5 ')
wfCSMACDMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1518))).clone(namedValues=NamedValues(("default", 1518))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDMtu.setDescription(' mtu parameter, fixed ')
wfCSMACDMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDMadr.setDescription(' line MAC address, fixed - line driver fills in ')
wfCSMACDOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDOctetsRxOk.setDescription(' Number of octets received without error ')
wfCSMACDFramesRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDFramesRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDFramesRxOk.setDescription(' Number of frames received without error ')
wfCSMACDOctetsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDOctetsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDOctetsTxOk.setDescription(' Number of octets transmitted without error ')
wfCSMACDFramesTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDFramesTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDFramesTxOk.setDescription(' Number of frames transmitted without error ')
wfCSMACDDeferredTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDDeferredTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDDeferredTx.setDescription(' Number of deferred transmissions ')
wfCSMACDLateCollnTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDLateCollnTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDLateCollnTx.setDescription(' Number of late collisions ')
wfCSMACDExcessvCollnTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDExcessvCollnTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDExcessvCollnTx.setDescription(' Number of excessive collisions ')
wfCSMACDBablErrorTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDBablErrorTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDBablErrorTx.setDescription(' Number of frames transmitted larger than 1518 octets ')
wfCSMACDBufErrorTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDBufErrorTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDBufErrorTx.setDescription(' Number of internal buffer errors ')
wfCSMACDLcarTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDLcarTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDLcarTx.setDescription(' Number of loss of carrier errors ')
wfCSMACDUfloTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDUfloTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDUfloTx.setDescription(' Number of transmitter underflow errors ')
wfCSMACDFcsErrorRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDFcsErrorRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDFcsErrorRx.setDescription(' Number of receiver checksum errors ')
wfCSMACDAlignErrorRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDAlignErrorRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDAlignErrorRx.setDescription(' Number of receiver alignment errors ')
wfCSMACDLackRescErrorRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDLackRescErrorRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDLackRescErrorRx.setDescription(' Number of receiver lack of resource errors ')
wfCSMACDTooLongErrorRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDTooLongErrorRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDTooLongErrorRx.setDescription(' Number of frames received exceeding 1518 octets ')
wfCSMACDOfloRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDOfloRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDOfloRx.setDescription(' Number of receiver overflow errors ')
wfCSMACDMerr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDMerr.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDMerr.setDescription(' Number of internal memory errors ')
wfCSMACDCerr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDCerr.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDCerr.setDescription(' Number of collision errors ')
wfCSMACDHardwareFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDHardwareFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDHardwareFilter.setDescription(' Hardware filtering parameter. ')
wfCSMACDTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 32))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 32))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDTxQueueLength.setDescription(' Transmit Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfCSMACDRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 32))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 32))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfCSMACDRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDRxQueueLength.setDescription(' Receive Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfCSMACDTxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDTxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDTxClipFrames.setDescription(" Number of frames clipped in driver's transmit routine due to transmit congestion. ")
wfCSMACDRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 1, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfCSMACDRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfCSMACDRxReplenMisses.setDescription(' Number of packet buffer misses while attempting to replenish driver receive ring. ')
wfivRouteGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1))
wfivRouteCreateDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteCreateDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteCreateDelete.setDescription(" 'This value determines whether DECnet is configured on this slot.' ")
wfivRouteEnableDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteEnableDisable.setDescription(" 'This value determines whether DECnet is to startup.' ")
wfivRouteState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 3, 2, 1))).clone(namedValues=NamedValues(("notpresent", 4), ("initializing", 3), ("down", 2), ("up", 1))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivRouteState.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteState.setDescription(" 'This value determines whether DECnet is to startup.' ")
wfivRouteBroadcastRouteTimer = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 180, 65535))).clone(namedValues=NamedValues(("routetimermin", 1), ("routetimerdflt", 180), ("routetimermax", 65535))).clone('routetimerdflt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteBroadcastRouteTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteBroadcastRouteTimer.setDescription(" 'This value determines the maximum time allowed between Routing updates on Ethernet circuits. When this timer expires before a routing update occurs, a routing update is forced. With a standard calculation, Routing also uses this timer to enforce a minimum delay between routing updates. Seconds is a decimal integer in the range 1-65535.' ")
wfivRouteRoutingVers = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivRouteRoutingVers.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteRoutingVers.setDescription(" 'This read-only parameter identifies the executor node's Routing version number. The format is the same as for the Network Management version number.' ")
wfivRouteMaxAddr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minaddr", 1), ("maxaddr", 1023))).clone('maxaddr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxAddr.setDescription(" 'This value represents the largest node number and, therefore, number of nodes that can be known about by the executor node's home area. The number is an integer in the range 1-1023.' ")
wfivRouteMaxBdcastNonRouters = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(64, 1023))).clone(namedValues=NamedValues(("nonroutersdflt", 64), ("nonroutersmax", 1023))).clone('nonroutersdflt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxBdcastNonRouters.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxBdcastNonRouters.setDescription(" 'This value represents the maximum total number of nonrouters the executor node can have on its broadcast circuits for one slot. The number is an integer in the range 0-1023.' ")
wfivRouteMaxBdcastRouters = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32, 1023))).clone(namedValues=NamedValues(("routersdflt", 32), ("routersdmax", 1023))).clone('routersdflt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxBdcastRouters.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxBdcastRouters.setDescription(" 'This value represents the maximum total number of routers the executor node can have on its broadcast circuits for one slot. The number is an integer in the range 0-1023.' ")
wfivRouteMaxCircuits = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16, 1024, 65535))).clone(namedValues=NamedValues(("circuitsmin", 1), ("circuitsdflt", 16), ("circuitswfmax", 1024), ("circuitsmax", 65535))).clone('circuitswfmax')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxCircuits.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxCircuits.setDescription(" 'This value represents the maximum number of Routing circuits that the executor node can know about. The number is decimal in the range 1-65535. Wellfleet limits this to 1024' ")
wfivRouteMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1022))).clone(namedValues=NamedValues(("mincost", 1), ("maxcost", 1022))).clone('maxcost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxCost.setDescription(" 'This value represents the maximum total path cost allowed from the executor to any node within an area. The path cost is the sum of the circuit costs along a path between two nodes. This parameter defines the point where the executor node's Routing decision algorithm declares another node unreachable because the cost of the least costly path to the other node is excessive. For correct operation, this parameter must not be less than the maximum path cost of the network. The MAXIMUM COST number is decimal in the range 1-1022.' ")
wfivRouteMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 30))).clone(namedValues=NamedValues(("minhops", 1), ("maxhops", 30))).clone('maxhops')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxHops.setDescription(" 'This value represents the maximum number of routing hops allowable from the executor to any other reachable node within an area. (A hop is the logical distance over a circuit between two adjacent nodes.) This parameter defines the point where the executor node's Routing decision algorithm declares another node unreachable because the length of the shortest path between the two nodes is too long. For correct operation, this parameter must not be less than the network diameter. (The network diameter is the reachability distance between the two nodes of the network having the greatest reachability distance, where reachability distance is the length the shortest path between a given pair of nodes.) The MAXIMUM HOPS number is decimal in the range 1-30.' ")
wfivRouteMaxVisits = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(63))).clone(namedValues=NamedValues(("maxvisits", 63))).clone('maxvisits')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxVisits.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxVisits.setDescription(" 'This value represents the maximum number of nodes a message coming into the executor node can have visited. If the message is not for this node and the MAXIMUM VISITS number is exceeded, the message is discarded. The MAXIMUM VISITS parameter defines the point where the packet lifetime control algorithm discards a packet that has traversed too many nodes. For correct operation, this parameter must not be less than the maximum path length of the network. (The maximum path length is the routing distance between the two nodes of the network having the greatest routing distance, where routing distance is the length of the least costly path between a given pair of nodes.) The MAXIMUM VISITS number is decimal in the range MAXIMUM HOPS to 63.' ")
wfivRouteAreaMaxCost = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1022))).clone(namedValues=NamedValues(("amincost", 1), ("amaxcost", 1022))).clone('amaxcost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteAreaMaxCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteAreaMaxCost.setDescription(" 'This value represents the maximum total path cost allowed from the executor to any other level 2 routing node. The AREA MAXIMUM COST number is decimal in the range 1-1022. This parameter is only applicable if the executor node is of type AREA.' ")
wfivRouteAreaMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 30))).clone(namedValues=NamedValues(("aminhops", 1), ("amaxhops", 30))).clone('amaxhops')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteAreaMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteAreaMaxHops.setDescription(" 'This value represents the maximum number of routing hops allowable from the executor to any other level 2 routing node. The AREA MAXIMUM HOPS number is decimal in the range 1-30.This parameter is only applicable if the executor node is of type AREA.' ")
wfivRouteMaxArea = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 63))).clone(namedValues=NamedValues(("minarea", 1), ("maxarea", 63))).clone('maxarea')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivRouteMaxArea.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteMaxArea.setDescription(" 'This value represents the largest area number and, therefore, number of areas that can be known about by the executor node's Routing. This parameter is only applicable if the executor node is of type AREA. The number is an integer in the range 1-63.' ")
wfivRouteType = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("area", 3), ("routingiv", 4), ("nonroutingiv", 5))).clone('area')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: wfivRouteType.setDescription(" 'This parameter indicates the type of the executor node. The node-type is one of the following: ROUTING III NONROUTING III ROUTING IV NONROUTING IV AREA A routing node has full routing capability. A nonrouting node contains a subset of the Routing modules. The III and IV indicate the DNA phase of the node. Nonrouting nodes can deliver and receive packets to and from any node, but cannot route packets from other nodes through to other nodes. An area node routes between areas. Refer to the Routing specification for details. For adjacent nodes, this is a read-only parameter that indicates the type of the reachable adjacent node. NOTE: The ROUTING III and NONROUTING III values are incremented by one compared to the standard DECnet values in order to maintain compliance with RFC 1155)' ")
wfivCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2), )
if mibBuilder.loadTexts: wfivCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitTable.setDescription(" ' Table of DECnet Circuit Configuration and Counter Records' ")
wfivCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivCircuitID"))
if mibBuilder.loadTexts: wfivCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitEntry.setDescription(" 'Parameters information about all circuits currently known. NOTE: depending on the type of object being querried (e.g., a level 1 vs. a level 2 router or end system) some variables may not be present.' ")
wfivCircuitCreateDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitCreateDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCreateDelete.setDescription(" 'This value determines whether the circuit is configured' ")
wfivCircuitEnableDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitEnableDisable.setDescription(" 'This value represents the circuit's Network Management operational state. NOTE: These values are incremented by one compared to the standard DECnet values in order to maintain compliance with RFC 1155.' ")
wfivCircuitCommonState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 3, 2, 1))).clone(namedValues=NamedValues(("notpresent", 4), ("initializing", 3), ("down", 2), ("up", 1))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCommonState.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCommonState.setDescription(" 'This value represents the circuit's operational state.' ")
wfivCircuitArea = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1, 63))).clone(namedValues=NamedValues(("minarea", 1), ("defarea", 1), ("maxarea", 63))).clone('defarea')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitArea.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitArea.setDescription(" 'DECnet Phase IV area number for this circuit.' ")
wfivCircuitNodeid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1, 1023))).clone(namedValues=NamedValues(("minnodeid", 1), ("defnodeid", 1), ("maxnodeid", 1023))).clone('defnodeid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitNodeid.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitNodeid.setDescription(" 'DECnet Phase IV node address for this circuit.' ")
wfivCircuitNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitNodeAddr.setDescription(" 'The address of the adjacent node.' ")
wfivCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitID.setDescription(" 'A unique value for each known circuit.' ")
wfivCircuitCommonType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 6, 15, 100, 101))).clone(namedValues=NamedValues(("sync", 1), ("x25", 4), ("ethernet", 6), ("fddi", 15), ("smds", 100), ("fr", 101)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCommonType.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCommonType.setDescription(" 'Represents the type of the circuit. For X.25 circuits, the value must be set to X25. For DDCMP and Ethernet circuits it is read only and is the same value as the protocol of the associated line. NOTE: Values 1 - 5 are incremented by one compared to the standard DECnet values in order to maintain compliance with RFC 1155.' ")
wfivCircuitExecCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 63))).clone(namedValues=NamedValues(("mincost", 1), ("defcost", 10), ("maxcost", 63))).clone('defcost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitExecCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitExecCost.setDescription(" 'This value represents the Routing cost of the circuit. Routing routes messages along the path between two nodes having the smallest cost. The cost is a decimal integer in the range 1-63.' ")
wfivCircuitExecHelloTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 15, 8191))).clone(namedValues=NamedValues(("hellomin", 1), ("hellodef", 15), ("hellomax", 8191))).clone('hellodef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitExecHelloTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitExecHelloTimer.setDescription(" 'This value determines the frequency of Routing Hello (T3) messages sent to the adjacent node on the circuit. Seconds is a decimal integer in the range 1-8191.' ")
wfivCircuitDesigRouterNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitDesigRouterNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitDesigRouterNodeAddr.setDescription(" 'This value is the address of the designated router.' ")
wfivCircuitMaxRouters = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(33, 33))).clone(namedValues=NamedValues(("maxroutersdef", 33), ("maxroutersmax", 33))).clone('maxroutersdef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitMaxRouters.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitMaxRouters.setDescription(" 'NR -This parameter is the maximum number of routers (including the executor itself) allowed on the circuit by Routing for circuits that are owned by the executor node. Number is a decimal integer in the range 1-33.' ")
wfivCircuitRouterPri = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(64, 127))).clone(namedValues=NamedValues(("routerpridef", 64), ("routerprimax", 127))).clone('routerpridef')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitRouterPri.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitRouterPri.setDescription(" 'This parameter is the priority that this router is to have in the selection of designated router for the circuit on circuits that are owned by the executor node. Number is a decimal integer in the range 0-127. The default value is 64.' ")
wfivCircuitCountAgedPktLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountAgedPktLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountAgedPktLoss.setDescription(" 'Aged packet loss.' ")
wfivCircuitCountNodeUnrPktLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountNodeUnrPktLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountNodeUnrPktLoss.setDescription(" 'Node unreachable packet loss.' ")
wfivCircuitCountOutRngePktLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountOutRngePktLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountOutRngePktLoss.setDescription(" 'Node out-of-range packet loss.' ")
wfivCircuitCountOverSzePktLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountOverSzePktLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountOverSzePktLoss.setDescription(" 'Oversized packet loss.' ")
wfivCircuitCountPacketFmtErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountPacketFmtErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountPacketFmtErr.setDescription(" 'Packet format errors.' ")
wfivCircuitCountPtlRteUpdtLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountPtlRteUpdtLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountPtlRteUpdtLoss.setDescription(" 'Partial routing update loss.' ")
wfivCircuitCountTransitPksRecd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountTransitPksRecd.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountTransitPksRecd.setDescription(" 'Transit packets Received. This value is stored internally as a 32 bit value.' ")
wfivCircuitCountTransitPkSent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountTransitPkSent.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountTransitPkSent.setDescription(" 'Transit packets sent. This value is stored internally as a 32 bit value.' ")
wfivCircuitCountRtHelloSent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountRtHelloSent.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountRtHelloSent.setDescription(" ' Router Hellos Sent' ")
wfivCircuitCountRtHelloRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountRtHelloRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountRtHelloRcvd.setDescription(" ' Router Hellos Received' ")
wfivCircuitCountHelloSent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountHelloSent.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountHelloSent.setDescription(" ' Endnode Hellos Sent' ")
wfivCircuitCountHelloRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountHelloRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountHelloRcvd.setDescription(" ' Endnode Hellos Received' ")
wfivCircuitCountL1UpdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountL1UpdSent.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountL1UpdSent.setDescription(" ' Level 1 Routing Updates Sent' ")
wfivCircuitCountL1UpdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountL1UpdRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountL1UpdRcvd.setDescription(" ' Level 1 Routing Updates Received' ")
wfivCircuitCountAreaUpdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountAreaUpdSent.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountAreaUpdSent.setDescription(" ' Area Routing Updates Sent' ")
wfivCircuitCountAreaUpdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountAreaUpdRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountAreaUpdRcvd.setDescription(" ' Area Routing Updates Received' ")
wfivCircuitCountDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivCircuitCountDropped.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitCountDropped.setDescription(" ' Dropped Packets ' ")
wfivCircuitAllEndnodesMac = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 31), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitAllEndnodesMac.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitAllEndnodesMac.setDescription(" 'This parameter can be used to assign the AllEndnodes multicast MAC address value for use over WAN media (e.g. Frame Relay).' ")
wfivCircuitAllRoutersMac = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 32), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitAllRoutersMac.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitAllRoutersMac.setDescription(" 'This parameter can be used to assign the AllRouters multicast MAC address value for use over WAN media (e.g. Frame Relay).' ")
wfivCircuitAllAreaRoutersMac = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 33), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitAllAreaRoutersMac.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitAllAreaRoutersMac.setDescription(" 'This parameter can be used to assign the AllAreaRouters multicast MAC address value for use over WAN media (e.g. Frame Relay).' ")
wfivCircuitHelloEnableDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitHelloEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitHelloEnableDisable.setDescription(" ' This parameter is used to disable to sending of Hellos to Endnodes. It would be used in conjunction with Static Adjacencies to limit the amount of data passed over a WAN link (e.g. Frame Relay).' ")
wfivCircuitRtHelloEnableDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitRtHelloEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitRtHelloEnableDisable.setDescription(" ' This parameter is used to disable to sending of Hellos to Routers. It would be used in conjunction with Static Adjacencies to limit the amount of data passed over a WAN link (e.g. Frame Relay).' ")
wfivCircuitL1UpdateEnableDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivCircuitL1UpdateEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivCircuitL1UpdateEnableDisable.setDescription(" ' This parameter is used to disable to sending of Level 1 topology updates. It would be used in conjunction with Static Adjacencies to limit the amount of data passed over a WAN link (e.g. Frame Relay).' ")
wfivLevel1RouteTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3), )
if mibBuilder.loadTexts: wfivLevel1RouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteTable.setDescription(" ' Table of Level 1 Routing Table Entries' ")
wfivLevel1RouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivLevel1AreaId"), (0, "Wellfleet-Series7-MIB", "wfivLevel1NodeId"))
if mibBuilder.loadTexts: wfivLevel1RouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteEntry.setDescription(" 'A Record in the Level 1 Routing Table' ")
wfivLevel1AreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1AreaId.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1AreaId.setDescription(" 'Area Id for this node' ")
wfivLevel1NodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1NodeId.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1NodeId.setDescription(" 'Area Id for this node' ")
wfivLevel1RouteNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1RouteNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteNodeAddr.setDescription(" 'This value is the address of the node about which routing information is contained in this level 1 routing table.' ")
wfivLevel1RouteCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1RouteCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteCircuitID.setDescription(" 'This READ_ONLY parameter identifies the circuit used to get to a remote node. Circuit-id is an id-string. This parameter can be used when displaying a list of nodes to indicate that the display is to be restricted to those nodes adjacent on the specified circuit.' ")
wfivLevel1RouteCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1RouteCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteCost.setDescription(" 'This READ_ONLY parameter represents the total cost over the current path to the destination node. Cost is a positive integer value associated with using a circuit. Routing routes messages (data) along the path between two nodes with the smallest cost. COST is kept on a remote node basis.' ")
wfivLevel1RouteHops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1RouteHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteHops.setDescription(" 'This READ_ONLY parameter represents the number of hops over to a destination node. A hop is Routing value representing the logical distance between two nodes in a network. HOPS is kept on a remote node basis.' ")
wfivLevel1RouteNextNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivLevel1RouteNextNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfivLevel1RouteNextNode.setDescription(" 'This READ_ONLY value indicates the next node on the circuit used to get to the node under scrutiny (next hop).' ")
wfivAreaTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4), )
if mibBuilder.loadTexts: wfivAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaTable.setDescription(" 'Table of Area Routing Table Entries' ")
wfivAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivAreaNum"))
if mibBuilder.loadTexts: wfivAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaEntry.setDescription(" 'The area routing information.' ")
wfivAreaNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaNum.setDescription(" 'This value indicates the area number of this entry.' ")
wfivAreaState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5))).clone(namedValues=NamedValues(("reachable", 4), ("unreachable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaState.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaState.setDescription(" 'This value indicates the state of the area' ")
wfivAreaCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaCost.setDescription(" 'The total cost over the current path to the destination area. Cost is a value associated with using a circuit. Routing routes messages (data) along the path between 2 areas with the smallest cost.' ")
wfivAreaHops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaHops.setDescription(" 'The number of hops to a destination area. A hop is the routing value representing the logical distance between two areas in network.' ")
wfivAreaCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaCircuitID.setDescription(" 'The circuit used to get to the remote area' ")
wfivAreaNextNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAreaNextNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAreaNextNode.setDescription(" 'The next node on the circuit used to get to the area under scrutiny.' ")
wfivAdjTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5), )
if mibBuilder.loadTexts: wfivAdjTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjTable.setDescription(' Adjacency Table ')
wfivAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivAdjIndex"))
if mibBuilder.loadTexts: wfivAdjEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjEntry.setDescription(" ' Adjacency Table - the real index is the adjacency index' ")
wfivAdjIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjIndex.setDescription(" 'Index in the Adjacency Table' ")
wfivAdjNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjNodeAddr.setDescription(" 'The address of the adjacent node.' ")
wfivAdjBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjBlockSize.setDescription(" 'This READ_ONLY parameter is the block size that was negotiated with the adjacent Routing layer during Routing initialization over a particular circuit. It includes the routing header, but excludes the data link header. This parameter is qualified by ADJACENT NODE.' ")
wfivAdjListenTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjListenTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjListenTimer.setDescription(" 'This READ_ONLY value determines the maximum time allowed to elapse before Routing receives some message (either a Hello message or a user message) from the adjacent node on the circuit. It was agreed during Routing initialization with the adjacent Routing layer. Seconds is a decimal integer in the range 1-65535. This parameter is qualified by ADJACENT NODE.' ")
wfivAdjCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjCircuitID.setDescription(" 'A unique value for each known circuit.' ")
wfivAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjType.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjType.setDescription(" 'This parameter indicates the type of adjacency. For adjacent nodes, this is a READ_ONLY parameter that indicates the type of the reachable adjacent node. NOTE: The ROUTING III and NONROUTING III values are incremented by one compared to the standard DECnet values in order to maintain compliance with RFC 1155) ROUTING III (1), NONROUTING III (2), AREA (3), ROUTING IV (4), NONROUTING IV (5)' ")
wfivAdjState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("init", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjState.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjState.setDescription(" 'This value indicates the state of a router adjacency. On adjacencies over a circuit of type (wfivCircuitCommonType) Ethernet, CI, or FDDI, with an adjacent node of type (wfivAdjType) ROUTING IV or AREA, this variable is the state of the Ethernet Initialization Layer for this adjacency, and can have values INITIALIZING or UP. (See Section 9.1.1 of DECnet Phase IV Routing Layer Functional Specification.) On adjacencies over a circuit of type (wfivCircuitCommonType) Ethernet, CI, or FDDI, with an adjacent node of type (wfivAdjType) NONROUTING IV, this varaible will always take on the value UP. On adjacencies over a circuit of type (wfivCircuitCommonType) DDCMP POINT, DDCMP CONTROL, DDCMP TRIBUTARY, DDCMP DMC, or X.25, this variable is the state of the Routing Layer Initialization Circuit State. (See section 7.3, ibid.) It can have values between RUN and HALT. On adjacencies over a circuit of type (wfivCircuitCommonType) OTHER, this variable may be used in a manner consistent with the Initialization Layer used on that circuit. INITIALIZING (1), -- Ethernet one-way UP (2), -- Ethernet two-way RUN (3), -- The eight DDCMP/X.25 states CIRCUIT REJECTED (4), DATA LINK START (5), ROUTING LAYER INITIALIZE (6), ROUTING LAYER VERIFY (7), ROUTING LAYER COMPLETE (8), OFF (9), HALT (10)' ")
wfivAdjPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjPriority.setDescription(" 'Priority assigned by the adjacent node for this circuit.' ")
wfivAdjClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivAdjClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfivAdjClass.setDescription(" 'Specifies whether this adjacency is Static or Dynamic' ")
wfivTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6), )
if mibBuilder.loadTexts: wfivTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterTable.setDescription(' DECNET Traffic Filters ')
wfivTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfivTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfivTrafficFilterFragment"))
if mibBuilder.loadTexts: wfivTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterEntry.setDescription(' An entry in WfivTrafficFilterTable. ')
wfivTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfivTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfivTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfivTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfivTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 5), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfivTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 6), Integer32())
if mibBuilder.loadTexts: wfivTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterReserved.setDescription(' Reserved field. ')
wfivTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterCircuit.setDescription(' The ID of the Circuit to which the filter is applied. ')
wfivTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfivTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfivTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfivStaticAdjTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7), )
if mibBuilder.loadTexts: wfivStaticAdjTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjTable.setDescription(' Static Adjacency Table ')
wfivStaticAdjEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfivStaticAdjCircuitID"), (0, "Wellfleet-Series7-MIB", "wfivStaticAdjArea"), (0, "Wellfleet-Series7-MIB", "wfivStaticAdjNodeid"))
if mibBuilder.loadTexts: wfivStaticAdjEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjEntry.setDescription(" ' Static Adjacency Table ' ")
wfivStaticAdjCreateDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivStaticAdjCreateDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjCreateDelete.setDescription(" 'This value determines whether the static adjacency is configured' ")
wfivStaticAdjEnableDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivStaticAdjEnableDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjEnableDisable.setDescription(" 'This value determines whether the static adjacency is active ' ")
wfivStaticAdjArea = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivStaticAdjArea.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjArea.setDescription(" 'DECnet Phase IV area number for this static Adjacency.' ")
wfivStaticAdjNodeid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivStaticAdjNodeid.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjNodeid.setDescription(" 'DECnet Phase IV node address for this static adjacency.' ")
wfivStaticAdjCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivStaticAdjCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjCircuitID.setDescription(" 'The circuit used for this static adjacency.' ")
wfivStaticAdjNodeAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfivStaticAdjNodeAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjNodeAddr.setDescription(" 'The address of the adjacent node in display format.' ")
wfivStaticAdjType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("area", 3), ("routingiv", 4), ("nonroutingiv", 5))).clone('area')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivStaticAdjType.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjType.setDescription(" ' Specifies whether the static adjacency is to a router or end station.' ")
wfivStaticAdjPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivStaticAdjPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjPriority.setDescription(" ' Specifies the priority of the static adjacency if it's a router.' ")
wfivStaticAdjDestMACAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 2, 7, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfivStaticAdjDestMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfivStaticAdjDestMACAddr.setDescription(" ' Specifies the destination MAC address of the Static Adjacency if the circuit type is Frame Relay or SMDS.' ")
wfDs1Config = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1), )
if mibBuilder.loadTexts: wfDs1Config.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1Config.setDescription(' The DS1 Configuration table ')
wfDs1ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1LineIndex"))
if mibBuilder.loadTexts: wfDs1ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1ConfigEntry.setDescription(' per circuit DS1 configuration objects; wfDs1LineIndex corresponds to Wellfleet circuit number ')
wfDs1LineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1LineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1LineIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1TimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TimeElapsed.setDescription(' 1..900 seconds within the current 15-minute interval ')
wfDs1ValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1ValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1ValidIntervals.setDescription(' 0..96 previous intervals that valid data were collected. This is 96 unless the CSU device was brought on line within the last 24 hours. ')
wfDs1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("ds1ansi-esf", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1LineType.setDescription(' the variety of DS1 implementing this circuit ')
wfDs1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 5))).clone(namedValues=NamedValues(("ds1b8zs", 2), ("ds1zbtsi", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1ZeroCoding.setDescription(' the variety of Zero Code Suppression used on the link ')
wfDs1SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("ds1sendnocode", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1SendCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1SendCode.setDescription(' the type of code being sent across the DS1 circuit by the CSU ')
wfDs1CircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CircuitIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CircuitIdentifier.setDescription(" the transmission vendor's circuit identifier ")
wfDs1LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ds1noloop", 1), ("ds1mgrpayloadloop", 2), ("ds1mgrlineloop", 3), ("ds1netreqpayloadloop", 4), ("ds1netreqlineloop", 5), ("ds1otherloop", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1LoopbackConfig.setDescription(' the loopback state of the CSU ')
wfDs1LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("ds1noalarm", 1), ("ds1farendalarm", 2), ("ds1alarmindicationsignal", 4), ("ds1lossofframe", 8), ("ds1lossofsignal", 16), ("ds1loopbackstate", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1LineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1LineStatus.setDescription(' the state of the DS1 line ')
wfDs1Current = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2), )
if mibBuilder.loadTexts: wfDs1Current.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1Current.setDescription(' The DS1 Current table ')
wfDs1CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1CurrentIndex"))
if mibBuilder.loadTexts: wfDs1CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentEntry.setDescription(' per circuit DS1 current objects - wfDs1CurrentIndex corresponds to Wellfleet circuit number ')
wfDs1CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1CurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentESs.setDescription(' the count of errored seconds in the current interval ')
wfDs1CurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentSESs.setDescription(' the count of severely errored seconds in the current interval ')
wfDs1CurrentSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentSEFs.setDescription(' the count of severely errored framing seconds in the current interval ')
wfDs1CurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentUASs.setDescription(' the number of unavailable seconds in the current interval ')
wfDs1CurrentBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentBPVs.setDescription(' the count of bipolar violations in the current interval ')
wfDs1CurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1CurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1CurrentCVs.setDescription(' the count of code violation error events in the current interval ')
wfDs1Interval = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3), )
if mibBuilder.loadTexts: wfDs1Interval.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1Interval.setDescription(' The DS1 Interval table ')
wfDs1IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1IntervalIndex"), (0, "Wellfleet-Series7-MIB", "wfDs1IntervalNumber"))
if mibBuilder.loadTexts: wfDs1IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalEntry.setDescription(' per circuit DS1 interval objects - wfDs1IntervalIndex corresponds to Wellfleet circuit number, wfDs1IntervalNumber is the numbered previous 15-minute interval ')
wfDs1IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 96)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalNumber.setDescription(' 1..96 where 1 is the most recent 15-minute interval and 96 is the least ')
wfDs1IntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalESs.setDescription(' the count of errored seconds in the specified interval ')
wfDs1IntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalSESs.setDescription(' the count of severely errored seconds in the specified interval ')
wfDs1IntervalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalSEFs.setDescription(' the count of severely errored framing seconds in the specified interval ')
wfDs1IntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalUASs.setDescription(' the number of unavailable seconds in the specified interval ')
wfDs1IntervalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalBPVs.setDescription(' the count of bipolar violations in the specified interval ')
wfDs1IntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1IntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1IntervalCVs.setDescription(' the count of code violation error events in the specified interval ')
wfDs1Total = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4), )
if mibBuilder.loadTexts: wfDs1Total.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1Total.setDescription(' The DS1 Total table ')
wfDs1TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1TotalIndex"))
if mibBuilder.loadTexts: wfDs1TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalEntry.setDescription(' per circuit DS1 total objects - wfDs1TotalIndex corresponds to Wellfleet circuit number ')
wfDs1TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1TotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalESs.setDescription(' total count of errored seconds ')
wfDs1TotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalSESs.setDescription(' total count of severely errored seconds ')
wfDs1TotalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalSEFs.setDescription(' total count of severely errored framing seconds ')
wfDs1TotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalUASs.setDescription(' total number of unavailable seconds ')
wfDs1TotalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalBPVs.setDescription(' total count of bipolar violations ')
wfDs1TotalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1TotalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1TotalCVs.setDescription(' total count of code violation error events ')
wfDs1FeCurrent = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5), )
if mibBuilder.loadTexts: wfDs1FeCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrent.setDescription(' The DS1 Far End Current table ')
wfDs1FeCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1FeCurrentIndex"))
if mibBuilder.loadTexts: wfDs1FeCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentEntry.setDescription(' per circuit DS1 far end current objects wfDs1CurrentIndex corresponds to Wellfleet circuit number ')
wfDs1FeCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1FeCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentESs.setDescription(' the count of errored seconds in the current interval ')
wfDs1FeCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentSESs.setDescription(' the count of severely errored seconds in the current interval ')
wfDs1FeCurrentSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentSEFs.setDescription(' the count of severely errored framing seconds in the current interval ')
wfDs1FeCurrentBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentBPVs.setDescription(' the count of bipolar violations in the current interval ')
wfDs1FeCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeCurrentCVs.setDescription(' the count of code violation error events in the current interval ')
wfDs1FeInterval = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6), )
if mibBuilder.loadTexts: wfDs1FeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeInterval.setDescription(' The DS1 Far End Interval table ')
wfDs1FeIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1FeIntervalIndex"), (0, "Wellfleet-Series7-MIB", "wfDs1FeIntervalNumber"))
if mibBuilder.loadTexts: wfDs1FeIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalEntry.setDescription(' per circuit DS1 far end interval objects - wfDs1FeIntervalIndex corresponds to Wellfleet circuit number, wfDs1FeIntervalNumber is the numbered previous 15-minute interval ')
wfDs1FeIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1FeIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 96)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalNumber.setDescription(' 1..96 where 1 is the most recent 15-minute interval and 96 is the least ')
wfDs1FeIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalESs.setDescription(' the count of errored seconds in the specified interval ')
wfDs1FeIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalSESs.setDescription(' the count of severely errored seconds in the specified interval ')
wfDs1FeIntervalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalSEFs.setDescription(' the count of severely errored framing seconds in the specified interval ')
wfDs1FeIntervalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalBPVs.setDescription(' the count of bipolar violations in the specified interval ')
wfDs1FeIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 6, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeIntervalCVs.setDescription(' the count of code violation error events in the specified interval ')
wfDs1FeTotal = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7), )
if mibBuilder.loadTexts: wfDs1FeTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotal.setDescription(' The DS1 Far End Total table ')
wfDs1FeTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs1FeTotalIndex"))
if mibBuilder.loadTexts: wfDs1FeTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalEntry.setDescription(' per circuit DS1 far end total objects - wfDs1FeTotalIndex corresponds to Wellfleet circuit number ')
wfDs1FeTotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs1FeTotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalESs.setDescription(' total count of errored seconds ')
wfDs1FeTotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalSESs.setDescription(' total count of severely errored seconds ')
wfDs1FeTotalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalSEFs.setDescription(' total count of severely errored framing seconds ')
wfDs1FeTotalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalBPVs.setDescription(' total count of bipolar violations ')
wfDs1FeTotalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 12, 7, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs1FeTotalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs1FeTotalCVs.setDescription(' total count of code violation error events ')
wfDs3Config = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1), )
if mibBuilder.loadTexts: wfDs3Config.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3Config.setDescription(' The DS3 Configuration table ')
wfDs3ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3LineIndex"))
if mibBuilder.loadTexts: wfDs3ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3ConfigEntry.setDescription(' per circuit DS3 configuration objects; wfDs3LineIndex corresponds to Wellfleet circuit number ')
wfDs3LineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3LineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3LineIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3TimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TimeElapsed.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TimeElapsed.setDescription(' 1..900 seconds within the current 15-minute interval ')
wfDs3ValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3ValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3ValidIntervals.setDescription(' 0..96 previous intervals that valid data were collected. This is 96 unless the CSU device was brought on line within the last 24 hours. ')
wfDs3LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("ds3cbitparity", 4), ("ds3clearchannel", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3LineType.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3LineType.setDescription(' the variety of DS3 implementing this circuit ')
wfDs3ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("ds3b3zs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3ZeroCoding.setDescription(' the variety of Zero Code Suppression used on the link ')
wfDs3SendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("ds3sendnocode", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3SendCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3SendCode.setDescription(' the type of code being sent across the DS3 circuit by the CSU ')
wfDs3CircuitIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CircuitIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CircuitIdentifier.setDescription(" the transmission vendor's circuit identifier ")
wfDs3LoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("ds3noloop", 1), ("ds3mgrpayloadloop", 2), ("ds3mgrlineloop", 3), ("ds3netreqpayloadloop", 4), ("ds3netreqlineloop", 5), ("ds3otherloop", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3LoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3LoopbackConfig.setDescription(' the loopback state of the CSU ')
wfDs3LineStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("ds3noalarm", 1), ("ds3farendalarm", 2), ("ds3alarmindicationsignal", 4), ("ds3lossofframe", 8), ("ds3lossofsignal", 16), ("ds3loopbackstate", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3LineStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3LineStatus.setDescription(' the state of the DS3 line ')
wfDs3Current = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2), )
if mibBuilder.loadTexts: wfDs3Current.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3Current.setDescription(' The DS3 Current table ')
wfDs3CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3CurrentIndex"))
if mibBuilder.loadTexts: wfDs3CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentEntry.setDescription(' per circuit DS3 current objects - wfDs3CurrentIndex corresponds to Wellfleet circuit number ')
wfDs3CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3CurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentESs.setDescription(' the count of errored seconds in the current interval ')
wfDs3CurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentSESs.setDescription(' the count of severely errored seconds in the current interval ')
wfDs3CurrentSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentSEFs.setDescription(' the count of severely errored framing seconds in the current interval ')
wfDs3CurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentUASs.setDescription(' the number of unavailable seconds in the current interval ')
wfDs3CurrentBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentBPVs.setDescription(' the count of bipolar violations in the current interval ')
wfDs3CurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3CurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3CurrentCVs.setDescription(' the count of code violation error events in the current interval ')
wfDs3Interval = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3), )
if mibBuilder.loadTexts: wfDs3Interval.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3Interval.setDescription(' The DS3 Interval table ')
wfDs3IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3IntervalIndex"), (0, "Wellfleet-Series7-MIB", "wfDs3IntervalNumber"))
if mibBuilder.loadTexts: wfDs3IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalEntry.setDescription(' per circuit DS3 interval objects - wfDs3IntervalIndex corresponds to Wellfleet circuit number, wfDs3IntervalNumber is the numbered previous 15-minute interval ')
wfDs3IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 96)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalNumber.setDescription(' 1..96 where 1 is the most recent 15-minute interval and 96 is the least ')
wfDs3IntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalESs.setDescription(' the count of errored seconds in the specified interval ')
wfDs3IntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalSESs.setDescription(' the count of severely errored seconds in the specified interval ')
wfDs3IntervalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalSEFs.setDescription(' the count of severely errored framing seconds in the specified interval ')
wfDs3IntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalUASs.setDescription(' the number of unavailable seconds in the specified interval ')
wfDs3IntervalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalBPVs.setDescription(' the count of bipolar violations in the specified interval ')
wfDs3IntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 3, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3IntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3IntervalCVs.setDescription(' the count of code violation error events in the specified interval ')
wfDs3Total = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4), )
if mibBuilder.loadTexts: wfDs3Total.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3Total.setDescription(' The DS3 Total table ')
wfDs3TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3TotalIndex"))
if mibBuilder.loadTexts: wfDs3TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalEntry.setDescription(' per circuit DS3 total objects - wfDs3TotalIndex corresponds to Wellfleet circuit number ')
wfDs3TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3TotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalESs.setDescription(' total count of errored seconds ')
wfDs3TotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalSESs.setDescription(' total count of severely errored seconds ')
wfDs3TotalSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalSEFs.setDescription(' total count of severely errored framing seconds ')
wfDs3TotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalUASs.setDescription(' total number of unavailable seconds ')
wfDs3TotalBPVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalBPVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalBPVs.setDescription(' total count of bipolar violations ')
wfDs3TotalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3TotalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3TotalCVs.setDescription(' total count of code violation error events ')
wfDs3FeConfig = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5), )
if mibBuilder.loadTexts: wfDs3FeConfig.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeConfig.setDescription(' The DS3 Far End Configuration table ')
wfDs3FeConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3FeConfigIndex"))
if mibBuilder.loadTexts: wfDs3FeConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeConfigEntry.setDescription(' per circuit DS3 far end config objects - wfDs3FeIntervalIndex corresponds to Wellfleet circuit number ')
wfDs3FeConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeConfigIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3FarEndEquipCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDs3FarEndEquipCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FarEndEquipCode.setDescription(' equipment description code - C-bit parity only ')
wfDs3FarEndLocationIDCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDs3FarEndLocationIDCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FarEndLocationIDCode.setDescription(' equipment location code - C-bit parity only ')
wfDs3FarEndFrameIDCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDs3FarEndFrameIDCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FarEndFrameIDCode.setDescription(' code for the equipment location within a building ')
wfDs3FarEndUnitCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDs3FarEndUnitCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FarEndUnitCode.setDescription(' code for the equipment location within a bay ')
wfDs3FarEndFacilityIDCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 5, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDs3FarEndFacilityIDCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FarEndFacilityIDCode.setDescription(' path identification code ')
wfDs3FeCurrent = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6), )
if mibBuilder.loadTexts: wfDs3FeCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrent.setDescription(' The DS3 Far End Current table ')
wfDs3FeCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3FeCurrentIndex"))
if mibBuilder.loadTexts: wfDs3FeCurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrentEntry.setDescription(' per circuit DS3 far end current objects wfDs3FeCurrentIndex corresponds to Wellfleet circuit number ')
wfDs3FeCurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeCurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrentIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3FeCurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeCurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrentESs.setDescription(' the count of errored seconds in the current interval ')
wfDs3FeCurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeCurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrentSESs.setDescription(' the count of severely errored seconds in the current interval ')
wfDs3FeCurrentCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeCurrentCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeCurrentCVs.setDescription(' the count of code violation error events in the current interval ')
wfDs3FeInterval = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7), )
if mibBuilder.loadTexts: wfDs3FeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeInterval.setDescription(' The DS3 Far End Interval table ')
wfDs3FeIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3FeIntervalIndex"), (0, "Wellfleet-Series7-MIB", "wfDs3FeIntervalNumber"))
if mibBuilder.loadTexts: wfDs3FeIntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalEntry.setDescription(' per circuit DS3 far end interval objects - wfDs3FeIntervalIndex corresponds to Wellfleet circuit number, wfDs3FeIntervalNumber is the numbered previous 15-minute interval ')
wfDs3FeIntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeIntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3FeIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 96))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 96)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeIntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalNumber.setDescription(' 1..96 where 1 is the most recent 15-minute interval and 96 is the least ')
wfDs3FeIntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeIntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalESs.setDescription(' the count of errored seconds in the specified interval ')
wfDs3FeIntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeIntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalSESs.setDescription(' the count of severely errored seconds in the specified interval ')
wfDs3FeIntervalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 7, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeIntervalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeIntervalCVs.setDescription(' the count of code violation error events in the specified interval ')
wfDs3FeTotal = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8), )
if mibBuilder.loadTexts: wfDs3FeTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotal.setDescription(' The DS3 Far End Total table ')
wfDs3FeTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfDs3FeTotalIndex"))
if mibBuilder.loadTexts: wfDs3FeTotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotalEntry.setDescription(' per circuit far end DS3 total objects - wfDs3FeTotalIndex corresponds to Wellfleet circuit number ')
wfDs3FeTotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeTotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotalIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfDs3FeTotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeTotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotalESs.setDescription(' total count of errored seconds ')
wfDs3FeTotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeTotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotalSESs.setDescription(' total count of severely errored seconds ')
wfDs3FeTotalCVs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 13, 8, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfDs3FeTotalCVs.setStatus('mandatory')
if mibBuilder.loadTexts: wfDs3FeTotalCVs.setDescription(' total count of code violation error events ')
wfE1Table = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 11), )
if mibBuilder.loadTexts: wfE1Table.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Table.setDescription(' E1 line record ')
wfE1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfE1Slot"), (0, "Wellfleet-Series7-MIB", "wfE1Connector"))
if mibBuilder.loadTexts: wfE1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Entry.setDescription(' An entry in the E1 table ')
wfE1Delete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1Delete.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Delete.setDescription(' create/delete parameter, dflt = created ')
wfE1Disable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1Disable.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Disable.setDescription(' enable/disable parameter, dflt = enabled ')
wfE1State = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1State.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1State.setDescription(' line driver state variable, Not Present, Init, Up ')
wfE1Slot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1Slot.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Slot.setDescription(' instance ID Slot, filled in by driver ')
wfE1Connector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1Connector.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Connector.setDescription(' instance ID Connector, filled in by driver ')
wfE1Madr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1Madr.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1Madr.setDescription(' Line mac address, filled in by driver ')
wfE1HDB3Support = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1HDB3Support.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1HDB3Support.setDescription(' HDB3 Support - Enables or disables high density bipolar coding ')
wfE1ClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 1))).clone(namedValues=NamedValues(("internal", 1), ("slave", 2), ("manual", 4), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1ClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1ClockMode.setDescription(' Clock Mode - Specifies the source of the E1 transmit clock ')
wfE1MiniDacs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1MiniDacs.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1MiniDacs.setDescription(' MiniDacs Configuration - assigns each E1 channel to a specific function ')
wfE1BipolarVios = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1BipolarVios.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1BipolarVios.setDescription(' Number of Bipolar Violations ')
wfE1FrameErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1FrameErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1FrameErrs.setDescription(' Number of Frame errors ')
wfE1RcvRemAlms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1RcvRemAlms.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1RcvRemAlms.setDescription(' Number of remote alarms received ')
wfE1RcvMfmAlms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1RcvMfmAlms.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1RcvMfmAlms.setDescription(' Number of Multiframe Alarms Received ')
wfE1MfsErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1MfsErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1MfsErrs.setDescription(' Number of instances of CAS Multiframe resync criteria met ')
wfE1SyncLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1SyncLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1SyncLoss.setDescription(' Number of instances of sync loss ')
wfE1RcvSig1s = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1RcvSig1s.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1RcvSig1s.setDescription(" Number of instances of receive signalling all 1's ")
wfE1RcvUnfrm1s = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 11, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfE1RcvUnfrm1s.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1RcvUnfrm1s.setDescription(" Number of instances of Receive unframed all 1's ")
wfFakeEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 4))
wfFakeEventString = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 4, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFakeEventString.setStatus('optional')
if mibBuilder.loadTexts: wfFakeEventString.setDescription(' A dummy display string. While no string will actually be kept here, the full identifier (object id + attribute id + instance ID ) will be used to wrap event strings passed from the system logger into an SNMP Trap message. ')
wfFddiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 4), )
if mibBuilder.loadTexts: wfFddiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiTable.setDescription(' FDDI line record ')
wfFddiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFDDISlot"), (0, "Wellfleet-Series7-MIB", "wfFDDINode"))
if mibBuilder.loadTexts: wfFddiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiEntry.setDescription(' An entry in the FDDI table ')
wfFDDIDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIDelete.setDescription(' create/delete parameter, default = created ')
wfFDDIEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIEnable.setDescription(' enable/disable parameter, default = enabled ')
wfFDDIState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIState.setDescription(' line driver state variable, not present, init, down, up ')
wfFDDISlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISlot.setDescription(' instance ID slot - filled in by driver ')
wfFDDINode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2))).clone('one')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDINode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDINode.setDescription(' instance ID Node - filled in by driver ')
wfFDDICct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDICct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICct.setDescription(' cct number for this line instance ')
wfFDDIBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBofl.setDescription(' bofl parameter, default = enabled ')
wfFDDIBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 60, 5))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 60), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIBoflTmo.setDescription(' bofl parameter, default = 5 seconds ')
wfFDDIMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4495))).clone(namedValues=NamedValues(("default", 4495))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMtu.setDescription(' mtu parameter, fixed ')
wfFDDIMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMadr.setDescription(' line MAC address, fixed - line driver fills in ')
wfFDDIOctetsRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOctetsRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOctetsRxOk.setDescription(' Number of bytes received without error ')
wfFDDIFramesRxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIFramesRxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIFramesRxOk.setDescription(' Number of frames received without error ')
wfFDDIOctetsTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOctetsTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOctetsTxOk.setDescription(' Number of bytes transmitted without error ')
wfFDDIFramesTxOk = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIFramesTxOk.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIFramesTxOk.setDescription(' Number of frames transmitted without error ')
wfFDDICrcErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDICrcErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDICrcErrRx.setDescription(' Number of frames received with CRC errors ')
wfFDDIOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIOverrunRx.setDescription(' Number of frames received with internal overrun errors ')
wfFDDIParityErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIParityErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIParityErrRx.setDescription(' Number of frames received with parity errors ')
wfFDDIMacErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacErrRx.setDescription(' Number of frames received with mac errors ')
wfFDDIRingErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingErrRx.setDescription(' Number of receive ring error events ')
wfFDDISmtRingErrRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISmtRingErrRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtRingErrRx.setDescription(' Number of SMT receive ring error events ')
wfFDDIRingOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingOverrunRx.setDescription(' Number of LLC receive ring overrun events ')
wfFDDISmtRingOverrunRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDISmtRingOverrunRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtRingOverrunRx.setDescription(' Number of SMT receive ring overrun events ')
wfFDDIAbortTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIAbortTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIAbortTx.setDescription(' Number of transmit frames with internal abort errors ')
wfFDDIUnderrunTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIUnderrunTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIUnderrunTx.setDescription(' Number of transmit frames aborted with underrun errors ')
wfFDDIParityErrTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIParityErrTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIParityErrTx.setDescription(' Number of transmit frames aborted with parity errors ')
wfFDDIRingErrTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRingErrTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRingErrTx.setDescription(' Number of LLC/SMT transmit ring error events ')
wfFDDIPortOpErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIPortOpErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIPortOpErr.setDescription(' Number of port operation error events ')
wfFDDIInternOpErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIInternOpErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIInternOpErr.setDescription(' Number of internal operation error events ')
wfFDDIHostErr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIHostErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIHostErr.setDescription(' Number of host error events ')
wfFDDISmtConnectionPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(65381))).clone(namedValues=NamedValues(("default", 65381))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtConnectionPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtConnectionPolicy.setDescription(" A value that indicates the connection policies enforced at the station. A station sets the corresponding policy for each of the connection types that it rejects. The letter designations, X and Y, in the 'rejectX-Y' names have the following significance: X represents the PC-Type of the local PORT and Y represents a PC-Neighbor in the evaluation of Connection-Policy (PC-Type, PC- Neighbor) that is done to determine the setting of T-Val(3) in the PC-Signaling sequence. The value is a sum. This value initially takes the value zero, then for each of the connection policies currently enforced on the node, 2 raised to a power is added to the sum. The powers are according to the following table: Policy Power rejectA-A 0 rejectA-B 1 rejectA-S 2 rejectA-M 3 rejectB-A 4 rejectB-B 5 rejectB-S 6 rejectB-M 7 rejectS-A 8 rejectS-B 9 rejectS-S 10 rejectS-M 11 rejectM-A 12 rejectM-B 13 rejectM-S 14 rejectM-M 15 ")
wfFDDISmtTNotify = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 22, 30))).clone(namedValues=NamedValues(("min", 2), ("default", 22), ("max", 30))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtTNotify.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtTNotify.setDescription(' The timer used in the Neighbor Notification protocol, reported in seconds and ranging from 2 to 30 seconds. ')
wfFDDIMacTReq = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2062500))).clone(namedValues=NamedValues(("default", 2062500))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIMacTReq.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTReq.setDescription(" The requested Target Token Rotation Time (TTRT) for a MAC's synchronous traffic represented in unsigned integer specifying time in octet units (80 nanoseconds). ")
wfFDDIMacTMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2097152))).clone(namedValues=NamedValues(("default", 2097152))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTMax.setDescription(' The requested maximum TTRT to be supported by a MAC represented in unsigned integer specifying time in octet units (80 nanoseconds). ')
wfFDDIMacTvxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(32768))).clone(namedValues=NamedValues(("default", 32768))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTvxValue.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTvxValue.setDescription(' The requested value of TvxValue represented in unsigned integer specifying time in octet units (80 nanoseconds). ')
wfFDDIMacTMin = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(50000))).clone(namedValues=NamedValues(("default", 50000))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIMacTMin.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIMacTMin.setDescription(' The requested minimum TTRT to be requested by a MAC represented in unsigned integer specifying time in octet units (80 nanoseconds). ')
wfFDDIHardwareFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIHardwareFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIHardwareFilter.setDescription(' Hardware filter (CAM) parameter. ')
wfFDDISmtEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDISmtEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDISmtEnable.setDescription(' ')
wfFDDITxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 127))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 127))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDITxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxQueueLength.setDescription(' Transmit Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfFDDIRxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 64))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 64))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDIRxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxQueueLength.setDescription(' Receive Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfFDDITxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDITxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDITxClipFrames.setDescription(" Number of frames clipped in driver's transmit routine due to transmit congestion. ")
wfFDDIRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 4, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFDDIRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDIRxReplenMisses.setDescription(' Number of packet buffer misses while attempting to replenish driver receive ring. ')
wfFddiSmtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2), )
if mibBuilder.loadTexts: wfFddiSmtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtTable.setDescription(' A list of SMT entries. ')
wfFddiSmtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFddiSmtSlot"), (0, "Wellfleet-Series7-MIB", "wfFddiSmtNode"))
if mibBuilder.loadTexts: wfFddiSmtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtEntry.setDescription(' An SMT entry containing information common to a given SMT. ')
wfFddiSmtSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtSlot.setDescription(' Slot number associated with an SMT entity. ')
wfFddiSmtNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtNode.setDescription(' Node/connector number associated with an SMT entity. ')
wfFddiSmtCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtCct.setDescription(' Circuit number associated with an SMT entity. ')
wfFddiSmtStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtStationId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtStationId.setDescription(' Unique identifier of an FDDI station. ')
wfFddiSmtOpVersionId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtOpVersionId.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtOpVersionId.setDescription(' The version that this station is using for its operation. ')
wfFddiSmtMacCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtMacCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtMacCt.setDescription(' The number of MACs in the station or concentrator. ')
wfFddiSmtNonMasterCt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtNonMasterCt.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtNonMasterCt.setDescription(' The number of Non Master PORTs (A, B, or S PORTs) in the station or concentrator. ')
wfFddiSmtEcmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("out", 1), ("in", 2), ("trace", 3), ("leave", 4), ("pathtest", 5), ("insert", 6), ("check", 7), ("deinsert", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtEcmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtEcmState.setDescription(' Indicates the current state of the ECM state machine. ')
wfFddiSmtCfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("isolated", 1), ("wraps", 2), ("wrapa", 3), ("wrapb", 4), ("wrapab", 5), ("thru", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiSmtCfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiSmtCfState.setDescription(' The attachment configuration for the station or concentrator. ')
wfFddiMacTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2), )
if mibBuilder.loadTexts: wfFddiMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTable.setDescription(' A list of MAC entries. ')
wfFddiMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFddiMacSlot"), (0, "Wellfleet-Series7-MIB", "wfFddiMacNode"))
if mibBuilder.loadTexts: wfFddiMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacEntry.setDescription(' A MAC entry containing information common to a given MAC. ')
wfFddiMacSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacSlot.setDescription(' Slot number associated with a MAC entity. ')
wfFddiMacNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacNode.setDescription(' Node/connector number associated with a MAC entity. ')
wfFddiMacCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacCct.setDescription(' Circuit number associated with a MAC entity. ')
wfFddiMacUpstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacUpstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacUpstreamNbr.setDescription(" The MAC's upstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol. The value shall be reported as '00 00 00 00 00 00' if it is unknown. ")
wfFddiMacDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacDownstreamNbr.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacDownstreamNbr.setDescription(" The MAC's downstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame protocol. The value shall be reported as '00 00 00 00 00 00' if it is unknown. ")
wfFddiMacSmtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacSmtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacSmtAddress.setDescription(' The 48 bit individual address of the MAC used for SMT frames. ')
wfFddiMacTNeg = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacTNeg.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacTNeg.setDescription(' The negotiated TTRT during the claim process represented in unsigned integer specifying time in octet units (80 nanosecond). ')
wfFddiMacRmtState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64, 128))).clone(namedValues=NamedValues(("isolated", 1), ("nonop", 2), ("ringop", 4), ("detect", 8), ("nonopdup", 16), ("ringopdup", 32), ("directed", 64), ("trace", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiMacRmtState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiMacRmtState.setDescription(' Indicates the current state of the Ring Management state machine. ')
wfFddiPortTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2), )
if mibBuilder.loadTexts: wfFddiPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortTable.setDescription(' A list of PORT entries. The number of entries is given by the value of wfFddiPortNumber. ')
wfFddiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFddiPortSlot"), (0, "Wellfleet-Series7-MIB", "wfFddiPortNode"), (0, "Wellfleet-Series7-MIB", "wfFddiPortIndex"))
if mibBuilder.loadTexts: wfFddiPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortEntry.setDescription(' A PORT entry containing information common to a given PORT. ')
wfFddiPortSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortSlot.setDescription(' Slot number associated with a PORT entity. ')
wfFddiPortNode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortNode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortNode.setDescription(' Node/connector number associated with a PORT entity. ')
wfFddiPortCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortCct.setDescription(' Circuit number associated with a PORT entity. ')
wfFddiPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortIndex.setDescription(' A unique value for each PORT associated with each slot/connector pair. ')
wfFddiPortPcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcType.setDescription(' PC_Type. ')
wfFddiPortPcNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("a", 1), ("b", 2), ("s", 3), ("m", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcNeighbor.setDescription(' The type (PC_Neighbor) of the remote PORT that is determined in PC_Signaling in R_Val (1,2). ')
wfFddiPortPcmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 15, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("off", 1), ("break", 2), ("trace", 3), ("connect", 4), ("next", 5), ("signal", 6), ("join", 7), ("verify", 8), ("active", 9), ("maint", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFddiPortPcmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFddiPortPcmState.setDescription(' State of Physical State Machine. ')
wfFrDlcmiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1), )
if mibBuilder.loadTexts: wfFrDlcmiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiTable.setDescription('The Parameters for the Data Link Connection Management Interface ')
wfFrDlcmiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFrDlcmiCircuit"))
if mibBuilder.loadTexts: wfFrDlcmiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiEntry.setDescription('The parameters for a particular Data Link Connection Management Interface')
wfFrDlcmiDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiDelete.setDescription(' Indication to delete this frame relay interface ')
wfFrDlcmiDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiDisable.setDescription(' Indicates when a dlcmi entry is to be enabled or disabled. ')
wfFrDlcmiState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiState.setDescription(' The current state of Frame Relay. The not present state is not actually valid except when the record is first added. It is included for consistency. ')
wfFrDlcmiCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiCircuit.setDescription(' Instance identifier. The circuit number of this entry')
wfFrDlcmiManagementType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("lmi", 2), ("t1617d", 3), ("t1617b", 4), ("annexa", 5), ("lmiswitch", 6), ("annexdswitch", 7), ("annexaswitch", 8))).clone('t1617d')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiManagementType.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiManagementType.setDescription(' This variable indicates which Data Link Connection Management scheme is active (and by implication, what DLCI it uses). ')
wfFrDlcmiStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("start", 1), ("running", 2), ("fault", 3), ("recovered", 4))).clone('start')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiStatus.setDescription(' Indicates the status of the interface. FR_STATUS_START is the state during rebooting or initial start of circuit FR_STATUS_RUNNING is the sate after the circuit is up (either LMI successful or there is no DLCMI and the system just comes up). FR_STATUS_FAULT is a transient state indicating that errors have caused the circuit to be disabled until DLCMI recovery. FR_STATUS_RECOVERED indicates that an the system has been in the FR_STATUS_FAULT mode before, but has since recovered. ')
wfFrDlcmiAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("q921", 1), ("q922march90", 2), ("q922november90", 3), ("q922", 4))).clone('q922')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiAddress.setDescription(' This states which address format is in use on the FR interface. The default is Q922 ')
wfFrDlcmiAddressLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("twobyte", 2), ("threebyte", 3), ("fourbyte", 4))).clone('twobyte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiAddressLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiAddressLen.setDescription(' This variable states the address length in octets. In the case of Q922 format, the length indicates the entire length of the address includeding the control portion. ')
wfFrDlcmiPollingInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 30))).clone(namedValues=NamedValues(("minimum", 5), ("default", 10), ("maximum", 30))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiPollingInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiPollingInterval.setDescription(' The number of seconds between successive status enquiry messages ')
wfFrDlcmiFullEnquiryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 6, 255))).clone(namedValues=NamedValues(("minimum", 1), ("default", 6), ("maximum", 255))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiFullEnquiryInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiFullEnquiryInterval.setDescription(' The number of status enquiry intervals that pass before issuance of a full status enquiry message. ')
wfFrDlcmiErrorThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 11), Integer32().clone(3)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiErrorThreshold.setDescription('This is the maximum number of unanswered Status Enquiries the equipment shall accept before declaring the interface down. ')
wfFrDlcmiMonitoredEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 12), Integer32().clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiMonitoredEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiMonitoredEvents.setDescription(" This is the number of status polling intervals over which the error threshold is counted. For example, if within 'MonitoredEvents' number of events the station receives 'ErrorThreshold' number of errors, the interface is marked as down. ")
wfFrDlcmiMaxSupportedVCs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiMaxSupportedVCs.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiMaxSupportedVCs.setDescription(' The maximum number of Virtual Circuits allowed for this interface. Usually dictated by the Frame Relay network. The system sets this initially. ')
wfFrDlcmiMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrDlcmiMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiMulticast.setDescription(' This indicates whether the frame relay provider offers a multicast ')
wfFrDlcmiSeqCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255))).clone('minimum')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiSeqCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiSeqCount.setDescription(" This station's sequence counter. It represents the next value to send. ")
wfFrDlcmiLastReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255))).clone('minimum')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiLastReceived.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiLastReceived.setDescription(' The sequence number just received from the switch. ')
wfFrDlcmiPassiveSeqCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255))).clone('minimum')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiPassiveSeqCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiPassiveSeqCount.setDescription(" This station's sequence counter for answering status enquiry. ")
wfFrDlcmiPassiveReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255))).clone('minimum')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiPassiveReceived.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiPassiveReceived.setDescription(' The sequence number just received from the enquring station. ')
wfFrDlcmiPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiPolls.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiPolls.setDescription(' This is the counter of where we are in the polling cycle. ')
wfFrDlcmiAlarmTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrDlcmiAlarmTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrDlcmiAlarmTimer.setDescription(' This is a counter of 1/2 second timeouts. When it reaches 2 x the polling interval, an enquiry message is sent. ')
wfFrErrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 1), ("short", 2), ("long", 3), ("illegaldlci", 4), ("unknowndlci", 5), ("protoerr", 6), ("unknownie", 7), ("sequenceerr", 8), ("unknownrpt", 9), ("reset", 10), ("cntrl", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrErrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrErrType.setDescription(' Indicate the type of the last specific monitored error. ')
wfFrErrData = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 22), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrErrData.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrErrData.setDescription(' Contains as much of the error packet as possible. ')
wfFrErrTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrErrTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrErrTime.setDescription(' The time the last error occurred. ')
wfFrErrDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrErrDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrErrDiscards.setDescription(' The number of inbound frames dropped because of format or other errors or because the VC was not known. ')
wfFrErrDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrErrDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrErrDrops.setDescription(' The number of outbound frames dropped. Usually this is due the specified DLCI being unknown or a broadcast packet is too long ')
wfFrCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2), )
if mibBuilder.loadTexts: wfFrCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitTable.setDescription(' Frame Relay Circuit table gives information about a virtual circuits. ')
wfFrCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfFrCircuitNumber"), (0, "Wellfleet-Series7-MIB", "wfFrCircuitDlci"))
if mibBuilder.loadTexts: wfFrCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitEntry.setDescription(' An entry in the Frame Relay Circuit table. ')
wfFrCircuitDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2), ("system", 3))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitDelete.setDescription(' Indication to delete this frame relay interface. ')
wfFrCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitNumber.setDescription(' Instance identifier. The circuit number of this interface. ')
wfFrCircuitDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 1007, 1024, 64511, 131072, 8257535))).clone(namedValues=NamedValues(("twobyteminimum", 16), ("twobytemaximum", 1007), ("threebyteminimum", 1024), ("threebytemaximum", 64511), ("fourbyteminimum", 131072), ("fourbytemaximum", 8257535)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitDlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitDlci.setDescription(' Instance identifier. This indicates which virtual circuit. ')
wfFrCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3), ("xoff", 4), ("control", 5))).clone('invalid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitState.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitState.setDescription(' Indicates the state of the particular virtual circuit. ')
wfFrCircuitStateSet = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("invalid", 1), ("active", 2), ("inactive", 3))).clone('invalid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitStateSet.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitStateSet.setDescription(' User access for setting the state of a virtual circuit ')
wfFrCircuitReceivedFECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitReceivedFECNs.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitReceivedFECNs.setDescription(' Number of frames received indicating forward congestion. ')
wfFrCircuitReceivedBECNs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitReceivedBECNs.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitReceivedBECNs.setDescription(' Number of frames received indicating backward congestion. ')
wfFrCircuitSentFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitSentFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitSentFrames.setDescription(' The number of frames sent from this virtual circuit. ')
wfFrCircuitSentOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitSentOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitSentOctets.setDescription(' The number of octets sent from this virtual circuit. ')
wfFrCircuitReceivedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitReceivedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitReceivedFrames.setDescription(' The number of frames received from this virtual circuit. ')
wfFrCircuitReceivedOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitReceivedOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitReceivedOctets.setDescription(' The number of octets received from this virtual circuit. ')
wfFrCircuitCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitCreationTime.setDescription(' The value of sysUpTime when the vc was created. ')
wfFrCircuitLastTimeChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 13), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitLastTimeChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitLastTimeChange.setDescription(' The value of sysUpTime when last there was a change in vc state. ')
wfFrCircuitCommittedBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitCommittedBurst.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitCommittedBurst.setDescription(' Indicates the maximum amount of data, in bits, that the network agrees to transfer under normal conditions, during the measurement interval. Wellfleet does not presently support this. ')
wfFrCircuitExcessBurst = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitExcessBurst.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitExcessBurst.setDescription(' Indicates teh maximum amount of uncommitted data bits that the network will attempt to deliver over the measurement interval. Wellfleet does not presently support this. ')
wfFrCircuitThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitThroughput.setDescription(" This is the average number of 'Frame Relay Information Field' bits transferred per second across a user network interface in one direction, measured over the measurement interval. Wellfleet does not presently support this. ")
wfFrCircuitMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("multicast", 1), ("unicast", 2))).clone('unicast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitMulticast.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitMulticast.setDescription(' Indicates whether this DLCI is used for multicast or single destination. ')
wfFrCircuitDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitDiscards.setDescription(' The number of inbound frames discarded because of format errors, because the VC is inactive or because the protocol was not registered for this circuit. ')
wfFrCircuitDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfFrCircuitDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitDrops.setDescription(' Indicates how many outbound frames were dropped. Usually these are dropped because the VC is not active. ')
wfFrCircuitSubCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitSubCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitSubCct.setDescription(' Circuit number to use for this VC when configured in hybrid (for bridging) or direct access (VC as a circuit) mode. ')
wfFrCircuitMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("group", 1), ("hybrid", 2), ("direct", 3))).clone('group')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFrCircuitMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfFrCircuitMode.setDescription(" The mode of the given VC. GROUP - treats the VC as one of many vc's on a circuit. HYBRID - treats the VC as one of many vc's on a circuit for protocol traffic, but as a separate circuit for bridging. DIRECT - treats the VC as a separate circuit for all applications. ")
wfKernelTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1), )
if mibBuilder.loadTexts: wfKernelTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelTable.setDescription(' Table of kernel statistics, indexed by slot number ')
wfKernelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfKernelSlot"))
if mibBuilder.loadTexts: wfKernelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelEntry.setDescription(' A particular interface ')
wfKernelSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelSlot.setDescription(' The slot number indexes the kernel statistics table ')
wfKernelMemorySize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemorySize.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemorySize.setDescription(' The total size of allocatable memory, in bytes ')
wfKernelMemoryFree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemoryFree.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemoryFree.setDescription(" The amount of memory which hasn't been allocated yet, in bytes ")
wfKernelMemorySegsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemorySegsTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemorySegsTotal.setDescription(' Total number of memory segments in the kernel ')
wfKernelMemorySegsFree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemorySegsFree.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemorySegsFree.setDescription(' Total number of unallocated memory segments in the kernel ')
wfKernelMemoryMaxSegFree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemoryMaxSegFree.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemoryMaxSegFree.setDescription(' Size of the largest unallocated memory segment ')
wfKernelBuffersTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBuffersTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBuffersTotal.setDescription(' Total number of packet buffers ')
wfKernelBuffersFree = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBuffersFree.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBuffersFree.setDescription(' Number of packet buffers in the free pool ')
wfKernelTasksTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelTasksTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelTasksTotal.setDescription(' Number of tasks running ')
wfKernelTasksInQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelTasksInQueue.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelTasksInQueue.setDescription(' Number of tasks awaiting scheduling ')
wfKernelTimersTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelTimersTotal.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelTimersTotal.setDescription(' Total number of timers available ')
wfKernelTimersActive = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelTimersActive.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelTimersActive.setDescription(' Total number of timers in use by tasks ')
wfKernelBufOwnerTask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask1.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask1.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask1Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask1Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask1Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask2.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask2.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask2Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask2Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask2Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask3 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask3.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask3.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask3Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask3Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask3Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask4 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask4.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask4.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask4Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask4Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask4Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask5 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask5.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask5.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask5Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask5Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask5Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask6 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 23), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask6.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask6.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask6Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask6Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask6Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask7 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 25), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask7.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask7.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask7Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask7Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask7Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask8 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 27), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask8.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask8.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask8Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask8Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask8Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask9 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 29), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask9.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask9.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask9Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask9Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask9Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelBufOwnerTask10 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 31), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask10.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask10.setDescription(' Activation address of task which owns many buffers ')
wfKernelBufOwnerTask10Bufs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelBufOwnerTask10Bufs.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelBufOwnerTask10Bufs.setDescription(' Number of buffers owned by the task ')
wfKernelMemOwnerTask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 33), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask1.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask1.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask1Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask1Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask1Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 35), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask2.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask2.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask2Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask2Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask2Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask3 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 37), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask3.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask3.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask3Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask3Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask3Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask4 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 39), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask4.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask4.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask4Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask4Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask4Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask5 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 41), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask5.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask5.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask5Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask5Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask5Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask6 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 43), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask6.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask6.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask6Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask6Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask6Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask7 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 45), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask7.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask7.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask7Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask7Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask7Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask8 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 47), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask8.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask8.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask8Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask8Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask8Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask9 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 49), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask9.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask9.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask9Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask9Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask9Size.setDescription(' Amount of memory owned by the task ')
wfKernelMemOwnerTask10 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 51), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask10.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask10.setDescription(' Activation address of task which owns a sizable amount of memory ')
wfKernelMemOwnerTask10Size = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 5, 1, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfKernelMemOwnerTask10Size.setStatus('mandatory')
if mibBuilder.loadTexts: wfKernelMemOwnerTask10Size.setDescription(' Amount of memory owned by the task ')
wfHwBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 1, 1))
wfHwBpIdOpt = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 16640, 16896))).clone(namedValues=NamedValues(("acefn", 1), ("aceln", 2), ("acecn", 3), ("fns", 4), ("in", 5), ("freln", 16640), ("frecn", 16896)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBpIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBpIdOpt.setDescription(' The BackPlane identification number. ')
wfHwBpRev = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBpRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBpRev.setDescription(' The revision level of the BackPlane. High byte is in upper 2 bytes. ')
wfHwBpSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBpSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBpSerialNumber.setDescription(' The serial number of the BackPlane. ')
wfBCNPwrSupply1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNPwrSupply1.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNPwrSupply1.setDescription(' Status of BCN Hot-Swappable Power Supply 1 ')
wfBCNPwrSupply2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNPwrSupply2.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNPwrSupply2.setDescription(' Status of BCN Hot-Swappable Power Supply 2 ')
wfBCNPwrSupply3 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNPwrSupply3.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNPwrSupply3.setDescription(' Status of BCN Hot-Swappable Power Supply 3 ')
wfBCNPwrSupply4 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNPwrSupply4.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNPwrSupply4.setDescription(' Status of BCN Hot-Swappable Power Supply 4 ')
wfBCNFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("fail", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNFanStatus.setDescription(' Status of BCN Fan Tray ')
wfBCNTemperature = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("caution", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBCNTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: wfBCNTemperature.setDescription(' Status of BCN Fan Tray ')
wfHwTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 1, 2), )
if mibBuilder.loadTexts: wfHwTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwTable.setDescription(' Hardware Table - indexed by slot number ')
wfHwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfHwSlot"))
if mibBuilder.loadTexts: wfHwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwEntry.setDescription(' Hardware specific information about a slot. ')
wfHwSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwSlot.setDescription(' A unique value for each slot. Its value ranges between 1 and 14. There are products in this family that contain 1, 5, and 14 slots. ')
wfHwModIdOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 8, 16, 17, 24, 32, 33, 40, 41, 42, 43, 44, 45, 46, 47, 48, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 80, 81, 88, 89, 104, 112, 113, 114, 116, 117, 118, 119, 120, 132, 156, 160, 161, 162, 164, 165, 168, 176, 184, 192, 193, 194, 195, 196, 197, 198, 199, 208, 216, 217, 224, 225, 8448))).clone(namedValues=NamedValues(("enet1", 1), ("enet2", 8), ("sync1", 16), ("sync1a", 17), ("t11", 24), ("dse1", 32), ("dse1a", 33), ("dst416", 40), ("sst416a", 41), ("dst4", 42), ("sst4a", 43), ("sst416", 44), ("stok416", 45), ("sst4", 46), ("stok4", 47), ("floppy", 48), ("t12", 56), ("t12a", 57), ("st1", 58), ("t156k", 60), ("e1", 61), ("st156k", 62), ("se1", 63), ("t12n", 64), ("st1n", 65), ("t156kn", 66), ("st156kn", 67), ("e1n", 68), ("se1n", 69), ("sync", 80), ("sync2a", 81), ("cmcfddi", 88), ("iphfddi", 89), ("dt", 104), ("dsde1", 112), ("dsde1a", 113), ("enet", 114), ("dse2", 116), ("dse2a", 117), ("sse", 118), ("ssea", 119), ("dsde10bt", 120), ("enet3", 132), ("dsde2", 156), ("oldqenf", 160), ("denf", 161), ("qenf", 162), ("qef", 164), ("def", 165), ("mct1", 168), ("dtok", 176), ("mce1", 184), ("wffddi2m", 192), ("wffddi1m", 193), ("wffddi2s", 194), ("wffddi1s", 195), ("wffddi2mf", 196), ("wffddi1mf", 197), ("wffddi2sf", 198), ("wffddi1sf", 199), ("fnsdse", 208), ("fnsdsdt", 216), ("fnsdst", 217), ("dhssi", 224), ("shssi", 225), ("srml", 8448)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwModIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwModIdOpt.setDescription(" The module identification number. Port Configurations HWStat Name Enet Sync Async Token Framer Fiber ------ ------------ ------ ---- ----- ----- ------ ----- 1 ENET-1 2 0 0 0 0 0 8 ENET-2 2 0 0 0 0 0 16 SYNC-1 0 4 1 0 0 0 17 SYNC-1 [1] 0 4 1 0 0 0 24 T1-1 0 2 1 0 2 0 32 DSE-1 1 2 1 0 0 0 33 DSE-1 [1] 1 2 1 0 0 0 40 DST-4/16 0 2 1 1 0 0 41 SST-4/16 [1] 0 1 1 1 0 0 42 DST-4 0 2 1 1 0 0 43 SST-4 [1] 0 1 1 1 0 0 44 SST-4/16 0 1 1 1 0 0 45 STOK-4/16 [3] 0 0 0 1 0 0 46 SST-4 0 1 1 1 0 0 47 STOK-4 [3] 0 0 0 1 0 0 48 FLOPPY 0 0 0 0 0 0 56 T1-2 0 2 1 0 2 0 57 T1-2 0 2 1 0 2 0 58 ST1 0 1 1 0 1 0 60 T1-56K 0 1 1 0 1 0 61 E1 [3] 0 2 0 0 2 0 62 ST1-56K 0 1 1 0 1 0 63 SE1 [3] 0 1 0 0 1 0 64 T1-2n 0 2 1 0 2 0 65 ST1n 0 1 1 0 1 0 66 T1-56Kn 0 1 1 0 1 0 67 ST1-56Kn 0 1 1 0 1 0 68 E1n [3] 0 2 0 0 2 0 69 SE1n [3] 0 1 0 0 1 0 80 SYNC-2 0 4 1 0 0 0 81 SYNC-2 [1] 0 4 1 0 0 0 88 CMC-FDDI [6] 0 0 0 0 0 1 89 IPHASE-FDDI [6] 0 0 0 0 0 1 104 DT 0 0 0 2 0 0 112 DSDE-1 2 2 1 0 0 0 113 DSDE-1 [1] 2 2 1 0 0 0 114 ENET 2 0 0 0 0 0 116 DSE-2 1 2 1 0 0 0 117 DSE-2 [1] 1 2 1 0 0 0 118 SSE 1 1 1 0 0 0 119 SSE [1] 1 1 1 0 0 0 120 DSDE10BT 2 2 0 0 0 0 132 ENET-3 [2] 2 0 0 0 0 0 156 DSDE-2 [2] 2 2 1 0 0 0 160 QE/NF 4 0 0 0 0 0 161 DE/NF [5] 2 0 0 0 0 0 162 QE/NF 4 0 0 0 0 0 164 QE/F [4] 4 0 0 0 0 0 165 DE/F [4,5] 2 0 0 0 0 0 168 MCT1 0 2 Munich 0 0 2 0 176 DTOK 0 0 0 2 0 0 168 MCE1 0 2 Munich 0 0 2 0 192 WF_FDDI_2M 0 0 0 0 0 1 193 WF_FDDI_1M 0 0 0 0 0 1 194 WF_FDDI_2S 0 0 0 0 0 1 195 WF_FDDI_1S 0 0 0 0 0 1 196 WF_FDDI_2MF 0 0 0 0 0 1 197 WF_FDDI_1MF 0 0 0 0 0 1 198 WF_FDDI_2SF 0 0 0 0 0 1 199 WF_FDDI_1SF 0 0 0 0 0 1 208 FNSDSE [7] 1 2 0 0 0 0 216 FNSDSDT [7] 0 2 0 2 0 0 217 FNSDST [7] 0 2 0 1 0 0 224 DHSSI 0 2 hssi 0 0 0 0 225 SHSSI 0 1 hssi 0 0 0 0 8448 SRML 0 0 0 0 0 0 NOTES: [1] Indicates Module has COM Port 1 configured for ASYNC. The AM8530's port B is configured for COM1. [2] This Module contains the DEFA - Hardware Filtering. CAMS must be programmed (can contain 2 - 6 CAMS onboard). [3] The AM8530 has been removed (depopulated) from this module. Programming this device should not be performed. [4] Contains Dual Defa hardware. (Can be depopulated) [5] Depop'd two ports of hardware to make Dual Ethernet module. [6] These are FDDI modules. The ID cannot be read from the Link module I/O space. [7] These are FNS Platform Integrated 'Modules' - Cannot be detached or be used by any other platform. ")
wfHwModRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwModRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwModRev.setDescription(' The revision level of the module. High byte is in upper 2 bytes. ')
wfHwModSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwModSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwModSerialNumber.setDescription(' The serial number of the module. ')
wfHwMotherBdIdOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 256, 8704))).clone(namedValues=NamedValues(("sysctrl", 1), ("ace12", 2), ("ace25", 3), ("ace32", 4), ("fns", 5), ("in", 6), ("fre", 256), ("srmf", 8704)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwMotherBdIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwMotherBdIdOpt.setDescription(' The mother board identification number. ')
wfHwMotherBdRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwMotherBdRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwMotherBdRev.setDescription(' The revision level of the mother board. High byte is in upper 2 bytes. ')
wfHwMotherBdSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwMotherBdSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwMotherBdSerialNumber.setDescription(' The serial number of the mother board. ')
wfHwDaughterBdIdOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 4352, 4608))).clone(namedValues=NamedValues(("sysctrl", 1), ("ace68020mhz12", 2), ("ace68020mhz25", 3), ("ace68030mhz32", 4), ("fre68040mhz25", 4352), ("fre68040mhz33", 4608)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDaughterBdIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDaughterBdIdOpt.setDescription(' The daughter board identification number. ')
wfHwDaughterBdRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDaughterBdRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDaughterBdRev.setDescription(' The revision level of the daughter board. High byte is in upper 2 bytes. ')
wfHwDaughterBdSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDaughterBdSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDaughterBdSerialNumber.setDescription(' The serial number of the daughter board. ')
wfHwBabyBdIdOpt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBabyBdIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBabyBdIdOpt.setDescription(' The baby board identification number. ')
wfHwBabyBdRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBabyBdRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBabyBdRev.setDescription(' The revision level of the baby board. High byte is in upper 2 bytes. ')
wfHwBabyBdSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBabyBdSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBabyBdSerialNumber.setDescription(' The serial number of the baby board. ')
wfHwDiagPromRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 14), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDiagPromRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDiagPromRev.setDescription(' The revision level of the Diagnostic PROM. Major revision level is in the upper 2 bytes, minor revision level in the lower 2 bytes. ')
wfHwDiagPromDate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDiagPromDate.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDiagPromDate.setDescription(' The creation date of the Diagnostic PROM ')
wfHwDiagPromSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwDiagPromSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwDiagPromSource.setDescription(' The origin of the Diagnostic PROM contents ')
wfHwBootPromRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 17), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBootPromRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBootPromRev.setDescription(' The revision level of the BOOT PROM. Major revision level is in the upper 2 bytes, minor revision level in the lower 2 bytes. ')
wfHwBootPromDate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 18), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBootPromDate.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBootPromDate.setDescription(' The creation date of the Boot PROM ')
wfHwBootPromSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwBootPromSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwBootPromSource.setDescription(' The origin of the Boot PROM contents ')
wfHwSparePromRev = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 20), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwSparePromRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwSparePromRev.setDescription(' The revision level of the BOOT PROM. Major revision level is in the upper 2 bytes, minor revision level in the lower 2 bytes. ')
wfHwSparePromDate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwSparePromDate.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwSparePromDate.setDescription(' The creation date of the Spare PROM ')
wfHwSparePromSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwSparePromSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwSparePromSource.setDescription(' The origin of the Spare PROM contents ')
wfHwFileSysPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("filesys", 1), ("nofilesys", 2))).clone('nofilesys')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwFileSysPresent.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwFileSysPresent.setDescription(' Flag indicating presence of File System on this slot. ')
wfHssiTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 7), )
if mibBuilder.loadTexts: wfHssiTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTable.setDescription(' HSSI line record ')
wfHssiEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfHssiSlot"), (0, "Wellfleet-Series7-MIB", "wfHssiConnector"))
if mibBuilder.loadTexts: wfHssiEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiEntry.setDescription(' An entry in the HSSI table ')
wfHssiDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiDelete.setDescription(' Create/Delete parameter ')
wfHssiDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiDisable.setDescription(' Enable/Disable parameter ')
wfHssiState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("up", 1), ("lmiwait", 2), ("boflwait", 3), ("cawait", 4), ("init", 5), ("notpresent", 6))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiState.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiState.setDescription(' Line Driver state variable, Not Present, Init, Down, Up ')
wfHssiSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiSlot.setDescription(' Instance ID Slot, filled in by driver ')
wfHssiConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiConnector.setDescription(' Instance ID Connector, filled in by driver ')
wfHssiCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiCct.setDescription(' CCT number for this line instance ')
wfHssiBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiBofl.setDescription(' breath of life parameter ')
wfHssiBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 60, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 60), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiBoflTmo.setDescription(' breath of life frequency in seconds ')
wfHssiMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4500, 4495))).clone(namedValues=NamedValues(("minimum", 3), ("maximum", 4500), ("default", 4495))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiMtu.setDescription(' MTU parameter, this is buffer size for HSSI media, fixed ')
wfHssiMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiMadr.setDescription(' Line MAC address, fixed - line driver fills in from the 48 bit address stored in the serial number prom for this connector. ')
wfHssiService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transparent", 1), ("undefined", 2))).clone('transparent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiService.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiService.setDescription(' Service type for this circuit. Transparent is raw HDLC mode, and is the only service provided on the current HSSI product ')
wfHssiWanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("standard", 1), ("passthru", 2), ("ppp", 3), ("smds", 4), ("framerelay", 5))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiWanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiWanProtocol.setDescription(' WAN protocol selection is provided via this parameter. The supported protocols can be selected per interface. ')
wfHssiTransmissionInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("dsone", 1), ("dsthree", 3))).clone('dsthree')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiTransmissionInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTransmissionInterface.setDescription(' T1 or T3, in the future OC1, OC3 and OC12. Used for MIB selection ')
wfHssiExternalClkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(307200, 52638515, 46359642))).clone(namedValues=NamedValues(("minimum", 307200), ("maximum", 52638515), ("default", 46359642))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiExternalClkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiExternalClkSpeed.setDescription(' External Clock Speed, Used in the future for route selection ')
wfHssiCrcSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16bit", 1), ("crc32bit", 2))).clone('crc32bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiCrcSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiCrcSize.setDescription(' CRC size parameter, 16 bit standard CCITT or extended 32 bit CRC ')
wfHssiInternalClkTestMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiInternalClkTestMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiInternalClkTestMode.setDescription(' Enables internal transmit clock generation. Should NEVER be enabled for normal operation. ')
wfHssiRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxOctets.setDescription(' Number of bytes received without error ')
wfHssiRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxFrames.setDescription(' Number of frames received without error ')
wfHssiTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxOctets.setDescription(' Number of bytes transmitted without error ')
wfHssiTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxFrames.setDescription(' Number of frames transmitted without error ')
wfHssiInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiInDiscards.setDescription(' Number of error-free inbound packets discarded. Usually due to lack of memory resources. ')
wfHssiInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiInErrors.setDescription(' Number of inbound packets not delivered to higher-layer protocol because of errors. ')
wfHssiOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiOutDiscards.setDescription(' Number of error-free outbound packets discarded. Usually due to lack of transmission bandwidth. ')
wfHssiOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiOutErrors.setDescription(' Number of outbound packets that could not be transmitted because of errors. ')
wfHssiRxLongFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxLongFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxLongFrames.setDescription(' Number of Long frames dropped on receive because of length ')
wfHssiTxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxClipFrames.setDescription(' Number of frames clipped in the transmit routine ')
wfHssiRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxReplenMisses.setDescription(' Number of failed attempts by the line driver to aquire a packet buffer ')
wfHssiLastRxErrorCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiLastRxErrorCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiLastRxErrorCtrl.setDescription(" Last errored receive descriptor's control field ")
wfHssiRxCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxCrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxCrcErrors.setDescription(' Number of frames received with CRC errors ')
wfHssiRxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxOverruns.setDescription(' Number of frames received with fifo overrun errors ')
wfHssiRxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxAborts.setDescription(' Number of frames received with abort status ')
wfHssiLastTxErrorCtrl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiLastTxErrorCtrl.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiLastTxErrorCtrl.setDescription(" Last errored transmit descriptor's control field ")
wfHssiTxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxAborts.setDescription(' Number of transmit frames with internal abort errors ')
wfHssiTxUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxUnderruns.setDescription(' Number of transmit frames aborted with underrun errors ')
wfHssiRxRingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxRingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxRingErrors.setDescription(' Number of receive ring error events ')
wfHssiLastRxRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiLastRxRingState.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiLastRxRingState.setDescription(' Last 8 bit value from the recv ring state register ')
wfHssiRxRingOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxRingOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxRingOverruns.setDescription(' Number of receive ring overrun events ')
wfHssiTxRingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxRingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxRingErrors.setDescription(' Number of transmit ring error events ')
wfHssiLastTxRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiLastTxRingState.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiLastTxRingState.setDescription(' Last 8 bit value from the transmit ring state register ')
wfHssiPortOpErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiPortOpErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiPortOpErrors.setDescription(' Number of port operation error events ')
wfHssiInternOpErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiInternOpErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiInternOpErrors.setDescription(' Number of internal operation error events ')
wfHssiHostErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiHostErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiHostErrors.setDescription(' Number of parity errs on host accesses to directly accessable registers. ')
wfHssiRxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiRxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxProcessings.setDescription(' Number of receive frame processings (RINT) ')
wfHssiTxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxProcessings.setDescription(' Number of transmit processings, invokations of transmit routine ')
wfHssiTxCmplProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiTxCmplProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxCmplProcessings.setDescription(' Number of transmit complete processings (TINT) ')
wfHssiIntrProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHssiIntrProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiIntrProcessings.setDescription(' Number of Interrupt processings, invokations of intr routine ')
wfHssiBoflNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 127, 5))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 127), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiBoflNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiBoflNum.setDescription(' Number of breath of life packets per breath of life ')
wfHssiBoflLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(22, 4450, 100))).clone(namedValues=NamedValues(("minimum", 22), ("maximum", 4450), ("default", 100))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiBoflLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiBoflLen.setDescription(' breath of life packet length ')
wfHssiRxBufferLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(64, 128))).clone(namedValues=NamedValues(("length4k", 64), ("length8k", 128))).clone('length4k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiRxBufferLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxBufferLength.setDescription(' Performance tunning parameter controls Receive buffer size. ')
wfHssiMemPageLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("length32", 1), ("length256", 3))).clone('length32')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiMemPageLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiMemPageLength.setDescription(' Performance tunning parameter controls device memory access burst length. ')
wfHssiRxRingLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 64))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 64))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiRxRingLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxRingLength.setDescription(' Performance tunning parameter controls the receive queue length. Receive Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfHssiTxRingLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 127))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 127))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiTxRingLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxRingLength.setDescription(' Performance tunning parameter controls the transmit queue length. Transmit Queue Length, values larger than the compiled ring size are truncated to the compiled ring size. ')
wfHssiRxFifoWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 255, 2))).clone(namedValues=NamedValues(("minimum", 2), ("maximum", 255), ("default", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiRxFifoWatermark.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiRxFifoWatermark.setDescription(' Performance tunning parameter controls the receive watermark. ')
wfHssiTxFifoWatermark = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 255, 16))).clone(namedValues=NamedValues(("minimum", 2), ("maximum", 255), ("default", 16))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiTxFifoWatermark.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTxFifoWatermark.setDescription(' Performance tunning parameter controls the transmit watermark. ')
wfHssiMaxRxMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 255), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiMaxRxMemory.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiMaxRxMemory.setDescription(' Performance tunning parameter controls fifo area allowed for receive. ')
wfHssiLinkInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 56), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("ace25", 2), ("ace32", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiLinkInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiLinkInterface.setDescription(' Only for DEBUG. ')
wfHssiTurboBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 7, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHssiTurboBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfHssiTurboBofl.setDescription(' Only for DEBUG, Turbo breath of life parameter ')
wfHwfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1), )
if mibBuilder.loadTexts: wfHwfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfTable.setDescription(' The following table will contain information about a collection of Hardware Filter (HWF) driver records. Only one HWF driver may be spawned, by the loader, on a given slot. Hence, only the slot number is used as the instance identifier into the table. ')
wfHwfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfHwfSlot"))
if mibBuilder.loadTexts: wfHwfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfEntry.setDescription(' Slot number used as instance identifier. ')
wfHwfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHwfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfDelete.setDescription(' Create/delete parameter. ')
wfHwfEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHwfEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfEnable.setDescription(' Enable/disable parameter. ')
wfHwfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfState.setDescription(' Driver state variable. ')
wfHwfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfSlot.setDescription(' Slot number -- instance ID. ')
wfHwfAvailableLines = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfAvailableLines.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfAvailableLines.setDescription(' Number of available lines on module. ')
wfHwfLineTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2), )
if mibBuilder.loadTexts: wfHwfLineTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineTable.setDescription(' The following table will contain information about a collection of Hardware Filter (HWF) line records. ')
wfHwfLineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfHwfLineSlot"), (0, "Wellfleet-Series7-MIB", "wfHwfLineNumber"))
if mibBuilder.loadTexts: wfHwfLineEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineEntry.setDescription(' Slot number and line number used as instance identifier. ')
wfHwfLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("operational", 1), ("disabled", 2), ("full", 3))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineState.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineState.setDescription(' State of filtering hardware on a per line basis. ')
wfHwfLineSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineSlot.setDescription(' Slot number -- instance ID. ')
wfHwfLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineNumber.setDescription(' Line number -- instance ID. ')
wfHwfLineCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineCct.setDescription(' Circuit number associated with a line. ')
wfHwfLineCapableMaxTblSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineCapableMaxTblSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineCapableMaxTblSize.setDescription(' This attribute specifies the maximum number of table entries capable of being used by a line based upon actual hardware filter devices present and available. ')
wfHwfLineCurrentTblSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineCurrentTblSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineCurrentTblSize.setDescription(' Current capacity of the hardware filter table. Hardware filter table resources are dynamically allocated (in increments of 256) on an as-needed basis up to the available table size. ')
wfHwfLineCurrentUsedEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineCurrentUsedEntries.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineCurrentUsedEntries.setDescription(' Number of hardware filter table entries used. ')
wfHwfLineDroppedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 6, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfHwfLineDroppedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfHwfLineDroppedFrames.setDescription(' Number of frames dropped because of hardware filter match. ')
wfMod = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 1, 3))
wfModState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("init", 1))))
if mibBuilder.loadTexts: wfModState.setStatus('mandatory')
if mibBuilder.loadTexts: wfModState.setDescription(' State of this record ')
wfModSlot = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 2), Integer32())
if mibBuilder.loadTexts: wfModSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfModSlot.setDescription(' Instance of this record ')
wfModIdOpt = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 3), Integer32())
if mibBuilder.loadTexts: wfModIdOpt.setStatus('mandatory')
if mibBuilder.loadTexts: wfModIdOpt.setDescription(' actual module ID and Option ')
wfModRev = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 4), Integer32())
if mibBuilder.loadTexts: wfModRev.setStatus('mandatory')
if mibBuilder.loadTexts: wfModRev.setDescription(' actual module Revision ')
wfModProm = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 5), Integer32())
if mibBuilder.loadTexts: wfModProm.setStatus('mandatory')
if mibBuilder.loadTexts: wfModProm.setDescription(' module PROM ')
wfModMidr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 6), Integer32())
if mibBuilder.loadTexts: wfModMidr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMidr.setDescription(' module ID register ')
wfModMled = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 7), Integer32())
if mibBuilder.loadTexts: wfModMled.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMled.setDescription(' module LED register ')
wfModMisr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 8), Integer32())
if mibBuilder.loadTexts: wfModMisr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMisr.setDescription(' module MISR register ')
wfModSnprom = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 9), Integer32())
if mibBuilder.loadTexts: wfModSnprom.setStatus('mandatory')
if mibBuilder.loadTexts: wfModSnprom.setDescription(' module SNPROM ')
wfModMadr1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 10), OctetString())
if mibBuilder.loadTexts: wfModMadr1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMadr1.setDescription(' SNPROM MAC address connector 1 ')
wfModMadr2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 11), OctetString())
if mibBuilder.loadTexts: wfModMadr2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMadr2.setDescription(' SNPROM MAC address connector 2 ')
wfModMadr3 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 12), OctetString())
if mibBuilder.loadTexts: wfModMadr3.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMadr3.setDescription(' SNPROM MAC address connector 3 ')
wfModMadr4 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 13), OctetString())
if mibBuilder.loadTexts: wfModMadr4.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMadr4.setDescription(' SNPROM MAC address connector 4 ')
wfModLance1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 14), Integer32())
if mibBuilder.loadTexts: wfModLance1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModLance1.setDescription(' LANCE line 1 ')
wfModLance2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 15), Integer32())
if mibBuilder.loadTexts: wfModLance2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModLance2.setDescription(' LANCE line 2 ')
wfModMk50251 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 16), Integer32())
if mibBuilder.loadTexts: wfModMk50251.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMk50251.setDescription(' MK5025 line 1 ')
wfModMk50252 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 17), Integer32())
if mibBuilder.loadTexts: wfModMk50252.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMk50252.setDescription(' MK5025 line 2 ')
wfModMk50253 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 18), Integer32())
if mibBuilder.loadTexts: wfModMk50253.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMk50253.setDescription(' MK5025 line 3 ')
wfModMk50254 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 19), Integer32())
if mibBuilder.loadTexts: wfModMk50254.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMk50254.setDescription(' MK5025 line 4 ')
wfModSicr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 20), Integer32())
if mibBuilder.loadTexts: wfModSicr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModSicr.setDescription(' SYNC interface control register ')
wfModSbrr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 21), Integer32())
if mibBuilder.loadTexts: wfModSbrr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModSbrr.setDescription(' SYNC baudrate register ')
wfMod8530 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 22), Integer32())
if mibBuilder.loadTexts: wfMod8530.setStatus('mandatory')
if mibBuilder.loadTexts: wfMod8530.setDescription(' 8530 DUART ')
wfModCar = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 23), Integer32())
if mibBuilder.loadTexts: wfModCar.setStatus('mandatory')
if mibBuilder.loadTexts: wfModCar.setDescription(' CAM assembly register ')
wfModDefaA = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 24), Integer32())
if mibBuilder.loadTexts: wfModDefaA.setStatus('mandatory')
if mibBuilder.loadTexts: wfModDefaA.setDescription(' DEFA A chip ')
wfModCamALock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 25), Integer32())
if mibBuilder.loadTexts: wfModCamALock.setStatus('mandatory')
if mibBuilder.loadTexts: wfModCamALock.setDescription(' CAM A lock ')
wfModCamAUnlock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 26), Integer32())
if mibBuilder.loadTexts: wfModCamAUnlock.setStatus('mandatory')
if mibBuilder.loadTexts: wfModCamAUnlock.setDescription(' CAM A unlock ')
wfModDefaB = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 27), Integer32())
if mibBuilder.loadTexts: wfModDefaB.setStatus('mandatory')
if mibBuilder.loadTexts: wfModDefaB.setDescription(' DEFA B chip ')
wfModCamBLock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 28), Integer32())
if mibBuilder.loadTexts: wfModCamBLock.setStatus('mandatory')
if mibBuilder.loadTexts: wfModCamBLock.setDescription(' CAM B lock ')
wfModCamBUnlock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 29), Integer32())
if mibBuilder.loadTexts: wfModCamBUnlock.setStatus('mandatory')
if mibBuilder.loadTexts: wfModCamBUnlock.setDescription(' CAM B unlock ')
wfModIlacc1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 30), Integer32())
if mibBuilder.loadTexts: wfModIlacc1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModIlacc1.setDescription(' ILACC line 1 ')
wfModIlacc2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 31), Integer32())
if mibBuilder.loadTexts: wfModIlacc2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModIlacc2.setDescription(' ILACC line 2 ')
wfModIlacc3 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 32), Integer32())
if mibBuilder.loadTexts: wfModIlacc3.setStatus('mandatory')
if mibBuilder.loadTexts: wfModIlacc3.setDescription(' ILACC line 3 ')
wfModIlacc4 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 33), Integer32())
if mibBuilder.loadTexts: wfModIlacc4.setStatus('mandatory')
if mibBuilder.loadTexts: wfModIlacc4.setDescription(' ILACC line 4 ')
wfModTms3801 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 34), Integer32())
if mibBuilder.loadTexts: wfModTms3801.setStatus('mandatory')
if mibBuilder.loadTexts: wfModTms3801.setDescription(' TOKEN ring chip line 1 ')
wfModTms3802 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 35), Integer32())
if mibBuilder.loadTexts: wfModTms3802.setStatus('mandatory')
if mibBuilder.loadTexts: wfModTms3802.setDescription(' TOKEN ring chip line 2 ')
wfModTocr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 36), Integer32())
if mibBuilder.loadTexts: wfModTocr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModTocr.setDescription(' TOKEN control register ')
wfModTsra = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 37), Integer32())
if mibBuilder.loadTexts: wfModTsra.setStatus('mandatory')
if mibBuilder.loadTexts: wfModTsra.setDescription(' TOKEN source route accelerator ')
wfModMuxram1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 38), Integer32())
if mibBuilder.loadTexts: wfModMuxram1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMuxram1.setDescription(' T1 mux RAM active ')
wfModMuxram2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 39), Integer32())
if mibBuilder.loadTexts: wfModMuxram2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMuxram2.setDescription(' T1 mux RAM inactive ')
wfModTicr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 40), Integer32())
if mibBuilder.loadTexts: wfModTicr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModTicr.setDescription(' T1 interface control register ')
wfModFramer1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 41), Integer32())
if mibBuilder.loadTexts: wfModFramer1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModFramer1.setDescription(' T1 framer line 1 ')
wfModFramer2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 42), Integer32())
if mibBuilder.loadTexts: wfModFramer2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModFramer2.setDescription(' T1 framer line 2 ')
wfModFsi1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 43), Integer32())
if mibBuilder.loadTexts: wfModFsi1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModFsi1.setDescription(' FDDI FSI line 1 ')
wfModMac1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 44), Integer32())
if mibBuilder.loadTexts: wfModMac1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMac1.setDescription(' FDDI MAC line 1 ')
wfModElmA1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 45), Integer32())
if mibBuilder.loadTexts: wfModElmA1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModElmA1.setDescription(' FDDI ELM A line 1 ')
wfModElmB1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 46), Integer32())
if mibBuilder.loadTexts: wfModElmB1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModElmB1.setDescription(' FDDI ELM B line 1 ')
wfModMcr1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 47), Integer32())
if mibBuilder.loadTexts: wfModMcr1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModMcr1.setDescription(' FDDI Module control register line 1 ')
wfModHssiFsi1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 48), Integer32())
if mibBuilder.loadTexts: wfModHssiFsi1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHssiFsi1.setDescription(' HSSI FSI line 1 ')
wfModHssiFsi2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 49), Integer32())
if mibBuilder.loadTexts: wfModHssiFsi2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHssiFsi2.setDescription(' HSSI FSI line 2 ')
wfModHssiUga1 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 50), Integer32())
if mibBuilder.loadTexts: wfModHssiUga1.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHssiUga1.setDescription(' HSSI UGA-330-2 line 1 ')
wfModHssiUga2 = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 51), Integer32())
if mibBuilder.loadTexts: wfModHssiUga2.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHssiUga2.setDescription(' HSSI UGA-330-2 line 2 ')
wfModHicr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 52), Integer32())
if mibBuilder.loadTexts: wfModHicr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHicr.setDescription(' HSSI Control Register address ')
wfModHicrData = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 53), Integer32())
if mibBuilder.loadTexts: wfModHicrData.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHicrData.setDescription(' HSSI Last value written to the HICR ')
wfModHlsr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 54), Integer32())
if mibBuilder.loadTexts: wfModHlsr.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHlsr.setDescription(' HSSI Line Status Register address ')
wfModHlsrData = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 1, 3, 55), Integer32())
if mibBuilder.loadTexts: wfModHlsrData.setStatus('mandatory')
if mibBuilder.loadTexts: wfModHlsrData.setDescription(' HSSI Last value read from HLSR ')
wfIf = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 1))
wfIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfNumber.setDescription(' Total number of possible active interfaces ')
wfIfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2), )
if mibBuilder.loadTexts: wfIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfTable.setDescription(' A table containing active interfaces ')
wfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIfIndex"))
if mibBuilder.loadTexts: wfIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfEntry.setDescription(' A particular interface ')
wfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfIndex.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfDescr.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfType.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfMtu.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfSpeed.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfPhysAddress.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfAdminStatus.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOperStatus.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfLastChange.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInOctets.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInUcastPkts.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInNUCastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInNUCastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInNUCastPkts.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInDiscards.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInErrors.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfInUnknownProtos.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutOctets.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutUcastPkts.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutNUcastPkts.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutDiscards.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutErrors.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfOutQLen.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIfSpecific = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 3, 2, 1, 22), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIfSpecific.setStatus('mandatory')
if mibBuilder.loadTexts: wfIfSpecific.setDescription(" Corresponds to same attribute of MIB-II's ifTable ")
wfIpBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1))
wfIpBaseCreate = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseCreate.setDescription('Create/Delete parameter. Default is created. Users perform a set operation on this object in order to create/delete IP.')
wfIpBaseEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform a set operation on this object in order to enable/disable IP.')
wfIpBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpres", 4))).clone('notpres')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseState.setDescription('The current state of the entire IP.')
wfIpBaseForwarding = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("notforwarding", 2))).clone('forwarding')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseForwarding.setDescription("The indication of whether this entity is acting as an IP gateway in respect to the forwarding of datagrams received by, but not addressed to, this entity. IP gateways forward datagrams. IP hosts do not (except those source-routed via the host). Note that for some managed nodes, this object may take on only a subset of the values possible. Accordingly, it is appropriate for an agent to return a `badValue' response if a management station attempts to change this object to an inappropriate value.")
wfIpBaseDefaultTTL = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(30, 255))).clone(namedValues=NamedValues(("default", 30), ("ttlmax", 255))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseDefaultTTL.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseDefaultTTL.setDescription('The default value inserted into the Time-To-Live field of the IP header of datagrams originated at this entity, whenever a TTL value is not supplied by the transport layer protocol. ')
wfIpBaseRipDiameter = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15, 15))).clone(namedValues=NamedValues(("dflt", 15), ("maximum", 15))).clone('dflt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseRipDiameter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRipDiameter.setDescription(" The Diameter of the RIP network. 1 less than 'infinity' ")
wfIpBaseRtEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2), )
if mibBuilder.loadTexts: wfIpBaseRtEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRtEntryTable.setDescription(" The list of elements in IP's routing table ")
wfIpBaseRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpBaseRouteDest"))
if mibBuilder.loadTexts: wfIpBaseRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRtEntry.setDescription(' A description of a route ')
wfIpBaseRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteDest.setDescription(' The destination IP address of this route. An entry with a value of 0.0.0.0 is considered a default route. Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
wfIpBaseRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
wfIpBaseRouteMetric1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMetric1.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMetric1.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpBaseRouteMetric2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMetric2.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMetric2.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpBaseRouteMetric3 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMetric3.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMetric3.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpBaseRouteMetric4 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMetric4.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMetric4.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpBaseRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteNextHop.setDescription("The IP address of the next hop of this route. (In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IP address on that interface.)")
wfIpBaseRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteType.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the IP architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively dissasociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. nagement stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
wfIpBaseRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 14))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("is", 9), ("ospf", 13), ("bgp", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
wfIpBaseRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
wfIpBaseRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMask.setDescription('Indicate the mask to be logical-ANDed with the destination address before being compared to the value in the ipRouteDest field. For those systems that do not support arbitrary subnet masks, an agent constructs the value of the ipRouteMask by determining whether the value of the correspondent ipRouteDest field belong to a class-A, B, or C network, and then using one of: mask network 255.0.0.0 class-A 255.255.0.0 class-B 255.255.255.0 class-C If the value of the ipRouteDest is 0.0.0.0 (a default route), then the mask value is also 0.0.0.0. It should be noted that all IP routing subsystems implicitly use this mechanism.')
wfIpBaseRouteMetric5 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteMetric5.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteMetric5.setDescription("An alternate routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpBaseRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 2, 1, 13), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseRouteInfo.setDescription(' A user-defined string which describes this Route entry ')
wfIpBaseHostEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3), )
if mibBuilder.loadTexts: wfIpBaseHostEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseHostEntryTable.setDescription(" The list of elements in IP's host table ")
wfIpBaseHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpBaseNetToMediaNetAddress"))
if mibBuilder.loadTexts: wfIpBaseHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseHostEntry.setDescription(' A description of a resolved host ')
wfIpBaseNetToMediaIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseNetToMediaIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseNetToMediaIfIndex.setDescription("The interface on which this entry's equivalence is effective. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.")
wfIpBaseNetToMediaPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseNetToMediaPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseNetToMediaPhysAddress.setDescription("The media-dependent `physical' address.")
wfIpBaseNetToMediaNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpBaseNetToMediaNetAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseNetToMediaNetAddress.setDescription("The IpAddress corresponding to the media-dependent `physical' address.")
wfIpBaseNetToMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpBaseNetToMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpBaseNetToMediaType.setDescription('The type of mapping. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipNetToMediaTable. That is, it effectively dissasociates the interface identified with said entry from the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipNetToMediaType object. ')
wfIpInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4), )
if mibBuilder.loadTexts: wfIpInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceTable.setDescription(' The list of configured IP interface ')
wfIpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpInterfaceAddr"), (0, "Wellfleet-Series7-MIB", "wfIpInterfaceCircuit"))
if mibBuilder.loadTexts: wfIpInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceEntry.setDescription(' An IP interface description ')
wfIpInterfaceCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceCreate.setDescription('Create/Delete parameter. Default is created. Users perform a set operation on this object in order to create/delete an IP interface.')
wfIpInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform a set operation on this object in order to enable/disable an IP interface.')
wfIpInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("invalid", 4), ("notpres", 5))).clone('notpres')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceState.setDescription(' INvalid indicates an error in processing the cfg record ')
wfIpInterfaceAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceAddr.setDescription(" The IP Address to which this entry's addressing information pertains ")
wfIpInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceCircuit.setDescription(' The Circuit Number that this interface runs over')
wfIpInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceMask.setDescription('The subnet mask associated with the IP address of this entry. The value of the mask is an IP address with all the network bits set to 1 and all the hosts bits set to 0.')
wfIpInterfaceCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 7), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceCost.setDescription(' The Cost metric associated with the IP Address of this entry ')
wfIpInterfaceCfgBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 8), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceCfgBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceCfgBcastAddr.setDescription(' The user can specifcy a broadcast address for a NWIF ')
wfIpInterfaceBcastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceBcastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceBcastAddr.setDescription('The value of the broadcast address used for sending datagrams on the (logical) interface associated with the IP address of this entry. This value applies to both the subnet and network broadcasts addresses used by the entity on this (logical) interface. This is value used by the software ')
wfIpInterfaceMTUDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceMTUDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceMTUDiscovery.setDescription(' Whether MTU discovery option is on/off ')
wfIpInterfaceAMR = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceAMR.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceAMR.setDescription(' Whether Address Mask Reply is ON/OFF ')
wfIpInterfaceASB = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceASB.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceASB.setDescription(' Whether All-Subnet Broadcasts Are excepted and Sent out this NWIF ')
wfIpInterfaceAddressResolutionType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("arp", 1), ("probe", 2), ("ddn", 3), ("pdn", 4), ("inarp", 5), ("arpinarp", 6))).clone('arp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceAddressResolutionType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceAddressResolutionType.setDescription(' Indicates which Address Resolution Type to use ')
wfIpInterfaceProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceProxy.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceProxy.setDescription(' Indicates Whether Proxy is on this Interface or not ')
wfIpInterfaceHostCache = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 120, 180, 240, 300, 600, 900, 1200))).clone(namedValues=NamedValues(("cacheoff", 1), ("cache120", 120), ("cache180", 180), ("cache240", 240), ("cache300", 300), ("cache600", 600), ("cache900", 900), ("cache1200", 1200))).clone('cacheoff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceHostCache.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceHostCache.setDescription(" Whether the Host Cache (Address Aging) is on or not. A Range of discrete values is specified as well as a value meaning don't age ")
wfIpInterfaceUdpXsumOn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceUdpXsumOn.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceUdpXsumOn.setDescription(' Whether to turn UDP checksum verification on for UDP packets recieved and transmitted by this router ')
wfIpInterfaceCfgMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceCfgMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceCfgMacAddress.setDescription(' The desired mac set by the user ')
wfIpInterfaceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceMacAddress.setDescription(' The MAC Address for this Interface- actual one used ')
wfIpInterfaceReasmMaxSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceReasmMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceReasmMaxSize.setDescription('The size of the largest IP datagram which this entity can re-assemble from incoming IP fragmented datagrams received on this interface.')
wfIpInterfaceMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
wfIpInterfaceInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInReceives.setDescription('The total number of input datagrams received from interfaces, including those received in error.')
wfIpInterfaceInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInHdrErrors.setDescription('The number of input datagrams discarded due to errors in their IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc.')
wfIpInterfaceInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInAddrErrors.setDescription("The number of input datagrams discarded because the IP address in their IP header's destination field was not a valid address to be received at this entity. This count includes invalid addresses (e.g., 0.0.0.0) and addresses of unsupported Classes (e.g., Class E). For entities which are not IP Gateways and therefore do not forward datagrams, this counter includes datagrams discarded because the destination address was not a local address.")
wfIpInterfaceForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceForwDatagrams.setDescription('The number of input datagrams for which this entity was not their final IP destination, as a result of which an attempt was made to find a route to forward them to that final destination. In entities which do not act as IP Gateways, this counter will include only those packets which were Source-Routed via this entity, and the Source- Route option processing was successful.')
wfIpInterfaceInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol.')
wfIpInterfaceInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInDiscards.setDescription('The number of input IP datagrams for which no problems were encountered to prevent their continued processing, but which were discarded (e.g., for lack of buffer space). Note that this counter does not include any datagrams discarded while awaiting re-assembly.')
wfIpInterfaceInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceInDelivers.setDescription('The total number of input datagrams successfully delivered to IP user-protocols (including ICMP).')
wfIpInterfaceOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceOutRequests.setDescription('The total number of IP datagrams which local IP user-protocols (including ICMP) supplied to IP in requests for transmission. Note that this counter does not include any datagrams counted in ipForwDatagrams.')
wfIpInterfaceOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceOutDiscards.setDescription('The number of output IP datagrams for which no problem was encountered to prevent their transmission to their destination, but which were discarded (e.g., for lack of buffer space). Note that this counter would include datagrams counted in ipForwDatagrams if any such packets met this (discretionary) discard criterion.')
wfIpInterfaceOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceOutNoRoutes.setDescription("The number of IP datagrams discarded because no route could be found to transmit them to their destination. Note that this counter includes any packets counted in ipForwDatagrams which meet this `no-route' criterion. Note that this includes any datagarms which a host cannot route because all of its default gateways are down.")
wfIpInterfaceReasmTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceReasmTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceReasmTimeout.setDescription('The maximum number of seconds which received fragments are held while they are awaiting reassembly at this entity.')
wfIpInterfaceReasmReqds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceReasmReqds.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceReasmReqds.setDescription('The number of IP fragments received which needed to be reassembled at this entity.')
wfIpInterfaceReasmOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceReasmOKs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceReasmOKs.setDescription('The number of IP datagrams successfully reassembled.')
wfIpInterfaceReasmFails = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceReasmFails.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceReasmFails.setDescription('The number of failures detected by the IP re- assembly algorithm (for whatever reason: timed out, errors, etc). Note that this is not necessarily a count of discarded IP fragments since some algorithms (notably the algorithm in RFC 815) can lose track of the number of fragments by combining them as they are received.')
wfIpInterfaceFragOKs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceFragOKs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFragOKs.setDescription('The number of IP datagrams that have been successfully fragmented at this entity.')
wfIpInterfaceFragFails = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceFragFails.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFragFails.setDescription("The number of IP datagrams that have been discarded because they needed to be fragmented at this entity but could not be, e.g., because their Don't Fragment flag was set.")
wfIpInterfaceFragCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceFragCreates.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFragCreates.setDescription('The number of IP datagram fragments that have been generated as a result of fragmentation at this entity.')
wfIpInterfaceIcmpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInMsgs.setDescription('The total number of ICMP messages which includes all those counted by wfIpInterfaceIcmpInErrors.')
wfIpInterfaceIcmpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInErrors.setDescription('The number of ICMP messages which the entity received but determined as having ICMP-specific errors (bad ICMP checksums, bad length, etc.).')
wfIpInterfaceIcmpInDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInDestUnreachs.setDescription('The number of ICMP Destination Unreachable messages received.')
wfIpInterfaceIcmpInTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimeExcds.setDescription('The number of ICMP Time Exceeded messages received.')
wfIpInterfaceIcmpInParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInParmProbs.setDescription('The number of ICMP Parameter Problem messages received.')
wfIpInterfaceIcmpInSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInSrcQuenchs.setDescription('The number of ICMP Source Quench messages received.')
wfIpInterfaceIcmpInRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInRedirects.setDescription('The number of ICMP Redirect messages received.')
wfIpInterfaceIcmpInEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInEchos.setDescription('The number of ICMP Echo (request) messages received.')
wfIpInterfaceIcmpInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInEchoReps.setDescription('The number of ICMP Echo Reply messages received.')
wfIpInterfaceIcmpInTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimestamps.setDescription('The number of ICMP Timestamp (request) messages received.')
wfIpInterfaceIcmpInTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInTimestampReps.setDescription('The number of ICMP Timestamp Reply messages received.')
wfIpInterfaceIcmpInAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInAddrMasks.setDescription('The number of ICMP Address Mask Request messages received.')
wfIpInterfaceIcmpInAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpInAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpInAddrMaskReps.setDescription('The number of ICMP Address Mask Reply messages received.')
wfIpInterfaceIcmpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutMsgs.setDescription('The total number of ICMP messages which this entity attempted to send. Note that this counter includes all those counted by icmpOutErrors.')
wfIpInterfaceIcmpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutErrors.setDescription("The number of ICMP messages which this entity did not send due to problems discovered within ICMP such as a lack of buffers. This value should not include errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram. In some implementations there may be no types of error which contribute to this counter's value.")
wfIpInterfaceIcmpOutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutDestUnreachs.setDescription('The number of ICMP Destination Unreachable messages sent.')
wfIpInterfaceIcmpOutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimeExcds.setDescription('The number of ICMP Time Exceeded messages sent.')
wfIpInterfaceIcmpOutParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutParmProbs.setDescription('The number of ICMP Parameter Problem messages sent.')
wfIpInterfaceIcmpOutSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutSrcQuenchs.setDescription('The number of ICMP Source Quench messages sent.')
wfIpInterfaceIcmpOutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutRedirects.setDescription('The number of ICMP Redirect messages sent. For a host, this object will always be zero, since hosts do not send redirects.')
wfIpInterfaceIcmpOutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutEchos.setDescription('The number of ICMP Echo (request) messages sent.')
wfIpInterfaceIcmpOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutEchoReps.setDescription('The number of ICMP Echo Reply messages sent.')
wfIpInterfaceIcmpOutTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimestamps.setDescription('The number of ICMP Timestamp (request) messages sent.')
wfIpInterfaceIcmpOutTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutTimestampReps.setDescription('The number of ICMP Timestamp Reply messages sent.')
wfIpInterfaceIcmpOutAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutAddrMasks.setDescription('The number of ICMP Address Mask Request messages sent.')
wfIpInterfaceIcmpOutAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceIcmpOutAddrMaskReps.setDescription('The number of ICMP Address Mask Reply messages sent.')
wfIpInterfaceTrEndStation = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 64), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceTrEndStation.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceTrEndStation.setDescription(' Use Source Routing over token ring selection. Only applies if pam type is TRING. ')
wfIpInterfaceSMDSGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 65), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceSMDSGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceSMDSGroupAddress.setDescription(' The SMDS group address ')
wfIpInterfaceSMDSArpReqAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 66), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceSMDSArpReqAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceSMDSArpReqAddress.setDescription(' The SMDS arp req address ')
wfIpInterfaceFRBcastDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 67), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceFRBcastDlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFRBcastDlci.setDescription(' Frame Relay broadcast dlci ')
wfIpInterfaceFRMcast1Dlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 68), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceFRMcast1Dlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFRMcast1Dlci.setDescription(' Frame Relay multicast dlci #1 ')
wfIpInterfaceFRMcast2Dlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 69), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceFRMcast2Dlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceFRMcast2Dlci.setDescription(' Frame Relay multicast dlci #2 ')
wfIpInterfaceRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceRedirect.setDescription(" Indicates Whether we're sending out redirects on this Interface or not ")
wfIpInterfaceEnetArpEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 4, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enet", 1), ("snap", 2), ("both", 3))).clone('enet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpInterfaceEnetArpEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpInterfaceEnetArpEncaps.setDescription(' The data link encapsulation type to use for ARP packets if the the media is ethernet. ')
wfIpStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5), )
if mibBuilder.loadTexts: wfIpStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpStaticRouteTable.setDescription(' The list of static routes ')
wfIpStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpSrIpAddress"), (0, "Wellfleet-Series7-MIB", "wfIpSrIpNetMask"), (0, "Wellfleet-Series7-MIB", "wfIpSrIpAddressRt"))
if mibBuilder.loadTexts: wfIpStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpStaticRouteEntry.setDescription(' A static route definition ')
wfIpSrCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrCreate.setDescription('Create/Delete parameter. Default is created. Users perform a set operation on this object in order to create/delete the IP Static Route.')
wfIpSrEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform a set operation on this object in order to enable/disable this IP Static Route.')
wfIpSrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpSrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrIpAddress.setDescription(' The Address of this static route ')
wfIpSrIpNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpSrIpNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrIpNetMask.setDescription(' The IP Network Mask for this Static Route ')
wfIpSrCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("cost", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrCost.setDescription(' The Cost of this Static Route ')
wfIpSrNextHopAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrNextHopAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrNextHopAddr.setDescription(' The Next Hop IP Address ')
wfIpSrNextHopMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrNextHopMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrNextHopMask.setDescription(' The Next Hop IP Netmask ')
wfIpSrPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16))).clone(namedValues=NamedValues(("pref", 16))).clone('pref')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpSrPreference.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrPreference.setDescription(' This Routes Preference ')
wfIpSrIpAddressRt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpSrIpAddressRt.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrIpAddressRt.setDescription(' The Route Identifier Which numbered route this is to be')
wfIpSrValid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpSrValid.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpSrValid.setDescription(' Whether this Static Route is valid or not ')
wfIpAdjacentHostTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6), )
if mibBuilder.loadTexts: wfIpAdjacentHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjacentHostTable.setDescription(' The list of Adjacent Hosts (static IP-Mac resolutions) ')
wfIpAdjacentHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpAdjHostIpAddress"))
if mibBuilder.loadTexts: wfIpAdjacentHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjacentHostEntry.setDescription(' A description of an adjacent host ')
wfIpAdjHostCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostCreate.setDescription(' Whether to Delete this Adjacent Host ')
wfIpAdjHostEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostEnable.setDescription(' Whether to Disable this Host ')
wfIpAdjHostIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpAdjHostIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostIpAddress.setDescription(' The IP address of this Adjacent Host ')
wfIpAdjHostIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostIntf.setDescription(' The Interface for this Adjacent Host ')
wfIpAdjHostIntfMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostIntfMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostIntfMask.setDescription(' The Network Mask of this Intf')
wfIpAdjHostMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostMacAddr.setDescription(' The LAN Address for this HOST ')
wfIpAdjHostEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enet", 1), ("snap", 2))).clone('enet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpAdjHostEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostEncaps.setDescription(' The encapsulation type of this entry ')
wfIpAdjHostValid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpAdjHostValid.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpAdjHostValid.setDescription(' Whether the record passed validation or not ')
wfIpTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7), )
if mibBuilder.loadTexts: wfIpTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterTable.setDescription(' IP Traffic Filters ')
wfIpTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpTrafficFilterInterface"), (0, "Wellfleet-Series7-MIB", "wfIpTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfIpTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfIpTrafficFilterFragment"))
if mibBuilder.loadTexts: wfIpTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterEntry.setDescription(' A traffic filter definition ')
wfIpTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfIpTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfIpTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfIpTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfIpTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 5), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfIpTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 6), Integer32())
if mibBuilder.loadTexts: wfIpTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterReserved.setDescription(' Reserved field. ')
wfIpTrafficFilterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterInterface.setDescription(' The network address of the IP interface to which this filter is applied. ')
wfIpTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterCircuit.setDescription(' The ID of the Circuit to which the filter is applied. ')
wfIpTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfIpTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfRipIntfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1), )
if mibBuilder.loadTexts: wfRipIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipIntfTable.setDescription(' The list of configured RIP interfaces ')
wfRipIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfRipInterfaceIndex"))
if mibBuilder.loadTexts: wfRipIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipIntfEntry.setDescription(' A description of a RIP interface ')
wfRipInterfaceCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceCreate.setDescription('Create/Delete parameter. Default is created. Users perform a set operation on this object in order to create/delete an RIP Interface instance.')
wfRipInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform a set operation on this object in order to enable/disable a RIP interface.')
wfRipInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpres", 4))).clone('notpres')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfRipInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceState.setDescription('The current state of RIP on this interface.')
wfRipInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfRipInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceIndex.setDescription('The IP interface to run RIP on.')
wfRipInterfaceSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceSupply.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceSupply.setDescription('Transmit RIP packets.')
wfRipInterfaceListen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceListen.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceListen.setDescription(' Whether to listen to RIP packets ')
wfRipInterfaceDefaultRouteSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceDefaultRouteSupply.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceDefaultRouteSupply.setDescription('Transmit the default route, 0.0.0.0, in RIP packets.')
wfRipInterfaceDefaultRouteListen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfaceDefaultRouteListen.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfaceDefaultRouteListen.setDescription('Receive the default route, 0.0.0.0, in RIP packets.')
wfRipInterfacePoisonedReversed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("poisoned", 1), ("actual", 2), ("split", 3))).clone('poisoned')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfRipInterfacePoisonedReversed.setStatus('mandatory')
if mibBuilder.loadTexts: wfRipInterfacePoisonedReversed.setDescription("Specifies how the router advertises routes it has learned from a neighboring router in periodic updates subsequently sent to the neighbor. If 'Poisoned', the node implements poisoned reverse. The router now advertises routes learned from a neighbor in RIP updates subsequently sent to that neighbor with a hop count of wfRipBaseRipNetworkDiameter plus 1, (thus declaring the destination unreachable). If 'Split', the router implements a split-horizon, and omits routes learned from a neighbor in RIP updates subsequently sent to that neighbor. If 'Actual', the learned cost of the route is advertised. ")
wfArpBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 1))
wfArpBaseCreate = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfArpBaseCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpBaseCreate.setDescription('Create/Delete parameter. Default is created. Users perform a set operation on this object in order to create/delete ARP.')
wfArpBaseEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfArpBaseEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpBaseEnable.setDescription(' Enable/Disable Parameter indicates whether this ARP record is enabled or disabled. ')
wfArpBaseForwarding = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("notforwarding", 2))).clone('forwarding')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfArpBaseForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpBaseForwarding.setDescription(' Equivalent to IP Host Only. This attribute says that ARP should send unknown addresses to the bridge for further handling ')
wfArpIntfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 2), )
if mibBuilder.loadTexts: wfArpIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpIntfTable.setDescription(' List of configured ARP interfaces ')
wfArpIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfArpCctno"))
if mibBuilder.loadTexts: wfArpIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpIntfEntry.setDescription(' A description of an ARP interface ')
wfArpCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfArpCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpCreate.setDescription(' Indicates whether this ARP intf record is to be deleted or created ')
wfArpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfArpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpEnable.setDescription(' Indicates whether this ARP intf record is to be enabled or disabled ')
wfArpCctno = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfArpCctno.setStatus('mandatory')
if mibBuilder.loadTexts: wfArpCctno.setDescription(' Which Circuit arp should run on ')
wfIpxBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1))
wfIpxBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete IPX.')
wfIpxBaseDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxBaseDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable IPX.')
wfIpxBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("in", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseState.setDescription('The current state of the entire IPX.')
wfIpxBaseCfgHostNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxBaseCfgHostNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseCfgHostNumber.setDescription(' box generated hostnumber. ')
wfIpxBaseActiveHostNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseActiveHostNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseActiveHostNumber.setDescription(' generated variable. ')
wfIpxBaseNetCount = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseNetCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseNetCount.setDescription(' Count the total number of nets in the box. ')
wfIpxBaseServiceCount = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseServiceCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseServiceCount.setDescription(' Count the total number of saps in the box. ')
wfIpxBaseLogFilter = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 16, 3, 17, 18, 19))).clone(namedValues=NamedValues(("debug", 1), ("info", 2), ("trace", 16), ("debuginfo", 3), ("debugtrace", 17), ("infotrace", 18), ("debuginfotrace", 19))).clone('trace')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxBaseLogFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseLogFilter.setDescription(' Filter out some log messages, Default filters out debugs, info, and trace messages.')
wfIpxBaseNetTblSize = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(250))).clone(namedValues=NamedValues(("size", 250))).clone('size')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxBaseNetTblSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseNetTblSize.setDescription(' Tell me how much space to set aside when creating the forwarding and network tables. ')
wfIpxBaseRtEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2), )
if mibBuilder.loadTexts: wfIpxBaseRtEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRtEntryTable.setDescription(" The table of Elements in IPX's routing table ")
wfIpxBaseRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxBaseRouteDest"))
if mibBuilder.loadTexts: wfIpxBaseRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRtEntry.setDescription(' An entry in the Routing Table ')
wfIpxBaseRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteDest.setDescription(' Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
wfIpxBaseRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
wfIpxBaseRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteMetric.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfIpxBaseRouteNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteNextHopNetwork.setDescription("(In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's IPX address on that interface.)")
wfIpxBaseRouteNextHopHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteNextHopHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteNextHopHost.setDescription(' Full network.host_id address of nexthop host for this network. ')
wfIpxBaseRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4), ("static", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteType.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the IPX architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively dissasociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. nagement stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
wfIpxBaseRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("rip", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
wfIpxBaseRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
wfIpxBaseRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseRouteInfo.setDescription(' A user-defined string which describes this Route entry ')
wfIpxBaseSapEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3), )
if mibBuilder.loadTexts: wfIpxBaseSapEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapEntryTable.setDescription(" The table of Elements in IPX's SAP table ")
wfIpxBaseSapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxBaseSapIndex"))
if mibBuilder.loadTexts: wfIpxBaseSapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapEntry.setDescription(' An entry in the Routing Table ')
wfIpxBaseSapType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapType.setDescription(' Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use. ')
wfIpxBaseSapNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapNetwork.setDescription(' The network address of this service. ')
wfIpxBaseSapHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapHost.setDescription(' The host address for this service. ')
wfIpxBaseSapSocket = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapSocket.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapSocket.setDescription(' The socket for this particular service ')
wfIpxBaseSapName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapName.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapName.setDescription(' The server name. ')
wfIpxBaseSapAge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapAge.setDescription(' The number of seconds since SAP entry has been updated. ')
wfIpxBaseSapHops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapHops.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapHops.setDescription(' The number of Hops away service is from router. ')
wfIpxBaseSapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapIndex.setDescription(' Index string comprised of type.network.hostid.socket. Makes sorting easier and its a ah work around. ')
wfIpxBaseSapIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 3, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxBaseSapIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxBaseSapIntf.setDescription(' Network Address of Nexthop Interface. ')
wfIpxInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4), )
if mibBuilder.loadTexts: wfIpxInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceTable.setDescription(' The network interface record ')
wfIpxInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxInterfaceNetworkNumber"), (0, "Wellfleet-Series7-MIB", "wfIpxInterfaceCircuit"))
if mibBuilder.loadTexts: wfIpxInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceEntry.setDescription(' An entry in the Routing Table ')
wfIpxInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceIndex.setDescription('A unique value for each IPX interface. Its value ranges between 1 and the value of MAXCIRCUITS.')
wfIpxInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an IPX interface.')
wfIpxInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an IPX interface.')
wfIpxInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceState.setDescription('The current state of the IPX interface')
wfIpxInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceCircuit.setDescription(' The Circuit Number that this interface runs over')
wfIpxInterfaceNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceNetworkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceNetworkNumber.setDescription(" The IPX Address to which this entry's addressing information pertains ")
wfIpxInterfaceCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("cost", 1))).clone('cost')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceCost.setDescription(' The Cost associated with the IPX Address of this entry ')
wfIpxInterfaceXsumOn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceXsumOn.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceXsumOn.setDescription(' Flag for checksums ')
wfIpxInterfaceCfgEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("lsap", 2), ("novell", 3), ("snap", 4))).clone('ethernet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceCfgEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceCfgEncaps.setDescription(' The encapsulation method associated with this interface chosen by the user but not necessarily the one used. (See wfIpxInterfaceEncaps) ')
wfIpxInterfaceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceMacAddress.setDescription(' The MacAddress of this interface this port will receive or transmit. ')
wfIpxInterfaceSMDSGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceSMDSGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceSMDSGroupAddress.setDescription(' The SMDS group address ')
wfIpxInterfaceMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceMaxInfo.setDescription('The maximum size of the INFO (non-MAC) field that this port will receive or transmit.')
wfIpxInterfaceInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInReceives.setDescription('The total number of input datagrams received from interfaces, including those received in error.')
wfIpxInterfaceInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInHdrErrors.setDescription('The number of input datagrams discarded due to errors in their IPX headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IPX options, etc.')
wfIpxInterfaceInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInAddrErrors.setDescription("The number of input datagrams discarded because the IPX address in their IPX header's destination field was not a valid address to be received at this entity. ")
wfIpxInterfaceForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceForwDatagrams.setDescription('The number of input datagrams for which this entity was not their final IPX destination, as a result of which an attempt was made to find a route to forward them to that final destination. In entities which do not act as IPX Gateways, this counter will include only those packets which were Source-Routed via this entity, and the Source- Route option processing was successful.')
wfIpxInterfaceInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol.')
wfIpxInterfaceInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInDiscards.setDescription('The number of input IPX datagrams for which no problems were encountered to prevent their continued processing, but which were discarded (e.g., for lack of buffer space). Note that this counter does not include any datagrams discarded while awaiting re-assembly.')
wfIpxInterfaceInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceInDelivers.setDescription(' The total number of input datagrams successfully delivered to IPX user-protocols . ')
wfIpxInterfaceOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceOutRequests.setDescription(' The total number of IPX datagrams which local IPX user-protocols supplied to IPX in requests for transmission. Note that this counter does not include any datagrams counted in ipxForwDatagrams. ')
wfIpxInterfaceOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceOutDiscards.setDescription('The number of output IPX datagrams for which no problem was encountered to prevent their transmission to their destination, but which were discarded (e.g., for lack of buffer space). Note that this counter would include datagrams counted in ipForwDatagrams if any such packets met this (discretionary) discard criterion.')
wfIpxInterfaceOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceOutNoRoutes.setDescription("The number of IPX datagrams discarded because no route could be found to transmit them to their destination. Note that this counter includes any packets counted in ipForwDatagrams which meet this `no-route' criterion. Note that this includes any datagarms which a host cannot route because all of its default gateways are down.")
wfIpxInterfaceTrEndStation = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceTrEndStation.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceTrEndStation.setDescription(' Source Routing flag ')
wfIpxInterfaceNetbiosAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceNetbiosAccept.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceNetbiosAccept.setDescription(' Accept NetBios All Networks Broadcast Packets ')
wfIpxInterfaceNetbiosDeliver = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceNetbiosDeliver.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceNetbiosDeliver.setDescription(' Deliver NetBios All Networks Broadcast Packets ')
wfIpxInterfaceWanSapPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceWanSapPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceWanSapPeriod.setDescription(' Timer for Sap entries over WAN ')
wfIpxInterfaceFRBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 27), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceFRBcast.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceFRBcast.setDescription(' Configurable Frame Relay broadcast address ')
wfIpxInterfaceFRMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 28), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceFRMcast.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceFRMcast.setDescription(' Configurable Frame Relay multicast address ')
wfIpxInterfaceEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ethernet", 1), ("lsap", 2), ("novell", 3), ("snap", 4))).clone('ethernet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceEncaps.setDescription(" The Active or final encapsulation method associated with this interface as determined by the router's implementation of encapsulation algorithms (rules, restrictions) based on media type. ")
wfIpxInterfaceSplit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxInterfaceSplit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceSplit.setDescription(' Comes into to play for non full-meshed WAN networks (Frame Relay)')
wfIpxInterfaceCacheHit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxInterfaceCacheHit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxInterfaceCacheHit.setDescription(' Will provide information that will determine the usefullness of caching. ')
wfIpxRipIntfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5), )
if mibBuilder.loadTexts: wfIpxRipIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipIntfTable.setDescription(' The list of RIP interfaces ')
wfIpxRipIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxRipInterfaceIndex"))
if mibBuilder.loadTexts: wfIpxRipIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipIntfEntry.setDescription(' An entry in the Routing Table ')
wfIpxRipInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxRipInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an RIP Interface instance.')
wfIpxRipInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxRipInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an RIP instance.')
wfIpxRipInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxRipInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceState.setDescription('The current state of RIP on this interface.')
wfIpxRipInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxRipInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceIndex.setDescription('The IPX interface to run RIP on (instance id ).')
wfIpxRipInterfaceSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxRipInterfaceSupply.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceSupply.setDescription('Transmit RIP packets.')
wfIpxRipInterfaceListen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxRipInterfaceListen.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxRipInterfaceListen.setDescription('Receive RIP packets.')
wfIpxAdjacentHostTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6), )
if mibBuilder.loadTexts: wfIpxAdjacentHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAdjacentHostTable.setDescription(' must be configured for a nexthop host. ')
wfIpxAdjacentHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxAhTargHostNetwork"), (0, "Wellfleet-Series7-MIB", "wfIpxAhTargHostId"))
if mibBuilder.loadTexts: wfIpxAdjacentHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAdjacentHostEntry.setDescription(' An entry in the Adjacent Host Table ')
wfIpxAhDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxAhDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX Static Host.')
wfIpxAhDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxAhDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX Static Route.')
wfIpxAhTargHostNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxAhTargHostNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhTargHostNetwork.setDescription('The network address of the static host. ')
wfIpxAhTargHostId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxAhTargHostId.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhTargHostId.setDescription(' The Address of this static host. ')
wfIpxAhNextHopIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxAhNextHopIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhNextHopIntf.setDescription(' The Next Hop Interface Network Address ')
wfIpxAhDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 6, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxAhDlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxAhDlci.setDescription(' The next Hop Host address ')
wfIpxStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7), )
if mibBuilder.loadTexts: wfIpxStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxStaticRouteTable.setDescription(' The list of static routes used for Configuring IPX ')
wfIpxStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxSrTargNetwork"), (0, "Wellfleet-Series7-MIB", "wfIpxSrNextHopNetwork"))
if mibBuilder.loadTexts: wfIpxStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxStaticRouteEntry.setDescription(' An entry in the Routing Table ')
wfIpxSrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX Static Route.')
wfIpxSrDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSrDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX Static Route.')
wfIpxSrTargNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSrTargNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrTargNetwork.setDescription(' The Address of this static route ')
wfIpxSrCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSrCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrCost.setDescription(' The Cost of this Static Route ')
wfIpxSrNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSrNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrNextHopNetwork.setDescription(' The Next Hop IPX Address ')
wfIpxSrNextHopHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSrNextHopHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrNextHopHost.setDescription(' The next Hop Host address ')
wfIpxSrTargNetworkRt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSrTargNetworkRt.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSrTargNetworkRt.setDescription(' The Route Identifier Which numbered route this is to be ')
wfIpxNetBiosStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8), )
if mibBuilder.loadTexts: wfIpxNetBiosStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosStaticRouteTable.setDescription(' The list of static routes used for Configuring IPX ')
wfIpxNetBiosStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxNetBiosSrTargNetwork"), (0, "Wellfleet-Series7-MIB", "wfIpxNetBiosSrIntf"))
if mibBuilder.loadTexts: wfIpxNetBiosStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosStaticRouteEntry.setDescription(' An entry in the Routing Table ')
wfIpxNetBiosSrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxNetBiosSrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX NETBIOS Static Route.')
wfIpxNetBiosSrDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxNetBiosSrDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX NETBIOS Static Route.')
wfIpxNetBiosSrTargNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxNetBiosSrTargNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrTargNetwork.setDescription(' The Address of this static route ')
wfIpxNetBiosSrName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxNetBiosSrName.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrName.setDescription(' The Name of the Target Server ')
wfIpxNetBiosSrIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxNetBiosSrIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrIntf.setDescription(' The Interface Identifier for this static entry ')
wfIpxNetBiosSrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxNetBiosSrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxNetBiosSrIndex.setDescription(' The Entry Index Which identifies this is entry ')
wfIpxSapNetLvlFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9), )
if mibBuilder.loadTexts: wfIpxSapNetLvlFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlFilterTable.setDescription(' The list of Network Level SAP Filters ')
wfIpxSapNetLvlFilter = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxSapNetLvlIntf"), (0, "Wellfleet-Series7-MIB", "wfIpxSapNetLvlIndex"))
if mibBuilder.loadTexts: wfIpxSapNetLvlFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlFilter.setDescription(' An entry in the Filter Table ')
wfIpxSapNetLvlDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapNetLvlDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX Sap network level filter. ')
wfIpxSapNetLvlDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapNetLvlDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlDisable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX network level SAP filter. ')
wfIpxSapNetLvlTargNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapNetLvlTargNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlTargNetwork.setDescription(' The Target Network address to monitor ')
wfIpxSapNetLvlType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapNetLvlType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlType.setDescription(' The Type of service to monitor ')
wfIpxSapNetLvlAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapNetLvlAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlAction.setDescription(' The Action to take Advertise or not Advertise ')
wfIpxSapNetLvlIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSapNetLvlIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlIntf.setDescription(' The Interface identifier for this filter ')
wfIpxSapNetLvlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSapNetLvlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapNetLvlIndex.setDescription(' The Filter Index . ')
wfIpxSapServtLvlFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10), )
if mibBuilder.loadTexts: wfIpxSapServtLvlFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServtLvlFilterTable.setDescription(' The list of Server Level SAP Filters ')
wfIpxSapServLvlFilter = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxSapServLvlIntf"), (0, "Wellfleet-Series7-MIB", "wfIpxSapServLvlIndex"))
if mibBuilder.loadTexts: wfIpxSapServLvlFilter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlFilter.setDescription(' An entry in the Filter Table ')
wfIpxSapServLvlDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapServLvlDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX server-level SAP filter. ')
wfIpxSapServLvlDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapServLvlDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlDisable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX server-level SAP filter. ')
wfIpxSapServLvlTargServer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapServLvlTargServer.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlTargServer.setDescription(' The Server Name to monitor. ')
wfIpxSapServLvlType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapServLvlType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlType.setDescription(' Type of service File server, Printer, etc... ')
wfIpxSapServLvlAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxSapServLvlAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlAction.setDescription(' Associated Action (advertise or ignore ) ')
wfIpxSapServLvlIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSapServLvlIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlIntf.setDescription(' The Interface identifier for this filter ')
wfIpxSapServLvlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxSapServLvlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxSapServLvlIndex.setDescription(' The Filter Index . ')
wfIpxTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11), )
if mibBuilder.loadTexts: wfIpxTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterTable.setDescription(' IPX Traffic Filters ')
wfIpxTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpxTrafficFilterInterface"), (0, "Wellfleet-Series7-MIB", "wfIpxTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfIpxTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfIpxTrafficFilterFragment"))
if mibBuilder.loadTexts: wfIpxTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterEntry.setDescription(' A traffic filter definition ')
wfIpxTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfIpxTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfIpxTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfIpxTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfIpxTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 5), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpxTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfIpxTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 6), Integer32())
if mibBuilder.loadTexts: wfIpxTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterReserved.setDescription(' Reserved field. ')
wfIpxTrafficFilterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterInterface.setDescription(' The network address of the IPX interface to which this filter is applied. ')
wfIpxTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterCircuit.setDescription(' The ID of the Circuit to which the filter is applied. ')
wfIpxTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfIpxTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 5, 11, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpxTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpxTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfProtocols = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 2, 1))
wfIPROTOLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 1), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIPROTOLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfIPROTOLoad.setDescription(' Bit mask for loading the IP routing suite (RIP, EGP, OSPF) on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfDECNETLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDECNETLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDECNETLoad.setDescription(' Bit mask for loading the DECNet router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfATLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfATLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfATLoad.setDescription(' Bit mask for loading the AppleTalk router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfXNSLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXNSLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfXNSLoad.setDescription(' Bit mask for loading the XNS router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfIPXLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 5), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIPXLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfIPXLoad.setDescription(' Bit mask for loading the IPX router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfOSILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 6), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOSILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfOSILoad.setDescription(' Bit mask for loading the ISO router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfX25DTELoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 7), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25DTELoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25DTELoad.setDescription(' Bit mask for loading the X.25 DTE protocol on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfX25DCELoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 8), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25DCELoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25DCELoad.setDescription(' Bit mask for loading the X.25 DCE protocol on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfVINESLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 1, 9), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVINESLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfVINESLoad.setDescription(' Bit mask for loading the VINES router on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfLinkModules = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 2, 2))
wfENETIILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 1), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfENETIILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfENETIILoad.setDescription(' Bit mask for loading the Ethernet II driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfQENETLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfQENETLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfQENETLoad.setDescription(' Bit mask for loading the Quad Ethernet driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfFDDILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFDDILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfFDDILoad.setDescription(' Bit mask for loading the FDDI driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDSDELoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDSDELoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDSDELoad.setDescription(' Bit mask for loading the Dual Sync - Dual Enet driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfDSDEIILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 5), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDSDEIILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDSDEIILoad.setDescription(' Bit mask for loading the Dual Sync - Dual Enet II driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfQSYNCLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 6), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfQSYNCLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfQSYNCLoad.setDescription(' Bit mask for loading the Quad Sync driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfDTLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 7), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDTLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDTLoad.setDescription(' Bit mask for loading the Dual Token driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDSTLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 8), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDSTLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDSTLoad.setDescription(' Bit mask for loading the DST driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfT1IILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 9), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1IILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1IILoad.setDescription(' Bit mask for loading the T1 II driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfE1IILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 10), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfE1IILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfE1IILoad.setDescription(' Bit mask for loading the E1 II driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfHSSILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 11), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHSSILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfHSSILoad.setDescription(' Bit mask for loading the HSSI driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfFNSDSELoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 12), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFNSDSELoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfFNSDSELoad.setDescription(' Bit mask for loading the FNSDSE driver on slot 2 (FNES Only). The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfFNSDSDTLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 2, 13), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFNSDSDTLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfFNSDSDTLoad.setDescription(' Bit mask for loading the FNSDSDT driver on slot 2 (FNTS Only). The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDrivers = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 2, 3))
wfLANCELoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 1), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLANCELoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfLANCELoad.setDescription(' Bit mask for loading the LANCE chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfILACCLoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfILACCLoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfILACCLoad.setDescription(' Bit mask for loading the ILACC chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfFSILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfFSILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfFSILoad.setDescription(' Bit mask for loading the FDDI System Interface (FSI) chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. This attribute shall be used to configure the FSI chip driver on the appropriate slots for FDDI only (see wfHSSIFSILoad for other usage). ')
wfTMS380Load = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTMS380Load.setStatus('mandatory')
if mibBuilder.loadTexts: wfTMS380Load.setDescription(' Bit mask for loading the TMS380 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfMK5025Load = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 5), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfMK5025Load.setStatus('mandatory')
if mibBuilder.loadTexts: wfMK5025Load.setDescription(' Bit mask for loading the MK5025 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDS2180Load = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 6), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDS2180Load.setStatus('mandatory')
if mibBuilder.loadTexts: wfDS2180Load.setDescription(' Bit mask for loading the DS2180 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDS2181Load = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 7), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDS2181Load.setStatus('mandatory')
if mibBuilder.loadTexts: wfDS2181Load.setDescription(' Bit mask for loading the DS2181 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. ')
wfDEFALoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 8), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfDEFALoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfDEFALoad.setDescription(' Bit mask for loading the AM99C10 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2 and so forth. The AM99C10 chip is Content Addressable Memory (CAM) and the driver to control it is represented by this attribute. The generic name of this attribute shall be the Hardware Filter Driver which will also provide control of the Dual Ethernet Filter Accelerator (DEFA) chip. ')
wfAMZ8530Load = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 9), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfAMZ8530Load.setStatus('mandatory')
if mibBuilder.loadTexts: wfAMZ8530Load.setDescription(' Bit mask for loading the AMZ8530 chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfHSSIFSILoad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 2, 3, 10), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfHSSIFSILoad.setStatus('mandatory')
if mibBuilder.loadTexts: wfHSSIFSILoad.setDescription(' Bit mask for loading the HSSI FSI chip driver on slots 1-14. The MSBit represents slot 1, the next most significant bit represents slot 2, and so forth. ')
wfOspfGeneralGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1))
wfOspfGeneralDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfGeneralDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfGeneralDelete.setDescription(" 'This value determines whether OSPF is configured' ")
wfOspfGeneralDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfGeneralDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfGeneralDisable.setDescription(" 'The administrative status of OSPF in the router. The value 'enabled' denotes that the OSPF Process is active on at least one interface; 'disabled' disables it on all interfaces.' ")
wfOspfGeneralState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfGeneralState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfGeneralState.setDescription(" 'The state of OSPF' ")
wfOspfRouterId = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfRouterId.setDescription(" 'A 32-bit integer uniquely identifying the router in the Autonomous System. By convention, to ensure uniqueness, this should default to the value of one of the router's IP interface addresses.' REFERENCE 'OSPF Version 2, C.1 Global parameters' ")
wfOspfVersionNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVersionNumber.setDescription(" 'The current version number of the OSPF protocol is 2.' REFERENCE 'OSPF Version 2, Title' ")
wfOspfAreaBdrRtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaBdrRtrStatus.setDescription(" 'A flag to note whether this router is an area border router.' REFERENCE 'OSPF Version 2, Section 3 Splitting the AS into Areas' ")
wfOspfASBdrRtrStatus = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfASBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfASBdrRtrStatus.setDescription(" 'A flag to note whether this router is an Autonomous System border router.' REFERENCE 'OSPF Version 2, Section 3.3 Classification of routers' ")
wfOspfTOSSupport = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfTOSSupport.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfTOSSupport.setDescription(" 'The router's support for type-of-service routing.' REFERENCE 'OSPF Version 2, Appendix F.1.2 Optional TOS support' ")
wfOspfSpfHoldDown = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10))).clone(namedValues=NamedValues(("defval", 1), ("maximum", 10))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfSpfHoldDown.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfSpfHoldDown.setDescription(' Hold Down Timer for the SPF. The SPF will run at most once per hold down timer value. A value of 0 means no hold down. ')
wfOspfSlotMask = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16383))).clone(namedValues=NamedValues(("slotmask", 16383))).clone('slotmask')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfSlotMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfSlotMask.setDescription(' Slot mask for which slots OSPF is eligible to run on. The LSBit represents slot 1, the next least significant bit represents slot 2, and so on... Slots can be 1-14. ')
wfOspfAreaTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2), )
if mibBuilder.loadTexts: wfOspfAreaTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaTable.setDescription(" -- The OSPF Area Data Structure contains information -- regarding the various areas. The interfaces and -- virtual links are configured as part of these areas. -- Area 0.0.0.0, by definition, is the Backbone Area 'Information describing the configured parameters and cumulative statistics of the router's attached areas.' REFERENCE 'OSPF Version 2, Section 6 The Area Data Structure' ")
wfOspfAreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfAreaId"))
if mibBuilder.loadTexts: wfOspfAreaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaEntry.setDescription(" 'Information describing the configured parameters and cumulative statistics of one of the router's attached areas.' ")
wfOspfAreaDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAreaDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaDelete.setDescription(' This value determines if the OSPF router is configured with this area. ')
wfOspfAreaDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAreaDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaDisable.setDescription(' This value indicates the state of this area on the OSPF router. ')
wfOspfAreaState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaState.setDescription(' This value indicates the state of the OSPF Area. ')
wfOspfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaId.setDescription(" 'A 32-bit integer uniquely identifying an area. Area ID 0.0.0.0 is used for the OSPF backbone.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nopassword", 1), ("simplepassword", 2))).clone('nopassword')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAuthType.setDescription(" 'The authentication type specified for an area. Additional authentication types may be assigned locally on a per Area basis.' REFERENCE 'OSPF Version 2, Appendix E Authentication' -- none (0), -- simplePassword (1) -- reserved for future specification (2..255) -- reserved for AS specific values (> 255) ")
wfOspfImportASExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfImportASExtern.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfImportASExtern.setDescription(" 'The area's support for importing AS external link- state advertisements.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 16777215))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 16777215))).clone('minimum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfStubMetric.setDescription(" 'The metric value applied at the indicated type of service. By default, this equals the least metric at the type of service among the interfaces to other areas.' ")
wfOspfImportSum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfImportSum.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfImportSum.setDescription(" 'The area's support for importing Summary advertisements into a stub area. This variable should not be set unless wfOspfImportASExtern is set to FALSE' ")
wfOspfLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3), )
if mibBuilder.loadTexts: wfOspfLsdbTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbTable.setDescription(" -- OSPF Link State Database -- The Link State Database contains the Link State -- Advertisements from throughout the areas that the -- device is attached to. 'The OSPF Process's Links State Database.' REFERENCE 'OSPF Version 2, Section 12 Link State Advertisements' ")
wfOspfLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfLsdbAreaId"), (0, "Wellfleet-Series7-MIB", "wfOspfLsdbType"), (0, "Wellfleet-Series7-MIB", "wfOspfLsdbLSID"), (0, "Wellfleet-Series7-MIB", "wfOspfLsdbRouterId"))
if mibBuilder.loadTexts: wfOspfLsdbEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbEntry.setDescription(" 'A single Link State Advertisement.' ")
wfOspfLsdbAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbAreaId.setDescription(" 'The 32 bit identifier of the Area from which the LSA was received.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("routerlink", 1), ("networklink", 2), ("summarylink", 3), ("assummarylink", 4), ("asexternallink", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbType.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbType.setDescription(" 'The type of the link state advertisement. Each link state type has a separate advertisement format.' REFERENCE 'OSPF Version 2, Appendix A.4.1 The Link State Advertisement header' stubLink (0), routerLink (1), networkLink (2), summaryLink (3), asSummaryLink (4), asExternalLink (5) ")
wfOspfLsdbLSID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbLSID.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbLSID.setDescription(" 'The Link State ID is an LS Type Specific field containing either a Router ID or an IP Address; it identifies the piece of the routing domain that is being described by the advertisement.' REFERENCE 'OSPF Version 2, Section 12.1.4 Link State ID' ")
wfOspfLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbRouterId.setDescription(" 'The 32 bit number that uniquely identifies the originating router in the Autonomous System.' REFERENCE 'OSPF Version 2, Appendix C.1 Global parameters' ")
wfOspfLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbSequence.setDescription(" -- Note that the OSPF Sequence Number is a 32 bit signed -- integer. It starts with the value '80000001'h, -- or -'7FFFFFFF'h, and increments until '7FFFFFFF'h -- Thus, a typical sequence number will be very negative. 'The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number the more recent the advertisement.' REFERENCE 'OSPF Version 2, Section 12.1.6 LS sequence number' ")
wfOspfLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3600))).clone(namedValues=NamedValues(("lsdbmaxage", 3600)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbAge.setDescription(" 'This field is the age of the link state advertisement in seconds.' (OSPF_LSDBMINAGE = 0) REFERENCE 'OSPF Version 2, Section 12.1.1 LS age' ")
wfOspfLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbChecksum.setDescription(" 'This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum.' REFERENCE 'OSPF Version 2, Section 12.1.7 LS checksum' ")
wfOspfLsdbAdvLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfLsdbAdvLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfLsdbAdvLen.setDescription(" 'The length of entire Link State Advertisement, including its header.' REFERENCE 'OSPF Version 2, Section 12 Link State Advertisements' ")
wfOspfAreaRangeTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4), )
if mibBuilder.loadTexts: wfOspfAreaRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeTable.setDescription(" 'A range if IP addresses specified by an IP address/IP network mask pair. For example, class B address range of X.X.X.X with a network mask of 255.255.0.0 includes all IP addresses from X.X.0.0 to X.X.255.255' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfAreaRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfAreaRangeAreaID"), (0, "Wellfleet-Series7-MIB", "wfOspfAreaRangeNet"))
if mibBuilder.loadTexts: wfOspfAreaRangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeEntry.setDescription(' ')
wfOspfAreaRangeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAreaRangeDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeDelete.setDescription(' This value determines if an Area Range has been configured for the OSPF router. ')
wfOspfAreaRangeDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAreaRangeDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeDisable.setDescription(" 'This variable displays the status of the entry. Setting it to 'DISBALED' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.' ")
wfOspfAreaRangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaRangeState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeState.setDescription(' The state of the OSPF Area Range. ')
wfOspfAreaRangeAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaRangeAreaID.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeAreaID.setDescription(" 'The Area the Address Range is to be found within.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfAreaRangeNet = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAreaRangeNet.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeNet.setDescription(" 'The IP Address of the Net or Subnet indicated by the range.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfAreaRangeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 4, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfAreaRangeMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAreaRangeMask.setDescription(" 'The Subnet Mask that pertains to the Net or Subnet.' REFERENCE 'OSPF Version 2, Appendix C.2 Area parameters' ")
wfOspfIfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5), )
if mibBuilder.loadTexts: wfOspfIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTable.setDescription(" -- OSPF Interface Table -- The OSPF Interface Table augments the ifTable with OSPF -- specific information. 'The OSPF Interface Table describes the interfaces from the viewpoint of OSPF.' REFERENCE 'OSPF Version 2, Appendix C.3 Router interface parameters' ")
wfOspfIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfIfIpAddress"), (0, "Wellfleet-Series7-MIB", "wfOspfAddressLessIf"))
if mibBuilder.loadTexts: wfOspfIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfEntry.setDescription(" 'The OSPF Interface Entry describes one interface from the viewpoint of OSPF.' ")
wfOspfIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfDelete.setDescription(' This variable determines in an OSPF Interface has been configured on the router. ')
wfOspfIfDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfDisable.setDescription(" 'The OSPF interface's administrative status. The value 'enabled' denotes that neighbor relationships may be formed on the interface, and the interface will be advertised as an internal route to some area. The value 'disabled' denotes that the interface is external to OSPF.' ")
wfOspfIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointtopoint", 4), ("designatedrouter", 5), ("backupdesignatedrouter", 6), ("otherdesignatedrouter", 7))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfState.setDescription(" 'The OSPF Interface State.' down (1), loopback (2), waiting (3), pointToPoint (4), designatedRouter (5), backupDesignatedRouter (6), otherDesignatedRouter (7) ")
wfOspfIfIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfIpAddress.setDescription(" 'The IP address of this OSPF interface.' ")
wfOspfAddressLessIf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfAddressLessIf.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfAddressLessIf.setDescription(" 'For the purpose of easing the instancing of addressed and addressless interfaces; This variable takes the value 0 on interfaces with IP Addresses, and the corresponding value of ifIndex for interfaces having no IP Address.' ")
wfOspfIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfAreaId.setDescription(" 'A 32-bit integer uniquely identifying the area to which the interface connects. Area ID 0.0.0.0 is used for the OSPF backbone.' default { '00000000'H } -- 0.0.0.0 ")
wfOspfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointtopoint", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfType.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfType.setDescription(" 'The OSPF interface type. By way of a default, this field may be intuited from the corresponding value of ifType. Broadcast LANs, such as Ethernet and IEEE 802.5, take the value 'broadcast', X.25, Frame Relay, and similar technologies take the value 'nbma', and links that are definitively point to point take the value 'pointToPoint'.' broadcast (1), nbma (2), pointToPoint (3) ")
wfOspfIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("defval", 1), ("maximum", 255))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfRtrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRtrPriority.setDescription(" 'The priority of this interface. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular network. In the event of a tie in this value, routers will use their router id as a tie breaker.' ")
wfOspfIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1, 3600))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 1), ("maximum", 3600))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTransitDelay.setDescription(" 'The estimated number of seconds it takes to transmit a link- state update packet over this interface.' ")
wfOspfIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 3600))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 5), ("maximum", 3600))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRetransInterval.setDescription(" 'The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets.' ")
wfOspfIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 10, 65535))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 10), ("maximum", 65535))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfHelloInterval.setDescription(" 'The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.' ")
wfOspfIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 40, 2147483647))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 40), ("maximum", 2147483647))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRtrDeadInterval.setDescription(" 'The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for all routers attached to a common network.' ")
wfOspfIfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 120, 2147483647))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 120), ("maximum", 2147483647))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfPollInterval.setDescription(" 'The larger time interval, in seconds, between the Hello packets sent to an inactive non-broadcast multi- access neighbor.' ")
wfOspfIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfDesignatedRouter.setDescription(" 'The IP Address of the Designated Router.' default { '00000000'H } -- 0.0.0.0 ")
wfOspfIfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfBackupDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfBackupDesignatedRouter.setDescription(" 'The IP Address of the Backup Designated Router.' default { '00000000'H } -- 0.0.0.0 ")
wfOspfIfMetricCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 65535))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 65535))).clone('minimum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfMetricCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfMetricCost.setDescription(" 'The cost of using this type of service on this interface. The default value of the TOS 0 Metric is 10^8 / ifSpeed. The value FFFF is distinguished to mean 'no route via this TOS'.' ")
wfOspfIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfAuthKey.setDescription(" 'The Authentication Key. If the Area's Authorization Type is simplePassword, and the key length is shorter than 8 octets, the agent will left adjust and zero fill to 8 octets. When read, ospfIfAuthKey always returns an Octet String of length zero.' default { '0000000000000000'H } -- 0.0.0.0.0.0.0.0 REFERENCE 'OSPF Version 2, Section 9 The Interface Data Structure' ")
wfOspfIfTxHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfTxHellos.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTxHellos.setDescription(' Number of OSPF Hello packets transmitted. ')
wfOspfIfTxDBDescripts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfTxDBDescripts.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTxDBDescripts.setDescription(' Number of OSPF DataBase Description packets transmitted. ')
wfOspfIfTxLinkStateReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfTxLinkStateReqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTxLinkStateReqs.setDescription(' Number of OSPF Link State Request packets transmitted. ')
wfOspfIfTxLinkStateUpds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfTxLinkStateUpds.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTxLinkStateUpds.setDescription(' Number of OSPF Link State Update packets transmitted. ')
wfOspfIfTxLinkStateAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfTxLinkStateAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfTxLinkStateAcks.setDescription(' Number of OSPF Link States Acknowledgements transmitted. ')
wfOspfIfRxHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfRxHellos.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRxHellos.setDescription(' Number of OSPF Hello packets received. ')
wfOspfIfRxDBDescripts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfRxDBDescripts.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRxDBDescripts.setDescription(' Number of OSPF DataBase Description packets received. ')
wfOspfIfRxLinkStateReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfRxLinkStateReqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRxLinkStateReqs.setDescription(' Number of OSPF Link State Requests received. ')
wfOspfIfRxLinkStateUpds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfRxLinkStateUpds.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRxLinkStateUpds.setDescription(' Number of OSPF Link State Updates received. ')
wfOspfIfRxLinkStateAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfRxLinkStateAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfRxLinkStateAcks.setDescription(' Number of OSPF Link State Acknowledgements received. ')
wfOspfIfDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfIfDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfIfDrops.setDescription(' Number of OSPF packets dropped because of invalid information in the packet. ')
wfOspfVirtIfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6), )
if mibBuilder.loadTexts: wfOspfVirtIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTable.setDescription(" -- OSPF Virtual Interface Table -- The Virtual Interface Table describes the virtual -- links that the OSPF Process is configured to -- carry on. 'Information about this router's virtual interfaces.' REFERENCE 'OSPF Version 2, Appendix C.4 Virtual link parameters' ")
wfOspfVirtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfVirtIfAreaID"), (0, "Wellfleet-Series7-MIB", "wfOspfVirtIfNeighbor"))
if mibBuilder.loadTexts: wfOspfVirtIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfEntry.setDescription(" 'Information about a single Virtual Interface.' ")
wfOspfVirtIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfDelete.setDescription(' ')
wfOspfVirtIfDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfDisable.setDescription(" 'This variable displays the validity or invalidity of the entry. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.' ")
wfOspfVirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointtopoint", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfState.setDescription(" 'OSPF virtual interface states.' down (1), -- these use the same encoding pointToPoint (4) -- as the ospfIfTable ")
wfOspfVirtIfAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfAreaID.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfAreaID.setDescription(" 'The Transit Area that the Virtual Link traverses. By definition, this is not 0.0.0.0' ")
wfOspfVirtIfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfNeighbor.setDescription(" 'The Router ID of the Virtual Neighbor.' ")
wfOspfVirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1, 3600))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 1), ("maximum", 3600))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTransitDelay.setDescription(" 'The estimated number of seconds it takes to transmit a link- state update packet over this interface.' ")
wfOspfVirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 3600))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 5), ("maximum", 3600))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRetransInterval.setDescription(" 'The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This value should be well over the expected round-trip time.' ")
wfOspfVirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 15, 65535))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 15), ("maximum", 65535))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfHelloInterval.setDescription(" 'The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.' ")
wfOspfVirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 60, 2147483647))).clone(namedValues=NamedValues(("minimum", 1), ("defval", 60), ("maximum", 2147483647))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRtrDeadInterval.setDescription(" 'The number of seconds that a router's Hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.' ")
wfOspfVirtIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfVirtIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfAuthKey.setDescription(" 'If Authentication Type is simplePassword, the device will left adjust and zero fill to 8 octets. When read, ospfVifAuthKey always returns a string of length zero.' REFERENCE 'OSPF Version 2, Section 9 The Interface Data Structure' ")
wfOspfVirtIfTxHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfTxHellos.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTxHellos.setDescription(' Number of OSPF Hello packets transmitted on Virtual Interfaces. ')
wfOspfVirtIfTxDBDescripts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfTxDBDescripts.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTxDBDescripts.setDescription(' Number of OSPF DataBase Description packets transmitted on Virtual Interfaces. ')
wfOspfVirtIfTxLinkStateReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateReqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateReqs.setDescription(' Number of OSPF Link State Request packets transmitted on Virtual Interfaces. ')
wfOspfVirtIfTxLinkStateUpds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateUpds.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateUpds.setDescription(' Number of OSPF Link State Update packets transmitted on Virtual Interfaces. ')
wfOspfVirtIfTxLinkStateAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfTxLinkStateAcks.setDescription(' Number of OSPF Link State Acknowledgement packets transmitted on Virtual Interfaces. ')
wfOspfVirtIfRxHellos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfRxHellos.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRxHellos.setDescription(' Number of OSPF Hello packets received on Virtual Interfaces. ')
wfOspfVirtIfRxDBDescripts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfRxDBDescripts.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRxDBDescripts.setDescription(' Number of OSPF DataBase Description packets received on Virtual Interfaces. ')
wfOspfVirtIfRxLinkStateReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateReqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateReqs.setDescription(' Number of OSPF Link State Request packets recieved on Virtual Interfaces. ')
wfOspfVirtIfRxLinkStateUpds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateUpds.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateUpds.setDescription(' Number of OSPF Link State Update packets received on Virtual Interfaces. ')
wfOspfVirtIfRxLinkStateAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateAcks.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfRxLinkStateAcks.setDescription(' Number of OSPF Link State Acknowledgement packets received on Virtual Interfaces. ')
wfOspfVirtIfDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtIfDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtIfDrops.setDescription(' Number of OSPF packets dropped on Virtual Interfaces. ')
wfOspfNbrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7), )
if mibBuilder.loadTexts: wfOspfNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrTable.setDescription(" -- OSPF Neighbor Table -- The OSPF Neighbor Table describes all neighbors in -- the locality of the subject router. 'A table of non-virtual neighbor information.' REFERENCE 'OSPF Version 2, Section 10 The Neighbor Data Structure' ")
wfOspfNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfNbrIpAddr"), (0, "Wellfleet-Series7-MIB", "wfOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: wfOspfNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrEntry.setDescription(" 'The information regarding a single neighbor.' REFERENCE 'OSPF Version 2, Section 10 The Neighbor Data Structure' ")
wfOspfNbrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfNbrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrDelete.setDescription(' This variable indicates the existence of a static OSPF neighbor. ')
wfOspfNbrDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfNbrDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrDisable.setDescription(" 'This variable displays the status of the entry. Setting it to 'DISABLED' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.' ")
wfOspfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoway", 4), ("exchangstart", 5), ("exchange", 6), ("loading", 7), ("full", 8))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrState.setDescription(" 'The State of the relationship with this Neighbor.' REFERENCE 'OSPF Version 2, Section 10.1 Neighbor States' down (1), attempt (2), init (3), twoWay (4), exchangeStart (5), exchange (6), loading (7), full (8) ")
wfOspfNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrIpAddr.setDescription(" 'The IP address of this neighbor.' ")
wfOspfNbrIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfNbrIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrIfAddr.setDescription(" 'The Interface IP address for this neighbor.' ")
wfOspfNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrAddressLessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrAddressLessIndex.setDescription(" ' On an interface having an IP Address, zero. On addressless interfaces, the corresponding value of ifIndex in the Internet Standard MIB. On row creation, this can be derived from the instance.' ")
wfOspfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrRtrId.setDescription(" 'A 32-bit integer (represented as a type IpAddress) uniquely identifying the neighboring router in the Autonomous System.' default { '00000000'H } -- 0.0.0.0 ")
wfOspfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrOptions.setDescription(" 'A Bit Mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information; if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric.' REFERENCE 'OSPF Version 2, Section 12.1.2 Options' ")
wfOspfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 255))).clone(namedValues=NamedValues(("defval", 1), ("maximum", 255))).clone('defval')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfOspfNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrPriority.setDescription(" 'The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network.' ")
wfOspfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrEvents.setDescription(" 'The number of times this neighbor relationship has changed state, or an error has occurred.' ")
wfOspfNbrLSRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfNbrLSRetransQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfNbrLSRetransQLen.setDescription(" 'The current length of the retransmission queue.' ")
wfOspfVirtNbrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8), )
if mibBuilder.loadTexts: wfOspfVirtNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrTable.setDescription(" -- WFOSPF Virtual Neighbor Table -- This table describes all virtual neighbors. -- Since Virtual Links are configured in the -- virtual interface table, this table is read-only. 'A table of virtual neighbor information.' REFERENCE 'OSPF Version 2, ' ")
wfOspfVirtNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfVirtNbrArea"), (0, "Wellfleet-Series7-MIB", "wfOspfVirtNbrRtrId"))
if mibBuilder.loadTexts: wfOspfVirtNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrEntry.setDescription(" 'Virtual neighbor information.' REFERENCE 'OSPF Version 2, ' ")
wfOspfVirtNbrArea = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrArea.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrArea.setDescription(" 'The Transit Area Identifier.' ")
wfOspfVirtNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrRtrId.setDescription(" 'A 32-bit integer uniquely identifying the neighboring router in the Autonomous System.' ")
wfOspfVirtNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrIpAddr.setDescription(" 'The IP address this Virtual Neighbor is using.' ")
wfOspfVirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrOptions.setDescription(" 'A bit map corresponding to the neighbor's options field. Thus, Bit 1, if set, indicates that the neighbor supports Type of Service Routing; if zero, no metrics other than TOS 0 are in use by the neighbor.' ")
wfOspfVirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoway", 4), ("exchangstart", 5), ("exchange", 6), ("loading", 7), ("full", 8))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrState.setDescription(" 'The state of the Virtual Neighbor Relationship.' down (1), attempt (2), init (3), twoWay (4), exchangeStart (5), exchange (6), loading (7), full (8) ")
wfOspfVirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrEvents.setDescription(" 'The number of times this virtual link has changed its state, or an error has occurred.' ")
wfOspfVirtNbrLSRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfVirtNbrLSRetransQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfVirtNbrLSRetransQLen.setDescription(" 'The current length of the retransmission queue.' ")
wfOspfDynNbrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9), )
if mibBuilder.loadTexts: wfOspfDynNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrTable.setDescription(" -- OSPF Dynamic Neighbor Table -- The OSPF Dynamic Neighbor Table describes all neighbors in -- the locality of the subject router learned during operation. 'A table of non-virtual neighbor information.' REFERENCE 'OSPF Version 2, Section 10 The Neighbor Data Structure' ")
wfOspfDynNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfOspfDynNbrIpAddr"), (0, "Wellfleet-Series7-MIB", "wfOspfDynNbrAddressLessIndex"))
if mibBuilder.loadTexts: wfOspfDynNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrEntry.setDescription(" 'The information regarding a single neighbor.' REFERENCE 'OSPF Version 2, Section 10 The Neighbor Data Structure' ")
wfOspfDynNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoway", 4), ("exchangstart", 5), ("exchange", 6), ("loading", 7), ("full", 8))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrState.setDescription(" 'The State of the relationship with this Neighbor.' REFERENCE 'OSPF Version 2, Section 10.1 Neighbor States' down (1), attempt (2), init (3), twoWay (4), exchangeStart (5), exchange (6), loading (7), full (8) ")
wfOspfDynNbrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrIpAddr.setDescription(" 'The IP address of this neighbor.' ")
wfOspfDynNbrIfAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrIfAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrIfAddr.setDescription(" 'The Interface IP address for this neighbor.' ")
wfOspfDynNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrAddressLessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrAddressLessIndex.setDescription(" ' On an interface having an IP Address, zero. On addressless interfaces, the corresponding value of ifIndex in the Internet Standard MIB. On row creation, this can be derived from the instance.' ")
wfOspfDynNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrRtrId.setDescription(" 'A 32-bit integer (represented as a type IpAddress) uniquely identifying the neighboring router in the Autonomous System.' default { '00000000'H } -- 0.0.0.0 ")
wfOspfDynNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrOptions.setDescription(" 'A Bit Mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information; if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric.' REFERENCE 'OSPF Version 2, Section 12.1.2 Options' ")
wfOspfDynNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrPriority.setDescription(" 'The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network.' ")
wfOspfDynNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrEvents.setDescription(" 'The number of times this neighbor relationship has changed state, or an error has occurred.' ")
wfOspfDynNbrLSRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 3, 9, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfOspfDynNbrLSRetransQLen.setStatus('mandatory')
if mibBuilder.loadTexts: wfOspfDynNbrLSRetransQLen.setDescription(" 'The current length of the retransmission queue.' ")
wfIpRfRipImportTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8), )
if mibBuilder.loadTexts: wfIpRfRipImportTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportTable.setDescription(' The list of Rip Import Route Filter Rules in IP ')
wfIpRfRipImportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpRfRipImportAddress"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipImportMask"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipImportRipGateway"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipImportRipInterface"))
if mibBuilder.loadTexts: wfIpRfRipImportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportEntry.setDescription(' An entry in the Rip Import Rule Table ')
wfIpRfRipImportCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipImportCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportCreate.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete this Rule.')
wfIpRfRipImportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipImportEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this Rule.')
wfIpRfRipImportAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipImportAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportAddress.setDescription(' The IP address to which this filter applies ')
wfIpRfRipImportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipImportMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportMask.setDescription(' The Mask to which this filter applies. When combined with the Address, a range is specified for application of this rule ')
wfIpRfRipImportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("accept", 1), ("ignore", 3))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipImportAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportAction.setDescription(' The Action of this Filter ')
wfIpRfRipImportPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16))).clone(namedValues=NamedValues(("maximum", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipImportPreference.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportPreference.setDescription(' The Preference associated with this filter - only valid if accept ')
wfIpRfRipImportRipGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipImportRipGateway.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportRipGateway.setDescription(' The RIP Gateway to be concerned with ')
wfIpRfRipImportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 8, 1, 8), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipImportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipImportRipInterface.setDescription(' The IP Network Interface to be concerned with ')
wfIpRfRipExportTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9), )
if mibBuilder.loadTexts: wfIpRfRipExportTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportTable.setDescription(' The list of Rip Export Route Filter Rules in IP ')
wfIpRfRipExportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpRfRipExportAddress"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipExportMask"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipExportFromProtocol"), (0, "Wellfleet-Series7-MIB", "wfIpRfRipExportInterface"))
if mibBuilder.loadTexts: wfIpRfRipExportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportEntry.setDescription(' An entry in the Rip Export Rule Table ')
wfIpRfRipExportCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipExportCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportCreate.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete this Rule.')
wfIpRfRipExportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipExportEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this Rule.')
wfIpRfRipExportAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipExportAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportAddress.setDescription(' The IP address to which this filter applies ')
wfIpRfRipExportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipExportMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportMask.setDescription(' The Mask for the Address Above. When combined with the Address, a range is specified for application of this filter rule ')
wfIpRfRipExportFromProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 3), ("direct", 4), ("static", 5))).clone('rip')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipExportFromProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportFromProtocol.setDescription(' The protocol from which this Information is derived ')
wfIpRfRipExportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("propa", 2), ("ignore", 3))).clone('propa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipExportAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportAction.setDescription(' The action of this export filter ')
wfIpRfRipExportInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfRipExportInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportInterface.setDescription(' The optional outbound interface on which to apply this filter ')
wfIpRfRipExportRipMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(15))).clone(namedValues=NamedValues(("maximum", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfRipExportRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfRipExportRipMetric.setDescription(" The optional export RIP metric to apply to this filter. Zero means: use the route's actual cost. Only valid for propagate ")
wfIpRfOspfImportTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10), )
if mibBuilder.loadTexts: wfIpRfOspfImportTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportTable.setDescription(' The list of OSPF Import Route Filter Rules in IP ')
wfIpRfOspfImportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpRfOspfImportAddress"), (0, "Wellfleet-Series7-MIB", "wfIpRfOspfImportMask"), (0, "Wellfleet-Series7-MIB", "wfIpRfOspfImportType"), (0, "Wellfleet-Series7-MIB", "wfIpRfOspfImportTag"))
if mibBuilder.loadTexts: wfIpRfOspfImportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportEntry.setDescription(' An entry in the OSPF Import Route Filter Table ')
wfIpRfOspfImportCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfImportCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportCreate.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete this Rule.')
wfIpRfOspfImportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfImportEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this Rule.')
wfIpRfOspfImportAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfImportAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportAddress.setDescription(' The IP Address to which this filter applies ')
wfIpRfOspfImportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfImportMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportMask.setDescription(' The Mask to which this filter applies. When combined with the Address, a range is specified for application of this rule ')
wfIpRfOspfImportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("accept", 1), ("ignore", 3))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfImportAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportAction.setDescription(' The Action of this Filter ')
wfIpRfOspfImportPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16))).clone(namedValues=NamedValues(("maximum", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfImportPreference.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportPreference.setDescription(' The Preference associated with this filter - only valid if accept ')
wfIpRfOspfImportType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfImportType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportType.setDescription(' The OSPF route Type to be concerned with. The valid values are null (any route type), 1 (OSPF external type 1), and 2 (OSPF external type 2). ')
wfIpRfOspfImportTag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 10, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfImportTag.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfImportTag.setDescription(' The OSPF Tag to be concerned with ')
wfIpRfOspfExportTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11), )
if mibBuilder.loadTexts: wfIpRfOspfExportTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportTable.setDescription(' The list of OSPF Export Route Filter Rules in IP ')
wfIpRfOspfExportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfIpRfOspfExportAddress"), (0, "Wellfleet-Series7-MIB", "wfIpRfOspfExportMask"), (0, "Wellfleet-Series7-MIB", "wfIpRfOspfExportFromProtocol"))
if mibBuilder.loadTexts: wfIpRfOspfExportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportEntry.setDescription(' An entry in the OSPF Export Route Filter Table ')
wfIpRfOspfExportCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("create", 1), ("delete", 2))).clone('create')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfExportCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportCreate.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete this Rule.')
wfIpRfOspfExportEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfExportEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportEnable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this Rule.')
wfIpRfOspfExportAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfExportAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportAddress.setDescription(' The IP address to which this filter applies ')
wfIpRfOspfExportMask = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfExportMask.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportMask.setDescription(' The Mask for the Address Above. When combined with the Address, a range is specified for application of this filter rule ')
wfIpRfOspfExportFromProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5))).clone(namedValues=NamedValues(("rip", 1), ("ospf", 3), ("direct", 4), ("static", 5))).clone('rip')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfIpRfOspfExportFromProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportFromProtocol.setDescription(' The protocol from which this Information is derived ')
wfIpRfOspfExportAction = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("propa", 2), ("ignore", 3))).clone('propa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfExportAction.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportAction.setDescription(' The action of this export filter ')
wfIpRfOspfExportType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("type1", 1), ("type2", 2))).clone('type1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfExportType.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportType.setDescription(' The ospf type to use when this filter matches ')
wfIpRfOspfExportTag = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 2, 1, 11, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfIpRfOspfExportTag.setStatus('mandatory')
if mibBuilder.loadTexts: wfIpRfOspfExportTag.setDescription(' The ospf tag to use when this filter matches ')
wfSipL2 = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1), )
if mibBuilder.loadTexts: wfSipL2.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2.setDescription(' The SIP L2 Table ')
wfSipL2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSipL2Index"))
if mibBuilder.loadTexts: wfSipL2Entry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2Entry.setDescription(' per circuit SIP Level 2 objects - wfSipL2Index corresponds to Wellfleet circuit number ')
wfSipL2Index = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2Index.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2Index.setDescription(' this corresponds to the Wellfleet circuit number ')
wfSipL2ReceivedCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2ReceivedCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2ReceivedCounts.setDescription(' total of unerrored received SIP L2 PDUs ')
wfSipL2SentCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2SentCounts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2SentCounts.setDescription(" total of unerrored SIP L2 PDU's sent across the SNI ")
wfSipHcsOrCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipHcsOrCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipHcsOrCRCErrors.setDescription(' total SIP L2 PDUs with HCS or CRC errors ')
wfSipL2PayloadLengthErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2PayloadLengthErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2PayloadLengthErrors.setDescription(' total SIP L2 PDUs with length errors ')
wfSipL2SequenceNumberErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2SequenceNumberErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2SequenceNumberErrors.setDescription(' total SIP L2 PDUs with unexpected sequence numbers ')
wfSipL2MidCurrentlyActiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2MidCurrentlyActiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2MidCurrentlyActiveErrors.setDescription(' number of SIP L2 PDUs with BOMs previously started ')
wfSipL2BomOrSSMsMIDErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2BomOrSSMsMIDErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2BomOrSSMsMIDErrors.setDescription(' number of SIP L2 PDUs with zero BOMs or SSMs not zero ')
wfSipL2EomsMIDErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipL2EomsMIDErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipL2EomsMIDErrors.setDescription(' number of SIP L2 PDUs with zero EOMs or EOMs without BOMs ')
wfSipDs1Plcp = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1), )
if mibBuilder.loadTexts: wfSipDs1Plcp.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1Plcp.setDescription(' The SIP DS1 PLCP Table ')
wfSipDs1PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSipDs1PlcpIndex"))
if mibBuilder.loadTexts: wfSipDs1PlcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1PlcpEntry.setDescription(' per circuit DS1 PLCP objects - wfSipDs1PlcpIndex corresponds to Wellfleet circuit number ')
wfSipDs1PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs1PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1PlcpIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfSipDs1PlcpSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs1PlcpSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1PlcpSEFs.setDescription(' number of second intervals containing one or more severely errored seconds ')
wfSipDs1PlcpAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noalarm", 1), ("receivedfarendalarm", 2), ("incominglof", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs1PlcpAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1PlcpAlarmState.setDescription(' alarm state ')
wfSipDs1PlcpUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs1PlcpUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs1PlcpUASs.setDescription(' number of second intervals containing one or more unavailable seconds ')
wfSipDs3Plcp = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2), )
if mibBuilder.loadTexts: wfSipDs3Plcp.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3Plcp.setDescription(' The SIP DS3 PLCP Table ')
wfSipDs3PlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSipDs3PlcpIndex"))
if mibBuilder.loadTexts: wfSipDs3PlcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3PlcpEntry.setDescription(' per circuit DS3 PLCP objects - wfSipDs3PlcpIndex corresponds to Wellfleet circuit number ')
wfSipDs3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1024))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1024)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3PlcpIndex.setDescription(' this corresponds to the Wellfleet circuit number ')
wfSipDs3PlcpSEFs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs3PlcpSEFs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3PlcpSEFs.setDescription(' number of second intervals containing one or more severely errored seconds ')
wfSipDs3PlcpAlarmState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noalarm", 1), ("receivedfarendalarm", 2), ("incominglof", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs3PlcpAlarmState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3PlcpAlarmState.setDescription(' alarm state ')
wfSipDs3PlcpUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 14, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSipDs3PlcpUASs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSipDs3PlcpUASs.setDescription(' number of second intervals containing one or more unavailable seconds ')
wfSmdsCircuitTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3), )
if mibBuilder.loadTexts: wfSmdsCircuitTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitTable.setDescription(' The Wellfleet SMDS Circuit Record ')
wfSmdsCircuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSmdsCircuitID"))
if mibBuilder.loadTexts: wfSmdsCircuitEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitEntry.setDescription(' per Wellfleet circuit SMDS configuration parameters and counters ')
wfSmdsCircuitDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitDelete.setDescription(' create/delete parameter, dflt = created ')
wfSmdsCircuitDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitDisable.setDescription(' enable/disable parameter, dflt = enabled')
wfSmdsCircuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitState.setDescription(' SMDS state variable, Up, Down Init, Not Present ')
wfSmdsCircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitID.setDescription(' cct number for this instance ')
wfSmdsCircuitIndivAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitIndivAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitIndivAddr.setDescription(' SMDS E.164 Individual address for this Wellfleet circuit - must be 8 octets long ')
wfSmdsCircuitGroupAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitGroupAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitGroupAddr.setDescription(' SMDS E.164 Group address for this Wellfleet circuit - must be 8 octets long ')
wfSmdsCircuitArpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitArpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitArpAddr.setDescription(' SMDS E.164 ARP address for this Wellfleet circuit - must be 8 octets long ')
wfSmdsCircuitDisableHrtbtPoll = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitDisableHrtbtPoll.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitDisableHrtbtPoll.setDescription(' determine use of DXI heartbeat poll ')
wfSmdsCircuitHrtbtPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(6, 10))).clone(namedValues=NamedValues(("minimum", 6), ("default", 10))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitHrtbtPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitHrtbtPollInterval.setDescription(" heartbeat polling messages get sent every this many seconds - we don't want the polling interval to be less than or equal to the unacknowledgment timer, which is 5 seconds ")
wfSmdsCircuitHrtbtPollDownCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("minimum", 1), ("default", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitHrtbtPollDownCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitHrtbtPollDownCount.setDescription(' if this many consecutive heartbeat polling messages go unacknowledged, log an event declaring the line down ')
wfSmdsCircuitDisableNetMgmt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSmdsCircuitDisableNetMgmt.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitDisableNetMgmt.setDescription(' determine use of LMI network management ')
wfSmdsCircuitSipL3ReceivedIndividualDAs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitSipL3ReceivedIndividualDAs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitSipL3ReceivedIndividualDAs.setDescription(' The total number of individually addressed SIP Level 3 PDUs received from the remote system across the SNI. The total includes only unerrored L3PDUs. ')
wfSmdsCircuitSipL3ReceivedGAs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitSipL3ReceivedGAs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitSipL3ReceivedGAs.setDescription(' The total number of group addressed SIP Level 3 PDUs received from the remote system across the SNI. The total includes only unerrored L3PDUs. ')
wfSmdsCircuitSipL3SentIndividualDAs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitSipL3SentIndividualDAs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitSipL3SentIndividualDAs.setDescription(' The number of individually addressed SIP Level 3 PDUs that have been sent by this system across the SNI. ')
wfSmdsCircuitSipL3SentGAs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitSipL3SentGAs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitSipL3SentGAs.setDescription(' The number of group addressed SIP L3PDUs that have been sent by this system across the SNI. ')
wfSmdsCircuitSipL3VersionSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("version", 1))).clone('version')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSmdsCircuitSipL3VersionSupport.setStatus('mandatory')
if mibBuilder.loadTexts: wfSmdsCircuitSipL3VersionSupport.setDescription(' A value which indicates the version(s) of SIP that this interface supports. The value is a sum. This sum initially takes the value zero. For each version, V, that this interface supports, 2 raised to (V - 1) is added to the sum. For example, a port supporting versions 1 and 2 would have a value of (2^(1-1)+2^(2-1))=3. The SipL3VersionSupport is effectively a bit mask with Version 1 equal to the least significant bit (LSB). ')
wfSnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1))
wfSnmpDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpDisable.setDescription(' Enables or disables the SNMP subsystem ')
wfSnmpUseLock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpUseLock.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpUseLock.setDescription(' Flag to indicate whether locking mechanism is enabled or disabled ')
wfSnmpLockAddress = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpLockAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpLockAddress.setDescription(' Address of remote manager that is enforcing the lock. This value is set by the SNMP agent. Remote managers are only allowed to clear it. ')
wfSnmpLockTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 60))).clone(namedValues=NamedValues(("default", 2), ("minimum", 1), ("maximum", 60))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpLockTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpLockTimeOut.setDescription(' The maximum time (in minutes) a lock can be idle before it is cleared. ')
wfSnmpAuth = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trivial", 1), ("party", 2))).clone('trivial')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpAuth.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpAuth.setDescription(' The type of authentication used by the agent ')
wfSnmpInPkts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInPkts.setDescription(' Total number of PDUs received by SNMP from transport entity ')
wfSnmpOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutPkts.setDescription(' Total number of PDUs sent by SNMP to transport entity ')
wfSnmpInBadVersions = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInBadVersions.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInBadVersions.setDescription(' Total number of PDUs requesting unsupported versions ')
wfSnmpInBadCommunityNames = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInBadCommunityNames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInBadCommunityNames.setDescription(' Total number of PDUs which had an invalid community string ')
wfSnmpInBadCommunityUses = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInBadCommunityUses.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInBadCommunityUses.setDescription(' Total number of PDUs requesting an operation unsupported by the community ')
wfSnmpInASNParseErrs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInASNParseErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInASNParseErrs.setDescription(' Total number of ASN.1 parsing errors during decoding ')
wfSnmpInBadTypes = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInBadTypes.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInBadTypes.setDescription(' Total number of PDUs having an unknown PDU type ')
wfSnmpInTooBigs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInTooBigs.setDescription(" Total number of PDUs delivered with ErrorStatus='tooBig' ")
wfSnmpInNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInNoSuchNames.setDescription(" Total number of PDUs delivered with ErrorStatus='noSuchName' ")
wfSnmpInBadValues = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInBadValues.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInBadValues.setDescription(" Total number of PDUs delivered with ErrorStatus='badValue' ")
wfSnmpInReadOnlys = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInReadOnlys.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInReadOnlys.setDescription(" Total number of PDUs delivered with ErrorStatus='readOnly' ")
wfSnmpInGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInGenErrs.setDescription(" Total number of PDUs delivered with ErrorStatus='genErr' ")
wfSnmpInTotalReqVars = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInTotalReqVars.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInTotalReqVars.setDescription(' Total number of MIB objects retrieved successfully by the agent ')
wfSnmpInTotalSetVars = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInTotalSetVars.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInTotalSetVars.setDescription(' Total number of MIB objects which have been SET successfully ')
wfSnmpInGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInGetRequests.setDescription(' Total number of Get-Request PDUS accepted and processed')
wfSnmpInGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInGetNexts.setDescription(' Total number of GetNext-Request PDUS accepted and processed')
wfSnmpInSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInSetRequests.setDescription(' Total number of Set-Request PDUS accepted and processed')
wfSnmpInGetResponses = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInGetResponses.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInGetResponses.setDescription(' Total number of GetResponse PDUs accepted and processed')
wfSnmpInTraps = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpInTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpInTraps.setDescription(' Total number of Trap PDUs accepted and processed')
wfSnmpOutTooBigs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutTooBigs.setDescription(" Total number of PDUs generated by the agent with ErrorStatus='tooBig' ")
wfSnmpOutNoSuchNames = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutNoSuchNames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutNoSuchNames.setDescription(" Total number of PDUs generated by the agent with ErrorStatus='noSuchName' ")
wfSnmpOutBadValues = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutBadValues.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutBadValues.setDescription(" Total number of PDUs generated by the agent with ErrorStatus='badValue' ")
wfSnmpOutReadOnlys = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutReadOnlys.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutReadOnlys.setDescription(" Total number of PDUs generated by the agent with ErrorStatus='readOnly' ")
wfSnmpOutGenErrs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutGenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutGenErrs.setDescription(" Total number of PDUs generated by the agent with ErrorStatus='genErr' ")
wfSnmpOutGetRequests = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutGetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutGetRequests.setDescription(' Total number of Get-Request PDUs generated by the agent ')
wfSnmpOutGetNexts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutGetNexts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutGetNexts.setDescription(' Total number of Get-Next-Request PDUs generated by the agent ')
wfSnmpOutSetRequests = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutSetRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutSetRequests.setDescription(' Total number of Set-Request PDUs generated by the agent ')
wfSnmpOutGetResponses = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutGetResponses.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutGetResponses.setDescription(' Total number of Get-Response PDUs generated by the agent ')
wfSnmpOutTraps = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpOutTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpOutTraps.setDescription(' Total number of Trap PDUs generated by the agent ')
wfSnmpEnableAuthTraps = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpEnableAuthTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpEnableAuthTraps.setDescription(' Idicates whether agent can generate Authentication Failure Traps ')
wfSnmpTrapDebug = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpTrapDebug.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpTrapDebug.setDescription(' This attribute controls the specific trap filter for debug messages ')
wfSnmpTrapTrace = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpTrapTrace.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpTrapTrace.setDescription(' This attribute controls the specific trap filter for trace messages ')
wfSnmpTrapInfo = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpTrapInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpTrapInfo.setDescription(' This attribute controls the specific trap filter for informational messages ')
wfSnmpTrapWarn = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpTrapWarn.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpTrapWarn.setDescription(' This attribute controls the specific trap filter for warning messages ')
wfSnmpTrapFault = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpTrapFault.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpTrapFault.setDescription(' This attribute controls the specific trap filter for fault messages ')
wfSnmpCommTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2), )
if mibBuilder.loadTexts: wfSnmpCommTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommTable.setDescription(' A table containing valid management communities ')
wfSnmpCommEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSnmpCommIndex"))
if mibBuilder.loadTexts: wfSnmpCommEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommEntry.setDescription(' Information about a particular community ')
wfSnmpCommDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpCommDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommDelete.setDescription(' A flag to indicate community instance deletion ')
wfSnmpCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpCommIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommIndex.setDescription(' A unique numeric value that has a one to one correspondence with the community name ')
wfSnmpCommName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpCommName.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommName.setDescription(' Community name ')
wfSnmpCommAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("readonly", 1), ("readwrite", 2))).clone('readonly')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpCommAccess.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpCommAccess.setDescription(' Community access mode ')
wfSnmpMgrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3), )
if mibBuilder.loadTexts: wfSnmpMgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrTable.setDescription(' A table containing managers and their respective communities ')
wfSnmpMgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSnmpMgrCommIndex"), (0, "Wellfleet-Series7-MIB", "wfSnmpMgrAddress"))
if mibBuilder.loadTexts: wfSnmpMgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrEntry.setDescription(' Information about a manager of a community ')
wfSnmpMgrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpMgrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrDelete.setDescription(' A flag to indicate manager instance deletion */ ')
wfSnmpMgrCommIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpMgrCommIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrCommIndex.setDescription(' Associates this manager with a community in the community table ')
wfSnmpMgrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSnmpMgrAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrAddress.setDescription(' IP Address of this manager ')
wfSnmpMgrName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpMgrName.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrName.setDescription(' A name for this manager ')
wfSnmpMgrTrapPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 5), Integer32().clone(162)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpMgrTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrTrapPort.setDescription(' The UDP Port on which this manager is listening for traps ')
wfSnmpMgrTraps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 5, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 7))).clone(namedValues=NamedValues(("none", 1), ("generic", 2), ("specific", 4), ("all", 7))).clone('generic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSnmpMgrTraps.setStatus('mandatory')
if mibBuilder.loadTexts: wfSnmpMgrTraps.setDescription(' Allowable Traps to be sent to Manager, defaults to only generic trap types ')
wfBrStp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1))
wfBrStpBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBaseDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the Spanning tree. ')
wfBrStpBaseEnable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBaseEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBaseEnable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable the spanning tree. ')
wfBrStpBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("pres", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBaseState.setDescription(' The current state of the spanning tree. ')
wfBrStpProtocolSpecification = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("declb100", 2), ("ieee8021d", 3))).clone('ieee8021d')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpProtocolSpecification.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpProtocolSpecification.setDescription(' The version of the Spanning Tree protocol being run. ')
wfBrStpBridgeID = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBridgeID.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBridgeID.setDescription(' The Spanning Tree Bridge ID assigned to this bridge. It is a 8-octet string. The first two octets make up the bridge priority, and the last six are the MAC address of this bridge, which is commonly the MAC address of the first port on the bridge. ')
wfBrStpTimeSinceTopologyChange = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpTimeSinceTopologyChange.setDescription(' The time (in hundredths of a second) since the last topology change was detected by the bridge. ')
wfBrStpTopChanges = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpTopChanges.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpTopChanges.setDescription(' The total number of topology changes detected by this bridge since it was last reset or initialized ')
wfBrStpDesignatedRoot = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpDesignatedRoot.setDescription(' The bridge ID of the root of the spanning tree as determined by the Spanning Tree Protocol as executed by the bridge. This value is used as the Root Identifier parameter in all Configuration Bridge PDUs originated by this node. It is a 8-octet string. The first two octets make up the priority, and the last six are the MAC address of the designated root bridge. ')
wfBrStpRootCost = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpRootCost.setDescription(' The cost of the path to the root as seen from this bridge. ')
wfBrStpRootPort = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpRootPort.setDescription(' The port identifier of the port which offers the lowest cost path from this bridge to the root bridge. ')
wfBrStpMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpMaxAge.setDescription(' The maximum age of the Spanning Tree Protocol information learned from the network on any port before it is discarded, in hundredths of a second. This represents the value actually in use by the bridge. ')
wfBrStpHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpHelloTime.setDescription(' The amount of time between transmission of configuration BPDUs by this bridge on any port, when it is the root of the spanning tree or trying to become so, in hundreths of a second. This represents the value actually in use by the bridge. ')
wfBrStpHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100))).clone(namedValues=NamedValues(("time", 100))).clone('time')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpHoldTime.setDescription(' The value that determines the interval length during which no more than two configuration BPDUs shall be transmitted by this bridge, in hundredths of a second. ')
wfBrStpForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpForwardDelay.setDescription(' The time, in hundredths of a second, that a port on this bridge will stay in a transitional state (e.g. LISTENING) before moving to the next state (e.g. LEARNING). This value is also used to age all dynamic entries in the Forwarding Database when a topology changed has been detected and is underway. This represents the value actually in use by the bridge. ')
wfBrStpBridgeMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(600, 2000, 4000))).clone(namedValues=NamedValues(("minimum", 600), ("default", 2000), ("maximum", 4000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBridgeMaxAge.setDescription(' The value that all bridges use for MaxAge when this bridge acting as the root. ')
wfBrStpBridgeHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(100, 200, 1000))).clone(namedValues=NamedValues(("minimum", 100), ("default", 200), ("maximum", 1000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBridgeHelloTime.setDescription(' The value that all bridges use for HelloTime when this bridge acting as the root. ')
wfBrStpBridgeForwardDelay = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(400, 1500, 3000))).clone(namedValues=NamedValues(("minimum", 400), ("default", 1500), ("maximum", 3000))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpBridgeForwardDelay.setDescription(' The value that all bridges use for ForwardDelay when this bridge acting as the root. ')
wfBrStpInterface = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2), )
if mibBuilder.loadTexts: wfBrStpInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterface.setDescription(' inst_id[1] = wfBrStpInterfaceCircuit ')
wfBrStpInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrStpInterfaceCircuit"))
if mibBuilder.loadTexts: wfBrStpInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceEntry.setDescription(' An entry in wfBrStpInterface. ')
wfBrStpInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an interface for the Spanning Tree. ')
wfBrStpInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpInterfaceEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceEnable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an interface for the Spanning Tree. ')
wfBrStpInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceCircuit.setDescription(' The circuit number on which this interface is defined. ')
wfBrStpInterfacePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(128, 255))).clone(namedValues=NamedValues(("default", 128), ("maximum", 255))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpInterfacePriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfacePriority.setDescription(' The value of the priority field which is contained in the first octet of the (2 octet long) port ID for this circuit. The other octet of the port ID is given by wfBrStpInterfaceCircuit. ')
wfBrStpInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceState.setDescription(' The current state of the port as defined by the application of the Spanning Tree Protocol. ')
wfBrStpInterfaceMultiCastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceMultiCastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceMultiCastAddr.setDescription(' The MAC address used as the destination for all BPDU packets generated out this port. ')
wfBrStpInterfacePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 65535))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 65535))).clone('minimum')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrStpInterfacePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfacePathCost.setDescription(' The contribution of this port the the root path cost of paths toward the spanning tree root which include this port. ')
wfBrStpInterfaceDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedRoot.setDescription(' The unique Bridge Identifier of the Bridge recorded as the Root in the Configuration BPDUs transmitted by the Designated Bridge for the segment to which this port is attached. Bridge IDs are made up of a 2-byte priority field, and a 6-byte MAC address. ')
wfBrStpInterfaceDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedCost.setDescription(' The path cost of the Designated Port of the segment connected to this port. This value is compared to the Root Path Cost field in received bridge PDUs. ')
wfBrStpInterfaceDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedBridge.setDescription(" The Bridge Identifier of the bridge which this port considers to be the Designated Bridge for this port's segment. ")
wfBrStpInterfaceDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceDesignatedPort.setDescription(" The Port Identifier of the port on the Designated Bridge for this port's segment. ")
wfBrStpInterfaceForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfaceForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfaceForwardTransitions.setDescription(' The number of times this port has transitioned from the Learning State to the Forwarding state. ')
wfBrStpInterfacePktsXmitd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfacePktsXmitd.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfacePktsXmitd.setDescription(' The number of BPDU packets transmitted out this port ')
wfBrStpInterfacePktsRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrStpInterfacePktsRcvd.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrStpInterfacePktsRcvd.setDescription(' The number of BPDU packets received on this port ')
wfBrSr = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1))
wfBrSrBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the bridge. ')
wfBrSrBaseDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseDisable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable the bridge. ')
wfBrSrBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseState.setDescription(' The current state of the SR bridge. ')
wfBrSrBaseInternalLanId = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseInternalLanId.setDescription(' The SR bridge internal LAN ID ')
wfBrSrBaseBridgeId = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseBridgeId.setDescription(' The SR bridge Id ')
wfBrSrBaseGroupLanId = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 6), Integer32().clone(4095)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseGroupLanId.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseGroupLanId.setDescription(' The SR bridge Group LAN ID ')
wfBrSrBaseIpEncapsDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseIpEncapsDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseIpEncapsDisable.setDescription(' IP Encapsulation Enable/Disable ')
wfBrSrBaseIpNetworkRingId = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseIpNetworkRingId.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseIpNetworkRingId.setDescription(' The ring number of a connected IP network ')
wfBrSrBaseIpInReceives = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrBaseIpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseIpInReceives.setDescription(' The number IP frames received by the network ')
wfBrSrBaseIpSeqErrors = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrBaseIpSeqErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseIpSeqErrors.setDescription(' The number IP frames received by the network ')
wfBrSrBaseIpMtuSize = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 1, 11), Integer32().clone(4562)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBaseIpMtuSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBaseIpMtuSize.setDescription(' to the LF code in the Route Control field ')
wfBrSrInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2), )
if mibBuilder.loadTexts: wfBrSrInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceTable.setDescription(' A table that contains information about every interface that is associated with this source routing bridge. inst_id[1] = wfBrSrInterfaceCircuit ')
wfBrSrInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrInterfaceCircuit"))
if mibBuilder.loadTexts: wfBrSrInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceEntry.setDescription(' An entry in wfBrSrInterface. ')
wfBrSrInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an interface. ')
wfBrSrInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceDisable.setDescription(' Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an interface. ')
wfBrSrInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceState.setDescription(' The current state of the interface. ')
wfBrSrInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceCircuit.setDescription(' The circuit that this interface runs over. ')
wfBrSrInterfaceMaxRds = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 5), Integer32().clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceMaxRds.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceMaxRds.setDescription(' The maximum number of RDs permitted in incoming explorer frames ')
wfBrSrInterfaceRing = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceRing.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceRing.setDescription(' The ring number of the source routing circuit. Even non-ring circuit need a ring number if it is to do source routing ')
wfBrSrInterfaceBlockOutSte = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("accept", 2))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceBlockOutSte.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceBlockOutSte.setDescription(' Enables blocking of outbound STEs ')
wfBrSrInterfaceBlockInSte = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("accept", 2))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceBlockInSte.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceBlockInSte.setDescription(' Enables blocking of inbound STEs ')
wfBrSrInterfaceBlockIp = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("block", 1), ("accept", 2))).clone('accept')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceBlockIp.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceBlockIp.setDescription(' Enables blocking of inbound explorers that have have already been through the IP network ')
wfBrSrInterfaceIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrInterfaceIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceIpAddress.setDescription(' Ip address for this ring. This should match the the IP address in the IP MIB ')
wfBrSrInterfaceInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceInFrames.setDescription(' The number of frames that have been received by this interface from its circuit. ')
wfBrSrInterfaceOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceOutFrames.setDescription(' The number of frames that have been transmitted by this interface ')
wfBrSrInterfaceOutIpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceOutIpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceOutIpFrames.setDescription(' The number of frames that have been transmitted by this interface to the IP network ')
wfBrSrInterfaceDropInvalidRcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceDropInvalidRcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceDropInvalidRcs.setDescription(' Count of frames received which were discarded because of a bad Route Control field ')
wfBrSrInterfaceDropInvalidRings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceDropInvalidRings.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceDropInvalidRings.setDescription(' Count of frames received which were discarded because of a invalid incoming ring ')
wfBrSrInterfaceDropSrfs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrInterfaceDropSrfs.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrInterfaceDropSrfs.setDescription(' Count of specifically routed frames received which were discarded due to filtering or no next circuit ')
wfBrSrBridgeTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 3), )
if mibBuilder.loadTexts: wfBrSrBridgeTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBridgeTable.setDescription(' A table that contains the bridge numbers used by Wellfleet bridges in a source routing network inst_id[2] = wfBrSrBridgeId ')
wfBrSrBridgeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrBridgeId"))
if mibBuilder.loadTexts: wfBrSrBridgeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBridgeEntry.setDescription(' An entry in wfBrSrBridge. ')
wfBrSrBridgeDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrBridgeDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBridgeDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an IP encapsulation peer record. ')
wfBrSrBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrBridgeId.setDescription(' The Bridge Id reserved for Wellfleet bridges ')
wfBrSrIpExplorerTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 4), )
if mibBuilder.loadTexts: wfBrSrIpExplorerTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpExplorerTable.setDescription(' A table that contains the table of IP addresses to which source routing explorers should be sent inst_id[2] = wfBrSrIpExplorerAddress ')
wfBrSrIpExplorerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrIpExplorerAddr"))
if mibBuilder.loadTexts: wfBrSrIpExplorerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpExplorerEntry.setDescription(' An entry in wfBrSrIpExplorer. ')
wfBrSrIpExplorerDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrIpExplorerDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpExplorerDelete.setDescription(' Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an IP encapsulation peer record. ')
wfBrSrIpExplorerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 4, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrIpExplorerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpExplorerAddr.setDescription(' The IP address of this encapsulation peer. ')
wfBrSrIpEncapsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 5), )
if mibBuilder.loadTexts: wfBrSrIpEncapsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpEncapsTable.setDescription(" A table that contains information about IP Encapsulation ring-to-IP Address mappings. This information is used to make the 'next ring' IP Address decision. inst = wfBrSrIpEncapsRing ")
wfBrSrIpEncapsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrIpEncapsRing"))
if mibBuilder.loadTexts: wfBrSrIpEncapsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpEncapsEntry.setDescription(' An entry in the wfBrSrIpEncapsTable. ')
wfBrSrIpEncapsRing = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrIpEncapsRing.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpEncapsRing.setDescription(' The remote ring number for which we have a ring to IP Address mapping. ')
wfBrSrIpEncapsIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrIpEncapsIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpEncapsIpAddress.setDescription(' The IP Address of the Wellfleet IP Encapsulation peer to which this ring is connected. ')
wfBrSrIpEncapsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrIpEncapsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrIpEncapsStatus.setDescription(' The status of this entry. The meanings of the values are: learned(3) : the value of the corresponding instance of wfBrSrIpEncapsRing was learned, and is being used. ')
wfBrSrTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6), )
if mibBuilder.loadTexts: wfBrSrTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterTable.setDescription(' SR Bridge Traffic Filters ')
wfBrSrTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfBrSrTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfBrSrTrafficFilterFragment"))
if mibBuilder.loadTexts: wfBrSrTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterEntry.setDescription(' An entry in WfBrSrTrafficFilterTable. ')
wfBrSrTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfBrSrTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfBrSrTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfBrSrTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfBrSrTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfBrSrTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfBrSrTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 6), Integer32())
if mibBuilder.loadTexts: wfBrSrTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterReserved.setDescription(' Reserved field. ')
wfBrSrTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterCircuit.setDescription(' The ID of the Bridge Circuit to which the filter is applied. ')
wfBrSrTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfBrSrTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfBrSrEsRifTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7), )
if mibBuilder.loadTexts: wfBrSrEsRifTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifTable.setDescription(' A table that contains the currently active RIFs in use by Router End Station Support inst_id[9] = wfBrSrIpExplorerAddress ')
wfBrSrEsRifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfBrSrEsRifCircuit"), (0, "Wellfleet-Series7-MIB", "wfBrSrEsRifProtocol"), (0, "Wellfleet-Series7-MIB", "wfBrSrEsRifMacAddr"))
if mibBuilder.loadTexts: wfBrSrEsRifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifEntry.setDescription(' An entry in wfBrSrEsRif. ')
wfBrSrEsRifCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrEsRifCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifCircuit.setDescription(' The circuit on which this entry was learned ')
wfBrSrEsRifProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrEsRifProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifProtocol.setDescription(' protocol type. ')
wfBrSrEsRifMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrEsRifMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifMacAddr.setDescription(' to this RIF. ')
wfBrSrEsRifRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 1, 1, 2, 7, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfBrSrEsRifRoute.setStatus('mandatory')
if mibBuilder.loadTexts: wfBrSrEsRifRoute.setDescription(' The route contained in the RIF field ')
wfSyncTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 5), )
if mibBuilder.loadTexts: wfSyncTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTable.setDescription(' SYNC line record ')
wfSyncEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfSyncSlot"), (0, "Wellfleet-Series7-MIB", "wfSyncConnector"))
if mibBuilder.loadTexts: wfSyncEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncEntry.setDescription(' An entry in the SYNC table ')
wfSyncDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncDelete.setDescription(' Create/Delete parameter ')
wfSyncDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncDisable.setDescription(' Enable/Disable parameter ')
wfSyncState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("wait", 4), ("notpresent", 5))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncState.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncState.setDescription(' Line Driver state variable, Not Present, Init, Down, Up ')
wfSyncSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncSlot.setDescription(' Instance ID Slot, filled in by driver ')
wfSyncConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncConnector.setDescription(' Instance ID Connector, filled in by driver ')
wfSyncCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCct.setDescription(' CCT number for this line instance ')
wfSyncBofl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBofl.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBofl.setDescription(' breath of life parameter ')
wfSyncBoflTmo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 60, 5))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 60), ("default", 5))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBoflTmo.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBoflTmo.setDescription(' breath of life timeout in seconds ')
wfSyncMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4500, 1600))).clone(namedValues=NamedValues(("minimum", 3), ("maximum", 4500), ("default", 1600))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMtu.setDescription(' MTU parameter, this is buffer size for SYNC media, fixed ')
wfSyncMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMadr.setDescription(' Line MAC address, fixed - line driver fills in from the 48 bit address stored in the serial number prom for this connector. ')
wfSyncPromiscuous = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPromiscuous.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPromiscuous.setDescription(' The promiscuous parameter allows address filtering based on the local and remote addresses. When enabled, all frames are received, disabled indicates only frames destined for this local address are received ')
wfSyncXid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncXid.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncXid.setDescription(' XID enable/disable parameter. This parameter is used to enable or disable transmission/reception of Test XID frames. ')
wfSyncClkSource = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2))).clone('external')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncClkSource.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncClkSource.setDescription(' Tx/Rx clock source is either internally or external generated. ')
wfSyncClkSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1200, 2401, 4807, 7204, 9615, 19230, 32051, 38461, 56818, 64102, 125000, 227272, 416666, 625000, 833333, 1250000, 2500000, 5000000))).clone(namedValues=NamedValues(("clk1200b", 1200), ("clk2400b", 2401), ("clk4800b", 4807), ("clk7200b", 7204), ("clk9600b", 9615), ("clk19200b", 19230), ("clk32000b", 32051), ("clk38400b", 38461), ("clk56k", 56818), ("clk64k", 64102), ("clk125k", 125000), ("clk230k", 227272), ("clk420k", 416666), ("clk625k", 625000), ("clk833k", 833333), ("clk1mb", 1250000), ("clk2mb", 2500000), ("clk5mb", 5000000))).clone('clk64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncClkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncClkSpeed.setDescription(' Tx/Rx clock speed. This speed selection is valid only when the internal clock speed parameter has been selected. ')
wfSyncSignalMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("balanced", 1), ("unbalanced", 2))).clone('balanced')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncSignalMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncSignalMode.setDescription(' The signal mode parameter indicates the line paramter balanced or unbalanced. ')
wfSyncRtsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRtsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRtsEnable.setDescription(' The RTS parameter enables/disables detection of RTS signals on the interface. Normal default mode is running without RTS enabled. ')
wfSyncBurstCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncBurstCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBurstCount.setDescription(" Allows single or multiple DMA burst cycles. When enabled the chip performs 8 word burst's. Single word cycles are performed when disabled")
wfSyncService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("transparent", 1), ("llc1", 2), ("llc2", 3))).clone('llc1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncService.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncService.setDescription(' Service type for this circuit. Transparent is raw HDLC mode, LLC1 will prefix the HDLC address and control fields to the frame. The LLC2 service provides the LAPB protocol service. ')
wfSyncRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 64, 16))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 64), ("default", 16))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRetryCount.setDescription(' The Retry count parameter indicates the number of retransmission attempts which will be tried per frame before a line is determined to be down. The retry count is max attempts following expiration of the T1 timer. This parameter is equal to the N2 counter in ICB. ')
wfSyncLinkIdleTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9999, 3))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 9999), ("default", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLinkIdleTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLinkIdleTimer.setDescription(' The link idle parameter is the number of seconds before a line has been determined to be idle. An idle line is considered disconnectd This value is expressed in seconds. ')
wfSyncRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9999, 3))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 9999), ("default", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRetryTimer.setDescription(' The Retry Timer parameter indicates the timeout in seconds for a response to be heard form the link. Link control frames are sent at the expiration of this timer value. The frames will be resent up to retry count (N2) at which time the link will be disconnected. ')
wfSyncExtendedAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedAddress.setDescription(' This parameter controls length determination of the address field. When this parameter is enabled, the first bit of the address field be tested to determine the length of address field in octets. ')
wfSyncExtendedAddressForce = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedAddressForce.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedAddressForce.setDescription(' When this parameter is enabled, the receiver will assume that all address fields are 2 octets in length regardless of the first two bits of the control field. Usefull only in Transparent Mode. ')
wfSyncExtendedControl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedControl.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedControl.setDescription(' This parameter allows the control fields of all S and I frames to become 2 octets in length instead of one. Numbering of all I frame become modulo 128 instead of modulo 8. The control field of U frames remains one octet in length. ')
wfSyncExtendedControlForce = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncExtendedControlForce.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncExtendedControlForce.setDescription(' This parameter when enabled will force all control fields to become two octets in length regardless the first two bits in the control field. Usefull only in Transparent Mode. (LLC1) ')
wfSyncConnectAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 9999, 10))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 9999), ("default", 10))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncConnectAttempts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncConnectAttempts.setDescription(' This parameter controls the number of connection attempts which will be made during a LAPB connection request. This parameter is applicable only during LLC2 service. ')
wfSyncWindowSizeTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 7), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWindowSizeTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWindowSizeTx.setDescription(' The window size parameter controls the number of I frames which may be transmitted without acknowledgement. Non EXTC mode. ')
wfSyncWindowSizeTxExtc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 7, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 7), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWindowSizeTxExtc.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWindowSizeTxExtc.setDescription(' The window size parameter controls the number of I frames which may be transmitted without acknowledgement in EXTC mode. ')
wfSyncMinFrameSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 32, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 32), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMinFrameSpace.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMinFrameSpace.setDescription(' The minimum frame spacing parameter defines the number of flags that are transmitted between adjacent frames. ')
wfSyncLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 7))).clone(namedValues=NamedValues(("addressdte", 1), ("addressdce", 3), ("addressexplicit", 7))).clone('addressexplicit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncLocalAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLocalAddress.setDescription(' The local address parameter contains the DTE,DCE or EXPLICIT value expressed as a single octet. It may be extended to 2 octets if EXTA has been set. ')
wfSyncRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 7))).clone(namedValues=NamedValues(("addressdte", 1), ("addressdce", 3), ("addressexplicit", 7))).clone('addressexplicit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRemoteAddress.setDescription(' The remote address parameter contains the DTE,DCE or EXPLICIT value expressed as a single octet. It may be extended to 2 octets if EXTA has been set. ')
wfSyncPassThruLocalMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 32), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPassThruLocalMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPassThruLocalMadr.setDescription(' 48 bit MAC address of Local end of Sync Passthru circuit ')
wfSyncPassThruRemoteMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 33), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncPassThruRemoteMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncPassThruRemoteMadr.setDescription(' 48 bit MAC address of Remote end of Sync Passthru circuit ')
wfSyncWanProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("standard", 1), ("passthru", 2), ("ppp", 3), ("smds", 4), ("framerelay", 5))).clone('standard')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncWanProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncWanProtocol.setDescription(' WAN protocol selection is provided via this parameter. The supported protocols can be selected per interface. ')
wfSyncCrcSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("crc16bit", 1), ("crc32bit", 2))).clone('crc16bit')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncCrcSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncCrcSize.setDescription(' CRC size parameter, 16 bit standard CCITT or extended 32 bit CRC ')
wfSyncRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxOctets.setDescription(' Number of octets received without error ')
wfSyncRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxFrames.setDescription(' Number of frames received without error ')
wfSyncTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxOctets.setDescription(' Number of octets transmitted without error ')
wfSyncTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxFrames.setDescription(' Number of frames transmitted without error ')
wfSyncRxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRxErrors.setDescription(' Number of receive errors ')
wfSyncTxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncTxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncTxErrors.setDescription(' Number of transmission errors ')
wfSyncLackRescRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLackRescRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLackRescRx.setDescription(' Number of Rx frames dropped due to lack of buffer resources ')
wfSyncLackRescTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncLackRescTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncLackRescTx.setDescription(' Number of Tx frames dropped due to lack of buffer resources ')
wfSyncUnderFlowTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncUnderFlowTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncUnderFlowTx.setDescription(' Number of transmission underflows, device FIFO went empty before next DMA request was granted. ')
wfSyncRejectsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRejectsTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRejectsTx.setDescription(' Number of reject frames which were transmitted ')
wfSyncRejectsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRejectsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRejectsRx.setDescription(' Number of reject frames which were received ')
wfSyncOverFlowRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncOverFlowRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncOverFlowRx.setDescription(' Number of receive overflows, device FIFO overflowed before next DMA cycle granted. No buffer resources available. ')
wfSyncFramesIncompRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncFramesIncompRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncFramesIncompRx.setDescription(' Number of frames which were incompletely received. These are frames which may have resulted from FRMRR errors. ')
wfSyncBadFramesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncBadFramesRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncBadFramesRx.setDescription(' Number of bad receive frames, caused by FCS errors or non octet aligned. ')
wfSyncFrameRejectsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncFrameRejectsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncFrameRejectsRx.setDescription(' Number of Frame Rejects received ')
wfSyncRuntsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncRuntsRx.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncRuntsRx.setDescription(' Number of runt frames received ')
wfSyncT1Timeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncT1Timeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncT1Timeouts.setDescription(" Number of T1 timeout's detected. The T1 timer is the link retransmission timer. Link control frames will be retransmitted when T1 expires. This is a count of the number of timeouts. ")
wfSyncMemoryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSyncMemoryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMemoryErrors.setDescription(' Number of memory access errors detected. A MERR is the expiration of a DMA cycle without the bus being granted within 26us. ')
wfSyncMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 5, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("t1", 2), ("e1", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSyncMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: wfSyncMediaType.setDescription(' Media type selection is provided via this parameter ')
wfSys = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3, 1))
wfSysDescr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysDescr.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysDescr.setDescription(" A textual description of the entity including full name and version of the system's hardware type, OS, and networking SW ")
wfSysObjectID = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysObjectID.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysObjectID.setDescription(' Provides an unambiguous means for determining the MIB type (old product vs. harpoon MIB). ')
wfSysUpTime = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysUpTime.setDescription(' Time in seconds/100 since the last cold start ')
wfSysContact = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSysContact.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysContact.setDescription(' Contact person for this node and where/how to contact them ')
wfSysName = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSysName.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysName.setDescription(" Node's fully qualified domain name or administratively assigned name ")
wfSysLocation = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfSysLocation.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysLocation.setDescription(' Physical Location of this Node ')
wfSysServices = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 7), Integer32().clone(78)).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysServices.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysServices.setDescription(' A sum of numbers indicating the set of services the entity offers. For each layer L, add 2**(L - 1). Example: 78 = Layers 2,3,4, and 7. ')
wfSysGmtOffset = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysGmtOffset.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysGmtOffset.setDescription(' The positive or negative offset from Greenwich Mean Time (GMT). This effectively describes the time zone. ')
wfSysMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 1, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfSysMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: wfSysMibVersion.setDescription(' The version of the private management information base currently being used by the system software. Format is: xV.RR ')
wfT1Table = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 10), )
if mibBuilder.loadTexts: wfT1Table.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Table.setDescription(' T1 line record ')
wfT1Entry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfT1Slot"), (0, "Wellfleet-Series7-MIB", "wfT1Connector"))
if mibBuilder.loadTexts: wfT1Entry.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Entry.setDescription(' An entry in the T1 table ')
wfT1Delete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1Delete.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Delete.setDescription(' create/delete parameter, dflt = created ')
wfT1Disable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1Disable.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Disable.setDescription(' enable/disable parameter, dflt = enabled ')
wfT1State = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1State.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1State.setDescription(' line driver state variable, Not Present, Init, Up ')
wfT1Slot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1Slot.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Slot.setDescription(' instance ID Slot, filled in by driver ')
wfT1Connector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1Connector.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Connector.setDescription(' instance ID Connector, filled in by driver ')
wfT1Madr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1Madr.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1Madr.setDescription(' Line mac address, filled in by driver ')
wfT1FrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("d4", 1), ("esf", 2))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1FrameType.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1FrameType.setDescription(' Frame Type - differentiates between two tarrifed framing formats D4 and ESF. ')
wfT1LineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 655, 1))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 655), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1LineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1LineBuildout.setDescription(' Line Buildout - Approximate length of cable ')
wfT1B8ZSSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1B8ZSSupport.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1B8ZSSupport.setDescription(' B8ZS Support - Enables or disables Binary 8 zeros suppression ')
wfT1ClockMode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 1))).clone(namedValues=NamedValues(("internal", 1), ("slave", 2), ("manual", 4), ("default", 1))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1ClockMode.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1ClockMode.setDescription(' Clock Mode - Specifies the source of the T1 transmit clock ')
wfT1MiniDacs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfT1MiniDacs.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1MiniDacs.setDescription(' MiniDacs Configuration - assigns each T1 channel to a specific function ')
wfT1BipolarVios = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1BipolarVios.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1BipolarVios.setDescription(' Number of Bipolar Violations ')
wfT1FrameBitErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1FrameBitErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1FrameBitErrs.setDescription(' Number of frame bit errors ')
wfT1OutOfFrameErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1OutOfFrameErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1OutOfFrameErrs.setDescription(' Number of Out of Frame errors ')
wfT1SuperFrameErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1SuperFrameErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1SuperFrameErrs.setDescription(' Number of Superframe errors ')
wfT1RcvYelAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1RcvYelAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1RcvYelAlarms.setDescription(' Number of Yellow Alarms Received ')
wfT1RcvCarrierLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1RcvCarrierLoss.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1RcvCarrierLoss.setDescription(' Number of instances of carrier loss ')
wfT1RcvRedAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 10, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfT1RcvRedAlarms.setStatus('mandatory')
if mibBuilder.loadTexts: wfT1RcvRedAlarms.setDescription(' Number of Red Alarm Received ')
wfTftp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6))
wfTftpDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTftpDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpDisable.setDescription(' Enables or Disables TFTP Subsystem ')
wfTftpDefaultVolume = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 2, 14))).clone(namedValues=NamedValues(("minimum", 2), ("default", 2), ("maximum", 14))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTftpDefaultVolume.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpDefaultVolume.setDescription(' The file system volume number to which transferred files will be written and from which they will be retrieved. The volume number corresponds to the slot number on which the volume resides. Slot 1 is reserved for SRM. ')
wfTftpXfers = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpXfers.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpXfers.setDescription(' Number of Transfers in Progress ')
wfTftpTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 4), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTftpTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpTimeOut.setDescription(' General Retransmission time-out value (seconds) ')
wfTftpCloseTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 5), Integer32().clone(25)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTftpCloseTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpCloseTimeOut.setDescription(' Retransmission time-out value for sender of final ACK (seconds)')
wfTftpRexmit = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 6), Integer32().clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTftpRexmit.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpRexmit.setDescription(' Maximum Number of Retransmissions ')
wfTftpInFiles = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpInFiles.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpInFiles.setDescription(' Number of files Successfully received ')
wfTftpOutFiles = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpOutFiles.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpOutFiles.setDescription(' Number of files Successfully sent ')
wfTftpInWRQ = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpInWRQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpInWRQ.setDescription(' Number of write requests received ')
wfTftpOutWRQ = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpOutWRQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpOutWRQ.setDescription(' Number of write requests sent ')
wfTftpInRRQ = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpInRRQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpInRRQ.setDescription(' Number of read requests received ')
wfTftpOutRRQ = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpOutRRQ.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpOutRRQ.setDescription(' Number of read requests sent ')
wfTftpRexmitPkts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpRexmitPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpRexmitPkts.setDescription(' Number of Re-transmitted packets ')
wfTftpInErr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpInErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpInErr.setDescription(' Number of Error PDUs Received ')
wfTftpOutErr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpOutErr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpOutErr.setDescription(' Number of Error PDUs Sent ')
wfTftpAborts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 3, 6, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTftpAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTftpAborts.setDescription(' Number of Aborted Pseudo Connections ')
wfTiRui = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2))
wfTiRuiState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("idle", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTiRuiState.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiState.setDescription(' The state of the ti rui command processor. Idle is normal state. Busy indicates a command is being processed. ')
wfTiRuiAction = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTiRuiAction.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiAction.setDescription(' Ti command request string ')
wfTiRuiResult = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTiRuiResult.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiResult.setDescription(' The result of the Ti command requst ')
wfTiRuiInReqs = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTiRuiInReqs.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiInReqs.setDescription(' Total number of command requests ')
wfTiRuiOutResults = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTiRuiOutResults.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiOutResults.setDescription(' Total number of command requests that processed without error ')
wfTiRuiOutResultsErr = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 3, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTiRuiOutResultsErr.setStatus('optional')
if mibBuilder.loadTexts: wfTiRuiOutResultsErr.setDescription(' Total number of command requests that could not be processed because of errors ')
wfTokenRingTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 4, 2), )
if mibBuilder.loadTexts: wfTokenRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTable.setDescription(' TOKEN RING line record ')
wfTokenRingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfTokenRingSlot"), (0, "Wellfleet-Series7-MIB", "wfTokenRingConnector"))
if mibBuilder.loadTexts: wfTokenRingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingEntry.setDescription(' An entry in the token table ')
wfTokenRingDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDelete.setDescription(' create/delete parameter. ')
wfTokenRingDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDisable.setDescription(' enable/disable parameter. ')
wfTokenRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingState.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingState.setDescription(' line driver state variable, Not Present, Init, Down, Up ')
wfTokenRingSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 14))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSlot.setDescription(' instance ID Slot, filled in by driver ')
wfTokenRingConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("one", 1), ("two", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingConnector.setDescription(' instance ID Connector, filled in by driver ')
wfTokenRingCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 1023))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 1023)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCct.setDescription(' cct number for this line instance, configuration required ')
wfTokenRingMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4568))).clone(namedValues=NamedValues(("default", 4568))).clone('default')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMtu.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMtu.setDescription(' mtu parameter, fixed. This mtu of 4568 allows a type 3 Source Route Frame (info=4472) to be IP encapsulated over Token Ring. The components are: AC_FC (2) + SNAP (12+8) + SNAP_IP (12+8+20) + SR (12+18) + TYPE3_INFO (4472) + FCS (4) --------------------- total 4568 bytes ')
wfTokenRingMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMadr.setDescription(' line MAC address, line driver fills in the currently used 48 bit MAC address. ')
wfTokenRingCfgMadr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingCfgMadr.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCfgMadr.setDescription(' Configured line MAC address. Only used if wfTokenRingMadrSelect is set appropriately. ')
wfTokenRingMadrSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("boxwide", 1), ("prom", 2), ("cnfg", 3))).clone('boxwide')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingMadrSelect.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingMadrSelect.setDescription(' Selector determines which MAC address the interface will use. ')
wfTokenRingSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4194304, 16777216))).clone(namedValues=NamedValues(("mbps4", 4194304), ("mbps16", 16777216))).clone('mbps16')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSpeed.setDescription(' Token Ring speed parameter - 4 and 16 Mbps are only valid values ')
wfTokenRingEarlyTokenRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfTokenRingEarlyTokenRelease.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingEarlyTokenRelease.setDescription(' Early Token Release parameter, only valid with 16Mbps ')
wfTokenRingStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingStatus.setDescription(" The current interface status. This attribute is only valid when the wfTokenRingOpenState attribute is set to OPENED. The attribute's value is a sum of values, one for each currently applicable condition (ie, bit positions indicate active conditions). Occurrences of each condition are separately counted and the counts are included in this MIB as attributes wfTokenRingSignalLosses through wfTokenRingRingRecoveries. The following values are defined: 32768 = Signal Losses 16384 = Hard Errors 8192 = Soft Errors 4096 = Transmit Beacons 2048 = Lobe Wire Faults 1024 = Auto-Removal Errors 256 = Remove Received 128 = Counter Overflows 64 = Single Stations 32 = Ring Recoveries This attribute is the most recent sum of these conditions. More information on each condition is include in the descriptions of the individual counter attributes. ")
wfTokenRingOpenState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("opened", 1), ("opening", 2), ("closing", 3), ("openfailure", 4), ("ringfailure", 5), ("closed", 6))).clone('closed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOpenState.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOpenState.setDescription(' The current interface state with respect to entering or leaving the ring. ')
wfTokenRingOpenStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("open", 1), ("badparam", 2), ("lobefailed", 3), ("signalloss", 4), ("insertiontimeout", 5), ("ringfailed", 6), ("beaconing", 7), ("duplicatemac", 8), ("requestfailed", 9), ("removereceived", 10), ("unkerror", 11), ("noopen", 12))).clone('noopen')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOpenStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOpenStatus.setDescription(" Indicates the success, or the reason for failure, of the station's most recent attempt to enter the ring. ")
wfTokenRingUpStream = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 16), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingUpStream.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingUpStream.setDescription(" MAC address of Up Stream neighbor. Only valid when 'opened'. ")
wfTokenRingRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxOctets.setDescription(' Number of octets received without error. ')
wfTokenRingRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxFrames.setDescription(' Number of frames received without error. ')
wfTokenRingTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxOctets.setDescription(' Number of octets transmitted without error. ')
wfTokenRingTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxFrames.setDescription(' Number of frames transmitted without error. ')
wfTokenRingInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingInDiscards.setDescription(' Number of error-free inbound packets discarded. Usually due to lack of memory resources. This is equivalent to wfTokenRingRxCongestionErrors. ')
wfTokenRingInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingInErrors.setDescription(' Number of inbound packets not delivered to higher-layer protocol due to errors. The sum of wfTokenRingLineErrors and wfTokenRingBurstErrors. ')
wfTokenRingOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOutDiscards.setDescription(' Number of error-free outbound packets discarded. Usually due to lack of transmission bandwidth. This is equivalent to wfTokenRingTxClipFrames. ')
wfTokenRingOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingOutErrors.setDescription(' Number of outbound packets that could not be transmitted because of errors. This is equivalent to wfTokenRingLostFrameErrors. ')
wfTokenRingTxClipFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxClipFrames.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxClipFrames.setDescription(" Number of frames clipped in driver's transmit routine due to transmit congestion. ")
wfTokenRingRxReplenMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxReplenMisses.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxReplenMisses.setDescription(' Number of packet buffer misses while attempting to replenish driver receive ring. ')
wfTokenRingSignalLosses = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSignalLosses.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSignalLosses.setDescription(' Number of ring signal losses detected. ')
wfTokenRingHardErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingHardErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingHardErrors.setDescription(' Number of events causing the adapter to transmit or receive beacon MAC frames. ')
wfTokenRingSoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSoftErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSoftErrors.setDescription(' Number of soft errors. Corresponds to the number of Report Error MAC frames transmitted by this station. ')
wfTokenRingTransmitBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTransmitBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTransmitBeacons.setDescription(' Number of events causing the adapter to transmit beacon frames. ')
wfTokenRingLobeWireFaults = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLobeWireFaults.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLobeWireFaults.setDescription(' Number of opens or shorts (cable faults) between the adapter and the MAU. ')
wfTokenRingAutoRemovalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAutoRemovalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAutoRemovalErrors.setDescription(' Number of lobe wrap test failures during beacon auto_removal process. ')
wfTokenRingRequestRemoves = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRequestRemoves.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRequestRemoves.setDescription(' Number of Remove Ring Station MAC frames received. Each frame causes this station to leave the ring. ')
wfTokenRingCounterOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingCounterOverflows.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCounterOverflows.setDescription(' Number of adapter error counter overflows. ')
wfTokenRingSingleStations = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSingleStations.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSingleStations.setDescription(' Number of ring status change interrupts while adapter is only station on the ring. ')
wfTokenRingRingRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRingRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRingRecoveries.setDescription(' Number of claim token MAC frames (ring recoveries) observed on the ring. ')
wfTokenRingAdapterChecks = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAdapterChecks.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAdapterChecks.setDescription(' Number of internal adapter errors that result in adapter crashes. ')
wfTokenRingFirstAdapterCheckCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingFirstAdapterCheckCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingFirstAdapterCheckCode.setDescription(' Adapter Check Code of first occurrence. ')
wfTokenRingLastAdapterCheckCode = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLastAdapterCheckCode.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLastAdapterCheckCode.setDescription(' Adapter Check Code of most recent (last) occurrence. ')
wfTokenRingLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLineErrors.setDescription(' Number of frames copied or repeated by this station with bad format or an FCS error. ')
wfTokenRingBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingBurstErrors.setDescription(' Number of errored frames with no transition for 5 1/2 bit times. ')
wfTokenRingAriFciErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingAriFciErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingAriFciErrors.setDescription(' Number of occurrences of this station receiving both an AMP MAC frame and a SMP MAC frame with the a & c bits clear or more than one SMP MAC frame with the a & c bits clear without an intervening AMP MAC frame. This condition indicates that the up-stream neighbor is unable to set the a & c bits in a frame that it has copied. ')
wfTokenRingLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingLostFrameErrors.setDescription(' Number of frames being stripped which are missing their tails. ')
wfTokenRingRxCongestionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxCongestionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxCongestionErrors.setDescription(' Number of frames dropped due to receive congestion. ')
wfTokenRingFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingFrameCopiedErrors.setDescription(' Number of specifically addressed frames for this station that had their a & c bits previously set. ')
wfTokenRingTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTokenErrors.setDescription(' Number of token protocol errors. Only relevant when this station is the active monitor. ')
wfTokenRingDmaBusErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingDmaBusErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDmaBusErrors.setDescription(' Number of bus errors during DMA that do not exceed threshold. ')
wfTokenRingDmaParityErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingDmaParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingDmaParityErrors.setDescription(' Number of parity errors during DMA that do not exceed threshold. ')
wfTokenRingSrbNotFreeCmdAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingSrbNotFreeCmdAborts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingSrbNotFreeCmdAborts.setDescription(' Number of host to adapter commands aborted because of in-completed in process commands. ')
wfTokenRingRxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxProcessings.setDescription(' Number of processings of received frames (similar to RINT). ')
wfTokenRingTxProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxProcessings.setDescription(' Number of processings of frames for transmit. ')
wfTokenRingTxCmplProcessings = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingTxCmplProcessings.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingTxCmplProcessings.setDescription(' Number of processings of transmitted frames (similar to TINT). ')
wfTokenRingRxTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxTimeouts.setDescription(' Number of re-initializations due to receiver time-outs. ')
wfTokenRingCmdTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingCmdTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingCmdTimeouts.setDescription(' Number of re-initializations due to command time-outs. ')
wfTokenRingRxHostIntErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxHostIntErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxHostIntErrors.setDescription(' Number of re-initializations due to receive host interface errors. ')
wfTokenRingRxTxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 4, 2, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfTokenRingRxTxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfTokenRingRxTxBufferSize.setDescription(' Internal Adapter RAM buffer size. ')
wfVinesBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1))
wfVinesBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseDelete.setDescription(' Create/Delete parameter. This value determines whether or not VINES is configured on this slot. ')
wfVinesBaseDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesBaseDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseDisable.setDescription(' This parameter determines whether or not VINES is to startup. ')
wfVinesBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseState.setDescription(' This parameter reflects the current state of VINES. ')
wfVinesBaseUserNetid = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2097151))).clone(namedValues=NamedValues(("minimum", 1), ("maximum", 2097151)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesBaseUserNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseUserNetid.setDescription(' The network ID as defined by the user. A null value indicates that the user is not configuring a Network ID and that the the router should assign it. ')
wfVinesBaseRouterNetid = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesBaseRouterNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseRouterNetid.setDescription(' The network ID as defined by the router. If the user configures a Network ID in the above attribute, we will take that value and add in the Wellfleet code for VINES and save it here. ')
wfVinesBaseBcastClass = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("bcast", 1), ("chrg", 2), ("cost", 3), ("lans", 4), ("srvr", 5), ("nochrg", 6), ("locost", 7), ("alllans", 8))).clone('bcast')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesBaseBcastClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesBaseBcastClass.setDescription(' The broadcast modifier. This value defines the class of broadcast packets that are originated by this node. ')
wfVinesIp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2))
wfVinesIpTotIn = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpTotIn.setDescription(' The total number of VINES IP packets received. ')
wfVinesIpTotOut = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpTotOut.setDescription(' The total number of VINES IP packets sent. ')
wfVinesIpBad = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpBad.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpBad.setDescription(' The total number of badly formed packets that were received. This field is incremented when a packet is received with an improper checksum. ')
wfVinesIpRouted = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpRouted.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpRouted.setDescription(' The total number of packets received that were routed to another node. This statistic includes the number of IP packets encapsulated within routed VINES IP headers. Each routed packet counts as both an incoming and outgoing packet. ')
wfVinesIpRoutedHWM = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpRoutedHWM.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpRoutedHWM.setDescription(' The largest number of packets routed in one second since the server was last booted. ')
wfVinesIpBcast = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpBcast.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpBcast.setDescription(' The number of VINES IP broadcast packets sent, both locally generated and routed from other nodes. ')
wfVinesIpBcastHWM = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpBcastHWM.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpBcastHWM.setDescription(' The largest number of packets broadcast in one second since the server was last booted. ')
wfVinesIpReass = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpReass.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpReass.setDescription(' The number of times that packets were reassembled. Reassemblies result from the transmission of packets that must be broken into smaller pieces, then reassembled due to differences in transmission media. ')
wfVinesIpFrags = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpFrags.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpFrags.setDescription(' The number of packet fragmentations performed. ')
wfVinesIpToDodIP = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpToDodIP.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpToDodIP.setDescription(' The number of packets that VINES IP passed to IP for encapsulation in IP headers. These packets were initially handled by VINES IP, but were passed to IP for routing. If the TCP/IP Server-to-Server option is not installed, this value will be zero. ')
wfVinesIpFromDodIP = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIpFromDodIP.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIpFromDodIP.setDescription(' The number of packets that VINES IP received from IP to be decapsulated into VINES packets. IP initially handled these packets, but had to pass them on to VINES IP for routing. If the server is not running a TCP/IP option, this value will be zero. ')
wfVinesRtpNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 3))
wfVinesRtpNbrNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrNumber.setDescription(' Number of entries in the Table of Neighbors. ')
wfVinesRtpNbrTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4), )
if mibBuilder.loadTexts: wfVinesRtpNbrTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrTable.setDescription(' This is the Table of Neighbors. ')
wfVinesRtpNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesRtpNbrNetId"))
if mibBuilder.loadTexts: wfVinesRtpNbrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrEntry.setDescription(' An entry in the Table of Neighbors. ')
wfVinesRtpNbrNetId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrNetId.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrNetId.setDescription(' The network ID of this neighbor. ')
wfVinesRtpNbrSubNetId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrSubNetId.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrSubNetId.setDescription(' The subnetwork ID of this neighbor. ')
wfVinesRtpNbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("workst", 1), ("server", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrType.setDescription(' The type of node: client or server. ')
wfVinesRtpNbrIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))).clone(namedValues=NamedValues(("enet", 1), ("tr4k", 2), ("tr16k", 3), ("hdlc1200", 4), ("hdlc4800", 5), ("hdlc9600", 6), ("hdlc56000", 7), ("async1200", 8), ("async4800", 9), ("async9600", 10), ("async56000", 11), ("x251200", 12), ("x254800", 13), ("x259600", 14), ("x2556000", 15), ("t145k", 16), ("t1128k", 17), ("t1192k", 18), ("t1256k", 19), ("t1320k", 20), ("t1384k", 21), ("t1448k", 22), ("t1512k", 23), ("t1576k", 24), ("t1640k", 25), ("t1704k", 26), ("t1896k", 27), ("t11088k", 28), ("t11344k", 29), ("tunnel", 30), ("fddi", 31)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrIfType.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrIfType.setDescription(' This describes the type of interface. ')
wfVinesRtpNbrRemAdr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrRemAdr.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrRemAdr.setDescription(' Remote MAC address. ')
wfVinesRtpNbrLocAdr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrLocAdr.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrLocAdr.setDescription(' Local MAC address. ')
wfVinesRtpNbrLocSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrLocSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrLocSlot.setDescription(' Slot connected to this neighbor. ')
wfVinesRtpNbrLocLine = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrLocLine.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrLocLine.setDescription(' Line connected to this neighbor. ')
wfVinesRtpNbrSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrSvrName.setDescription(' Name of the server (N/A). ')
wfVinesRtpNbrCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 4, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpNbrCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpNbrCost.setDescription(' Cost for this neighbor. ')
wfVinesRtpRt = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 5))
wfVinesRtpRtNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtNumber.setDescription(' Number of entries in the Table of Networks. ')
wfVinesRtpRtTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6), )
if mibBuilder.loadTexts: wfVinesRtpRtTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtTable.setDescription(' This is the Table of Networks. ')
wfVinesRtpRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesRtpRtNetid"))
if mibBuilder.loadTexts: wfVinesRtpRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtEntry.setDescription(' An entry in the Table of Networks. ')
wfVinesRtpRtNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtNetid.setDescription(' The network ID number. ')
wfVinesRtpRtMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtMetric.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtMetric.setDescription(' The routing metric to get to this network. ')
wfVinesRtpRtIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtIdle.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtIdle.setDescription(' The idle time for this network. ')
wfVinesRtpRtGateNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtGateNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtGateNetid.setDescription(' The network ID of the gateway to this network. ')
wfVinesRtpRtSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtSvrName.setDescription(' The servers name (N/A). ')
wfVinesRtpRtGateSvrName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 6, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesRtpRtGateSvrName.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesRtpRtGateSvrName.setDescription(' The name of the gateway server. ')
wfVinesIf = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 7))
wfVinesIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfNumber.setDescription(' This is the number of entries in the Interfaces Table. ')
wfVinesIfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8), )
if mibBuilder.loadTexts: wfVinesIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfTable.setDescription(' This is the Table of Interfaces. ')
wfVinesIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesIfCct"))
if mibBuilder.loadTexts: wfVinesIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfEntry.setDescription(' An entry to the Interface Table. ')
wfVinesIfDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfDelete.setDescription(' Create/Delete parameter. Users perform an SNMP set command to create/delete a VINES interface. ')
wfVinesIfDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfDisable.setDescription(' Enable/Disable parameter. Users perform an SNMP set command to enable/disable a VINES interface. ')
wfVinesIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfState.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfState.setDescription(' This parameter reflects the current state of the VINES interface. ')
wfVinesIfSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfSlot.setDescription(' The slot on which this interface is configured. ')
wfVinesIfLine = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfLine.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfLine.setDescription(' The line on which this interface is configured. ')
wfVinesIfCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfCct.setDescription(' The circuit number for this interface. ')
wfVinesIfSession = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfSession.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfSession.setDescription(' The session number for this interface. ')
wfVinesIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31))).clone(namedValues=NamedValues(("enet", 1), ("tr4k", 2), ("tr16k", 3), ("hdlc1200", 4), ("hdlc4800", 5), ("hdlc9600", 6), ("hdlc56000", 7), ("async1200", 8), ("async4800", 9), ("async9600", 10), ("async56000", 11), ("x251200", 12), ("x254800", 13), ("x259600", 14), ("x2556000", 15), ("t145k", 16), ("t1128k", 17), ("t1192k", 18), ("t1256k", 19), ("t1320k", 20), ("t1384k", 21), ("t1448k", 22), ("t1512k", 23), ("t1576k", 24), ("t1640k", 25), ("t1704k", 26), ("t1896k", 27), ("t11088k", 28), ("t11344k", 29), ("tunnel", 30), ("fddi", 31))).clone('enet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfType.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfType.setDescription(' The type of interface this is. ')
wfVinesIfDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfDescr.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfDescr.setDescription(' Description of this interface. ')
wfVinesIfAdr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfAdr.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfAdr.setDescription(' The MAC address of this interface. ')
wfVinesIfDodIpDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfDodIpDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfDodIpDisable.setDescription(' This parameter indicates if this interface is enabled to encapsulate VINES packets over DoD IP. ')
wfVinesIfArpDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfArpDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpDisable.setDescription(' This parameter indicates if this interface is enabled to support VINES ARP. ')
wfVinesIfTrEndStation = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfTrEndStation.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfTrEndStation.setDescription(' This parameter indicates if this interface is enabled for source routing end station support. ')
wfVinesIfInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfInPkts.setDescription(' The number of packets received on this interface. ')
wfVinesIfInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfInErrs.setDescription(' The number of packets received with errors. ')
wfVinesIfOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfOutPkts.setDescription(' The number of packets transmitted on this interface.')
wfVinesIfOutErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfOutErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfOutErrs.setDescription(' The number of errors on packets transmitted. ')
wfVinesIfInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfInMsgs.setDescription(' The number of messages received on this interface. ')
wfVinesIfMux = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enet", 1), ("snap", 2))).clone('enet')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfMux.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfMux.setDescription(' Muxing scheme for this interface. VINES currently only supports Ethernet encapsulation, but they plan to switch to SNAP. ')
wfVinesIfFwdDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfFwdDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfFwdDrops.setDescription(' The number of pakets that were dropped because of no forwarding information for the destination. ')
wfVinesIfZeroHopDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfZeroHopDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfZeroHopDrops.setDescription(' The number of pakets that were dropped because of a zero hop count. ')
wfVinesIfIcpInErrorNotifs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfIcpInErrorNotifs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfIcpInErrorNotifs.setDescription(' The number of ICP error notification packets received. ')
wfVinesIfIcpInMetricNotifs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfIcpInMetricNotifs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfIcpInMetricNotifs.setDescription(' The number of ICP metric notification packets received. ')
wfVinesIfIcpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfIcpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfIcpInErrors.setDescription(' The number of ICP packets received with errors. ')
wfVinesIfIcpOutErrorNotifs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfIcpOutErrorNotifs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfIcpOutErrorNotifs.setDescription(' The number of ICP error notification packets transmitted. ')
wfVinesIfIcpOutMetricNotifs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfIcpOutMetricNotifs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfIcpOutMetricNotifs.setDescription(' The number of ICP metric notification packets transmitted. ')
wfVinesIfArpInQueries = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfArpInQueries.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpInQueries.setDescription(' The number of ARP queries received. ')
wfVinesIfArpInAssgReqs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfArpInAssgReqs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpInAssgReqs.setDescription(' The number of ARP assignment requests received. ')
wfVinesIfArpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfArpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpInErrors.setDescription(' The number of ARP packets received with errors. ')
wfVinesIfArpOutServRsps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfArpOutServRsps.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpOutServRsps.setDescription(' The number of ARP service responses sent. ')
wfVinesIfArpOutAssgRsps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfArpOutAssgRsps.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfArpOutAssgRsps.setDescription(' The number of ARP assignment responses sent. ')
wfVinesIfInRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfInRedirects.setDescription(' The number of Redirect packets received. ')
wfVinesIfOutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfOutRedirects.setDescription(' The number of Redirect packets sent. ')
wfVinesIfEchoInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfEchoInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfEchoInPkts.setDescription(' The number of Echo packets received. ')
wfVinesIfEchoOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfEchoOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfEchoOutPkts.setDescription(' The number of Echo packets sent. ')
wfVinesIfReassFails = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfReassFails.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfReassFails.setDescription(' The number of packet reassemblies that failed. ')
wfVinesIfRemClientPrivDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 8, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesIfRemClientPrivDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfRemClientPrivDisable.setDescription(' This parameter indicates that this interface will allow remote clients privileges on this segment. This means that a client is not restricted to being within one hop of a VINES server. ')
wfVinesIfX25VC = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 9))
wfVinesIfX25VCNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCNumber.setDescription(' This is the number of entries in the X.25 Virtual Circuit Table. ')
wfVinesIfX25VCTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10), )
if mibBuilder.loadTexts: wfVinesIfX25VCTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCTable.setDescription(' This is the Table of X.25 Virtual Circuits. ')
wfVinesIfX25VCEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesIfX25VCCct"))
if mibBuilder.loadTexts: wfVinesIfX25VCEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCEntry.setDescription(' An entry in the Table of X.25 Virtual Circuits. ')
wfVinesIfX25VCSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCSlot.setDescription(' The number of the slot in which the card is installed. ')
wfVinesIfX25VCLine = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCLine.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCLine.setDescription(' For a serial line, this is the number of the line on the card. ')
wfVinesIfX25VCCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCCct.setDescription(' Local circuit number for this Virtual Circuit. ')
wfVinesIfX25VCSession = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCSession.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCSession.setDescription(' Local session number for this Virtual Circuit. ')
wfVinesIfX25VCTotIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCTotIn.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCTotIn.setDescription(' The total number of VINES IP packets received on this VC. Depending on the size of the X.25 packets received, more than one X.25 packet can make up a VINES IP packet. ')
wfVinesIfX25VCTotOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCTotOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCTotOut.setDescription(' The total number of VINES IP packets sent on this VC. Depending on the size of the X.25 packets sent, more than one X.25 packet can make up a VINES IP packet. ')
wfVinesIfX25VCInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCInErrs.setDescription(' The total number of input errors. ')
wfVinesIfX25VCOutErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCOutErrs.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCOutErrs.setDescription(' The total number of output errors. ')
wfVinesIfX25VCPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCPktsOut.setDescription(' The total number of X.25 packets transmitted on this VC. ')
wfVinesIfX25VCPktsAwaitAck = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCPktsAwaitAck.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCPktsAwaitAck.setDescription(' Total number of X.25 packets transmitted on this VC waiting for ACK. ')
wfVinesIfX25VCBytesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCBytesOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCBytesOut.setDescription(' Total Bytes transmitted on this VC. ')
wfVinesIfX25VCBytesAwaitAck = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCBytesAwaitAck.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCBytesAwaitAck.setDescription(' Total bytes transmitted on this VC that are waiting for ACK. ')
wfVinesIfX25VCPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCPktsIn.setDescription(' Total X.25 packets received on this VC. ')
wfVinesIfX25VCBytesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCBytesIn.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCBytesIn.setDescription(' Total Bytes received on this VC. ')
wfVinesIfX25VCResetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCResetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCResetsIn.setDescription(' Number of X.25 reset packets received on this VC. ')
wfVinesIfX25VCResetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 10, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesIfX25VCResetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesIfX25VCResetsOut.setDescription(' Number of X.25 reset packets transmitted on this VC. ')
wfVinesTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11), )
if mibBuilder.loadTexts: wfVinesTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterTable.setDescription(' VINES Traffic Filters ')
wfVinesTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfVinesTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfVinesTrafficFilterFragment"))
if mibBuilder.loadTexts: wfVinesTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterEntry.setDescription(' An entry in WfVinesTrafficFilterTable. ')
wfVinesTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfVinesTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfVinesTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfVinesTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfVinesTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfVinesTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 6), Integer32())
if mibBuilder.loadTexts: wfVinesTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterReserved.setDescription(' Reserved field. ')
wfVinesTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterCircuit.setDescription(' The ID of the Circuit to which the filter is applied. ')
wfVinesTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfVinesTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 11, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
wfVinesNameTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12), )
if mibBuilder.loadTexts: wfVinesNameTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameTable.setDescription(' This is the Name-to-Address Binding Table. ')
wfVinesNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfVinesNameNetid"))
if mibBuilder.loadTexts: wfVinesNameEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameEntry.setDescription(' An entry in the Table of Names. ')
wfVinesNameDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesNameDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameDelete.setDescription(' Create/Delete parameter. Users perform an SNMP set command to create/delete this name. ')
wfVinesNameDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesNameDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameDisable.setDescription(' Enable/Disable parameter. Users perform an SNMP set command to enable/disable a name. ')
wfVinesNameNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesNameNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameNetid.setDescription(' This is the network number for the host. ')
wfVinesNameHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesNameHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameHost.setDescription(' This is the name of the host. ')
wfVinesNameSubNetid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 12, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesNameSubNetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesNameSubNetid.setDescription(' This is the subnetwork number for the host. ')
wfVinesArp = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13))
wfVinesArpDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesArpDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete ARP.')
wfVinesArpDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesArpDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpDisable.setDescription(' Enable/Disable Parameter indicates whether this ARP record is enabled or disabled. ')
wfVinesArpState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('down')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesArpState.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpState.setDescription(' State of ARP. ')
wfVinesArpSubnetid = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesArpSubnetid.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpSubnetid.setDescription(' The next subnetwork ID to be assigned. ')
wfVinesArpSubnetBlock = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 32))).clone(namedValues=NamedValues(("minimum", 1), ("default", 2), ("maximum", 32))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfVinesArpSubnetBlock.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpSubnetBlock.setDescription(' The size of the block of subnet ids a slot can grab. ')
wfVinesArpAssignDeniedPkts = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 8, 13, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfVinesArpAssignDeniedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfVinesArpAssignDeniedPkts.setDescription(" Number of ARP Assignment packets received for which we didn't have a free subnet number. ")
wfXnsBase = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 1))
wfXnsBaseDelete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsBaseDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete XNS.')
wfXnsBaseDisable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsBaseDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable XNS.')
wfXnsBaseState = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseState.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseState.setDescription('The current state of the entire XNS.')
wfXnsBaseHostNumber = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsBaseHostNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseHostNumber.setDescription(' Host Number of Router and potential MAC address of box.')
wfXnsBaseRtEntryTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2), )
if mibBuilder.loadTexts: wfXnsBaseRtEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRtEntryTable.setDescription(" The table of Elements in XNS's routing table ")
wfXnsBaseRtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsBaseRouteDest"))
if mibBuilder.loadTexts: wfXnsBaseRtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRtEntry.setDescription(' An entry in the Routing Table ')
wfXnsBaseRouteDest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteDest.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteDest.setDescription(' The destination XNS address of this route. An entry with a value of 0.0.0.0 is considered a default route. Multiple routes to a single destination can appear in the table, but access to such multiple entries is dependent on the table- access mechanisms defined by the network management protocol in use.')
wfXnsBaseRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteIfIndex.setDescription('The index value which uniquely identifies the local interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
wfXnsBaseRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteMetric.setDescription("The primary routing metric for this route. The semantics of this metric are determined by the routing-protocol specified in the route's ipRouteProto value. If this metric is not used, its value should be set to -1.")
wfXnsBaseRouteNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteNextHopNetwork.setDescription("(In the case of a route bound to an interface which is realized via a broadcast media, the value of this field is the agent's XNS address on that interface.)")
wfXnsBaseRouteNextHopHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteNextHopHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteNextHopHost.setDescription(' Full network.host_id address of nexthop host for this network. ')
wfXnsBaseRouteType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("direct", 3), ("indirect", 4), ("static", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteType.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteType.setDescription('The type of route. Note that the values direct(3) and indirect(4) refer to the notion of direct and indirect routing in the XNS architecture. Setting this object to the value invalid(2) has the effect of invalidating the corresponding entry in the ipRouteTable object. That is, it effectively dissasociates the destination identified with said entry from the route identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. nagement stations must be prepared to receive tabular information from agents that corresponds to entries not currently in use. Proper interpretation of such entries requires examination of the relevant ipRouteType object.')
wfXnsBaseRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("rip", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteProto.setDescription('The routing mechanism via which this route was learned. Inclusion of values for gateway routing protocols is not intended to imply that hosts should support those protocols.')
wfXnsBaseRouteAge = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteAge.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteAge.setDescription("The number of seconds since this route was last updated or otherwise determined to be correct. Note that no semantics of `too old' can be implied except through knowledge of the routing protocol by which the route was learned.")
wfXnsBaseRouteInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsBaseRouteInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsBaseRouteInfo.setDescription(' A user-defined string which describes this Route entry ')
wfXnsInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3), )
if mibBuilder.loadTexts: wfXnsInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceTable.setDescription(' The network interface record ')
wfXnsInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsInterfaceNetworkNumber"), (0, "Wellfleet-Series7-MIB", "wfXnsInterfaceCircuit"))
if mibBuilder.loadTexts: wfXnsInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceEntry.setDescription(' An entry in the Routing Table ')
wfXnsInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceIndex.setDescription('A unique value for each XNS interface. Its value ranges between 1 and the value of MAXCIRCUITS.')
wfXnsInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an XNS interface.')
wfXnsInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable an XNS interface.')
wfXnsInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceState.setDescription('The current state of the XNS interface')
wfXnsInterfaceCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceCircuit.setDescription(' The Circuit Number that this interface runs over')
wfXnsInterfaceNetworkNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceNetworkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceNetworkNumber.setDescription(" The XNS Address to which this entry's addressing information pertains ")
wfXnsInterfaceCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceCost.setDescription(' The Cost associated with the XNS Address of this entry ')
wfXnsInterfaceXsumOn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceXsumOn.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceXsumOn.setDescription(' Flag for checksums ')
wfXnsInterfaceEncaps = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("snap", 2))).clone('ethernet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceEncaps.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceEncaps.setDescription(' If changed while router is running yowsa !!!! ')
wfXnsInterfaceMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 10), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceMacAddress.setDescription(' The MacAddress of this interface this port will receive or transmit. ')
wfXnsInterfaceSMDSGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceSMDSGroupAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceSMDSGroupAddress.setDescription(' The SMDS Group Address of this interface this port will receive or transmit. ')
wfXnsInterfaceMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceMaxInfo.setDescription(' The maximum size of the INFO (non-MAC) field that this port will receive or transmit. ')
wfXnsInterfaceExtServer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceExtServer.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceExtServer.setDescription(' Flag indicating if this interface has External server capabilities turned on. Allows interface to pass on defined packets, such as PEP/TP requests, to a remote server not located on local network. ')
wfXnsInterfaceExServNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 14), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceExServNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceExServNetwork.setDescription(' The Network address of the remote server. ')
wfXnsInterfaceExServHostId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 15), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceExServHostId.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceExServHostId.setDescription(' The Host ID of the remote server. ')
wfXnsInterfaceExServPktType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceExServPktType.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceExServPktType.setDescription(' The packet type of the requests which are to be passed on to the specified remote server. ')
wfXnsInterfaceExServSockNm = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceExServSockNm.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceExServSockNm.setDescription(' The destination socket number of the requests which are to be passed on to the specified remote server. If no socket number is specified then all packets of the specified type that this interface receives will be forwarded to specified remote server. ')
wfXnsInterfaceInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInReceives.setDescription('The total number of input datagrams received from interfaces, including those received in error.')
wfXnsInterfaceInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInHdrErrors.setDescription(' The number of input datagrams discarded due to errors in their XNS headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their XNS options, etc. ')
wfXnsInterfaceInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInAddrErrors.setDescription(" The number of input datagrams discarded because the XNS address in their XNS header's destination field was not a valid address to be received at this entity. This count includes invalid addresses (e.g., 0.0.0.0) and addresses of unsupported Classes (e.g., Class E). For entities which are not XNS Gateways and therefore do not forward datagrams, this counter includes datagrams discarded because the destination address was not a local address. ")
wfXnsInterfaceForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceForwDatagrams.setDescription(' The number of input datagrams for which this entity was not their final XNS destination, as a result of which an attempt was made to find a route to forward them to that final destination. In entities which do not act as XNS Gateways, this counter will include only those packets which were Source-Routed via this entity, and the Source- Route option processing was successful. ')
wfXnsInterfaceInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInUnknownProtos.setDescription(' The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol. ')
wfXnsInterfaceInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInDiscards.setDescription(' The number of input XNS datagrams for which no problems were encountered to prevent their continued processing, but which were discarded (e.g., for lack of buffer space). Note that this counter does not include any datagrams discarded while awaiting re-assembly. ')
wfXnsInterfaceInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceInDelivers.setDescription(' The total number of input datagrams successfully delivered to XNS user-protocols (including ICMP). ')
wfXnsInterfaceOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceOutRequests.setDescription(' The total number of XNS datagrams which local XNS user-protocols supplied to XNS in requests for transmission. Note that this counter does not include any datagrams counted in XnsInteraceFwdDatagrams. ')
wfXnsInterfaceOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceOutDiscards.setDescription(' The number of output XNS datagrams for which no problem was encountered to prevent their transmission to their destination, but which were discarded (e.g., for lack of buffer space). Note that this counter would include datagrams counted in XnsForwDatagrams if any such packets met this (discretionary) discard criterion. ')
wfXnsInterfaceOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsInterfaceOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceOutNoRoutes.setDescription(" The number of XNS datagrams discarded because no route could be found to transmit them to their destination. Note that this counter includes any packets counted in ipForwDatagrams which meet this `no-route' criterion. Note that this includes any datagarms which a host cannot route because all of its default gateways are down. ")
wfXnsInterfaceFRBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 28), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceFRBcast.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceFRBcast.setDescription(' Configurable Frame Relay broadcast address ')
wfXnsInterfaceFRMcast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 3, 1, 29), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsInterfaceFRMcast.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsInterfaceFRMcast.setDescription(' Configurable Frame Relay multicast address ')
wfXnsRipIntfTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4), )
if mibBuilder.loadTexts: wfXnsRipIntfTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipIntfTable.setDescription(' The list of RIP interfaces ')
wfXnsRipIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsRipInterfaceIndex"))
if mibBuilder.loadTexts: wfXnsRipIntfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipIntfEntry.setDescription(' An entry in the Routing Table ')
wfXnsRipInterfaceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsRipInterfaceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete an RIP Interface instance.')
wfXnsRipInterfaceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsRipInterfaceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable a RIP instance.')
wfXnsRipInterfaceState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsRipInterfaceState.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceState.setDescription('The current state of RIP on this interface.')
wfXnsRipInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsRipInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceIndex.setDescription('The XNS interface to run RIP on.')
wfXnsRipInterfaceSupply = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsRipInterfaceSupply.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceSupply.setDescription('Transmit RIP packets.')
wfXnsRipInterfaceListen = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsRipInterfaceListen.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsRipInterfaceListen.setDescription('Receive RIP packets.')
wfXnsAdjacentHostTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5), )
if mibBuilder.loadTexts: wfXnsAdjacentHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAdjacentHostTable.setDescription(' must be configured for a nexthop host. ')
wfXnsAdjacentHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsAhTargHostNetwork"), (0, "Wellfleet-Series7-MIB", "wfXnsAhTargHostId"))
if mibBuilder.loadTexts: wfXnsAdjacentHostEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAdjacentHostEntry.setDescription(' An entry in the Adjacent Host Table ')
wfXnsAhDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsAhDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the IPX Static Host.')
wfXnsAhDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsAhDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this IPX Static Route.')
wfXnsAhTargHostNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsAhTargHostNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhTargHostNetwork.setDescription('The network address of the static host. ')
wfXnsAhTargHostId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsAhTargHostId.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhTargHostId.setDescription(' The Address of this static host. ')
wfXnsAhNextHopIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsAhNextHopIntf.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhNextHopIntf.setDescription(' The Next Hop Interface Network Address ')
wfXnsAhDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 5, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsAhDlci.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsAhDlci.setDescription(' The next Hop Host address ')
wfXnsStaticRouteTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6), )
if mibBuilder.loadTexts: wfXnsStaticRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsStaticRouteTable.setDescription(' The list of Adjacent Hosts used for Configuring XNS ')
wfXnsStaticRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsSrTargNetwork"), (0, "Wellfleet-Series7-MIB", "wfXnsSrNextHopNetwork"))
if mibBuilder.loadTexts: wfXnsStaticRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsStaticRouteEntry.setDescription(' An entry in the Host Table ')
wfXnsSrDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsSrDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrDelete.setDescription('Create/Delete parameter. Default is created. Users perform an SNMP SET operation on this object in order to create/delete the XNS Static Route.')
wfXnsSrDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsSrDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrDisable.setDescription('Enable/Disable parameter. Default is enabled. Users perform an SNMP SET operation on this object in order to enable/disable this XNS Static Route.')
wfXnsSrTargNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsSrTargNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrTargNetwork.setDescription(' The Address of this static route ')
wfXnsSrCost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsSrCost.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrCost.setDescription(' The Cost of this Static Route ')
wfXnsSrNextHopNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsSrNextHopNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrNextHopNetwork.setDescription(' The Next Hop XNS Address ')
wfXnsSrNextHopHost = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsSrNextHopHost.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrNextHopHost.setDescription(' The next Hop Host address ')
wfXnsSrTargNetworkRt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 6, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsSrTargNetworkRt.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsSrTargNetworkRt.setDescription(' The Route Identifier Which numbered route this is to be ')
wfXnsTrafficFilterTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7), )
if mibBuilder.loadTexts: wfXnsTrafficFilterTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterTable.setDescription(' XNS Traffic Filters ')
wfXnsTrafficFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1), ).setIndexNames((0, "Wellfleet-Series7-MIB", "wfXnsTrafficFilterInterface"), (0, "Wellfleet-Series7-MIB", "wfXnsTrafficFilterCircuit"), (0, "Wellfleet-Series7-MIB", "wfXnsTrafficFilterRuleNumber"), (0, "Wellfleet-Series7-MIB", "wfXnsTrafficFilterFragment"))
if mibBuilder.loadTexts: wfXnsTrafficFilterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterEntry.setDescription(' A traffic filter definition ')
wfXnsTrafficFilterCreate = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsTrafficFilterCreate.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterCreate.setDescription(' Defines the existence of the traffic filter rule: created - traffic filter exists delete - traffic filter does not exist and can be deleted. ')
wfXnsTrafficFilterEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsTrafficFilterEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterEnable.setDescription(' Defines whether or not the traffic filter rule should be used: enabled - activate the rule. disabled - inactivate the rule. ')
wfXnsTrafficFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("error", 2), ("inactive", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterStatus.setDescription(' Defines the current status of the traffic filter: inactive - the rule is not in use. active - the rule is being used. error - the application detected an error in the rule. ')
wfXnsTrafficFilterCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterCounter.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterCounter.setDescription(' The number of received packets that have matched this rule. ')
wfXnsTrafficFilterDefinition = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 5), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfXnsTrafficFilterDefinition.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterDefinition.setDescription(' The filter rule definition. ')
wfXnsTrafficFilterReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 6), Integer32())
if mibBuilder.loadTexts: wfXnsTrafficFilterReserved.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterReserved.setDescription(' Reserved field. ')
wfXnsTrafficFilterInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterInterface.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterInterface.setDescription(' The network address of the XNS interface to which this filter is applied. ')
wfXnsTrafficFilterCircuit = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterCircuit.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterCircuit.setDescription(' The ID of the Circuit to which the filter is applied. ')
wfXnsTrafficFilterRuleNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterRuleNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterRuleNumber.setDescription(' ID for the rule. ')
wfXnsTrafficFilterFragment = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 10, 7, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfXnsTrafficFilterFragment.setStatus('mandatory')
if mibBuilder.loadTexts: wfXnsTrafficFilterFragment.setDescription(' Fragment number - for large rules. ')
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfT1RcvYelAlarms=wfT1RcvYelAlarms, wfApplePortTrEndStation=wfApplePortTrEndStation, wfBrSrInterfaceCircuit=wfBrSrInterfaceCircuit, wfIpRfOspfExportAction=wfIpRfOspfExportAction, wfivCircuitHelloEnableDisable=wfivCircuitHelloEnableDisable, wfBrSr=wfBrSr, wfAppleAarpPhysAddress=wfAppleAarpPhysAddress, wfDs1CurrentESs=wfDs1CurrentESs, wfCctOptsBrFilterRuleNumber=wfCctOptsBrFilterRuleNumber, wfDs3FeTotalSESs=wfDs3FeTotalSESs, wfIpxSrNextHopHost=wfIpxSrNextHopHost, wfOspfNbrAddressLessIndex=wfOspfNbrAddressLessIndex, wfSnmpCommName=wfSnmpCommName, wfXnsBaseRouteIfIndex=wfXnsBaseRouteIfIndex, wfHwEntry=wfHwEntry, wfSnmpInGetResponses=wfSnmpInGetResponses, wfXnsInterfaceForwDatagrams=wfXnsInterfaceForwDatagrams, wfVinesTrafficFilterFragment=wfVinesTrafficFilterFragment, wfFddiPortCct=wfFddiPortCct, wfFddiSmtEntry=wfFddiSmtEntry, wfVinesIfRemClientPrivDisable=wfVinesIfRemClientPrivDisable, wfKernelMemOwnerTask4=wfKernelMemOwnerTask4, wfOspfIfRxDBDescripts=wfOspfIfRxDBDescripts, wfIpxSapNetLvlIndex=wfIpxSapNetLvlIndex, wfivTrafficFilterCreate=wfivTrafficFilterCreate, wfSyncFrameRejectsRx=wfSyncFrameRejectsRx, wfivRouteMaxAddr=wfivRouteMaxAddr, wfivCircuitL1UpdateEnableDisable=wfivCircuitL1UpdateEnableDisable, wfCSMACDMtu=wfCSMACDMtu, wfFrDlcmiMaxSupportedVCs=wfFrDlcmiMaxSupportedVCs, wfSmdsCircuitEntry=wfSmdsCircuitEntry, wfApplePortRtmpRoutingTableOverflows=wfApplePortRtmpRoutingTableOverflows, wfivCircuitExecHelloTimer=wfivCircuitExecHelloTimer, wfIpInterfaceInDelivers=wfIpInterfaceInDelivers, wfXnsSrNextHopHost=wfXnsSrNextHopHost, wfIpInterfaceRedirect=wfIpInterfaceRedirect, wfIpxTrafficFilterCircuit=wfIpxTrafficFilterCircuit, wfDs1CurrentCVs=wfDs1CurrentCVs, wfServices=wfServices, wfBrTpInterfaceDelete=wfBrTpInterfaceDelete, wfCctOptsNormalPriorityQueueLimit=wfCctOptsNormalPriorityQueueLimit, wfivCircuitArea=wfivCircuitArea, wfDs1IntervalSESs=wfDs1IntervalSESs, wfXnsInterfaceInDiscards=wfXnsInterfaceInDiscards, wfIpxSrTargNetworkRt=wfIpxSrTargNetworkRt, wfOspfVirtIfNeighbor=wfOspfVirtIfNeighbor, wfSnmpInReadOnlys=wfSnmpInReadOnlys, wfXnsTrafficFilterRuleNumber=wfXnsTrafficFilterRuleNumber, wfFrCircuitStateSet=wfFrCircuitStateSet, wfivAdjListenTimer=wfivAdjListenTimer, wfivRouteAreaMaxHops=wfivRouteAreaMaxHops, wfE1MiniDacs=wfE1MiniDacs, wfHssiConnector=wfHssiConnector, wfCctOptsBrFilterState=wfCctOptsBrFilterState, wfIpInterfaceCircuit=wfIpInterfaceCircuit, wfHssiOutDiscards=wfHssiOutDiscards, wfDs1TimeElapsed=wfDs1TimeElapsed, wfivAreaTable=wfivAreaTable, wfIpxBaseRouteMetric=wfIpxBaseRouteMetric, wfBrTpFdbEntry=wfBrTpFdbEntry, wfTokenRingUpStream=wfTokenRingUpStream, wfDs1FeIntervalIndex=wfDs1FeIntervalIndex, wfCSMACDBoflTmo=wfCSMACDBoflTmo, wfIpTrafficFilterCircuit=wfIpTrafficFilterCircuit, wfOspfIfDelete=wfOspfIfDelete, wfXnsInterfaceTable=wfXnsInterfaceTable, wfOspfIfTxLinkStateReqs=wfOspfIfTxLinkStateReqs, wfHwDiagPromDate=wfHwDiagPromDate, wfIpxInterfaceCost=wfIpxInterfaceCost, wfDs1LineType=wfDs1LineType, wfApplePortZipOutZipReplies=wfApplePortZipOutZipReplies, wfFrCircuitReceivedBECNs=wfFrCircuitReceivedBECNs, wfDs1TotalESs=wfDs1TotalESs, wfTftpAborts=wfTftpAborts, wfIfInDiscards=wfIfInDiscards, wfApplePortNbpOutLookUpReplies=wfApplePortNbpOutLookUpReplies, wfOspfAreaRangeMask=wfOspfAreaRangeMask, wfIpxSrCost=wfIpxSrCost, wfVinesIf=wfVinesIf, wfIpxSapNetLvlFilterTable=wfIpxSapNetLvlFilterTable, wfIfInUnknownProtos=wfIfInUnknownProtos, wfSipL2MidCurrentlyActiveErrors=wfSipL2MidCurrentlyActiveErrors, wfOspfVirtIfTxLinkStateUpds=wfOspfVirtIfTxLinkStateUpds, wfBrStpBaseEnable=wfBrStpBaseEnable, wfIpRfRipImportAction=wfIpRfRipImportAction, wfIpSrCost=wfIpSrCost, wfCSMACDRxQueueLength=wfCSMACDRxQueueLength, wfIpxInterfaceXsumOn=wfIpxInterfaceXsumOn, wfIpxInterfaceWanSapPeriod=wfIpxInterfaceWanSapPeriod, wfIpRfRipExportEntry=wfIpRfRipExportEntry, wfivRouteMaxHops=wfivRouteMaxHops, wfCctOptsIpFilterReserved=wfCctOptsIpFilterReserved, wfBrSrBaseIpSeqErrors=wfBrSrBaseIpSeqErrors, wfXnsInterfaceExServSockNm=wfXnsInterfaceExServSockNm, wfBrTpInterface=wfBrTpInterface, wfSipDs3Plcp=wfSipDs3Plcp, wfVinesIfReassFails=wfVinesIfReassFails, wfBrSrBaseBridgeId=wfBrSrBaseBridgeId, wfIpInterfaceIcmpInEchos=wfIpInterfaceIcmpInEchos, wfVinesIfX25VCResetsOut=wfVinesIfX25VCResetsOut, wfivLevel1AreaId=wfivLevel1AreaId, wfKernelTimersTotal=wfKernelTimersTotal, wfDs3FeCurrentESs=wfDs3FeCurrentESs, wfXnsInterfaceSMDSGroupAddress=wfXnsInterfaceSMDSGroupAddress, wfApplePortZipAddressInvalids=wfApplePortZipAddressInvalids, wfDs3IntervalUASs=wfDs3IntervalUASs, wfSipDs1Plcp=wfSipDs1Plcp, wfKernelMemOwnerTask7Size=wfKernelMemOwnerTask7Size, wfKernelBufOwnerTask6=wfKernelBufOwnerTask6, wfIpInterfaceIcmpOutSrcQuenchs=wfIpInterfaceIcmpOutSrcQuenchs, wfTMS380Load=wfTMS380Load, wfivCircuitMaxRouters=wfivCircuitMaxRouters, wfAppleRtmpNetEnd=wfAppleRtmpNetEnd, wfDs3CurrentSEFs=wfDs3CurrentSEFs, wfFrDlcmiMonitoredEvents=wfFrDlcmiMonitoredEvents, wfDs1FeTotalIndex=wfDs1FeTotalIndex, wfBrSrIpEncapsEntry=wfBrSrIpEncapsEntry, wfCctOptsLengthBasedLength=wfCctOptsLengthBasedLength, wfXnsInterfaceXsumOn=wfXnsInterfaceXsumOn, wfHSSIFSILoad=wfHSSIFSILoad, wfHwTable=wfHwTable, wfSyncFramesIncompRx=wfSyncFramesIncompRx, wfVinesIfCct=wfVinesIfCct, wfIpxSapNetLvlAction=wfIpxSapNetLvlAction, wfIpInterfaceForwDatagrams=wfIpInterfaceForwDatagrams, wfBaudRate=wfBaudRate, wfApplePortZipInZipReplies=wfApplePortZipInZipReplies, wfXnsSrNextHopNetwork=wfXnsSrNextHopNetwork, wfDs1FeInterval=wfDs1FeInterval, wfIpxBaseLogFilter=wfIpxBaseLogFilter, wfivCircuitAllRoutersMac=wfivCircuitAllRoutersMac, wfivTrafficFilterFragment=wfivTrafficFilterFragment, wfOspfIfTxDBDescripts=wfOspfIfTxDBDescripts, wfIpTrafficFilterTable=wfIpTrafficFilterTable, wfBrSrInterfaceDisable=wfBrSrInterfaceDisable, wfFDDISmtEnable=wfFDDISmtEnable, wfBrSrInterfaceMaxRds=wfBrSrInterfaceMaxRds, wfHssiBoflTmo=wfHssiBoflTmo, wfFrCircuitSentOctets=wfFrCircuitSentOctets, wfOspfAreaId=wfOspfAreaId, wfBridgeGroup=wfBridgeGroup, wfDs3CurrentESs=wfDs3CurrentESs, wfVinesIfLine=wfVinesIfLine, wfKernelMemoryFree=wfKernelMemoryFree, wfSipHcsOrCRCErrors=wfSipHcsOrCRCErrors, wfCctOptsDroppedPkts=wfCctOptsDroppedPkts, wfIpxInterfaceInDelivers=wfIpxInterfaceInDelivers, wfHssiRxReplenMisses=wfHssiRxReplenMisses, wfIpSrIpAddress=wfIpSrIpAddress, wfFDDIFramesRxOk=wfFDDIFramesRxOk, wfSyncExtendedAddressForce=wfSyncExtendedAddressForce, wfIpSrNextHopAddr=wfIpSrNextHopAddr, wfVinesRtpRtGateNetid=wfVinesRtpRtGateNetid, wfIpxAhTargHostId=wfIpxAhTargHostId, wfDs3FeTotalEntry=wfDs3FeTotalEntry, wfTokenRingOpenState=wfTokenRingOpenState, wfXnsRipInterfaceDisable=wfXnsRipInterfaceDisable, wfXnsRipIntfEntry=wfXnsRipIntfEntry, wfAppleBaseState=wfAppleBaseState, wfXnsBaseRouteProto=wfXnsBaseRouteProto, wfFrCircuitReceivedFrames=wfFrCircuitReceivedFrames, wfFrErrType=wfFrErrType, wfFDDIParityErrTx=wfFDDIParityErrTx, wfivAdjTable=wfivAdjTable, wfBrStpBaseState=wfBrStpBaseState, wfIpxInterfaceCircuit=wfIpxInterfaceCircuit, wfT1FrameBitErrs=wfT1FrameBitErrs, wfIfInUcastPkts=wfIfInUcastPkts, wfTiRuiOutResults=wfTiRuiOutResults, wfSmdsCircuitGroupAddr=wfSmdsCircuitGroupAddr, wfBrSrInterfaceDropSrfs=wfBrSrInterfaceDropSrfs, wfBrStpBridgeHelloTime=wfBrStpBridgeHelloTime, wfKernelTable=wfKernelTable, wfSnmpTrapDebug=wfSnmpTrapDebug, wfXnsBaseState=wfXnsBaseState, wfCSMACDConnector=wfCSMACDConnector, wfKernelSlot=wfKernelSlot, wfDs1TotalBPVs=wfDs1TotalBPVs, wfApplePortZipInGetNetInfoReplies=wfApplePortZipInGetNetInfoReplies, wfVinesIpFrags=wfVinesIpFrags, wfE1HDB3Support=wfE1HDB3Support, wfSnmpInBadTypes=wfSnmpInBadTypes, wfCctOptsNormalXmits=wfCctOptsNormalXmits, wfFNSDSDTLoad=wfFNSDSDTLoad, wfSipDs1PlcpSEFs=wfSipDs1PlcpSEFs, wfTftpOutRRQ=wfTftpOutRRQ, wfivLevel1RouteNextNode=wfivLevel1RouteNextNode, wfXnsTrafficFilterTable=wfXnsTrafficFilterTable, wfCctOptsHighWaterPktsClear=wfCctOptsHighWaterPktsClear, wfIpxRipIntfTable=wfIpxRipIntfTable, wfModMadr4=wfModMadr4, wfApplePortZipOutGetZoneListReplies=wfApplePortZipOutGetZoneListReplies, wfE1Entry=wfE1Entry, wfBrTpInterfaceEntry=wfBrTpInterfaceEntry, wfSyncSlot=wfSyncSlot, wfOspfGeneralDisable=wfOspfGeneralDisable, wfE1State=wfE1State, wfOspfVirtNbrTable=wfOspfVirtNbrTable, wfDs3IntervalIndex=wfDs3IntervalIndex, wfFakeEvent=wfFakeEvent, wfSnmpInTooBigs=wfSnmpInTooBigs, wfOspfVirtIfTxDBDescripts=wfOspfVirtIfTxDBDescripts, wfDs3FarEndEquipCode=wfDs3FarEndEquipCode, wfSnmp=wfSnmp, wfTiRuiInReqs=wfTiRuiInReqs, wfLine=wfLine, wfModMcr1=wfModMcr1, wfIpInterfaceIcmpInTimeExcds=wfIpInterfaceIcmpInTimeExcds, wfKernelBuffersTotal=wfKernelBuffersTotal, wfT1Madr=wfT1Madr, wfKernelMemorySize=wfKernelMemorySize, wfHssiTxFifoWatermark=wfHssiTxFifoWatermark, wfArpCreate=wfArpCreate, wfBrStpInterfaceEntry=wfBrStpInterfaceEntry, wfIpBaseDefaultTTL=wfIpBaseDefaultTTL, wfDs1TotalIndex=wfDs1TotalIndex, wfSnmpGroup=wfSnmpGroup, wfVinesRtpNbrNumber=wfVinesRtpNbrNumber, wfCSMACDLateCollnTx=wfCSMACDLateCollnTx, wfXnsInterfaceEncaps=wfXnsInterfaceEncaps, wfTokenRingTxFrames=wfTokenRingTxFrames, wfTokenRingSlot=wfTokenRingSlot, wfCctOptsBrFilterEnable=wfCctOptsBrFilterEnable, wfDs1ConfigEntry=wfDs1ConfigEntry, wfBrStpTimeSinceTopologyChange=wfBrStpTimeSinceTopologyChange, wfTftpInFiles=wfTftpInFiles, wfDs3CurrentCVs=wfDs3CurrentCVs, wfIpxBaseServiceCount=wfIpxBaseServiceCount, wfDSDELoad=wfDSDELoad, wfSnmpOutBadValues=wfSnmpOutBadValues, wfOspfVersionNumber=wfOspfVersionNumber, wfHssiSlot=wfHssiSlot, wfSysContact=wfSysContact, wfVinesTrafficFilterDefinition=wfVinesTrafficFilterDefinition, wfBrSrIpEncapsRing=wfBrSrIpEncapsRing, wfDEFALoad=wfDEFALoad, wfDs1FeCurrentESs=wfDs1FeCurrentESs, wfIpBaseRouteInfo=wfIpBaseRouteInfo, wfIpxTrafficFilterEntry=wfIpxTrafficFilterEntry, wfFrCircuitState=wfFrCircuitState, wfDs3FeTotal=wfDs3FeTotal, wfHwfState=wfHwfState, wfivAreaCircuitID=wfivAreaCircuitID, wfBrStpProtocolSpecification=wfBrStpProtocolSpecification, wfIpRfRipExportTable=wfIpRfRipExportTable, wfDs1TotalCVs=wfDs1TotalCVs, wfVINESLoad=wfVINESLoad, wfVinesIfOutPkts=wfVinesIfOutPkts, wfFrDlcmiFullEnquiryInterval=wfFrDlcmiFullEnquiryInterval, wfTokenRingRingRecoveries=wfTokenRingRingRecoveries, wfDs3Config=wfDs3Config, wfHssiRxLongFrames=wfHssiRxLongFrames, wfivTrafficFilterEntry=wfivTrafficFilterEntry, wfKernelBufOwnerTask5=wfKernelBufOwnerTask5)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfOspfStubMetric=wfOspfStubMetric, wfBrStp=wfBrStp, wfivAdjType=wfivAdjType, wfKernelMemOwnerTask9=wfKernelMemOwnerTask9, wfIpInterfaceReasmOKs=wfIpInterfaceReasmOKs, wfVinesIfTrEndStation=wfVinesIfTrEndStation, wfBrSrBridgeId=wfBrSrBridgeId, wfBCNTemperature=wfBCNTemperature, wfivCircuitAllEndnodesMac=wfivCircuitAllEndnodesMac, wfBrTpBaseState=wfBrTpBaseState, wfBrTrafficFilterCircuit=wfBrTrafficFilterCircuit, wfIpBaseState=wfIpBaseState, wfVinesBaseRouterNetid=wfVinesBaseRouterNetid, wfFrDlcmiPassiveSeqCount=wfFrDlcmiPassiveSeqCount, wfDs1FeIntervalEntry=wfDs1FeIntervalEntry, wfFddiPortGroup=wfFddiPortGroup, wfCctOptsCct=wfCctOptsCct, wfAppleRtmpNextHopNet=wfAppleRtmpNextHopNet, wfOspfVirtIfState=wfOspfVirtIfState, wfE1SyncLoss=wfE1SyncLoss, wfXnsBaseHostNumber=wfXnsBaseHostNumber, wfAppleRtmpNetStart=wfAppleRtmpNetStart, wfAppleBaseDelete=wfAppleBaseDelete, wfTokenRingOpenStatus=wfTokenRingOpenStatus, wfDs1TotalEntry=wfDs1TotalEntry, wfIpInterfaceSMDSGroupAddress=wfIpInterfaceSMDSGroupAddress, wfIpInterfaceIcmpInAddrMaskReps=wfIpInterfaceIcmpInAddrMaskReps, wfSoftwareConfig=wfSoftwareConfig, wfModProm=wfModProm, wfVinesRtpRt=wfVinesRtpRt, wfTftpRexmitPkts=wfTftpRexmitPkts, wfCctOptsRxPkts=wfCctOptsRxPkts, wfOspfLsdbTable=wfOspfLsdbTable, wfSipL2Index=wfSipL2Index, wfDs3LoopbackConfig=wfDs3LoopbackConfig, wfFrCircuitDelete=wfFrCircuitDelete, wfDs3TotalCVs=wfDs3TotalCVs, wfCctOptsBrFilterFragment=wfCctOptsBrFilterFragment, wfKernelBufOwnerTask8=wfKernelBufOwnerTask8, wfSmdsCircuitDisable=wfSmdsCircuitDisable, wfBrTpInterfaceInFrames=wfBrTpInterfaceInFrames, wfOspfVirtIfRetransInterval=wfOspfVirtIfRetransInterval, wfBrSrIpEncapsTable=wfBrSrIpEncapsTable, wfBrTpBaseDelete=wfBrTpBaseDelete, wfSipDs3PlcpSEFs=wfSipDs3PlcpSEFs, wfSnmpMgrName=wfSnmpMgrName, wfIfEntry=wfIfEntry, wfVinesIfX25VCBytesIn=wfVinesIfX25VCBytesIn, wfApplePortNodeId=wfApplePortNodeId, wfSnmpInTraps=wfSnmpInTraps, wfSyncT1Timeouts=wfSyncT1Timeouts, wfIpxBaseRouteType=wfIpxBaseRouteType, wfLinesPerScreen=wfLinesPerScreen, wfIpInterfaceFragOKs=wfIpInterfaceFragOKs, wfHssiState=wfHssiState, wfDs3Current=wfDs3Current, wfBrStpInterfacePktsRcvd=wfBrStpInterfacePktsRcvd, wfDs1TotalUASs=wfDs1TotalUASs, wfTokenRingStatus=wfTokenRingStatus, wfivAdjState=wfivAdjState, wfKernelBufOwnerTask3=wfKernelBufOwnerTask3, wfivRouteCreateDelete=wfivRouteCreateDelete, wfIpRfRipImportAddress=wfIpRfRipImportAddress, wfCSMACDEnable=wfCSMACDEnable, wfVinesRtpNbrSubNetId=wfVinesRtpNbrSubNetId, wfIpInterfaceIcmpOutTimeExcds=wfIpInterfaceIcmpOutTimeExcds, wfIpAdjacentHostEntry=wfIpAdjacentHostEntry, wfHssiLastTxErrorCtrl=wfHssiLastTxErrorCtrl, wfBrSrInterfaceDropInvalidRings=wfBrSrInterfaceDropInvalidRings, wfBrSrInterfaceState=wfBrSrInterfaceState, wfCctOptsBrFilterDefinition=wfCctOptsBrFilterDefinition, wfIpInterfaceInReceives=wfIpInterfaceInReceives, wfArpBaseCreate=wfArpBaseCreate, wfIpAdjacentHostTable=wfIpAdjacentHostTable, wfFddiSmtMacCt=wfFddiSmtMacCt, wfDSTLoad=wfDSTLoad, wfTokenRingTable=wfTokenRingTable, wfivRouteMaxCircuits=wfivRouteMaxCircuits, wfBrStpDesignatedRoot=wfBrStpDesignatedRoot, wfApplePortCurDfltZone=wfApplePortCurDfltZone, wfBrSrIpEncapsStatus=wfBrSrIpEncapsStatus, wfKernelBufOwnerTask4=wfKernelBufOwnerTask4, wfBrStpRootPort=wfBrStpRootPort, wfIpxRipInterfaceSupply=wfIpxRipInterfaceSupply, wfCommandTimeOut=wfCommandTimeOut, wfVinesIfDodIpDisable=wfVinesIfDodIpDisable, wfXnsInterfaceInReceives=wfXnsInterfaceInReceives, wfOspfIfType=wfOspfIfType, wfOspfDynNbrIpAddr=wfOspfDynNbrIpAddr, wfIpBaseRouteMetric4=wfIpBaseRouteMetric4, wfivRouteAreaMaxCost=wfivRouteAreaMaxCost, wfApplePortDelete=wfApplePortDelete, wfFDDIMacTvxValue=wfFDDIMacTvxValue, wfIpRfOspfExportFromProtocol=wfIpRfOspfExportFromProtocol, wfBrTpBaseFdbPort=wfBrTpBaseFdbPort, wfIpxBaseSapSocket=wfIpxBaseSapSocket, wfOspfAreaRangeState=wfOspfAreaRangeState, wfKernelBufOwnerTask6Bufs=wfKernelBufOwnerTask6Bufs, wfHssiRxFifoWatermark=wfHssiRxFifoWatermark, wfApplePortNbpOutLookUpRequests=wfApplePortNbpOutLookUpRequests, wfivLevel1RouteTable=wfivLevel1RouteTable, wfApplePortRtmpNextIREqualChanges=wfApplePortRtmpNextIREqualChanges, wfIpxInterfaceForwDatagrams=wfIpxInterfaceForwDatagrams, wfX25DCELoad=wfX25DCELoad, wfCSMACDOctetsTxOk=wfCSMACDOctetsTxOk, wfivAdjEntry=wfivAdjEntry, wfOspfLsdbRouterId=wfOspfLsdbRouterId, wfTokenRingDmaParityErrors=wfTokenRingDmaParityErrors, wfivCircuitCountAreaUpdRcvd=wfivCircuitCountAreaUpdRcvd, wfOspfIfRetransInterval=wfOspfIfRetransInterval, wfSyncMemoryErrors=wfSyncMemoryErrors, wfModTsra=wfModTsra, wfHwDaughterBdSerialNumber=wfHwDaughterBdSerialNumber, wfVinesIfEntry=wfVinesIfEntry, wfIpRfRipImportMask=wfIpRfRipImportMask, wfHwModSerialNumber=wfHwModSerialNumber, wfFddiPathGroup=wfFddiPathGroup, wfXnsRipInterfaceIndex=wfXnsRipInterfaceIndex, wfHardwareConfig=wfHardwareConfig, wfSnmpInTotalReqVars=wfSnmpInTotalReqVars, wfFddiSmtNode=wfFddiSmtNode, wfVinesTrafficFilterCounter=wfVinesTrafficFilterCounter, wfVinesIfMux=wfVinesIfMux, wfCctOptsBrFilterCreate=wfCctOptsBrFilterCreate, wfXnsAhTargHostNetwork=wfXnsAhTargHostNetwork, wfXnsTrafficFilterCreate=wfXnsTrafficFilterCreate, wfTftpXfers=wfTftpXfers, wfIpInterfaceCost=wfIpInterfaceCost, wfCctOptsNormalClippedPkts=wfCctOptsNormalClippedPkts, wfKernelBufOwnerTask2=wfKernelBufOwnerTask2, wfCSMACDTable=wfCSMACDTable, wfApplePortEchoRequests=wfApplePortEchoRequests, wfBrTrafficFilterEnable=wfBrTrafficFilterEnable, wfSyncBadFramesRx=wfSyncBadFramesRx, wfModMidr=wfModMidr, wfCctOptsLengthBasedDisable=wfCctOptsLengthBasedDisable, wfOspfIfRxHellos=wfOspfIfRxHellos, wfIpRfOspfExportCreate=wfIpRfOspfExportCreate, wfXnsBaseDelete=wfXnsBaseDelete, wfTokenRingRxReplenMisses=wfTokenRingRxReplenMisses, wfIpxInterfaceInHdrErrors=wfIpxInterfaceInHdrErrors, wfOspfAreaRangeAreaID=wfOspfAreaRangeAreaID, wfApplePortNbpRegistrationFailures=wfApplePortNbpRegistrationFailures, wfApplePortDdpHopCountErrors=wfApplePortDdpHopCountErrors, wfHwfLineTable=wfHwfLineTable, wfFDDIMacTMax=wfFDDIMacTMax, wfFDDISmtConnectionPolicy=wfFDDISmtConnectionPolicy, wfKernelMemOwnerTask6Size=wfKernelMemOwnerTask6Size, wfIpInterfaceProxy=wfIpInterfaceProxy, wfTokenRingRxTimeouts=wfTokenRingRxTimeouts, wfSyncState=wfSyncState, wfApplePortCurNetStart=wfApplePortCurNetStart, wfivCircuitCountHelloRcvd=wfivCircuitCountHelloRcvd, wfIpxBaseRouteAge=wfIpxBaseRouteAge, wfDs3TotalESs=wfDs3TotalESs, wfIpxRipInterfaceListen=wfIpxRipInterfaceListen, wfHssiExternalClkSpeed=wfHssiExternalClkSpeed, wfKernelEntry=wfKernelEntry, wfIpInterfaceSMDSArpReqAddress=wfIpInterfaceSMDSArpReqAddress, wfIf=wfIf, wfKernelMemOwnerTask9Size=wfKernelMemOwnerTask9Size, wfSyncCct=wfSyncCct, wfivRouteMaxArea=wfivRouteMaxArea, wfModFramer2=wfModFramer2, wfVinesRtpNbrTable=wfVinesRtpNbrTable, wfDs3FeConfigIndex=wfDs3FeConfigIndex, wfFDDICct=wfFDDICct, wfivTrafficFilterRuleNumber=wfivTrafficFilterRuleNumber, wfVinesRtpRtSvrName=wfVinesRtpRtSvrName, wfBrSrInterfaceBlockInSte=wfBrSrInterfaceBlockInSte, wfivRouteMaxVisits=wfivRouteMaxVisits, wfIpxNetBiosStaticRouteEntry=wfIpxNetBiosStaticRouteEntry, wfHwfAvailableLines=wfHwfAvailableLines, wfOspfLsdbAdvLen=wfOspfLsdbAdvLen, wfXnsSrCost=wfXnsSrCost, wfBCNPwrSupply2=wfBCNPwrSupply2, wfVinesRtpRtIdle=wfVinesRtpRtIdle, wfDs3LineIndex=wfDs3LineIndex, wfSipPlcpGroup=wfSipPlcpGroup, wfBrTpFdbTable=wfBrTpFdbTable, wfAppleRtmpNextHopNode=wfAppleRtmpNextHopNode, wfVinesBaseBcastClass=wfVinesBaseBcastClass, wfFrDlcmiDelete=wfFrDlcmiDelete, wfApplePortAarpFlush=wfApplePortAarpFlush, wfBrStpMaxAge=wfBrStpMaxAge, wfDs3IntervalSEFs=wfDs3IntervalSEFs, wfIpxTrafficFilterInterface=wfIpxTrafficFilterInterface, wfCSMACDFramesTxOk=wfCSMACDFramesTxOk, wfApplePortCksumDisable=wfApplePortCksumDisable, wfDataLink=wfDataLink, wfIpInterfaceMask=wfIpInterfaceMask, wfApplePortAarpProbeRxs=wfApplePortAarpProbeRxs, wfXnsRipInterfaceState=wfXnsRipInterfaceState, wfVinesIfX25VCPktsIn=wfVinesIfX25VCPktsIn, wfIpAdjHostEncaps=wfIpAdjHostEncaps, wfHssiDisable=wfHssiDisable, wfHwfDelete=wfHwfDelete, wfAppleZipZoneNetEnd=wfAppleZipZoneNetEnd, wfCSMACDBofl=wfCSMACDBofl, wfFDDIOctetsTxOk=wfFDDIOctetsTxOk, wfApplePortDdpBroadcastErrors=wfApplePortDdpBroadcastErrors, wfOspfASBdrRtrStatus=wfOspfASBdrRtrStatus, wfBrSrIpExplorerTable=wfBrSrIpExplorerTable, wfTokenRingCounterOverflows=wfTokenRingCounterOverflows, wfFrCircuitReceivedOctets=wfFrCircuitReceivedOctets, wfModMled=wfModMled, wfHssiLastTxRingState=wfHssiLastTxRingState, wfIfInNUCastPkts=wfIfInNUCastPkts, wfSnmpTrapTrace=wfSnmpTrapTrace, wfT1Delete=wfT1Delete, wfDs1LineIndex=wfDs1LineIndex, wfFDDIMacErrRx=wfFDDIMacErrRx, wfProtocols=wfProtocols, wfAppleZipTable=wfAppleZipTable, wfIpxSapServLvlDisable=wfIpxSapServLvlDisable, wfSnmpOutTraps=wfSnmpOutTraps, wfAppleRtmpTable=wfAppleRtmpTable, wfDs3TotalUASs=wfDs3TotalUASs, wfVinesIfX25VCTotOut=wfVinesIfX25VCTotOut, wfCctOptsLengthBasedGreaterThanQ=wfCctOptsLengthBasedGreaterThanQ, wfOspfIfPollInterval=wfOspfIfPollInterval, wfVinesGroup=wfVinesGroup, wfIpxInterfaceCacheHit=wfIpxInterfaceCacheHit, wfKernelBufOwnerTask1=wfKernelBufOwnerTask1, wfRipInterfaceListen=wfRipInterfaceListen, wfIpxSapServLvlTargServer=wfIpxSapServLvlTargServer, wfIfSpecific=wfIfSpecific, wfVinesIpReass=wfVinesIpReass, wfSystem=wfSystem, wfKernelBufOwnerTask1Bufs=wfKernelBufOwnerTask1Bufs, wfIpInterfaceOutDiscards=wfIpInterfaceOutDiscards, wfIpxBaseRouteInfo=wfIpxBaseRouteInfo, wfOspfIfHelloInterval=wfOspfIfHelloInterval, wfFddiPortPcType=wfFddiPortPcType, wfXnsInterfaceMaxInfo=wfXnsInterfaceMaxInfo, wfXnsInterfaceOutRequests=wfXnsInterfaceOutRequests, wfIpxNetBiosSrTargNetwork=wfIpxNetBiosSrTargNetwork, wfivCircuitEntry=wfivCircuitEntry, wfModCar=wfModCar, wfIpxInterfaceIndex=wfIpxInterfaceIndex, wfIpRfOspfExportType=wfIpRfOspfExportType, wfBrSourceRouting=wfBrSourceRouting, wfKernelMemoryMaxSegFree=wfKernelMemoryMaxSegFree, wfivRouteMaxBdcastRouters=wfivRouteMaxBdcastRouters, wfFDDIOverrunRx=wfFDDIOverrunRx, wfBCNPwrSupply4=wfBCNPwrSupply4, wfIpxBaseSapHost=wfIpxBaseSapHost, wfKernelBufOwnerTask8Bufs=wfKernelBufOwnerTask8Bufs, wfOspfVirtIfTransitDelay=wfOspfVirtIfTransitDelay, wfHwModRev=wfHwModRev, wfIpxBaseSapType=wfIpxBaseSapType, wfFddiMacSmtAddress=wfFddiMacSmtAddress, wfIpxBaseRouteNextHopNetwork=wfIpxBaseRouteNextHopNetwork, wfT1RcvCarrierLoss=wfT1RcvCarrierLoss)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfDs3FeTotalIndex=wfDs3FeTotalIndex, wfFDDIFramesTxOk=wfFDDIFramesTxOk, wfBrLearning=wfBrLearning, wfHssiPortOpErrors=wfHssiPortOpErrors, wfAppleAarpTable=wfAppleAarpTable, wfIpxInterfaceOutNoRoutes=wfIpxInterfaceOutNoRoutes, wfXnsTrafficFilterReserved=wfXnsTrafficFilterReserved, wfIpBaseEnable=wfIpBaseEnable, wfApplePortZipInErrors=wfApplePortZipInErrors, wfFrCircuitDlci=wfFrCircuitDlci, wfIpInterfaceIcmpInDestUnreachs=wfIpInterfaceIcmpInDestUnreachs, wfVinesTrafficFilterEntry=wfVinesTrafficFilterEntry, wfXnsSrDelete=wfXnsSrDelete, wfBrTpInterfaceState=wfBrTpInterfaceState, wfSnmpAuth=wfSnmpAuth, wfBrStpInterfaceForwardTransitions=wfBrStpInterfaceForwardTransitions, wfDs3FeConfig=wfDs3FeConfig, wfHssiRxAborts=wfHssiRxAborts, wfVinesIfArpOutAssgRsps=wfVinesIfArpOutAssgRsps, wfHwFileSysPresent=wfHwFileSysPresent, wfOspfVirtNbrLSRetransQLen=wfOspfVirtNbrLSRetransQLen, wfOspfVirtIfTable=wfOspfVirtIfTable, wfTokenRingInDiscards=wfTokenRingInDiscards, wfDs3FeTotalCVs=wfDs3FeTotalCVs, wfPasswordTimeOut=wfPasswordTimeOut, wfDs1TotalSESs=wfDs1TotalSESs, wfVinesIfX25VCTable=wfVinesIfX25VCTable, wfVinesIfEchoOutPkts=wfVinesIfEchoOutPkts, wfBrSrBaseIpMtuSize=wfBrSrBaseIpMtuSize, wfVinesIfArpDisable=wfVinesIfArpDisable, wfApplePortCircuit=wfApplePortCircuit, wfSipDs3PlcpAlarmState=wfSipDs3PlcpAlarmState, wfIfTable=wfIfTable, wfIpInterfaceIcmpOutMsgs=wfIpInterfaceIcmpOutMsgs, wfBrSrTrafficFilterCircuit=wfBrSrTrafficFilterCircuit, wfDs3FeInterval=wfDs3FeInterval, wfSyncConnector=wfSyncConnector, wfDs3ValidIntervals=wfDs3ValidIntervals, wfSnmpInBadCommunityNames=wfSnmpInBadCommunityNames, wfDs1FeIntervalCVs=wfDs1FeIntervalCVs, wfApplePortCurNodeId=wfApplePortCurNodeId, wfTiRuiAction=wfTiRuiAction, wfSyncDisable=wfSyncDisable, wfBrStpInterfaceMultiCastAddr=wfBrStpInterfaceMultiCastAddr, wfBrStpInterfaceEnable=wfBrStpInterfaceEnable, wfIpxAhDlci=wfIpxAhDlci, wfBrSrTrafficFilterCreate=wfBrSrTrafficFilterCreate, wfIfSpeed=wfIfSpeed, wfIpRfRipImportPreference=wfIpRfRipImportPreference, wfArpIntfTable=wfArpIntfTable, wfXnsInterfaceInUnknownProtos=wfXnsInterfaceInUnknownProtos, wfSnmpMgrEntry=wfSnmpMgrEntry, wfDs3Total=wfDs3Total, wfIpInterfaceInAddrErrors=wfIpInterfaceInAddrErrors, wfDs3FeIntervalCVs=wfDs3FeIntervalCVs, wfTtyOverrunErrors=wfTtyOverrunErrors, wfCSMACDSlot=wfCSMACDSlot, wfBrSrIpExplorerDelete=wfBrSrIpExplorerDelete, wfivAreaHops=wfivAreaHops, wfBrStpForwardDelay=wfBrStpForwardDelay, wfKernelTasksInQueue=wfKernelTasksInQueue, wfBrTpBaseFdbStatus=wfBrTpBaseFdbStatus, wfVinesRtpRtEntry=wfVinesRtpRtEntry, wfModLance2=wfModLance2, wfKernelMemOwnerTask6=wfKernelMemOwnerTask6, wfTokenRingSoftErrors=wfTokenRingSoftErrors, wfIpRfRipExportRipMetric=wfIpRfRipExportRipMetric, wfTokenRingTxProcessings=wfTokenRingTxProcessings, wfFddiSmtCfState=wfFddiSmtCfState, wfIpInterfaceBcastAddr=wfIpInterfaceBcastAddr, wfVinesIfX25VCCct=wfVinesIfX25VCCct, wfFDDIInternOpErr=wfFDDIInternOpErr, wfFrDlcmiErrorThreshold=wfFrDlcmiErrorThreshold, wfCircuitNameEntry=wfCircuitNameEntry, wfTokenRingRxFrames=wfTokenRingRxFrames, wfIfOutOctets=wfIfOutOctets, wfFDDIRxQueueLength=wfFDDIRxQueueLength, wfSnmpInGetRequests=wfSnmpInGetRequests, wfIfOutUcastPkts=wfIfOutUcastPkts, wfATLoad=wfATLoad, wfIpxBaseSapName=wfIpxBaseSapName, wfivCircuitCountHelloSent=wfivCircuitCountHelloSent, wfSipDs1PlcpUASs=wfSipDs1PlcpUASs, wfApplePortDisable=wfApplePortDisable, wfFDDITxQueueLength=wfFDDITxQueueLength, wfIpxSapServLvlIntf=wfIpxSapServLvlIntf, wfIpRfOspfImportTable=wfIpRfOspfImportTable, wfDs1IntervalSEFs=wfDs1IntervalSEFs, wfivAdjClass=wfivAdjClass, wfVinesArp=wfVinesArp, wfIfLastChange=wfIfLastChange, wfApplePortNetwork=wfApplePortNetwork, wfIpxBaseRouteProto=wfIpxBaseRouteProto, wfCctOptsLengthBasedMux=wfCctOptsLengthBasedMux, wfivTrafficFilterStatus=wfivTrafficFilterStatus, wfHssiTxFrames=wfHssiTxFrames, wfDs1Total=wfDs1Total, wfCctOptsIpFilterRuleNumber=wfCctOptsIpFilterRuleNumber, wfDs1FeIntervalNumber=wfDs1FeIntervalNumber, wfOspfAddressLessIf=wfOspfAddressLessIf, wfBCNPwrSupply1=wfBCNPwrSupply1, wfIpInterfaceInUnknownProtos=wfIpInterfaceInUnknownProtos, wfIpAdjHostMacAddr=wfIpAdjHostMacAddr, wfIpRfOspfExportMask=wfIpRfOspfExportMask, wfT1State=wfT1State, wfivCircuitRtHelloEnableDisable=wfivCircuitRtHelloEnableDisable, wfIpRfRipImportCreate=wfIpRfRipImportCreate, wfApplePortNbpOutForwardRequests=wfApplePortNbpOutForwardRequests, wfAppleRtmpPort=wfAppleRtmpPort, wfSyncBofl=wfSyncBofl, wfDs3CircuitIdentifier=wfDs3CircuitIdentifier, wfApplePortDfltZone=wfApplePortDfltZone, wfCSMACDRxReplenMisses=wfCSMACDRxReplenMisses, wfSnmpInASNParseErrs=wfSnmpInASNParseErrs, wfCctOptsPriorityQueueingDisable=wfCctOptsPriorityQueueingDisable, wfCctOptsMaxInterruptQueueLatency=wfCctOptsMaxInterruptQueueLatency, wfOspfNbrState=wfOspfNbrState, wfSyncClkSource=wfSyncClkSource, wfHssiIntrProcessings=wfHssiIntrProcessings, wfVinesRtpNbrLocAdr=wfVinesRtpNbrLocAdr, wfSnmpDisable=wfSnmpDisable, wfSyncLinkIdleTimer=wfSyncLinkIdleTimer, wfIpTrafficFilterCounter=wfIpTrafficFilterCounter, wfApplePortRtmpOutDataPkts=wfApplePortRtmpOutDataPkts, wfOspfAuthType=wfOspfAuthType, wfXnsAhDisable=wfXnsAhDisable, wfSipL2BomOrSSMsMIDErrors=wfSipL2BomOrSSMsMIDErrors, wfSnmpInBadCommunityUses=wfSnmpInBadCommunityUses, wfOspfLsdbLSID=wfOspfLsdbLSID, wfIpInterfaceEnable=wfIpInterfaceEnable, wfVinesIfX25VCNumber=wfVinesIfX25VCNumber, wfXnsTrafficFilterCircuit=wfXnsTrafficFilterCircuit, wfDS2180Load=wfDS2180Load, wfVinesRtpNbrLocLine=wfVinesRtpNbrLocLine, wfBrSrEsRifEntry=wfBrSrEsRifEntry, wfXNSLoad=wfXNSLoad, wfTftpTimeOut=wfTftpTimeOut, wfFDDITxClipFrames=wfFDDITxClipFrames, wfIpxSrTargNetwork=wfIpxSrTargNetwork, wfVinesRtpRtGateSvrName=wfVinesRtpRtGateSvrName, wfHwDaughterBdIdOpt=wfHwDaughterBdIdOpt, wfFddiMacCct=wfFddiMacCct, wfCctOptsIpFilterCounter=wfCctOptsIpFilterCounter, wfCctOptsLengthBasedEntry=wfCctOptsLengthBasedEntry, wfHwfLineSlot=wfHwfLineSlot, wfIpxBaseNetCount=wfIpxBaseNetCount, wfOspfIfBackupDesignatedRouter=wfOspfIfBackupDesignatedRouter, wfSyncBurstCount=wfSyncBurstCount, wfFDDIState=wfFDDIState, wfDs1IntervalESs=wfDs1IntervalESs, wfivCircuitTable=wfivCircuitTable, wfFddiSmtSlot=wfFddiSmtSlot, wfFrCircuitThroughput=wfFrCircuitThroughput, wfDs1FeTotalBPVs=wfDs1FeTotalBPVs, wfTftpRexmit=wfTftpRexmit, wfCctOptsLargePkts=wfCctOptsLargePkts, wfDs3FeConfigEntry=wfDs3FeConfigEntry, wfSnmpOutSetRequests=wfSnmpOutSetRequests, wfOspfDynNbrLSRetransQLen=wfOspfDynNbrLSRetransQLen, wfHssiRxRingLength=wfHssiRxRingLength, wfApplePortAarpRspRxs=wfApplePortAarpRspRxs, wfAppleBaseHomedPort=wfAppleBaseHomedPort, wfXnsInterfaceNetworkNumber=wfXnsInterfaceNetworkNumber, wfBrSrInterfaceBlockIp=wfBrSrInterfaceBlockIp, wfBrTrafficFilterCreate=wfBrTrafficFilterCreate, wfAppleLclZoneName=wfAppleLclZoneName, wfDs1CircuitIdentifier=wfDs1CircuitIdentifier, wfGameGroup=wfGameGroup, wfCSMACDBufErrorTx=wfCSMACDBufErrorTx, wfDs3IntervalCVs=wfDs3IntervalCVs, wfFDDISlot=wfFDDISlot, wfCSMACDCerr=wfCSMACDCerr, wfDs3FeCurrentSESs=wfDs3FeCurrentSESs, wfModMadr2=wfModMadr2, wfIpInterfaceIcmpOutDestUnreachs=wfIpInterfaceIcmpOutDestUnreachs, wfHwfLineCurrentTblSize=wfHwfLineCurrentTblSize, wfFrDlcmiCircuit=wfFrDlcmiCircuit, wfAppleAarpNode=wfAppleAarpNode, wfHssiTxRingErrors=wfHssiTxRingErrors, wfSnmpMgrTable=wfSnmpMgrTable, wfOspfAreaState=wfOspfAreaState, wfDs1IntervalUASs=wfDs1IntervalUASs, wfHwBabyBdSerialNumber=wfHwBabyBdSerialNumber, wfivLevel1RouteCircuitID=wfivLevel1RouteCircuitID, wfSyncPassThruLocalMadr=wfSyncPassThruLocalMadr, wfDS2181Load=wfDS2181Load, wfKernelBufOwnerTask10=wfKernelBufOwnerTask10, wfBrSrEsRifTable=wfBrSrEsRifTable, wfOspfVirtIfEntry=wfOspfVirtIfEntry, wfXnsTrafficFilterEntry=wfXnsTrafficFilterEntry, wfXnsBase=wfXnsBase, wfBrTrafficFilterDefinition=wfBrTrafficFilterDefinition, wfApplePortAarpProbeTxs=wfApplePortAarpProbeTxs, wfIpxSapServLvlIndex=wfIpxSapServLvlIndex, wfBrSrInterfaceDropInvalidRcs=wfBrSrInterfaceDropInvalidRcs, wfMoreEnable=wfMoreEnable, wfApplePortDdpOutNoRoutes=wfApplePortDdpOutNoRoutes, wfXnsSrTargNetwork=wfXnsSrTargNetwork, wfOspfGroup=wfOspfGroup, wfVinesBase=wfVinesBase, wfApplePortAarpReqTxs=wfApplePortAarpReqTxs, wfivCircuitEnableDisable=wfivCircuitEnableDisable, wfIpxTrafficFilterRuleNumber=wfIpxTrafficFilterRuleNumber, wfE1Connector=wfE1Connector, wfFDDIRingErrTx=wfFDDIRingErrTx, wfHwMotherBdSerialNumber=wfHwMotherBdSerialNumber, wfFrCircuitTable=wfFrCircuitTable, wfSyncTxOctets=wfSyncTxOctets, wfSyncRemoteAddress=wfSyncRemoteAddress, wfIpxRipInterfaceIndex=wfIpxRipInterfaceIndex, wfOspfNbrTable=wfOspfNbrTable, wfXnsTrafficFilterStatus=wfXnsTrafficFilterStatus, wfIpxNetBiosSrDelete=wfIpxNetBiosSrDelete, wfXnsTrafficFilterEnable=wfXnsTrafficFilterEnable, wfOspfVirtIfAuthKey=wfOspfVirtIfAuthKey, wfHssiTxClipFrames=wfHssiTxClipFrames, wfBrSrBaseIpEncapsDisable=wfBrSrBaseIpEncapsDisable, wfModHssiFsi2=wfModHssiFsi2, wfSipDs1PlcpEntry=wfSipDs1PlcpEntry, wfSmdsCircuitDelete=wfSmdsCircuitDelete, wfBrStpInterface=wfBrStpInterface, wfFrCircuitSentFrames=wfFrCircuitSentFrames, wfTokenRingCct=wfTokenRingCct, wfTftpInErr=wfTftpInErr, wfSnmpOutPkts=wfSnmpOutPkts, wfVinesRtpNbrEntry=wfVinesRtpNbrEntry, wfVinesTrafficFilterTable=wfVinesTrafficFilterTable, wfDs3TotalBPVs=wfDs3TotalBPVs, wfIpInterfaceIcmpInMsgs=wfIpInterfaceIcmpInMsgs, wfSipL2ReceivedCounts=wfSipL2ReceivedCounts, wfHwfLineCapableMaxTblSize=wfHwfLineCapableMaxTblSize, wfIpAdjHostValid=wfIpAdjHostValid, wfDs3FarEndLocationIDCode=wfDs3FarEndLocationIDCode, wfModMuxram2=wfModMuxram2, wfBrTpInterfaceMaxInfo=wfBrTpInterfaceMaxInfo, wfOspfLsdbEntry=wfOspfLsdbEntry, wfivCircuitCountOutRngePktLoss=wfivCircuitCountOutRngePktLoss, wfFrErrTime=wfFrErrTime, wfAppleAarpEntry=wfAppleAarpEntry, wfE1Madr=wfE1Madr, wfModemEnable=wfModemEnable, wfFDDIBoflTmo=wfFDDIBoflTmo, wfApplePortDdpInLocalDatagrams=wfApplePortDdpInLocalDatagrams, wfCctOptsIntrQHighWaterPkts=wfCctOptsIntrQHighWaterPkts, wfivCircuitExecCost=wfivCircuitExecCost, wfApplePortNbpInBroadcastRequests=wfApplePortNbpInBroadcastRequests, wfOspfImportASExtern=wfOspfImportASExtern, wfSyncOverFlowRx=wfSyncOverFlowRx, wfivStaticAdjCircuitID=wfivStaticAdjCircuitID, wfFDDIBofl=wfFDDIBofl, wfHwFGroup=wfHwFGroup, wfFddiPortPcmState=wfFddiPortPcmState, wfXnsRipInterfaceListen=wfXnsRipInterfaceListen, wfHwSparePromSource=wfHwSparePromSource)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfOspfVirtNbrIpAddr=wfOspfVirtNbrIpAddr, wfVinesIfX25VCTotIn=wfVinesIfX25VCTotIn, wfTokenRingSrbNotFreeCmdAborts=wfTokenRingSrbNotFreeCmdAborts, wfDs3FeCurrentIndex=wfDs3FeCurrentIndex, wfBrStpBridgeMaxAge=wfBrStpBridgeMaxAge, wfIpxAhDelete=wfIpxAhDelete, wfTokenRingRxTxBufferSize=wfTokenRingRxTxBufferSize, wfIpxInterfaceFRBcast=wfIpxInterfaceFRBcast, wfBrSrBaseState=wfBrSrBaseState, wfBrStpBaseDelete=wfBrStpBaseDelete, wfStopBits=wfStopBits, wfIpBaseRouteIfIndex=wfIpBaseRouteIfIndex, wfApplePortDdpTooShortErrors=wfApplePortDdpTooShortErrors, wfAtmGroup=wfAtmGroup, wfFddiSmtTable=wfFddiSmtTable, wfFddiMacEntry=wfFddiMacEntry, wfOspfVirtNbrEntry=wfOspfVirtNbrEntry, wfFDDIDelete=wfFDDIDelete, wfXnsBaseRouteNextHopNetwork=wfXnsBaseRouteNextHopNetwork, wfivStaticAdjPriority=wfivStaticAdjPriority, wfXnsInterfaceFRBcast=wfXnsInterfaceFRBcast, wfIpBaseRtEntryTable=wfIpBaseRtEntryTable, wfFddiSmtOpVersionId=wfFddiSmtOpVersionId, wfModMadr3=wfModMadr3, wfFddiPortIndex=wfFddiPortIndex, wfDs1CurrentEntry=wfDs1CurrentEntry, wfSyncRejectsRx=wfSyncRejectsRx, wfIpxInterfaceCfgEncaps=wfIpxInterfaceCfgEncaps, wfIpSrNextHopMask=wfIpSrNextHopMask, wfIpxSapServtLvlFilterTable=wfIpxSapServtLvlFilterTable, wfBrTpInterfaceEnable=wfBrTpInterfaceEnable, wfDs1IntervalIndex=wfDs1IntervalIndex, wfModMac1=wfModMac1, wfRipInterfaceCreate=wfRipInterfaceCreate, wfCctOptsLoClippedPkts=wfCctOptsLoClippedPkts, wfLinkModules=wfLinkModules, wfBrSrInterfaceDelete=wfBrSrInterfaceDelete, wfSyncRxErrors=wfSyncRxErrors, wfBrStpRootCost=wfBrStpRootCost, wfBrSrBaseInternalLanId=wfBrSrBaseInternalLanId, wfOspfVirtIfRxLinkStateAcks=wfOspfVirtIfRxLinkStateAcks, wfHwBase=wfHwBase, wfOspfVirtIfDrops=wfOspfVirtIfDrops, wfApplePortRtmpInRequestPkts=wfApplePortRtmpInRequestPkts, wfOspfIfDesignatedRouter=wfOspfIfDesignatedRouter, wfCSMACDMerr=wfCSMACDMerr, wfLoginRetries=wfLoginRetries, wfT1BipolarVios=wfT1BipolarVios, wfOsiGroup=wfOsiGroup, wfApplePortZipInZipExtendedReplies=wfApplePortZipInZipExtendedReplies, wfModHicrData=wfModHicrData, wfSipDs1PlcpIndex=wfSipDs1PlcpIndex, wfTokenRingCmdTimeouts=wfTokenRingCmdTimeouts, wfDs3TimeElapsed=wfDs3TimeElapsed, wfSnmpUseLock=wfSnmpUseLock, wfVinesIfX25VCLine=wfVinesIfX25VCLine, wfFddiMacGroup=wfFddiMacGroup, wfOspfIfIpAddress=wfOspfIfIpAddress, wfBrSrBaseGroupLanId=wfBrSrBaseGroupLanId, wfIpRfOspfExportAddress=wfIpRfOspfExportAddress, wfVinesRtpRtNetid=wfVinesRtpRtNetid, wfXnsBaseRouteMetric=wfXnsBaseRouteMetric, wfSyncClkSpeed=wfSyncClkSpeed, wfModIlacc1=wfModIlacc1, wfAppleRtmpState=wfAppleRtmpState, wfSipL2SequenceNumberErrors=wfSipL2SequenceNumberErrors, wfIpRfRipExportCreate=wfIpRfRipExportCreate, wfIpInterfaceEnetArpEncaps=wfIpInterfaceEnetArpEncaps, wfIpxInterfaceSplit=wfIpxInterfaceSplit, wfIpInterfaceOutRequests=wfIpInterfaceOutRequests, wfDs3FeIntervalEntry=wfDs3FeIntervalEntry, wfDs1FeTotalSEFs=wfDs1FeTotalSEFs, wfIpBase=wfIpBase, wfXnsInterfaceFRMcast=wfXnsInterfaceFRMcast, wfIpxSapServLvlDelete=wfIpxSapServLvlDelete, wfHssiRxFrames=wfHssiRxFrames, wfFDDISmtTNotify=wfFDDISmtTNotify, wfIpxSapNetLvlIntf=wfIpxSapNetLvlIntf, wfivCircuitCommonState=wfivCircuitCommonState, wfivCircuitCreateDelete=wfivCircuitCreateDelete, wfHwBootPromSource=wfHwBootPromSource, wfApplePortZipOutZipQueries=wfApplePortZipOutZipQueries, wfHssiService=wfHssiService, wfVinesTrafficFilterStatus=wfVinesTrafficFilterStatus, wfApplePortZipInGetLocalZones=wfApplePortZipInGetLocalZones, wfModFramer1=wfModFramer1, wfT1LineBuildout=wfT1LineBuildout, wfSyncExtendedAddress=wfSyncExtendedAddress, wfIpxBaseSapEntry=wfIpxBaseSapEntry, wfSyncRejectsTx=wfSyncRejectsTx, wfBrTpInterfaceCircuit=wfBrTpInterfaceCircuit, wfIpBaseRouteMetric1=wfIpBaseRouteMetric1, wfSnmpCommIndex=wfSnmpCommIndex, wfDs3CurrentSESs=wfDs3CurrentSESs, wfVinesIfX25VCPktsOut=wfVinesIfX25VCPktsOut, wfivAreaState=wfivAreaState, wfFDDIMacTMin=wfFDDIMacTMin, wfTokenRingAdapterChecks=wfTokenRingAdapterChecks, wfTokenRingLostFrameErrors=wfTokenRingLostFrameErrors, wfHssiInternalClkTestMode=wfHssiInternalClkTestMode, wfVinesNameSubNetid=wfVinesNameSubNetid, wfKernelBuffersFree=wfKernelBuffersFree, wfIpTrafficFilterInterface=wfIpTrafficFilterInterface, wfBrStpInterfacePriority=wfBrStpInterfacePriority, wfTokenRingSignalLosses=wfTokenRingSignalLosses, wfDs1FeIntervalBPVs=wfDs1FeIntervalBPVs, wfSyncMtu=wfSyncMtu, wfDs1FeTotalESs=wfDs1FeTotalESs, wfSnmpCommAccess=wfSnmpCommAccess, wfVinesIfInErrs=wfVinesIfInErrs, wfTokenRingTxCmplProcessings=wfTokenRingTxCmplProcessings, wfKernelMemOwnerTask2Size=wfKernelMemOwnerTask2Size, wfSyncUnderFlowTx=wfSyncUnderFlowTx, wfOspfVirtIfTxHellos=wfOspfVirtIfTxHellos, wfBrStpHoldTime=wfBrStpHoldTime, wfFrCircuitNumber=wfFrCircuitNumber, wfOspfAreaDelete=wfOspfAreaDelete, wfOspfVirtNbrState=wfOspfVirtNbrState, wfIpInterfaceCfgBcastAddr=wfIpInterfaceCfgBcastAddr, wfTokenRingAutoRemovalErrors=wfTokenRingAutoRemovalErrors, wfFDDIHostErr=wfFDDIHostErr, wfDs1ZeroCoding=wfDs1ZeroCoding, wfKernelBufOwnerTask4Bufs=wfKernelBufOwnerTask4Bufs, wfDs1CurrentSEFs=wfDs1CurrentSEFs, wfHwfLineNumber=wfHwfLineNumber, wfivLevel1RouteNodeAddr=wfivLevel1RouteNodeAddr, wfIpInterfaceInHdrErrors=wfIpInterfaceInHdrErrors, wfivAreaNextNode=wfivAreaNextNode, wfDs1FeIntervalSEFs=wfDs1FeIntervalSEFs, wfModCamAUnlock=wfModCamAUnlock, wfIpxSrDelete=wfIpxSrDelete, wfApplePortDdpNoProtocolHandlers=wfApplePortDdpNoProtocolHandlers, wfIpInterfaceUdpXsumOn=wfIpInterfaceUdpXsumOn, wfSipL2PayloadLengthErrors=wfSipL2PayloadLengthErrors, wfModMadr1=wfModMadr1, wfIpBaseNetToMediaPhysAddress=wfIpBaseNetToMediaPhysAddress, wfSmdsCircuitID=wfSmdsCircuitID, wfVinesNameDelete=wfVinesNameDelete, wfIpxTrafficFilterFragment=wfIpxTrafficFilterFragment, wfVinesIfEchoInPkts=wfVinesIfEchoInPkts, wfCSMACDBablErrorTx=wfCSMACDBablErrorTx, wfApplePortDdpChecksumErrors=wfApplePortDdpChecksumErrors, wfApplePortZipOutGetNetInfos=wfApplePortZipOutGetNetInfos, wfCctOptsLowPriorityQueueLimit=wfCctOptsLowPriorityQueueLimit, wfCctOptsNormalQHighWaterPkts=wfCctOptsNormalQHighWaterPkts, wfBrStpBridgeForwardDelay=wfBrStpBridgeForwardDelay, wfBrSrIpEncapsIpAddress=wfBrSrIpEncapsIpAddress, wfFDDIHardwareFilter=wfFDDIHardwareFilter, wfSnmpLockAddress=wfSnmpLockAddress, wfSnmpCommTable=wfSnmpCommTable, wfTokenRingTransmitBeacons=wfTokenRingTransmitBeacons, wfIfDescr=wfIfDescr, wfDs1FeTotalEntry=wfDs1FeTotalEntry, wfivTrafficFilterTable=wfivTrafficFilterTable, wfSysDescr=wfSysDescr, wfUserLoginErrors=wfUserLoginErrors, wfFrCircuitExcessBurst=wfFrCircuitExcessBurst, wfBrSrTrafficFilterReserved=wfBrSrTrafficFilterReserved, wfTokenRingTxClipFrames=wfTokenRingTxClipFrames, wfDs3LineType=wfDs3LineType, wfDs3FarEndFacilityIDCode=wfDs3FarEndFacilityIDCode, wfXnsBaseRtEntry=wfXnsBaseRtEntry, wfCctOptsLengthBasedLessThanQ=wfCctOptsLengthBasedLessThanQ, wfKernelMemOwnerTask1Size=wfKernelMemOwnerTask1Size, wfHwDiagPromSource=wfHwDiagPromSource, wfDs3FeIntervalESs=wfDs3FeIntervalESs, wfE1FrameErrs=wfE1FrameErrs, wfIpxSrDisable=wfIpxSrDisable, wfENETIILoad=wfENETIILoad, wfIpxInterfaceTrEndStation=wfIpxInterfaceTrEndStation, wfVinesIpTotIn=wfVinesIpTotIn, wfXnsTrafficFilterInterface=wfXnsTrafficFilterInterface, wfHssiLinkInterface=wfHssiLinkInterface, wfIpxSapNetLvlFilter=wfIpxSapNetLvlFilter, wfTokenRingAriFciErrors=wfTokenRingAriFciErrors, wfSyncRtsEnable=wfSyncRtsEnable, wfIpBaseNetToMediaIfIndex=wfIpBaseNetToMediaIfIndex, wfIpxBaseRtEntry=wfIpxBaseRtEntry, wfSnmpOutReadOnlys=wfSnmpOutReadOnlys, wfDs1FeIntervalSESs=wfDs1FeIntervalSESs, wfIfNumber=wfIfNumber, wfCSMACDUfloTx=wfCSMACDUfloTx, wfVinesIpRoutedHWM=wfVinesIpRoutedHWM, wfCctOptsIpFilterEntry=wfCctOptsIpFilterEntry, wfIpRfRipImportRipInterface=wfIpRfRipImportRipInterface, wfXnsInterfaceExServNetwork=wfXnsInterfaceExServNetwork, wfIpInterfaceReasmFails=wfIpInterfaceReasmFails, wfOspfVirtNbrRtrId=wfOspfVirtNbrRtrId, wfFddiSmtCct=wfFddiSmtCct, wfModSlot=wfModSlot, wfArpIntfEntry=wfArpIntfEntry, wfXnsInterfaceMacAddress=wfXnsInterfaceMacAddress, wfXnsStaticRouteEntry=wfXnsStaticRouteEntry, wfT1IILoad=wfT1IILoad, wfModHlsrData=wfModHlsrData, wfSyncMediaType=wfSyncMediaType, wfVinesIfArpInQueries=wfVinesIfArpInQueries, wfivTrafficFilterEnable=wfivTrafficFilterEnable, wfIpxBaseSapAge=wfIpxBaseSapAge, wfIpInterfaceIcmpOutAddrMaskReps=wfIpInterfaceIcmpOutAddrMaskReps, wfCctOptsMaxHighPriorityQueueLatency=wfCctOptsMaxHighPriorityQueueLatency, wfIpxAhNextHopIntf=wfIpxAhNextHopIntf, wfConsole=wfConsole, wfTokenRingOutErrors=wfTokenRingOutErrors, wfCSMACDMadr=wfCSMACDMadr, wfOspfIfState=wfOspfIfState, wfCctOptsBrFilterCounter=wfCctOptsBrFilterCounter, wfFrCircuitDrops=wfFrCircuitDrops, wfKernelMemOwnerTask10Size=wfKernelMemOwnerTask10Size, wfAppleZipZoneName=wfAppleZipZoneName, wfSyncMadr=wfSyncMadr, wfDecGroup=wfDecGroup, wfVinesIfIcpInErrorNotifs=wfVinesIfIcpInErrorNotifs, wfDs3FeIntervalIndex=wfDs3FeIntervalIndex, wfVinesIfX25VCSlot=wfVinesIfX25VCSlot, wfSysServices=wfSysServices, wfModMk50253=wfModMk50253, wfSyncRxOctets=wfSyncRxOctets, wfivCircuitDesigRouterNodeAddr=wfivCircuitDesigRouterNodeAddr, wfIpBaseRouteType=wfIpBaseRouteType, wfSnmpOutGetRequests=wfSnmpOutGetRequests, wfDs1Config=wfDs1Config, wfOspfNbrPriority=wfOspfNbrPriority, wfApplePortZipInZipQueries=wfApplePortZipInZipQueries, wfivStaticAdjCreateDelete=wfivStaticAdjCreateDelete, wfDs3IntervalEntry=wfDs3IntervalEntry, wfIpxRipInterfaceState=wfIpxRipInterfaceState, wfDs3TotalSEFs=wfDs3TotalSEFs, wfFddiPortTable=wfFddiPortTable, wfKernelMemOwnerTask7=wfKernelMemOwnerTask7, wfE1RcvUnfrm1s=wfE1RcvUnfrm1s, wfKernelBufOwnerTask7=wfKernelBufOwnerTask7, wfCctOptsHiXmits=wfCctOptsHiXmits, wfOspfGeneralDelete=wfOspfGeneralDelete, wfBrTpInterfaceInDiscards=wfBrTpInterfaceInDiscards, wfIpxNetBiosSrName=wfIpxNetBiosSrName, wfCctOptsHighPriorityQueueLimit=wfCctOptsHighPriorityQueueLimit, wfDs3FeCurrent=wfDs3FeCurrent, wfOspfVirtIfTxLinkStateAcks=wfOspfVirtIfTxLinkStateAcks, wfCctOptsLoQHighWaterPkts=wfCctOptsLoQHighWaterPkts, wfIpxInterfaceInDiscards=wfIpxInterfaceInDiscards, wfBrTrafficFilterRuleNumber=wfBrTrafficFilterRuleNumber, wfIpSrIpNetMask=wfIpSrIpNetMask, wfVinesNameDisable=wfVinesNameDisable, wfModElmA1=wfModElmA1, wfXnsSrTargNetworkRt=wfXnsSrTargNetworkRt, wfVinesIfArpInAssgReqs=wfVinesIfArpInAssgReqs, wfTftpInWRQ=wfTftpInWRQ, wfBrStpInterfaceState=wfBrStpInterfaceState, wfVinesIfX25VCPktsAwaitAck=wfVinesIfX25VCPktsAwaitAck, wfKernelBufOwnerTask3Bufs=wfKernelBufOwnerTask3Bufs, wfXnsInterfaceIndex=wfXnsInterfaceIndex, wfAppleBase=wfAppleBase, wfApplePortEchoReplies=wfApplePortEchoReplies)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfOspfNbrIfAddr=wfOspfNbrIfAddr, wfIpInterfaceIcmpInParmProbs=wfIpInterfaceIcmpInParmProbs, wfivCircuitCountL1UpdRcvd=wfivCircuitCountL1UpdRcvd, wfVinesIpRouted=wfVinesIpRouted, wfApplePortRtmpNextIRLessChanges=wfApplePortRtmpNextIRLessChanges, wfHwBootPromRev=wfHwBootPromRev, wfBrStpInterfacePathCost=wfBrStpInterfacePathCost, wfSnmpInTotalSetVars=wfSnmpInTotalSetVars, wfivCircuitCountAreaUpdSent=wfivCircuitCountAreaUpdSent, wfDSDEIILoad=wfDSDEIILoad, wfDs1FeCurrentBPVs=wfDs1FeCurrentBPVs, wfivAdjBlockSize=wfivAdjBlockSize, wfHssiTxRingLength=wfHssiTxRingLength, wfOspfDynNbrEvents=wfOspfDynNbrEvents, wfIpRfRipImportRipGateway=wfIpRfRipImportRipGateway, wfIpInterfaceIcmpOutTimestamps=wfIpInterfaceIcmpOutTimestamps, wfVinesNameHost=wfVinesNameHost, wfSnmpCommDelete=wfSnmpCommDelete, wfApplePortState=wfApplePortState, wfHssiRxRingOverruns=wfHssiRxRingOverruns, wfOspfLsdbAge=wfOspfLsdbAge, wfPrompt=wfPrompt, wfBrTrafficFilterFragment=wfBrTrafficFilterFragment, wfIpxBaseSapNetwork=wfIpxBaseSapNetwork, wfAppleZipEntry=wfAppleZipEntry, wfDs3IntervalSESs=wfDs3IntervalSESs, wfHssiLastRxErrorCtrl=wfHssiLastRxErrorCtrl, wfIpxBaseSapHops=wfIpxBaseSapHops, wfIPROTOLoad=wfIPROTOLoad, wfDs3IntervalBPVs=wfDs3IntervalBPVs, wfIpInterfaceReasmMaxSize=wfIpInterfaceReasmMaxSize, wfVinesIpBad=wfVinesIpBad, wfHssiTxCmplProcessings=wfHssiTxCmplProcessings, wfApplePortNetEnd=wfApplePortNetEnd, wfBrSrEsRifProtocol=wfBrSrEsRifProtocol, wfivLevel1RouteEntry=wfivLevel1RouteEntry, wfBrSrEsRifMacAddr=wfBrSrEsRifMacAddr, wfSyncCrcSize=wfSyncCrcSize, wellfleet=wellfleet, wfBrSrIpExplorerEntry=wfBrSrIpExplorerEntry, wfApplePortZipZoneConflictErrors=wfApplePortZipZoneConflictErrors, wfHssiTxUnderruns=wfHssiTxUnderruns, wfivCircuitID=wfivCircuitID, wfIpInterfaceIcmpInAddrMasks=wfIpInterfaceIcmpInAddrMasks, wfBootpGroup=wfBootpGroup, wfIpBaseRouteMask=wfIpBaseRouteMask, wfWanGroup=wfWanGroup, wfSipL2EomsMIDErrors=wfSipL2EomsMIDErrors, wfIpxStaticRouteTable=wfIpxStaticRouteTable, wfIpInterfaceMTUDiscovery=wfIpInterfaceMTUDiscovery, wfBrSrTrafficFilterTable=wfBrSrTrafficFilterTable, wfSnmpInSetRequests=wfSnmpInSetRequests, wfDs1Current=wfDs1Current, wfVinesBaseState=wfVinesBaseState, wfIpInterfaceOutNoRoutes=wfIpInterfaceOutNoRoutes, wfIpxStaticRouteEntry=wfIpxStaticRouteEntry, wfCctOptsEntry=wfCctOptsEntry, wfEgpGroup=wfEgpGroup, wfModTms3801=wfModTms3801, wfXnsAhTargHostId=wfXnsAhTargHostId, wfT1MiniDacs=wfT1MiniDacs, wfT1ClockMode=wfT1ClockMode, wfCSMACDTxClipFrames=wfCSMACDTxClipFrames, wfCircuitNumber=wfCircuitNumber, wfModState=wfModState, wfFrDlcmiState=wfFrDlcmiState, wfApplePortEntry=wfApplePortEntry, wfDs3ConfigEntry=wfDs3ConfigEntry, wfTiRui=wfTiRui, wfOspfIfAuthKey=wfOspfIfAuthKey, wfIfInOctets=wfIfInOctets, wfivRouteBroadcastRouteTimer=wfivRouteBroadcastRouteTimer, wfDs3LineStatus=wfDs3LineStatus, wfKernelMemOwnerTask5=wfKernelMemOwnerTask5, wfBrSrTrafficFilterDefinition=wfBrSrTrafficFilterDefinition, wfE1Table=wfE1Table, wfBrStpInterfaceDelete=wfBrStpInterfaceDelete, wfCSMACDOfloRx=wfCSMACDOfloRx, wfivRouteGroup=wfivRouteGroup, wfTftpOutWRQ=wfTftpOutWRQ, wfModHssiFsi1=wfModHssiFsi1, wfVinesRtpNbrNetId=wfVinesRtpNbrNetId, wfAppleRtmpEntry=wfAppleRtmpEntry, wfVinesIpFromDodIP=wfVinesIpFromDodIP, wfModDefaA=wfModDefaA, wfXnsInterfaceExServHostId=wfXnsInterfaceExServHostId, wfFDDIPortOpErr=wfFDDIPortOpErr, wfIpxRipInterfaceDelete=wfIpxRipInterfaceDelete, wfOSILoad=wfOSILoad, wfivCircuitRouterPri=wfivCircuitRouterPri, wfBrStpInterfacePktsXmitd=wfBrStpInterfacePktsXmitd, wfBrSrTrafficFilterEnable=wfBrSrTrafficFilterEnable, wfCSMACDLackRescErrorRx=wfCSMACDLackRescErrorRx, wfOspfIfEntry=wfOspfIfEntry, wfSnmpCommEntry=wfSnmpCommEntry, wfIpBaseHostEntryTable=wfIpBaseHostEntryTable, wfParity=wfParity, wfSnmpMgrTrapPort=wfSnmpMgrTrapPort, wfIpStaticRouteEntry=wfIpStaticRouteEntry, wfHssiCrcSize=wfHssiCrcSize, wfSyncDelete=wfSyncDelete, wfDs3Group=wfDs3Group, wfAppleBaseTotalNets=wfAppleBaseTotalNets, wfArpBaseForwarding=wfArpBaseForwarding, wfHssiMtu=wfHssiMtu, wfBrSrBridgeTable=wfBrSrBridgeTable, wfRipGroup=wfRipGroup, wfBrSrTrafficFilterStatus=wfBrSrTrafficFilterStatus, wfIpBaseRouteDest=wfIpBaseRouteDest, wfAppleRtmpHops=wfAppleRtmpHops, wfFrDlcmiMulticast=wfFrDlcmiMulticast, wfIfType=wfIfType, wfTftpOutFiles=wfTftpOutFiles, wfCctOptsLengthBasedData=wfCctOptsLengthBasedData, wfBrSrBridgeEntry=wfBrSrBridgeEntry, wfDs1FeTotalCVs=wfDs1FeTotalCVs, wfOspfVirtIfRxLinkStateUpds=wfOspfVirtIfRxLinkStateUpds, wfivCircuitCountTransitPksRecd=wfivCircuitCountTransitPksRecd, wfE1Disable=wfE1Disable, wfIpTrafficFilterEnable=wfIpTrafficFilterEnable, wfDs3IntervalESs=wfDs3IntervalESs, wfTcpGroup=wfTcpGroup, wfSnmpInBadValues=wfSnmpInBadValues, wfModLance1=wfModLance1, wfVinesIfInPkts=wfVinesIfInPkts, wfKernelTimersActive=wfKernelTimersActive, wfSmdsCircuitDisableNetMgmt=wfSmdsCircuitDisableNetMgmt, wfivStaticAdjTable=wfivStaticAdjTable, wfivRouteType=wfivRouteType, wfApplePortZipInGetZoneLists=wfApplePortZipInGetZoneLists, wfIpStaticRouteTable=wfIpStaticRouteTable, wfIpxSapNetLvlDelete=wfIpxSapNetLvlDelete, wfVinesArpDelete=wfVinesArpDelete, wfCSMACDDelete=wfCSMACDDelete, wfHwBpIdOpt=wfHwBpIdOpt, wfIpBaseRouteMetric3=wfIpBaseRouteMetric3, wfIpInterfaceIcmpInRedirects=wfIpInterfaceIcmpInRedirects, wfSnmpInBadVersions=wfSnmpInBadVersions, wfHssiInternOpErrors=wfHssiInternOpErrors, wfVinesBaseDisable=wfVinesBaseDisable, wfKernelTasksTotal=wfKernelTasksTotal, wfVinesIfDisable=wfVinesIfDisable, wfOspfVirtIfHelloInterval=wfOspfVirtIfHelloInterval, wfCctOptsBrFilterReserved=wfCctOptsBrFilterReserved, wfIpxInterfaceMacAddress=wfIpxInterfaceMacAddress, wfFrDlcmiManagementType=wfFrDlcmiManagementType, wfFrDlcmiPolls=wfFrDlcmiPolls, wfIpTrafficFilterReserved=wfIpTrafficFilterReserved, wfIpRfRipExportAddress=wfIpRfRipExportAddress, wfOspfImportSum=wfOspfImportSum, wfFrCircuitSubCct=wfFrCircuitSubCct, wfCircuitName=wfCircuitName, wfSyncXid=wfSyncXid, wfivRouteMaxBdcastNonRouters=wfivRouteMaxBdcastNonRouters, wfSysGmtOffset=wfSysGmtOffset, wfIpInterfaceTrEndStation=wfIpInterfaceTrEndStation, wfVinesIpTotOut=wfVinesIpTotOut, wfCctOptsLengthBasedCct=wfCctOptsLengthBasedCct, wfAppleZipZoneState=wfAppleZipZoneState, wfBrSrEsRifRoute=wfBrSrEsRifRoute, wfIpxInterfaceState=wfIpxInterfaceState, wfFDDIRingErrRx=wfFDDIRingErrRx, wfDs1FeIntervalESs=wfDs1FeIntervalESs, wfIpxBaseDisable=wfIpxBaseDisable, wfOspfNbrDisable=wfOspfNbrDisable, wfXnsTrafficFilterDefinition=wfXnsTrafficFilterDefinition, wfIpAdjHostCreate=wfIpAdjHostCreate, wfIpBaseNetToMediaType=wfIpBaseNetToMediaType, wfHwfTable=wfHwfTable, wfIpxInterfaceInAddrErrors=wfIpxInterfaceInAddrErrors, wfFDDISmtRingOverrunRx=wfFDDISmtRingOverrunRx, wfIpInterfaceASB=wfIpInterfaceASB, wfXnsInterfaceCost=wfXnsInterfaceCost, wfT1B8ZSSupport=wfT1B8ZSSupport, wfHssiRxRingErrors=wfHssiRxRingErrors, wfBCNPwrSupply3=wfBCNPwrSupply3, wfIpInterfaceIcmpOutParmProbs=wfIpInterfaceIcmpOutParmProbs, wfivCircuitCountRtHelloRcvd=wfivCircuitCountRtHelloRcvd, wfSyncLackRescRx=wfSyncLackRescRx, wfXnsInterfaceOutNoRoutes=wfXnsInterfaceOutNoRoutes, wfFDDIMadr=wfFDDIMadr, wfSyncConnectAttempts=wfSyncConnectAttempts, wfVinesIfInMsgs=wfVinesIfInMsgs, wfCSMACDDeferredTx=wfCSMACDDeferredTx, wfArpCctno=wfArpCctno, wfOspfLsdbSequence=wfOspfLsdbSequence, wfOspfVirtNbrArea=wfOspfVirtNbrArea, wfOspfDynNbrPriority=wfOspfDynNbrPriority, wfDs1IntervalEntry=wfDs1IntervalEntry, wfIpAdjHostIpAddress=wfIpAdjHostIpAddress, wfivRouteEnableDisable=wfivRouteEnableDisable, wfApplePortDdpForwRequests=wfApplePortDdpForwRequests, wfBrSrInterfaceInFrames=wfBrSrInterfaceInFrames, wfBrTpBaseFdbAddress=wfBrTpBaseFdbAddress, wfT1SuperFrameErrs=wfT1SuperFrameErrs, wfIpxInterfaceOutDiscards=wfIpxInterfaceOutDiscards, wfModMk50254=wfModMk50254, wfVinesIfIcpOutMetricNotifs=wfVinesIfIcpOutMetricNotifs, wfHssiTxAborts=wfHssiTxAborts, wfSmdsCircuitSipL3SentIndividualDAs=wfSmdsCircuitSipL3SentIndividualDAs, wfIpxInterfaceEntry=wfIpxInterfaceEntry, wfCctOptsIpFilterDefinition=wfCctOptsIpFilterDefinition, wfIfOutQLen=wfIfOutQLen, wfOspfIfTransitDelay=wfOspfIfTransitDelay, wfHssiRxCrcErrors=wfHssiRxCrcErrors, wfDs3IntervalNumber=wfDs3IntervalNumber, wfTokenRingMadrSelect=wfTokenRingMadrSelect, wfSysMibVersion=wfSysMibVersion, wfApplePortNbpInErrors=wfApplePortNbpInErrors, wfSysUpTime=wfSysUpTime, wfOspfAreaTable=wfOspfAreaTable, wfIpxInterfaceNetbiosDeliver=wfIpxInterfaceNetbiosDeliver, wfIpxBaseNetTblSize=wfIpxBaseNetTblSize, wfIpRfOspfImportType=wfIpRfOspfImportType, wfHssiBoflLen=wfHssiBoflLen, wfCctOptsTable=wfCctOptsTable, wfXnsInterfaceExtServer=wfXnsInterfaceExtServer, wfFDDIRxReplenMisses=wfFDDIRxReplenMisses, wfIpxGroup=wfIpxGroup, wfBrStpInterfaceCircuit=wfBrStpInterfaceCircuit, wfIpTrafficFilterStatus=wfIpTrafficFilterStatus, wfTtyFrameErrors=wfTtyFrameErrors, wfModFsi1=wfModFsi1, wfDs1FeCurrentEntry=wfDs1FeCurrentEntry, wfTiRuiState=wfTiRuiState, wfTiRuiOutResultsErr=wfTiRuiOutResultsErr, wfIpRfOspfExportEntry=wfIpRfOspfExportEntry, wfE1BipolarVios=wfE1BipolarVios, wfIpxNetBiosStaticRouteTable=wfIpxNetBiosStaticRouteTable, wfTokenRingState=wfTokenRingState, wfIpAdjHostEnable=wfIpAdjHostEnable, wfTokenRingLineErrors=wfTokenRingLineErrors, wfCctOptsIpFilterTable=wfCctOptsIpFilterTable, wfSnmpLockTimeOut=wfSnmpLockTimeOut, wfOspfGeneralGroup=wfOspfGeneralGroup, wfOspfIfDrops=wfOspfIfDrops, wfApplePortRtmpRouteDeletes=wfApplePortRtmpRouteDeletes, wfVinesIfTable=wfVinesIfTable, wfVinesIfState=wfVinesIfState, wfIfMtu=wfIfMtu, wfT1FrameType=wfT1FrameType, wfApplePortGniForever=wfApplePortGniForever, wfIpInterfaceIcmpInEchoReps=wfIpInterfaceIcmpInEchoReps, wfRipInterfaceDefaultRouteSupply=wfRipInterfaceDefaultRouteSupply, wfCSMACDTxQueueLength=wfCSMACDTxQueueLength, wfBrSrBaseIpNetworkRingId=wfBrSrBaseIpNetworkRingId, wfSyncRuntsRx=wfSyncRuntsRx, wfCircuitProtoMap=wfCircuitProtoMap, wfCSMACDExcessvCollnTx=wfCSMACDExcessvCollnTx, wfivCircuitCountNodeUnrPktLoss=wfivCircuitCountNodeUnrPktLoss, wfVinesIp=wfVinesIp, wfDs1FeCurrentCVs=wfDs1FeCurrentCVs, wfVinesIfInRedirects=wfVinesIfInRedirects, wfDs1TotalSEFs=wfDs1TotalSEFs)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfHssiRxOverruns=wfHssiRxOverruns, wfTftpOutErr=wfTftpOutErr, wfivCircuitCountTransitPkSent=wfivCircuitCountTransitPkSent, wfE1Slot=wfE1Slot, wfArpGroup=wfArpGroup, wfBrStpInterfaceDesignatedBridge=wfBrStpInterfaceDesignatedBridge, wfDs1IntervalNumber=wfDs1IntervalNumber, wfCSMACDCct=wfCSMACDCct, wfModHssiUga1=wfModHssiUga1, wfAppleLclZoneIndex=wfAppleLclZoneIndex, wfFrCircuitCommittedBurst=wfFrCircuitCommittedBurst, wfFDDICrcErrRx=wfFDDICrcErrRx, wfHssiRxOctets=wfHssiRxOctets, wfIpxBaseCfgHostNumber=wfIpxBaseCfgHostNumber, wfHssiTurboBofl=wfHssiTurboBofl, wfCSMACDHardwareFilter=wfCSMACDHardwareFilter, wfDs3TotalSESs=wfDs3TotalSESs, wfivRouteRoutingVers=wfivRouteRoutingVers, wfDs1SendCode=wfDs1SendCode, wfIPXLoad=wfIPXLoad, wfivStaticAdjEnableDisable=wfivStaticAdjEnableDisable, wfDECNETLoad=wfDECNETLoad, wfVinesIfSlot=wfVinesIfSlot, wfIpxAdjacentHostEntry=wfIpxAdjacentHostEntry, wfOspfRouterId=wfOspfRouterId, wfIpInterfaceIcmpInTimestamps=wfIpInterfaceIcmpInTimestamps, wfXnsInterfaceEntry=wfXnsInterfaceEntry, wfivStaticAdjNodeid=wfivStaticAdjNodeid, wfVinesIfOutErrs=wfVinesIfOutErrs, wfIpRfOspfImportPreference=wfIpRfOspfImportPreference, wfXnsInterfaceOutDiscards=wfXnsInterfaceOutDiscards, wfCSMACDEntry=wfCSMACDEntry, wfXnsStaticRouteTable=wfXnsStaticRouteTable, wfSmdsCircuitHrtbtPollInterval=wfSmdsCircuitHrtbtPollInterval, wfIpInterfaceIcmpInSrcQuenchs=wfIpInterfaceIcmpInSrcQuenchs, wfSnmpTrapWarn=wfSnmpTrapWarn, wfIpxTrafficFilterCreate=wfIpxTrafficFilterCreate, wfCctOptsIpFilterCreate=wfCctOptsIpFilterCreate, wfT1Disable=wfT1Disable, wfE1IILoad=wfE1IILoad, wfIfAdminStatus=wfIfAdminStatus, wfSnmpTrapFault=wfSnmpTrapFault, wfSyncWindowSizeTx=wfSyncWindowSizeTx, wfTokenRingMadr=wfTokenRingMadr, wfXnsTrafficFilterCounter=wfXnsTrafficFilterCounter, wfTelnetGroup=wfTelnetGroup, wfSysName=wfSysName, wfXnsBaseRouteAge=wfXnsBaseRouteAge, wfModSicr=wfModSicr, wfApplePortAarpRspTxs=wfApplePortAarpRspTxs, wfIpBaseRouteAge=wfIpBaseRouteAge, wfKernelMemOwnerTask1=wfKernelMemOwnerTask1, wfModIlacc2=wfModIlacc2, wfVinesRtpNbrLocSlot=wfVinesRtpNbrLocSlot, wfFrDlcmiAddressLen=wfFrDlcmiAddressLen, wfArpBaseEnable=wfArpBaseEnable, wfVinesTrafficFilterCircuit=wfVinesTrafficFilterCircuit, wfOspfAreaDisable=wfOspfAreaDisable, wfIpxNetBiosSrIntf=wfIpxNetBiosSrIntf, wfIpRfRipImportEntry=wfIpRfRipImportEntry, wfSnmpMgrAddress=wfSnmpMgrAddress, wfSysObjectID=wfSysObjectID, wfIfOperStatus=wfIfOperStatus, wfRipInterfaceDefaultRouteListen=wfRipInterfaceDefaultRouteListen, wfSmdsCircuitSipL3SentGAs=wfSmdsCircuitSipL3SentGAs, wfVinesIfAdr=wfVinesIfAdr, wfSyncExtendedControl=wfSyncExtendedControl, wfIpInterfaceFRMcast1Dlci=wfIpInterfaceFRMcast1Dlci, wfVinesArpSubnetid=wfVinesArpSubnetid, wfOspfVirtIfRxLinkStateReqs=wfOspfVirtIfRxLinkStateReqs, wfApplePortNbpInLookUpRequests=wfApplePortNbpInLookUpRequests, wfAppleLclZoneEntry=wfAppleLclZoneEntry, wfDs3FarEndUnitCode=wfDs3FarEndUnitCode, wfIpInterfaceHostCache=wfIpInterfaceHostCache, wfModIdOpt=wfModIdOpt, wfIpSrIpAddressRt=wfIpSrIpAddressRt, wfIpRfRipExportAction=wfIpRfRipExportAction, wfDs1LineStatus=wfDs1LineStatus, wfivCircuitCountL1UpdSent=wfivCircuitCountL1UpdSent, wfXnsBaseRouteNextHopHost=wfXnsBaseRouteNextHopHost, wfE1Delete=wfE1Delete, wfHwDaughterBdRev=wfHwDaughterBdRev, wfCSMACDOctetsRxOk=wfCSMACDOctetsRxOk, wfTokenRingDisable=wfTokenRingDisable, wfCctOptsLengthBasedDelete=wfCctOptsLengthBasedDelete, wfDTLoad=wfDTLoad, wfivStaticAdjEntry=wfivStaticAdjEntry, wfIpxInterfaceInReceives=wfIpxInterfaceInReceives, wfIpBaseNetToMediaNetAddress=wfIpBaseNetToMediaNetAddress, wfModMk50252=wfModMk50252, wfTokenRingConnector=wfTokenRingConnector, wfBrStpHelloTime=wfBrStpHelloTime, wfFrCircuitReceivedFECNs=wfFrCircuitReceivedFECNs, wfIpxTrafficFilterReserved=wfIpxTrafficFilterReserved, wfivCircuitNodeAddr=wfivCircuitNodeAddr, wfHwBabyBdRev=wfHwBabyBdRev, wfApplePortNbpInLookUpReplies=wfApplePortNbpInLookUpReplies, wfSpanningTree=wfSpanningTree, wfModCamBLock=wfModCamBLock, wfVinesRtpNbrCost=wfVinesRtpNbrCost, wfOspfIfRxLinkStateUpds=wfOspfIfRxLinkStateUpds, wfIpInterfaceIcmpOutErrors=wfIpInterfaceIcmpOutErrors, wfOspfIfTxLinkStateUpds=wfOspfIfTxLinkStateUpds, wfFddiMacTable=wfFddiMacTable, wfDs1CurrentIndex=wfDs1CurrentIndex, wfDs1CurrentSESs=wfDs1CurrentSESs, wfIpSrValid=wfIpSrValid, wfVinesIfX25VC=wfVinesIfX25VC, wfTokenRingLobeWireFaults=wfTokenRingLobeWireFaults, wfIfGroup=wfIfGroup, wfKernelBufOwnerTask10Bufs=wfKernelBufOwnerTask10Bufs, wfDs1Interval=wfDs1Interval, wfCctOptsIpFilterCct=wfCctOptsIpFilterCct, wfTokenRingRxProcessings=wfTokenRingRxProcessings, wfVinesRtpRtNumber=wfVinesRtpRtNumber, wfIpSrPreference=wfIpSrPreference, wfT1RcvRedAlarms=wfT1RcvRedAlarms, wfSyncTxFrames=wfSyncTxFrames, wfE1MfsErrs=wfE1MfsErrs, wfApplePortDdpInReceives=wfApplePortDdpInReceives, wfOspfAreaBdrRtrStatus=wfOspfAreaBdrRtrStatus, wfTokenRingLastAdapterCheckCode=wfTokenRingLastAdapterCheckCode, wfFrDlcmiAddress=wfFrDlcmiAddress, wfIpxTrafficFilterDefinition=wfIpxTrafficFilterDefinition, wfHssiOutErrors=wfHssiOutErrors, wfIpInterfaceIcmpOutTimestampReps=wfIpInterfaceIcmpOutTimestampReps, wfHwMotherBdIdOpt=wfHwMotherBdIdOpt, wfCSMACDFramesRxOk=wfCSMACDFramesRxOk, wfApplePortMacAddress=wfApplePortMacAddress, wfDs3FeCurrentEntry=wfDs3FeCurrentEntry, wfTokenRingRxOctets=wfTokenRingRxOctets, wfAppleAarpNet=wfAppleAarpNet, wfXnsAdjacentHostTable=wfXnsAdjacentHostTable, wfDs1IntervalCVs=wfDs1IntervalCVs, wfIpxRipIntfEntry=wfIpxRipIntfEntry, wfIpInterfaceReasmReqds=wfIpInterfaceReasmReqds, wfHssiMadr=wfHssiMadr, wfCctOptsLengthBasedState=wfCctOptsLengthBasedState, wfOspfGeneralState=wfOspfGeneralState, wfVinesTrafficFilterEnable=wfVinesTrafficFilterEnable, wfApplePortNbpOutBroadcastRequests=wfApplePortNbpOutBroadcastRequests, wfIpxInterfaceSMDSGroupAddress=wfIpxInterfaceSMDSGroupAddress, wfHssiEntry=wfHssiEntry, wfApplePortTable=wfApplePortTable, wfSyncTxErrors=wfSyncTxErrors, wfOspfIfRxLinkStateReqs=wfOspfIfRxLinkStateReqs, wfIpSrCreate=wfIpSrCreate, wfIpInterfaceIcmpOutAddrMasks=wfIpInterfaceIcmpOutAddrMasks, wfCctOptsIpFilterEnable=wfCctOptsIpFilterEnable, wfSnmpTrapInfo=wfSnmpTrapInfo, wfFddiPortSlot=wfFddiPortSlot, wfXnsBaseDisable=wfXnsBaseDisable, wfHssiMemPageLength=wfHssiMemPageLength, wfBrTp=wfBrTp, wfVinesArpSubnetBlock=wfVinesArpSubnetBlock, wfOspfIfTxLinkStateAcks=wfOspfIfTxLinkStateAcks, wfIpRfRipExportMask=wfIpRfRipExportMask, wfVinesRtpRtTable=wfVinesRtpRtTable, wfFrDlcmiPollingInterval=wfFrDlcmiPollingInterval, wfBrSrInterfaceRing=wfBrSrInterfaceRing, wfIpInterfaceIcmpOutEchos=wfIpInterfaceIcmpOutEchos, wfOspfVirtIfDisable=wfOspfVirtIfDisable, wfDs3FarEndFrameIDCode=wfDs3FarEndFrameIDCode, wfBrSrInterfaceOutIpFrames=wfBrSrInterfaceOutIpFrames, wfSmdsCircuitSipL3ReceivedGAs=wfSmdsCircuitSipL3ReceivedGAs, wfKernelMemorySegsTotal=wfKernelMemorySegsTotal, wfHssiInDiscards=wfHssiInDiscards, wfOspfSpfHoldDown=wfOspfSpfHoldDown, wfXnsAdjacentHostEntry=wfXnsAdjacentHostEntry, wfOspfDynNbrOptions=wfOspfDynNbrOptions, wfivStaticAdjType=wfivStaticAdjType, wfIpxBaseActiveHostNumber=wfIpxBaseActiveHostNumber, wfIpRfRipExportFromProtocol=wfIpRfRipExportFromProtocol, wfInternet=wfInternet, wfXnsAhNextHopIntf=wfXnsAhNextHopIntf, wfCctOptsHiClippedPkts=wfCctOptsHiClippedPkts, wfVinesIfOutRedirects=wfVinesIfOutRedirects, wfSmdsCircuitState=wfSmdsCircuitState, wfKernelBufOwnerTask5Bufs=wfKernelBufOwnerTask5Bufs, wfSnmpMgrDelete=wfSnmpMgrDelete, wfSysLocation=wfSysLocation, wfIpxTrafficFilterCounter=wfIpxTrafficFilterCounter, wfVinesNameEntry=wfVinesNameEntry, wfBrSrBaseIpInReceives=wfBrSrBaseIpInReceives, wfivCircuitNodeid=wfivCircuitNodeid, wfSyncWanProtocol=wfSyncWanProtocol, wfFddiSmtEcmState=wfFddiSmtEcmState, wfRipInterfaceEnable=wfRipInterfaceEnable, wfIpInterfaceFRBcastDlci=wfIpInterfaceFRBcastDlci, wfDs3CurrentBPVs=wfDs3CurrentBPVs, wfIpxRipInterfaceDisable=wfIpxRipInterfaceDisable, wfQENETLoad=wfQENETLoad, wfFddiPortEntry=wfFddiPortEntry, wfDs1CurrentUASs=wfDs1CurrentUASs, wfHssiTxProcessings=wfHssiTxProcessings, wfOspfVirtNbrOptions=wfOspfVirtNbrOptions, wfSnmpOutTooBigs=wfSnmpOutTooBigs, wfIpxSapServLvlType=wfIpxSapServLvlType, wfFddiSmtStationId=wfFddiSmtStationId, wfIpxBaseRtEntryTable=wfIpxBaseRtEntryTable, wfKernelMemOwnerTask8=wfKernelMemOwnerTask8, wfFrCircuitLastTimeChange=wfFrCircuitLastTimeChange, wfTokenRingRxHostIntErrors=wfTokenRingRxHostIntErrors, wfFNSDSELoad=wfFNSDSELoad, wfTokenRingCfgMadr=wfTokenRingCfgMadr, wfHssiTransmissionInterface=wfHssiTransmissionInterface, wfIpxInterfaceOutRequests=wfIpxInterfaceOutRequests, wfIpRfRipExportEnable=wfIpRfRipExportEnable, wfHssiHostErrors=wfHssiHostErrors, wfAppleAarpIfIndex=wfAppleAarpIfIndex, wfHssiCct=wfHssiCct, wfSmdsCircuitSipL3VersionSupport=wfSmdsCircuitSipL3VersionSupport, wfVinesIfFwdDrops=wfVinesIfFwdDrops, wfOspfAreaRangeDisable=wfOspfAreaRangeDisable, wfHssiLastRxRingState=wfHssiLastRxRingState, wfRipIntfTable=wfRipIntfTable, wfFrDlcmiAlarmTimer=wfFrDlcmiAlarmTimer, wfIpInterfaceIcmpInErrors=wfIpInterfaceIcmpInErrors, wfSipDs3PlcpUASs=wfSipDs3PlcpUASs, wfSys=wfSys, wfBrSrBaseDelete=wfBrSrBaseDelete, wfHssiBofl=wfHssiBofl, wfFddiTable=wfFddiTable, wfIpxInterfaceDelete=wfIpxInterfaceDelete, wfBrSrInterfaceEntry=wfBrSrInterfaceEntry, wfVinesIfX25VCBytesAwaitAck=wfVinesIfX25VCBytesAwaitAck, wfIpInterfaceAddressResolutionType=wfIpInterfaceAddressResolutionType, wfFrCircuitDiscards=wfFrCircuitDiscards, wfTftpInRRQ=wfTftpInRRQ, wfOspfAreaRangeNet=wfOspfAreaRangeNet, wfBrStpBridgeID=wfBrStpBridgeID, wfSnmpInPkts=wfSnmpInPkts, wfSyncRetryTimer=wfSyncRetryTimer, wfXnsBaseRouteInfo=wfXnsBaseRouteInfo, wfXnsGroup=wfXnsGroup, wfFrDlcmiStatus=wfFrDlcmiStatus, wfOspfNbrLSRetransQLen=wfOspfNbrLSRetransQLen, wfTtyParityErrors=wfTtyParityErrors, wfCctOptsLengthBasedTable=wfCctOptsLengthBasedTable, wfBrSrInterfaceOutFrames=wfBrSrInterfaceOutFrames, wfivAdjCircuitID=wfivAdjCircuitID, wfDs1IntervalBPVs=wfDs1IntervalBPVs, wfOspfVirtIfAreaID=wfOspfVirtIfAreaID, wfIpRfRipImportEnable=wfIpRfRipImportEnable, wfSyncRxFrames=wfSyncRxFrames, wfVinesIfArpInErrors=wfVinesIfArpInErrors, wfHwBabyBdIdOpt=wfHwBabyBdIdOpt, wfApplePortDdpTooLongErrors=wfApplePortDdpTooLongErrors, wfIpRfOspfImportEnable=wfIpRfOspfImportEnable, wfOspfVirtIfDelete=wfOspfVirtIfDelete, wfDs3FeCurrentCVs=wfDs3FeCurrentCVs, wfKernelMemOwnerTask2=wfKernelMemOwnerTask2, wfCircuitOptsGroup=wfCircuitOptsGroup, wfDs3CurrentIndex=wfDs3CurrentIndex)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfKernelBufOwnerTask7Bufs=wfKernelBufOwnerTask7Bufs, wfTokenRingEarlyTokenRelease=wfTokenRingEarlyTokenRelease, wfHwSparePromRev=wfHwSparePromRev, wfFDDIUnderrunTx=wfFDDIUnderrunTx, wfT1Slot=wfT1Slot, wfIpInterfaceCfgMacAddress=wfIpInterfaceCfgMacAddress, wfFrDlcmiTable=wfFrDlcmiTable, wfIpRfOspfImportAction=wfIpRfOspfImportAction, wfFrDlcmiPassiveReceived=wfFrDlcmiPassiveReceived, wfSyncMinFrameSpace=wfSyncMinFrameSpace, wfKernelBufOwnerTask9Bufs=wfKernelBufOwnerTask9Bufs, wfOspfIfDisable=wfOspfIfDisable, wfVinesArpAssignDeniedPkts=wfVinesArpAssignDeniedPkts, wfTokenRingTokenErrors=wfTokenRingTokenErrors, wfModTicr=wfModTicr, wfSmdsCircuitDisableHrtbtPoll=wfSmdsCircuitDisableHrtbtPoll, wfivCircuitCountAgedPktLoss=wfivCircuitCountAgedPktLoss, wfIpRfOspfImportTag=wfIpRfOspfImportTag, wfIpInterfaceFragFails=wfIpInterfaceFragFails, wfivCircuitAllAreaRoutersMac=wfivCircuitAllAreaRoutersMac, wfSipDs3PlcpEntry=wfSipDs3PlcpEntry, wfIpxBaseRouteIfIndex=wfIpxBaseRouteIfIndex, wfOspfDynNbrAddressLessIndex=wfOspfDynNbrAddressLessIndex, wfXnsBaseRouteDest=wfXnsBaseRouteDest, wfDrivers=wfDrivers, wfArpEnable=wfArpEnable, wfAppleBaseDdpQueLen=wfAppleBaseDdpQueLen, wfHssiTxOctets=wfHssiTxOctets, wfFDDILoad=wfFDDILoad, wfIpTrafficFilterFragment=wfIpTrafficFilterFragment, wfVinesIfArpOutServRsps=wfVinesIfArpOutServRsps, wfLANCELoad=wfLANCELoad, wfBgpGroup=wfBgpGroup, wfHwBpRev=wfHwBpRev, wfIpRfOspfImportAddress=wfIpRfOspfImportAddress, wfTokenRingSpeed=wfTokenRingSpeed, wfIpBaseRouteProto=wfIpBaseRouteProto, wfKernelMemOwnerTask8Size=wfKernelMemOwnerTask8Size, wfHwfLineState=wfHwfLineState, wfHssiBoflNum=wfHssiBoflNum, wfOspfVirtIfRxHellos=wfOspfVirtIfRxHellos, wfSnmpMgrTraps=wfSnmpMgrTraps, wfIpxBaseDelete=wfIpxBaseDelete, wfIpInterfaceIcmpOutEchoReps=wfIpInterfaceIcmpOutEchoReps, wfIpInterfaceAMR=wfIpInterfaceAMR, wfIpxSapServLvlAction=wfIpxSapServLvlAction, wfivTrafficFilterDefinition=wfivTrafficFilterDefinition, wfFrDlcmiLastReceived=wfFrDlcmiLastReceived, wfAppleBaseDisable=wfAppleBaseDisable, wfE1RcvSig1s=wfE1RcvSig1s, wfHwSparePromDate=wfHwSparePromDate, wfIfOutDiscards=wfIfOutDiscards, wfHssiInErrors=wfHssiInErrors, wfApplePortZipOutGetMyZoneReplies=wfApplePortZipOutGetMyZoneReplies, wfT1OutOfFrameErrs=wfT1OutOfFrameErrs, wfTokenRingFrameCopiedErrors=wfTokenRingFrameCopiedErrors, wfBCNFanStatus=wfBCNFanStatus, wfApplication=wfApplication, wfIpTrafficFilterCreate=wfIpTrafficFilterCreate, wfHwBootPromDate=wfHwBootPromDate, wfApplePortType=wfApplePortType, wfTotalLogins=wfTotalLogins, wfCircuitIfType=wfCircuitIfType, wfVinesIfNumber=wfVinesIfNumber, wfHSSILoad=wfHSSILoad, wfCSMACDAlignErrorRx=wfCSMACDAlignErrorRx, wfIpInterfaceState=wfIpInterfaceState, wfivRouteMaxCost=wfivRouteMaxCost, wfIfPhysAddress=wfIfPhysAddress, wfIpxTrafficFilterStatus=wfIpxTrafficFilterStatus, wfFddiMacSlot=wfFddiMacSlot, wfSyncPassThruRemoteMadr=wfSyncPassThruRemoteMadr, wfTokenRingHardErrors=wfTokenRingHardErrors, wfOspfTOSSupport=wfOspfTOSSupport, wfTokenRingTxOctets=wfTokenRingTxOctets, wfHwfSlot=wfHwfSlot, wfDs1CurrentBPVs=wfDs1CurrentBPVs, wfIpInterfaceMacAddress=wfIpInterfaceMacAddress, wfFrCircuitMulticast=wfFrCircuitMulticast, wfDs1LoopbackConfig=wfDs1LoopbackConfig, wfXnsRipInterfaceSupply=wfXnsRipInterfaceSupply, wfOspfNbrIpAddr=wfOspfNbrIpAddr, wfVinesIfX25VCBytesOut=wfVinesIfX25VCBytesOut, wfVinesTrafficFilterReserved=wfVinesTrafficFilterReserved, wfDs3CurrentUASs=wfDs3CurrentUASs, wfFDDIRingOverrunRx=wfFDDIRingOverrunRx, wfSyncBoflTmo=wfSyncBoflTmo, wfModElmB1=wfModElmB1, wfOtherLoginErrors=wfOtherLoginErrors, wfOspfVirtIfTxLinkStateReqs=wfOspfVirtIfTxLinkStateReqs, wfFrCircuitEntry=wfFrCircuitEntry, wfDs1FeCurrentSEFs=wfDs1FeCurrentSEFs, wfSipL2=wfSipL2, wfAppleLclZoneTable=wfAppleLclZoneTable, wfHssiRxBufferLength=wfHssiRxBufferLength, wfBrStpInterfaceDesignatedRoot=wfBrStpInterfaceDesignatedRoot, wfDs3Interval=wfDs3Interval, wfRipIntfEntry=wfRipIntfEntry, wfHssiRxProcessings=wfHssiRxProcessings, wfFrErrDrops=wfFrErrDrops, wfVinesTrafficFilterCreate=wfVinesTrafficFilterCreate, wfSipGroup=wfSipGroup, wfIpInterfaceIcmpInTimestampReps=wfIpInterfaceIcmpInTimestampReps, wfOspfAreaEntry=wfOspfAreaEntry, wfXnsInterfaceInAddrErrors=wfXnsInterfaceInAddrErrors, wfIpxInterfaceTable=wfIpxInterfaceTable, wfSipDs3PlcpIndex=wfSipDs3PlcpIndex, wfAMZ8530Load=wfAMZ8530Load, wfApplePortZipZoneOutInvalids=wfApplePortZipZoneOutInvalids, wfivCircuitCommonType=wfivCircuitCommonType, wfIpInterfaceIcmpOutRedirects=wfIpInterfaceIcmpOutRedirects, wfVinesIfX25VCResetsIn=wfVinesIfX25VCResetsIn, wfivCircuitCountPacketFmtErr=wfivCircuitCountPacketFmtErr, wfOspfNbrEvents=wfOspfNbrEvents, wfSnmpOutGetResponses=wfSnmpOutGetResponses, wfVinesIpBcast=wfVinesIpBcast, wfFddiMacNode=wfFddiMacNode, wfVinesIfX25VCOutErrs=wfVinesIfX25VCOutErrs, wfIpSrEnable=wfIpSrEnable, wfIpxSapNetLvlDisable=wfIpxSapNetLvlDisable, wfVinesRtpNbrRemAdr=wfVinesRtpNbrRemAdr, wfILACCLoad=wfILACCLoad, wfE1RcvMfmAlms=wfE1RcvMfmAlms, wfApplePortAarpReqRxs=wfApplePortAarpReqRxs, wfIpxSapNetLvlType=wfIpxSapNetLvlType, wfCctOptsIpFilterState=wfCctOptsIpFilterState, wfOspfVirtNbrEvents=wfOspfVirtNbrEvents, wfIpxTrafficFilterEnable=wfIpxTrafficFilterEnable, wfCctOptsDelete=wfCctOptsDelete, wfFSILoad=wfFSILoad, wfE1RcvRemAlms=wfE1RcvRemAlms, wfIpxBaseState=wfIpxBaseState, wfOspfIfRxLinkStateAcks=wfOspfIfRxLinkStateAcks, wfVinesBaseDelete=wfVinesBaseDelete, wfFrDlcmiEntry=wfFrDlcmiEntry, wfXnsAhDlci=wfXnsAhDlci, wfSnmpInNoSuchNames=wfSnmpInNoSuchNames, wfSnmpOutGenErrs=wfSnmpOutGenErrs, wfBrSrTrafficFilterEntry=wfBrSrTrafficFilterEntry, wfApplePortZipOutGetLocalZoneReplies=wfApplePortZipOutGetLocalZoneReplies, wfSyncTable=wfSyncTable, wfModMisr=wfModMisr, wfCctOptsBrFilterEntry=wfCctOptsBrFilterEntry, wfBrSrInterfaceIpAddress=wfBrSrInterfaceIpAddress, wfXnsRipInterfaceDelete=wfXnsRipInterfaceDelete, wfApplePortDdpOutRequests=wfApplePortDdpOutRequests, wfSmdsCircuitSipL3ReceivedIndividualDAs=wfSmdsCircuitSipL3ReceivedIndividualDAs, wfIpInterfaceFragCreates=wfIpInterfaceFragCreates, wfFDDIMacTReq=wfFDDIMacTReq, wfXnsInterfaceDisable=wfXnsInterfaceDisable, wfVinesIfX25VCSession=wfVinesIfX25VCSession, wfIpAdjHostIntfMask=wfIpAdjHostIntfMask, wfSmdsCircuitHrtbtPollDownCount=wfSmdsCircuitHrtbtPollDownCount, wfSnmpMgrCommIndex=wfSnmpMgrCommIndex, wfSwSeries7=wfSwSeries7, wfModRev=wfModRev, wfIfOutNUcastPkts=wfIfOutNUcastPkts, wfTokenRingOutDiscards=wfTokenRingOutDiscards, wfKernelBufOwnerTask9=wfKernelBufOwnerTask9, wfSnmpOutNoSuchNames=wfSnmpOutNoSuchNames, wfSyncEntry=wfSyncEntry, wfManagerLoginErrors=wfManagerLoginErrors, wfApplePortNbpInForwardRequests=wfApplePortNbpInForwardRequests, wfHwBpSerialNumber=wfHwBpSerialNumber, wfE1ClockMode=wfE1ClockMode, wfFDDISmtRingErrRx=wfFDDISmtRingErrRx, wfivCircuitCountOverSzePktLoss=wfivCircuitCountOverSzePktLoss, wfTftp=wfTftp, wfHssiTable=wfHssiTable, wfBrStpTopChanges=wfBrStpTopChanges, wfQSYNCLoad=wfQSYNCLoad, wfVinesRtpNbr=wfVinesRtpNbr, wfApplePortZipInGetNetInfos=wfApplePortZipInGetNetInfos, wfRipInterfacePoisonedReversed=wfRipInterfacePoisonedReversed, wfTokenRingSingleStations=wfTokenRingSingleStations, wfivLevel1RouteCost=wfivLevel1RouteCost, wfFrameRelayGroup=wfFrameRelayGroup, wfBrTrafficFilterCounter=wfBrTrafficFilterCounter, wfDs1FeTotal=wfDs1FeTotal, wfIpxInterfaceMaxInfo=wfIpxInterfaceMaxInfo, wfIpxInterfaceDisable=wfIpxInterfaceDisable, wfivCircuitCountRtHelloSent=wfivCircuitCountRtHelloSent, wfIpInterfaceAddr=wfIpInterfaceAddr, wfIpxAdjacentHostTable=wfIpxAdjacentHostTable, wfIpRfOspfImportEntry=wfIpRfOspfImportEntry, wfT1Table=wfT1Table, wfOspfDynNbrRtrId=wfOspfDynNbrRtrId, wfIpRfOspfImportCreate=wfIpRfOspfImportCreate, wfVinesRtpRtMetric=wfVinesRtpRtMetric, wfFddiMacDownstreamNbr=wfFddiMacDownstreamNbr, wfMod=wfMod, wfModHicr=wfModHicr, wfOspfSlotMask=wfOspfSlotMask, wfIpRfRipImportTable=wfIpRfRipImportTable, wfTokenRingFirstAdapterCheckCode=wfTokenRingFirstAdapterCheckCode, wfivAdjIndex=wfivAdjIndex, wfBrTrafficFilterTable=wfBrTrafficFilterTable, wfOspfIfTxHellos=wfOspfIfTxHellos, wfOspfLsdbAreaId=wfOspfLsdbAreaId, wfBrSrInterfaceTable=wfBrSrInterfaceTable, wfIpxInterfaceNetbiosAccept=wfIpxInterfaceNetbiosAccept, wfFDDINode=wfFDDINode, wfHwfEnable=wfHwfEnable, wfIpInterfaceFRMcast2Dlci=wfIpInterfaceFRMcast2Dlci, wfOspfNbrEntry=wfOspfNbrEntry, wfVinesIfIcpOutErrorNotifs=wfVinesIfIcpOutErrorNotifs, wfBrTpInterfaceOutFrames=wfBrTpInterfaceOutFrames, wfRipInterfaceIndex=wfRipInterfaceIndex, wfTokenRingDelete=wfTokenRingDelete, wfSyncSignalMode=wfSyncSignalMode, wfSipL2SentCounts=wfSipL2SentCounts, wfIpRouting=wfIpRouting, wfivLevel1NodeId=wfivLevel1NodeId, wfTokenRingMtu=wfTokenRingMtu, wfTiRuiResult=wfTiRuiResult, wfFrDlcmiSeqCount=wfFrDlcmiSeqCount, wfDs3TotalIndex=wfDs3TotalIndex, wfivAdjPriority=wfivAdjPriority, wfCSMACDState=wfCSMACDState, wfHssiDelete=wfHssiDelete, wfAppleLclZonePortCircuit=wfAppleLclZonePortCircuit, wfSyncRetryCount=wfSyncRetryCount, wfSyncLocalAddress=wfSyncLocalAddress, wfIpInterfaceMaxInfo=wfIpInterfaceMaxInfo, wfDs3FeIntervalSESs=wfDs3FeIntervalSESs, wfTokenRingDmaBusErrors=wfTokenRingDmaBusErrors, wfOspfLsdbType=wfOspfLsdbType, wfVinesRtpNbrType=wfVinesRtpNbrType, wfVinesIfIcpInMetricNotifs=wfVinesIfIcpInMetricNotifs, wfFddiMacRmtState=wfFddiMacRmtState, wfHwDiagPromRev=wfHwDiagPromRev, wfCctOptsIpFilterFragment=wfCctOptsIpFilterFragment, wfIpxBaseSapIndex=wfIpxBaseSapIndex, wfXnsInterfaceCircuit=wfXnsInterfaceCircuit, wfKernelMemOwnerTask4Size=wfKernelMemOwnerTask4Size, wfHssiMaxRxMemory=wfHssiMaxRxMemory, wfVinesIfType=wfVinesIfType, wfFrCircuitCreationTime=wfFrCircuitCreationTime, wfIpTrafficFilterDefinition=wfIpTrafficFilterDefinition, wfIpxSrNextHopNetwork=wfIpxSrNextHopNetwork, wfDs3CurrentEntry=wfDs3CurrentEntry, wfCctOptsLoXmits=wfCctOptsLoXmits, wfModIlacc3=wfModIlacc3, wfBrTrafficFilterReserved=wfBrTrafficFilterReserved, wfIpxBaseRouteNextHopHost=wfIpxBaseRouteNextHopHost, wfXnsInterfaceExServPktType=wfXnsInterfaceExServPktType, wfModIlacc4=wfModIlacc4, wfOspfAreaRangeDelete=wfOspfAreaRangeDelete, wfApplePortZipInGetMyZones=wfApplePortZipInGetMyZones, wfOspfVirtIfRtrDeadInterval=wfOspfVirtIfRtrDeadInterval, wfModSnprom=wfModSnprom, wfXnsInterfaceInDelivers=wfXnsInterfaceInDelivers, wfFddiMacTNeg=wfFddiMacTNeg, wfIpxSapServLvlFilter=wfIpxSapServLvlFilter)
mibBuilder.exportSymbols("Wellfleet-Series7-MIB", wfHwfLineCct=wfHwfLineCct, wfVinesIfZeroHopDrops=wfVinesIfZeroHopDrops, wfApplePortCurMacAddress=wfApplePortCurMacAddress, wfXnsBaseRouteType=wfXnsBaseRouteType, wfOspfNbrOptions=wfOspfNbrOptions, wfApplePortRtmpNetworkMismatchErrors=wfApplePortRtmpNetworkMismatchErrors, wfIfInErrors=wfIfInErrors, wfFddiSmtGroup=wfFddiSmtGroup, wfIpxNetBiosSrIndex=wfIpxNetBiosSrIndex, wfFakeEventString=wfFakeEventString, wfBrSrTrafficFilterRuleNumber=wfBrSrTrafficFilterRuleNumber, wfXnsInterfaceState=wfXnsInterfaceState, wfTftpCloseTimeOut=wfTftpCloseTimeOut, wfKernelBufOwnerTask2Bufs=wfKernelBufOwnerTask2Bufs, wfApplePortZipOutZipExtendedReplies=wfApplePortZipOutZipExtendedReplies, wfApplePortCurNetEnd=wfApplePortCurNetEnd, wfOspfDynNbrEntry=wfOspfDynNbrEntry, wfCctOptsBrFilterCct=wfCctOptsBrFilterCct, wfXnsRipIntfTable=wfXnsRipIntfTable, wfTokenRingEntry=wfTokenRingEntry, wfDs3FeTotalESs=wfDs3FeTotalESs, wfIpInterfaceCreate=wfIpInterfaceCreate, wfSyncPromiscuous=wfSyncPromiscuous, wfDs1ValidIntervals=wfDs1ValidIntervals, wfCircuitNameTable=wfCircuitNameTable, wfXnsAhDelete=wfXnsAhDelete, wfIpInterfaceEntry=wfIpInterfaceEntry, wfOspfLsdbChecksum=wfOspfLsdbChecksum, wfModDefaB=wfModDefaB, wfTestGroup=wfTestGroup, wfX25Group=wfX25Group, wfApplePortCurNetwork=wfApplePortCurNetwork, wfIpInterfaceReasmTimeout=wfIpInterfaceReasmTimeout, wfivRouteState=wfivRouteState, wfKernelMemorySegsFree=wfKernelMemorySegsFree, wfIpxTrafficFilterTable=wfIpxTrafficFilterTable, wfIpRfRipExportInterface=wfIpRfRipExportInterface, wfIpxSapNetLvlTargNetwork=wfIpxSapNetLvlTargNetwork, wfIpxBase=wfIpxBase, wfPppGroup=wfPppGroup, wfDs3TotalEntry=wfDs3TotalEntry, wfVinesBaseUserNetid=wfVinesBaseUserNetid, wfHwSlot=wfHwSlot, wfIpxNetBiosSrDisable=wfIpxNetBiosSrDisable, wfDataBits=wfDataBits, wfOspfAreaRangeEntry=wfOspfAreaRangeEntry, wfIpxAhDisable=wfIpxAhDisable, wfIfIndex=wfIfIndex, wfFrErrDiscards=wfFrErrDiscards, wfDs1FeTotalSESs=wfDs1FeTotalSESs, wfTtyInfifoErrors=wfTtyInfifoErrors, wfivCircuitCountPtlRteUpdtLoss=wfivCircuitCountPtlRteUpdtLoss, wfDs3SendCode=wfDs3SendCode, wfFddiEntry=wfFddiEntry, wfSipL2Entry=wfSipL2Entry, wfVinesIfDelete=wfVinesIfDelete, wfSnmpInGenErrs=wfSnmpInGenErrs, wfXnsBaseRtEntryTable=wfXnsBaseRtEntryTable, wfFddiPortNode=wfFddiPortNode, wfAppletalkGroup=wfAppletalkGroup, wfivStaticAdjArea=wfivStaticAdjArea, wfModMuxram1=wfModMuxram1, wfIpBaseHostEntry=wfIpBaseHostEntry, wfXnsTrafficFilterFragment=wfXnsTrafficFilterFragment, wfOspfVirtIfRxDBDescripts=wfOspfVirtIfRxDBDescripts, wfBrSrTrafficFilterFragment=wfBrSrTrafficFilterFragment, wfSnmpEnableAuthTraps=wfSnmpEnableAuthTraps, wfTftpDefaultVolume=wfTftpDefaultVolume, wfSnmpInGetNexts=wfSnmpInGetNexts, wfHssiWanProtocol=wfHssiWanProtocol, wfBrSrBridgeDelete=wfBrSrBridgeDelete, wfSipDs1PlcpAlarmState=wfSipDs1PlcpAlarmState, wfFddiSmtNonMasterCt=wfFddiSmtNonMasterCt, wfIpAdjHostIntf=wfIpAdjHostIntf, wfIpRfOspfExportEnable=wfIpRfOspfExportEnable, wfBrSrIpExplorerAddr=wfBrSrIpExplorerAddr, wfIpRfOspfExportTable=wfIpRfOspfExportTable, wfIpBaseRouteMetric2=wfIpBaseRouteMetric2, wfFDDIAbortTx=wfFDDIAbortTx, wfOspfNbrDelete=wfOspfNbrDelete, wfT1Entry=wfT1Entry, wfSyncLackRescTx=wfSyncLackRescTx, wfVinesIfDescr=wfVinesIfDescr, wfAppleBaseDebugLevel=wfAppleBaseDebugLevel, wfIpInterfaceInDiscards=wfIpInterfaceInDiscards, wfivAreaNum=wfivAreaNum, wfivTrafficFilterReserved=wfivTrafficFilterReserved, wfIpTrafficFilterRuleNumber=wfIpTrafficFilterRuleNumber, wfAppleBaseTotalZones=wfAppleBaseTotalZones, wfDs3ZeroCoding=wfDs3ZeroCoding, wfModTocr=wfModTocr, wfivAreaCost=wfivAreaCost, wfRipInterfaceState=wfRipInterfaceState, wfVinesTrafficFilterRuleNumber=wfVinesTrafficFilterRuleNumber, wfIfOutErrors=wfIfOutErrors, wfSyncWindowSizeTxExtc=wfSyncWindowSizeTxExtc, wfKernelMemOwnerTask3Size=wfKernelMemOwnerTask3Size, wfIpBaseRouteNextHop=wfIpBaseRouteNextHop, wfDs1FeCurrent=wfDs1FeCurrent, wfSmdsCircuitArpAddr=wfSmdsCircuitArpAddr, wfModCamALock=wfModCamALock, wfFddiPortPcNeighbor=wfFddiPortPcNeighbor, wfIpInterfaceTable=wfIpInterfaceTable, wfSyncExtendedControlForce=wfSyncExtendedControlForce, wfFddiMacUpstreamNbr=wfFddiMacUpstreamNbr, wfOspfDynNbrState=wfOspfDynNbrState, wfXnsInterfaceDelete=wfXnsInterfaceDelete, wfivCircuitCountDropped=wfivCircuitCountDropped, wfFDDIOctetsRxOk=wfFDDIOctetsRxOk, wfHwfLineCurrentUsedEntries=wfHwfLineCurrentUsedEntries, wfOspfAreaRangeTable=wfOspfAreaRangeTable, wfAppleZipIndex=wfAppleZipIndex, wfSmdsCircuitIndivAddr=wfSmdsCircuitIndivAddr, wfSyncService=wfSyncService, wfivAreaEntry=wfivAreaEntry, wfIpxBaseSapEntryTable=wfIpxBaseSapEntryTable, wfIpxInterfaceInUnknownProtos=wfIpxInterfaceInUnknownProtos, wfivAdjNodeAddr=wfivAdjNodeAddr, wfDs1FeCurrentSESs=wfDs1FeCurrentSESs, wfModHssiUga2=wfModHssiUga2, wfCSMACDFcsErrorRx=wfCSMACDFcsErrorRx, wfCircuitNameDelete=wfCircuitNameDelete, wfVinesIfSession=wfVinesIfSession, wfVinesIfX25VCEntry=wfVinesIfX25VCEntry, wfBrStpInterfaceDesignatedCost=wfBrStpInterfaceDesignatedCost, wfAppleZipZoneNetStart=wfAppleZipZoneNetStart, wfBrSrEsRifCircuit=wfBrSrEsRifCircuit, wfFDDIMtu=wfFDDIMtu, wfIpxBaseRouteDest=wfIpxBaseRouteDest, wfModCamBUnlock=wfModCamBUnlock, wfIpGroup=wfIpGroup, wfFDDIEnable=wfFDDIEnable, wfKernelMemOwnerTask10=wfKernelMemOwnerTask10, wfModHlsr=wfModHlsr, wfCctOptsHiQHighWaterPkts=wfCctOptsHiQHighWaterPkts, wfModTms3802=wfModTms3802, wfOspfIfRtrDeadInterval=wfOspfIfRtrDeadInterval, wfCSMACDTooLongErrorRx=wfCSMACDTooLongErrorRx, wfFrErrData=wfFrErrData, wfVinesArpState=wfVinesArpState, wfOspfIfMetricCost=wfOspfIfMetricCost, wfApplePortZipOutGetNetInfoReplies=wfApplePortZipOutGetNetInfoReplies, wfSmdsCircuitTable=wfSmdsCircuitTable, wfUdpGroup=wfUdpGroup, wfFDDIParityErrRx=wfFDDIParityErrRx, wfVinesNameTable=wfVinesNameTable, wfIpxInterfaceEncaps=wfIpxInterfaceEncaps, wfOspfDynNbrTable=wfOspfDynNbrTable, wfBrTpBaseEnable=wfBrTpBaseEnable, wfIpBaseRipDiameter=wfIpBaseRipDiameter, wfBrTrafficFilterEntry=wfBrTrafficFilterEntry, wfHwModIdOpt=wfHwModIdOpt, wfApplePortRtmpInDataPkts=wfApplePortRtmpInDataPkts, wfHwfEntry=wfHwfEntry, wfivStaticAdjDestMACAddr=wfivStaticAdjDestMACAddr, wfKernelMemOwnerTask3=wfKernelMemOwnerTask3, wfHwfLineEntry=wfHwfLineEntry, wfModSbrr=wfModSbrr, wfFddiGroup=wfFddiGroup, wfIpTrafficFilterEntry=wfIpTrafficFilterEntry, wfVinesArpDisable=wfVinesArpDisable, wfIpxInterfaceNetworkNumber=wfIpxInterfaceNetworkNumber, wfOspfNbrRtrId=wfOspfNbrRtrId, wfOspfIfAreaId=wfOspfIfAreaId, wfArpBase=wfArpBase, wfTokenRingInErrors=wfTokenRingInErrors, wfDs3FeIntervalNumber=wfDs3FeIntervalNumber, wfVinesNameNetid=wfVinesNameNetid, wfFrCircuitMode=wfFrCircuitMode, wfXnsSrDisable=wfXnsSrDisable, wfDs1FeCurrentIndex=wfDs1FeCurrentIndex, wfIpxAhTargHostNetwork=wfIpxAhTargHostNetwork, wfTokenRingBurstErrors=wfTokenRingBurstErrors, wfivLevel1RouteHops=wfivLevel1RouteHops, wfBrTrafficFilterStatus=wfBrTrafficFilterStatus, wfTokenRingRxCongestionErrors=wfTokenRingRxCongestionErrors, wfSnmpOutGetNexts=wfSnmpOutGetNexts, wfAppleLclZoneDelete=wfAppleLclZoneDelete, wfivStaticAdjNodeAddr=wfivStaticAdjNodeAddr, wfIpxInterfaceFRMcast=wfIpxInterfaceFRMcast, wfIpBaseRtEntry=wfIpBaseRtEntry, wfTokenRingRequestRemoves=wfTokenRingRequestRemoves, wfCSMACDLcarTx=wfCSMACDLcarTx, wfTftpDisable=wfTftpDisable, wfivTrafficFilterCircuit=wfivTrafficFilterCircuit, wfIpBaseRouteMetric5=wfIpBaseRouteMetric5, wfIpBaseCreate=wfIpBaseCreate, wfHwfLineDroppedFrames=wfHwfLineDroppedFrames, wfBrSrTrafficFilterCounter=wfBrSrTrafficFilterCounter, wfX25DTELoad=wfX25DTELoad, wfVinesRtpNbrIfType=wfVinesRtpNbrIfType, wfivTrafficFilterCounter=wfivTrafficFilterCounter, wfApplePortNetStart=wfApplePortNetStart, wfMod8530=wfMod8530, wfVinesIfIcpInErrors=wfVinesIfIcpInErrors, wfVinesRtpNbrSvrName=wfVinesRtpNbrSvrName, wfCctOptsBrFilterTable=wfCctOptsBrFilterTable, wfOspfDynNbrIfAddr=wfOspfDynNbrIfAddr, wfRipInterfaceSupply=wfRipInterfaceSupply, wfKernelMemOwnerTask5Size=wfKernelMemOwnerTask5Size, wfBrSrInterfaceBlockOutSte=wfBrSrInterfaceBlockOutSte, wfHwMotherBdRev=wfHwMotherBdRev, wfFrDlcmiDisable=wfFrDlcmiDisable, wfBrSrBaseDisable=wfBrSrBaseDisable, wfMK5025Load=wfMK5025Load, wfIpRfOspfImportMask=wfIpRfOspfImportMask, wfBrStpInterfaceDesignatedPort=wfBrStpInterfaceDesignatedPort, wfIpBaseForwarding=wfIpBaseForwarding, wfLoginTimeOut=wfLoginTimeOut, wfIpRfOspfExportTag=wfIpRfOspfExportTag, wfOspfIfTable=wfOspfIfTable, wfVinesIfX25VCInErrs=wfVinesIfX25VCInErrs, wfDs1Group=wfDs1Group, wfT1Connector=wfT1Connector, wfVinesIpBcastHWM=wfVinesIpBcastHWM, wfIpxBaseSapIntf=wfIpxBaseSapIntf, wfVinesIpToDodIP=wfVinesIpToDodIP, wfOspfIfRtrPriority=wfOspfIfRtrPriority, wfXnsInterfaceInHdrErrors=wfXnsInterfaceInHdrErrors, wfModMk50251=wfModMk50251)

#
# PySNMP MIB module HM2-INDUSTRIAL-PROTOCOLS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-INDUSTRIAL-PROTOCOLS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
hm2ConfigurationMibs, HmEnabledStatus = mibBuilder.importSymbols("HM2-TC-MIB", "hm2ConfigurationMibs", "HmEnabledStatus")
InetPortNumber, InetAddressIPv4 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressIPv4")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Counter32, Gauge32, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter64, TimeTicks, Unsigned32, ObjectIdentity, IpAddress, Bits, MibIdentifier, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Counter32", "Gauge32", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter64", "TimeTicks", "Unsigned32", "ObjectIdentity", "IpAddress", "Bits", "MibIdentifier", "Integer32")
TextualConvention, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue")
hm2IndustrialProtocolsMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 101))
hm2IndustrialProtocolsMib.setRevisions(('2014-02-24 00:00', '2014-01-15 00:00', '2013-05-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2IndustrialProtocolsMib.setRevisionsDescriptions(('Added hm2ModbusGroup.', 'Added hm2EthernetIPGroup.', 'Initial version.',))
if mibBuilder.loadTexts: hm2IndustrialProtocolsMib.setLastUpdated('201402240000Z')
if mibBuilder.loadTexts: hm2IndustrialProtocolsMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2IndustrialProtocolsMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2IndustrialProtocolsMib.setDescription('Hirschmann Industrial Protocols MIB. Copyright (C) 2013. All Rights Reserved.')
hm2IndustrialProtocolsNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 0))
hm2IndustrialProtocolsMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1))
hm2IndustrialProtocolsMibSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 3))
hm2Iec61850Group = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1))
hm2ProfinetIOGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2))
hm2EthernetIPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3))
hm2ModbusGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4))
hm2Iec61850ConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1))
hm2Iec61850StatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 2))
hm2Iec61850MmsServerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsServerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerAdminStatus.setDescription('Enables/disables the IEC61850 MMS server functionality on this device. If disabled(2), the IEC61850 MMS Server is deactivated, but the IEC61850 MIBs can be accessed. The default value is disabled.')
hm2Iec61850MmsServerWriteAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 2), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsServerWriteAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerWriteAccessStatus.setDescription('Enables/disables the read/write capability of the IEC61850 MMS. If disabled(2), the IEC61850 MMS Server is accessible read-only, if enabled(1) the device configuration can be changed using the IEC61850 MMS protocol. The default value is disabled.')
hm2Iec61850MmsServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 3), InetPortNumber().clone(102)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerPortNumber.setDescription('The port number of the IEC61850 MMS server. Setting the port to zero is not allowed.')
hm2Iec61850MmsServerMaxSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsServerMaxSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerMaxSessionsCount.setDescription('Max number of IEC61850 MMS sessions permitted on this switch.')
hm2Iec61850MmsServerTechnicalKey = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('KEY')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsServerTechnicalKey.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerTechnicalKey.setDescription("The IEC61850 MMS server technical key setting corresponds to the IEC61850 IED name. This name is used to identify the device via a IEC61850 MMS client. The size is restricted to 32 characters. According to IEC61850-7-2 Ed. the TechnicalKey represents an IEC61850 VisibleString. Thus the following characters are allowed: VisibleString ( FROM ('A'|'a'|'B'|'b'|'C'|'c'|'D'|'d'|'E'|'e'|'F'|'f'| 'G'|'g'|'H'|'h'|'I'|'i'|'J'|'j'|'K'|'k'|'L'|'l'| 'M'|'m'|'N'|'n'|'O'|'o'|'P'|'p'|'Q'|'q'|'R'|'r'| 'S'|'s'|'T'|'t'|'U'|'u'|'V'|'v'|'W'|'w'|'X'|'x'| 'Y'|'y'|'Z'|'z'|'_'|'0'|'1'|'2'|'3'|'4'|'5'|'6'| '7'|'8'|'9') )")
hm2Iec61850MmsTlsServerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 10), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerAdminStatus.setDescription('Enables/disables the IEC61850 MMS over TLS server functionality on this device. If disabled(2), the IEC61850 MMS over TLS Server is deactivated, but the IEC61850 MIBs can be accessed. The default value is disabled.')
hm2Iec61850MmsTlsServerWriteAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 11), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerWriteAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerWriteAccessStatus.setDescription('Enables/disables the read/write capability of the IEC61850 MMS. If disabled(2), the IEC61850 MMS over TLS Server is accessible read-only, if enabled(1) the device configuration can be changed using the IEC61850 MMS over TLS protocol. The default value is disabled.')
hm2Iec61850MmsTlsServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 12), InetPortNumber().clone(3782)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerPortNumber.setDescription('The port number of the IEC61850 MMS over TLS server. Setting the port to zero is not allowed.')
hm2Iec61850MmsTlsServerMaxSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerMaxSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerMaxSessionsCount.setDescription('Max number of IEC61850 MMS over TLS sessions permitted on this switch.')
hm2Iec61850MmsTlsServerKeysPresent = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dsa", 1), ("rsa", 2), ("both", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerKeysPresent.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerKeysPresent.setDescription('Indicates what key files are present on the device, if any.')
hm2Iec61850MmsTlsServerKeyOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("dsa", 1), ("rsa", 2), ("both", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerKeyOperStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerKeyOperStatus.setDescription('Indicates what key files are currently being generated or deleted, if any.')
hm2Iec61850MmsTlsServerRSAKeyControl = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noop", 1), ("generate", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerRSAKeyControl.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerRSAKeyControl.setDescription('Controls RSA key generation and deletion. Always returns noop(1).')
hm2Iec61850MmsTlsServerDSAKeyControl = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noop", 1), ("generate", 2), ("delete", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerDSAKeyControl.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerDSAKeyControl.setDescription('Controls DSA key generation and deletion. Always returns noop(1).')
hm2Iec61850MmsTlsServerFingerPrintDSA = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerFingerPrintDSA.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerFingerPrintDSA.setDescription('The local DSA fingerprint for IEC61850 MMS over TLS connections.')
hm2Iec61850MmsTlsServerFingerPrintRSA = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerFingerPrintRSA.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerFingerPrintRSA.setDescription('The local RSA fingerprint for IEC61850 MMS over TLS connections.')
hm2Iec61850MmsServerStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unavailable", 1), ("starting", 2), ("running", 3), ("stopping", 4), ("halted", 5), ("error", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsServerStatus.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerStatus.setDescription('Returns current MMS server status. As the MMS server takes a long time to start or to stop, this will return the actual server state, not just if it is enabled or disabled. If the value is unavailable(1) then the feature is not available on the device.')
hm2Iec61850MmsServerSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsServerSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsServerSessionsCount.setDescription('Current number of active IEC61850 MMS sessions on this switch.')
hm2Iec61850MmsTlsServerSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2Iec61850MmsTlsServerSessionsCount.setDescription('Current number of active IEC61850 MMS over TLS sessions on this switch.')
hm2ProfinetIOConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1))
hm2ProfinetIOStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 2))
hm2PNIOAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PNIOAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOAdminStatus.setDescription('Enables/disables the ProfinetIO functionality on this device. If disabled(2), the ProfinetIO protocol is inactive, but the ProfinetIO MIBs can be accessed. The default value is disabled.')
hm2PNIODeviceID = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIODeviceID.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODeviceID.setDescription('Identifier of the device family. Values 1 .. 65635 are valid device IDs.')
hm2PNIOModuleIdentNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIOModuleIdentNumber.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOModuleIdentNumber.setDescription('Identifier ID of the device of port or module.')
hm2PNIOOrderID = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIOOrderID.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOOrderID.setDescription('Product (switch) order ID. The size is restricted to 64 characters.')
hm2PNIODeviceTypeDetails = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIODeviceTypeDetails.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODeviceTypeDetails.setDescription('Switch device type details, for example: 4 Port Rail Switch.')
hm2PNIOSoftwareRelease = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIOSoftwareRelease.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOSoftwareRelease.setDescription('This value is a string that contains Version number of software in profinetio format, for example: 01.0.03.')
hm2PNIOHardwareRelease = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIOHardwareRelease.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOHardwareRelease.setDescription('Version number of switch hardware in profinetio format.')
hm2PNIOOrderID9th = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIOOrderID9th.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOOrderID9th.setDescription('Product (switch) order ID. The size is restricted to 32 characters (In the form of the 9-th numbers).')
hm2PNIONameOfStation = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PNIONameOfStation.setStatus('current')
if mibBuilder.loadTexts: hm2PNIONameOfStation.setDescription('Device name. The size is restricted to 240 characters. It must be conform to the restrictions as decribed in PNIO protocol specification.')
hm2PNIONumActiveApplicationRelations = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 10), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2PNIONumActiveApplicationRelations.setStatus('current')
if mibBuilder.loadTexts: hm2PNIONumActiveApplicationRelations.setDescription('Returns the number of active application relations.')
hm2PNIOClearIpParameter = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 11), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PNIOClearIpParameter.setStatus('current')
if mibBuilder.loadTexts: hm2PNIOClearIpParameter.setDescription('Clears the IP parameters if set to true and PNIO is enabled.')
hm2PNIODcpModeTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 20), )
if mibBuilder.loadTexts: hm2PNIODcpModeTable.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODcpModeTable.setDescription('Table of DCP mode entries')
hm2PNIODcpModeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 20, 1), ).setIndexNames((0, "HM2-INDUSTRIAL-PROTOCOLS-MIB", "hm2PNIODcpModePortID"))
if mibBuilder.loadTexts: hm2PNIODcpModeEntry.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODcpModeEntry.setDescription('DCP mode entry')
hm2PNIODcpModePortID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 20, 1, 1), Integer32())
if mibBuilder.loadTexts: hm2PNIODcpModePortID.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODcpModePortID.setDescription('Port ID for the DCP mode table entry')
hm2PNIODcpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 2, 1, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("ingress", 1), ("egress", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2PNIODcpMode.setStatus('current')
if mibBuilder.loadTexts: hm2PNIODcpMode.setDescription('DCP mode for one port. Allowed values none(0), ingress(1), egress(2) or both(3) which is default.')
hm2EthernetIPConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1))
hm2EthernetIPStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 2))
hm2EthernetIPTCPIPObjectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3))
hm2EthernetIPQoSObjectGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4))
hm2EtherNetIPAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPAdminStatus.setDescription('Enables/disables the EtherNet/IP(TM) operation on this device. If disabled, the EtherNet/IP protocol is deactivated, but the EtherNet/IP MIBs can be accessed. The default value is disabled.')
hm2EtherNetIPErrorCode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPErrorCode.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPErrorCode.setDescription('Read the error code within EtherNet/IP(TM) action. ')
hm2EtherNetIPProductCode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPProductCode.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPProductCode.setDescription('Read the Product Code as shown in the Identity Object of EtherNet/IP(TM). Values 1 .. 65635 are valid product codes.')
hm2EtherNetIPMajorRevision = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPMajorRevision.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMajorRevision.setDescription('Read the major revision number as shown in the Identity Object of EtherNet/IP(TM). Values 1 .. 255 are valid revisions.')
hm2EtherNetIPMinorRevision = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPMinorRevision.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMinorRevision.setDescription('Read the minor revision number as shown in the Identity Object of EtherNet/IP(TM). Values 1 .. 255 are valid revisions.')
hm2EtherNetIPProductName = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPProductName.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPProductName.setDescription('Read the product name as shown in the Identity Object of EtherNet/IP(TM). The size is restricted to 32 Characters.')
hm2EtherNetIPCatalogName = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPCatalogName.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPCatalogName.setDescription('Read the catolog name as provided in the EDS file for EtherNet/IP(TM). The size is restricted to 255 Characters.')
hm2EtherNetIPWriteAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 1, 8), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPWriteAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPWriteAccessStatus.setDescription('Enables/disables the read/write capability of the EtherNet/IP protocol. If disabled(2), the EtherNet/IP protocol is accessible the get requests only, if enabled(1), the EtherNet/IP protocol is accessible the set/get requests, The default value is disabled.')
hm2EtherNetIPConnEstablished = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 2, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPConnEstablished.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPConnEstablished.setDescription('Statistics: number of connections that have been established within EtherNet/IP.')
hm2EtherNetIPConnTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 2, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPConnTimeouts.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPConnTimeouts.setDescription('Statistics: number of connection timeouts that have been occurred within EtherNet/IP.')
hm2EtherNetIPVendorObjRequests = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 2, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2EtherNetIPVendorObjRequests.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPVendorObjRequests.setDescription('Statistics: number of requests to the vendor specific objects within EtherNet/IP.')
hm2EtherNetIPMcastTTLValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPMcastTTLValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMcastTTLValue.setDescription('Time-to-Live value for IP multicast packets. ')
hm2EtherNetIPMcastAllocControl = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("default", 0), ("defined", 1), ("reserved", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPMcastAllocControl.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMcastAllocControl.setDescription('Controls how the device shall allocate IP multicast addresses. A value of 0 means multicast addresses shall be generated using the default allocation algorithm. A value of 1 means multicast addresses shall be allocated according to the values specified in Num Mcast and Mcast Start Addr. The value 2 is reserved. ')
hm2EtherNetIPMcastCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPMcastCount.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMcastCount.setDescription('The maximum number of IP multicast addresses to be allocated. ')
hm2EtherNetIPMcastStartAddress = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 4), InetAddressIPv4()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPMcastStartAddress.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPMcastStartAddress.setDescription('The starting multicast address from which Num Mcast addresses are allocated. ')
hm2EtherNetIPLastConflictDetectedACDActivity = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(28, 28)).setFixedLength(28)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPLastConflictDetectedACDActivity.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPLastConflictDetectedACDActivity.setDescription('The ARP Response PDU (a copy of the ARP message that caused the address conflict) in binary format. Can only be written to a value of zero. ')
hm2EtherNetIPSelectACDStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("default", 0), ("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPSelectACDStatus.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPSelectACDStatus.setDescription('Sets the status of the ip address conflict detection mechanism on this device. The new value of this element is applied after the device executes a restart.')
hm2EtherNetIPQosDscpUrgentValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(55)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpUrgentValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpUrgentValue.setDescription('DSCP value for CIP transport Urgent priority messages. ')
hm2EtherNetIPQosDscpScheduledValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(47)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpScheduledValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpScheduledValue.setDescription('DSCP value for CIP transport Scheduled priority messages. ')
hm2EtherNetIPQosDscpHighValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(43)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpHighValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpHighValue.setDescription('DSCP value for CIP transport High priority messages. ')
hm2EtherNetIPQosDscpLowValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(31)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpLowValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpLowValue.setDescription('DSCP value for CIP transport Low priority messages. ')
hm2EtherNetIPQosDscpExplicitValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 63)).clone(27)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpExplicitValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosDscpExplicitValue.setDescription('DSCP value for CIP transport Explicit priority messages. ')
hm2EtherNetIPQosValue = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 3, 4, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2EtherNetIPQosValue.setStatus('current')
if mibBuilder.loadTexts: hm2EtherNetIPQosValue.setDescription('This object indicates a changes which be applied after the device executes a restart.')
hm2ModbusConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 1))
hm2ModbusStatisticsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 2))
hm2ModbusTcpServerAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 1, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModbusTcpServerAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hm2ModbusTcpServerAdminStatus.setDescription('Enables/disables the Modbus TCP server functionality on this device. If disabled(2), the Modbus TCP Server is deactivated, but the Modbus MIBs can be accessed. The default value is disabled.')
hm2ModbusTcpServerWriteAccessStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 1, 2), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModbusTcpServerWriteAccessStatus.setStatus('current')
if mibBuilder.loadTexts: hm2ModbusTcpServerWriteAccessStatus.setDescription('Enables/disables the read/write capability of the Modbus TCP server. If disabled(2), the Modbus TCP Server is accessible read-only, if enabled(1) the device configuration can be changed using the Modbus TCP protocol. The default value is disabled.')
hm2ModbusTcpServerPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 1, 3), InetPortNumber().clone(502)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModbusTcpServerPortNumber.setStatus('current')
if mibBuilder.loadTexts: hm2ModbusTcpServerPortNumber.setDescription('The port number of the Modbus TCP server. Setting the port to zero is not allowed.')
hm2ModbusTcpServerMaxSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2ModbusTcpServerMaxSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2ModbusTcpServerMaxSessionsCount.setDescription('Maximum number of concurrent sessions allowed by the Modbus TCP server.')
hm2ModbusTcpServerSessionsCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 101, 1, 4, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2ModbusTcpServerSessionsCount.setStatus('current')
if mibBuilder.loadTexts: hm2ModbusTcpServerSessionsCount.setDescription('Current number of active sessions to the Modbus TCP server.')
hm2Iec61850SESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 3, 1))
hm2ProfinetIOSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 3, 2))
hm2EthernetIPSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 3, 3))
hm2ModbusSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 101, 3, 4))
hm2ProfinetIOInvalidStationName = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 101, 3, 2, 1))
if mibBuilder.loadTexts: hm2ProfinetIOInvalidStationName.setStatus('current')
if mibBuilder.loadTexts: hm2ProfinetIOInvalidStationName.setDescription('Invalid station name.')
mibBuilder.exportSymbols("HM2-INDUSTRIAL-PROTOCOLS-MIB", hm2IndustrialProtocolsMibObjects=hm2IndustrialProtocolsMibObjects, hm2EtherNetIPCatalogName=hm2EtherNetIPCatalogName, hm2IndustrialProtocolsMib=hm2IndustrialProtocolsMib, hm2ModbusTcpServerMaxSessionsCount=hm2ModbusTcpServerMaxSessionsCount, hm2ModbusStatisticsGroup=hm2ModbusStatisticsGroup, hm2Iec61850MmsTlsServerKeysPresent=hm2Iec61850MmsTlsServerKeysPresent, hm2PNIODcpModeTable=hm2PNIODcpModeTable, hm2Iec61850MmsServerAdminStatus=hm2Iec61850MmsServerAdminStatus, hm2Iec61850MmsTlsServerKeyOperStatus=hm2Iec61850MmsTlsServerKeyOperStatus, hm2ModbusConfigGroup=hm2ModbusConfigGroup, hm2PNIODeviceTypeDetails=hm2PNIODeviceTypeDetails, hm2EtherNetIPQosDscpExplicitValue=hm2EtherNetIPQosDscpExplicitValue, hm2Iec61850MmsServerSessionsCount=hm2Iec61850MmsServerSessionsCount, hm2PNIODcpModeEntry=hm2PNIODcpModeEntry, hm2Iec61850MmsServerMaxSessionsCount=hm2Iec61850MmsServerMaxSessionsCount, hm2Iec61850MmsTlsServerSessionsCount=hm2Iec61850MmsTlsServerSessionsCount, hm2ProfinetIOSESGroup=hm2ProfinetIOSESGroup, hm2IndustrialProtocolsMibSNMPExtensionGroup=hm2IndustrialProtocolsMibSNMPExtensionGroup, hm2PNIOAdminStatus=hm2PNIOAdminStatus, hm2Iec61850ConfigGroup=hm2Iec61850ConfigGroup, hm2Iec61850Group=hm2Iec61850Group, hm2EtherNetIPMinorRevision=hm2EtherNetIPMinorRevision, hm2ModbusTcpServerPortNumber=hm2ModbusTcpServerPortNumber, hm2ModbusTcpServerSessionsCount=hm2ModbusTcpServerSessionsCount, hm2ProfinetIOConfigGroup=hm2ProfinetIOConfigGroup, hm2EtherNetIPSelectACDStatus=hm2EtherNetIPSelectACDStatus, hm2EtherNetIPAdminStatus=hm2EtherNetIPAdminStatus, hm2EthernetIPStatisticsGroup=hm2EthernetIPStatisticsGroup, hm2EtherNetIPMcastStartAddress=hm2EtherNetIPMcastStartAddress, hm2Iec61850SESGroup=hm2Iec61850SESGroup, hm2Iec61850MmsTlsServerFingerPrintRSA=hm2Iec61850MmsTlsServerFingerPrintRSA, hm2EtherNetIPWriteAccessStatus=hm2EtherNetIPWriteAccessStatus, hm2Iec61850MmsServerPortNumber=hm2Iec61850MmsServerPortNumber, hm2PNIOModuleIdentNumber=hm2PNIOModuleIdentNumber, hm2EtherNetIPQosValue=hm2EtherNetIPQosValue, hm2EthernetIPGroup=hm2EthernetIPGroup, hm2PNIOOrderID9th=hm2PNIOOrderID9th, hm2Iec61850MmsServerWriteAccessStatus=hm2Iec61850MmsServerWriteAccessStatus, hm2PNIODcpMode=hm2PNIODcpMode, hm2EtherNetIPMcastTTLValue=hm2EtherNetIPMcastTTLValue, hm2EtherNetIPMcastCount=hm2EtherNetIPMcastCount, hm2Iec61850MmsTlsServerWriteAccessStatus=hm2Iec61850MmsTlsServerWriteAccessStatus, hm2Iec61850MmsTlsServerFingerPrintDSA=hm2Iec61850MmsTlsServerFingerPrintDSA, hm2EtherNetIPQosDscpHighValue=hm2EtherNetIPQosDscpHighValue, hm2Iec61850StatisticsGroup=hm2Iec61850StatisticsGroup, hm2EtherNetIPQosDscpUrgentValue=hm2EtherNetIPQosDscpUrgentValue, hm2PNIONameOfStation=hm2PNIONameOfStation, hm2Iec61850MmsTlsServerRSAKeyControl=hm2Iec61850MmsTlsServerRSAKeyControl, hm2EtherNetIPProductCode=hm2EtherNetIPProductCode, hm2EtherNetIPMcastAllocControl=hm2EtherNetIPMcastAllocControl, hm2PNIOOrderID=hm2PNIOOrderID, hm2ProfinetIOGroup=hm2ProfinetIOGroup, hm2PNIONumActiveApplicationRelations=hm2PNIONumActiveApplicationRelations, hm2ProfinetIOInvalidStationName=hm2ProfinetIOInvalidStationName, hm2ModbusGroup=hm2ModbusGroup, hm2EtherNetIPMajorRevision=hm2EtherNetIPMajorRevision, hm2Iec61850MmsTlsServerAdminStatus=hm2Iec61850MmsTlsServerAdminStatus, hm2EtherNetIPVendorObjRequests=hm2EtherNetIPVendorObjRequests, hm2IndustrialProtocolsNotifications=hm2IndustrialProtocolsNotifications, hm2Iec61850MmsServerTechnicalKey=hm2Iec61850MmsServerTechnicalKey, hm2EtherNetIPProductName=hm2EtherNetIPProductName, hm2EtherNetIPQosDscpLowValue=hm2EtherNetIPQosDscpLowValue, hm2PNIODeviceID=hm2PNIODeviceID, hm2Iec61850MmsTlsServerPortNumber=hm2Iec61850MmsTlsServerPortNumber, hm2EtherNetIPQosDscpScheduledValue=hm2EtherNetIPQosDscpScheduledValue, hm2PNIODcpModePortID=hm2PNIODcpModePortID, hm2ModbusTcpServerWriteAccessStatus=hm2ModbusTcpServerWriteAccessStatus, hm2Iec61850MmsTlsServerMaxSessionsCount=hm2Iec61850MmsTlsServerMaxSessionsCount, hm2Iec61850MmsTlsServerDSAKeyControl=hm2Iec61850MmsTlsServerDSAKeyControl, hm2EthernetIPSESGroup=hm2EthernetIPSESGroup, hm2ModbusSESGroup=hm2ModbusSESGroup, hm2EthernetIPTCPIPObjectGroup=hm2EthernetIPTCPIPObjectGroup, hm2EtherNetIPConnEstablished=hm2EtherNetIPConnEstablished, hm2EthernetIPConfigGroup=hm2EthernetIPConfigGroup, hm2EtherNetIPConnTimeouts=hm2EtherNetIPConnTimeouts, hm2PNIOHardwareRelease=hm2PNIOHardwareRelease, PYSNMP_MODULE_ID=hm2IndustrialProtocolsMib, hm2EtherNetIPLastConflictDetectedACDActivity=hm2EtherNetIPLastConflictDetectedACDActivity, hm2Iec61850MmsServerStatus=hm2Iec61850MmsServerStatus, hm2PNIOClearIpParameter=hm2PNIOClearIpParameter, hm2ProfinetIOStatisticsGroup=hm2ProfinetIOStatisticsGroup, hm2PNIOSoftwareRelease=hm2PNIOSoftwareRelease, hm2EtherNetIPErrorCode=hm2EtherNetIPErrorCode, hm2EthernetIPQoSObjectGroup=hm2EthernetIPQoSObjectGroup, hm2ModbusTcpServerAdminStatus=hm2ModbusTcpServerAdminStatus)
